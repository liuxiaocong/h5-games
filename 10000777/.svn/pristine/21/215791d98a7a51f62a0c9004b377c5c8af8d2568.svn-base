(function() {
    var e = this;
    var t = t || {};
    t.WEBGL_RENDERER = 0;
    t.CANVAS_RENDERER = 1;
    t.VERSION = "v1.5.2";
    t.blendModes = {
        NORMAL: 0,
        ADD: 1,
        MULTIPLY: 2,
        SCREEN: 3,
        OVERLAY: 4,
        DARKEN: 5,
        LIGHTEN: 6,
        COLOR_DODGE: 7,
        COLOR_BURN: 8,
        HARD_LIGHT: 9,
        SOFT_LIGHT: 10,
        DIFFERENCE: 11,
        EXCLUSION: 12,
        HUE: 13,
        SATURATION: 14,
        COLOR: 15,
        LUMINOSITY: 16
    };
    t.scaleModes = {
        DEFAULT: 0,
        LINEAR: 0,
        NEAREST: 1
    };
    t.INTERACTION_FREQUENCY = 30;
    t.AUTO_PREVENT_DEFAULT = true;
    t.RAD_TO_DEG = 180 / Math.PI;
    t.DEG_TO_RAD = Math.PI / 180;
    t.Point = function(e, t) {
        this.x = e || 0;
        this.y = t || 0
    };
    t.Point.prototype.clone = function() {
        return new t.Point(this.x, this.y)
    };
    t.Point.prototype.constructor = t.Point;
    t.Point.prototype.set = function(e, t) {
        this.x = e || 0;
        this.y = t || (t !== 0 ? this.x : 0)
    };
    t.Rectangle = function(e, t, n, r) {
        this.x = e || 0;
        this.y = t || 0;
        this.width = n || 0;
        this.height = r || 0
    };
    t.Rectangle.prototype.clone = function() {
        return new t.Rectangle(this.x, this.y, this.width, this.height)
    };
    t.Rectangle.prototype.contains = function(e, t) {
        if (this.width <= 0 || this.height <= 0) return false;
        var n = this.x;
        if (e >= n && e <= n + this.width) {
            var r = this.y;
            if (t >= r && t <= r + this.height) {
                return true
            }
        }
        return false
    };
    t.Rectangle.prototype.constructor = t.Rectangle;
    t.EmptyRectangle = new t.Rectangle(0, 0, 0, 0);
    t.Polygon = function(e) {
        if (!(e instanceof Array)) e = Array.prototype.slice.call(arguments);
        if (typeof e[0] === "number") {
            var n = [];
            for (var r = 0, i = e.length; r < i; r += 2) {
                n.push(new t.Point(e[r], e[r + 1]))
            }
            e = n
        }
        this.points = e
    };
    t.Polygon.prototype.clone = function() {
        var e = [];
        for (var n = 0; n < this.points.length; n++) {
            e.push(this.points[n].clone())
        }
        return new t.Polygon(e)
    };
    t.Polygon.prototype.contains = function(e, t) {
        var n = false;
        for (var r = 0, i = this.points.length - 1; r < this.points.length; i = r++) {
            var s = this.points[r].x,
                o = this.points[r].y,
                u = this.points[i].x,
                a = this.points[i].y,
                f = o > t !== a > t && e < (u - s) * (t - o) / (a - o) + s;
            if (f) n = !n
        }
        return n
    };
    t.Polygon.prototype.constructor = t.Polygon;
    t.Circle = function(e, t, n) {
        this.x = e || 0;
        this.y = t || 0;
        this.radius = n || 0
    };
    t.Circle.prototype.clone = function() {
        return new t.Circle(this.x, this.y, this.radius)
    };
    t.Circle.prototype.contains = function(e, t) {
        if (this.radius <= 0) return false;
        var n = this.x - e,
            r = this.y - t,
            i = this.radius * this.radius;
        n *= n;
        r *= r;
        return n + r <= i
    };
    t.Circle.prototype.constructor = t.Circle;
    t.Ellipse = function(e, t, n, r) {
        this.x = e || 0;
        this.y = t || 0;
        this.width = n || 0;
        this.height = r || 0
    };
    t.Ellipse.prototype.clone = function() {
        return new t.Ellipse(this.x, this.y, this.width, this.height)
    };
    t.Ellipse.prototype.contains = function(e, t) {
        if (this.width <= 0 || this.height <= 0) return false;
        var n = (e - this.x) / this.width,
            r = (t - this.y) / this.height;
        n *= n;
        r *= r;
        return n + r <= 1
    };
    t.Ellipse.prototype.getBounds = function() {
        return new t.Rectangle(this.x, this.y, this.width, this.height)
    };
    t.Ellipse.prototype.constructor = t.Ellipse;
    t.determineMatrixArrayType = function() {
        return typeof Float32Array !== "undefined" ? Float32Array : Array
    };
    t.Matrix2 = t.determineMatrixArrayType();
    t.Matrix = function() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0
    };
    t.Matrix.prototype.fromArray = function(e) {
        this.a = e[0];
        this.b = e[1];
        this.c = e[3];
        this.d = e[4];
        this.tx = e[2];
        this.ty = e[5]
    };
    t.Matrix.prototype.toArray = function(e) {
        if (!this.array) this.array = new Float32Array(9);
        var t = this.array;
        if (e) {
            this.array[0] = this.a;
            this.array[1] = this.c;
            this.array[2] = 0;
            this.array[3] = this.b;
            this.array[4] = this.d;
            this.array[5] = 0;
            this.array[6] = this.tx;
            this.array[7] = this.ty;
            this.array[8] = 1
        } else {
            this.array[0] = this.a;
            this.array[1] = this.b;
            this.array[2] = this.tx;
            this.array[3] = this.c;
            this.array[4] = this.d;
            this.array[5] = this.ty;
            this.array[6] = 0;
            this.array[7] = 0;
            this.array[8] = 1
        }
        return t
    };
    t.identityMatrix = new t.Matrix;
    t.DisplayObject = function() {
        this.position = new t.Point;
        this.scale = new t.Point(1, 1);
        this.pivot = new t.Point(0, 0);
        this.rotation = 0;
        this.alpha = 1;
        this.visible = true;
        this.hitArea = null;
        this.buttonMode = false;
        this.renderable = false;
        this.parent = null;
        this.stage = null;
        this.worldAlpha = 1;
        this._interactive = false;
        this.defaultCursor = "pointer";
        this.worldTransform = new t.Matrix;
        this.color = [];
        this.dynamic = true;
        this._sr = 0;
        this._cr = 1;
        this.filterArea = null;
        this._bounds = new t.Rectangle(0, 0, 1, 1);
        this._currentBounds = null;
        this._mask = null;
        this._cacheAsBitmap = false;
        this._cacheIsDirty = false
    };
    t.DisplayObject.prototype.constructor = t.DisplayObject;
    t.DisplayObject.prototype.setInteractive = function(e) {
        this.interactive = e
    };
    Object.defineProperty(t.DisplayObject.prototype, "interactive", {
        get: function() {
            return this._interactive
        },
        set: function(e) {
            this._interactive = e;
            if (this.stage) this.stage.dirty = true
        }
    });
    Object.defineProperty(t.DisplayObject.prototype, "worldVisible", {
        get: function() {
            var e = this;
            do {
                if (!e.visible) return false;
                e = e.parent
            } while (e);
            return true
        }
    });
    Object.defineProperty(t.DisplayObject.prototype, "mask", {
        get: function() {
            return this._mask
        },
        set: function(e) {
            if (this._mask) this._mask.isMask = false;
            this._mask = e;
            if (this._mask) this._mask.isMask = true
        }
    });
    Object.defineProperty(t.DisplayObject.prototype, "filters", {
        get: function() {
            return this._filters
        },
        set: function(e) {
            if (e) {
                var t = [];
                for (var n = 0; n < e.length; n++) {
                    var r = e[n].passes;
                    for (var i = 0; i < r.length; i++) {
                        t.push(r[i])
                    }
                }
                this._filterBlock = {
                    target: this,
                    filterPasses: t
                }
            }
            this._filters = e
        }
    });
    Object.defineProperty(t.DisplayObject.prototype, "cacheAsBitmap", {
        get: function() {
            return this._cacheAsBitmap
        },
        set: function(e) {
            if (this._cacheAsBitmap === e) return;
            if (e) {
                this._generateCachedSprite()
            } else {
                this._destroyCachedSprite()
            }
            this._cacheAsBitmap = e
        }
    });
    t.DisplayObject.prototype.updateTransform = function() {
        if (this.rotation !== this.rotationCache) {
            this.rotationCache = this.rotation;
            this._sr = Math.sin(this.rotation);
            this._cr = Math.cos(this.rotation)
        }
        var e = this.parent.worldTransform;
        var t = this.worldTransform;
        var n = this.pivot.x;
        var r = this.pivot.y;
        var i = this._cr * this.scale.x,
            s = -this._sr * this.scale.y,
            o = this._sr * this.scale.x,
            u = this._cr * this.scale.y,
            a = this.position.x - i * n - r * s,
            f = this.position.y - u * r - n * o,
            l = e.a,
            c = e.b,
            h = e.c,
            p = e.d;
        t.a = l * i + c * o;
        t.b = l * s + c * u;
        t.tx = l * a + c * f + e.tx;
        t.c = h * i + p * o;
        t.d = h * s + p * u;
        t.ty = h * a + p * f + e.ty;
        this.worldAlpha = this.alpha * this.parent.worldAlpha
    };
    t.DisplayObject.prototype.getBounds = function(e) {
        e = e;
        return t.EmptyRectangle
    };
    t.DisplayObject.prototype.getLocalBounds = function() {
        return this.getBounds(t.identityMatrix)
    };
    t.DisplayObject.prototype.setStageReference = function(e) {
        this.stage = e;
        if (this._interactive) this.stage.dirty = true
    };
    t.DisplayObject.prototype.generateTexture = function(e) {
        var n = this.getLocalBounds();
        var r = new t.RenderTexture(n.width | 0, n.height | 0, e);
        r.render(this, new t.Point(-n.x, -n.y));
        return r
    };
    t.DisplayObject.prototype.updateCache = function() {
        this._generateCachedSprite()
    };
    t.DisplayObject.prototype._renderCachedSprite = function(e) {
        if (e.gl) {
            t.Sprite.prototype._renderWebGL.call(this._cachedSprite, e)
        } else {
            t.Sprite.prototype._renderCanvas.call(this._cachedSprite, e)
        }
    };
    t.DisplayObject.prototype._generateCachedSprite = function() {
        this._cacheAsBitmap = false;
        var e = this.getLocalBounds();
        if (!this._cachedSprite) {
            var n = new t.RenderTexture(e.width | 0, e.height | 0);
            this._cachedSprite = new t.Sprite(n);
            this._cachedSprite.worldTransform = this.worldTransform
        } else {
            this._cachedSprite.texture.resize(e.width | 0, e.height | 0)
        }
        var r = this._filters;
        this._filters = null;
        this._cachedSprite.filters = r;
        this._cachedSprite.texture.render(this, new t.Point(-e.x, -e.y));
        this._cachedSprite.anchor.x = -(e.x / e.width);
        this._cachedSprite.anchor.y = -(e.y / e.height);
        this._filters = r;
        this._cacheAsBitmap = true
    };
    t.DisplayObject.prototype._destroyCachedSprite = function() {
        if (!this._cachedSprite) return;
        this._cachedSprite.texture.destroy(true);
        this._cachedSprite = null
    };
    t.DisplayObject.prototype._renderWebGL = function(e) {
        e = e
    };
    t.DisplayObject.prototype._renderCanvas = function(e) {
        e = e
    };
    Object.defineProperty(t.DisplayObject.prototype, "x", {
        get: function() {
            return this.position.x
        },
        set: function(e) {
            this.position.x = e
        }
    });
    Object.defineProperty(t.DisplayObject.prototype, "y", {
        get: function() {
            return this.position.y
        },
        set: function(e) {
            this.position.y = e
        }
    });
    t.DisplayObjectContainer = function() {
        t.DisplayObject.call(this);
        this.children = []
    };
    t.DisplayObjectContainer.prototype = Object.create(t.DisplayObject.prototype);
    t.DisplayObjectContainer.prototype.constructor = t.DisplayObjectContainer;
    t.DisplayObjectContainer.prototype.addChild = function(e) {
        this.addChildAt(e, this.children.length)
    };
    t.DisplayObjectContainer.prototype.addChildAt = function(e, t) {
        if (t >= 0 && t <= this.children.length) {
            if (e.parent) {
                e.parent.removeChild(e)
            }
            e.parent = this;
            this.children.splice(t, 0, e);
            if (this.stage) e.setStageReference(this.stage)
        } else {
            throw new Error(e + " The index " + t + " supplied is out of bounds " + this.children.length)
        }
    };
    t.DisplayObjectContainer.prototype.swapChildren = function(e, t) {
        if (e === t) {
            return
        }
        var n = this.children.indexOf(e);
        var r = this.children.indexOf(t);
        if (n < 0 || r < 0) {
            throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.")
        }
        this.children[n] = t;
        this.children[r] = e
    };
    t.DisplayObjectContainer.prototype.getChildAt = function(e) {
        if (e >= 0 && e < this.children.length) {
            return this.children[e]
        } else {
            throw new Error("Supplied index does not exist in the child list, or the supplied DisplayObject must be a child of the caller")
        }
    };
    t.DisplayObjectContainer.prototype.removeChild = function(e) {
        return this.removeChildAt(this.children.indexOf(e))
    };
    t.DisplayObjectContainer.prototype.removeChildAt = function(e) {
        var t = this.getChildAt(e);
        if (this.stage) t.removeStageReference();
        t.parent = undefined;
        this.children.splice(e, 1);
        return t
    };
    t.DisplayObjectContainer.prototype.removeChildren = function(e, t) {
        var n = e || 0;
        var r = typeof t === "number" ? t : this.children.length;
        var i = r - n;
        if (i > 0 && i <= r) {
            var s = this.children.splice(n, i);
            for (var o = 0; o < s.length; o++) {
                var u = s[o];
                if (this.stage) u.removeStageReference();
                u.parent = undefined
            }
            return s
        } else {
            throw new Error("Range Error, numeric values are outside the acceptable range")
        }
    };
    t.DisplayObjectContainer.prototype.updateTransform = function() {
        if (!this.visible) return;
        t.DisplayObject.prototype.updateTransform.call(this);
        if (this._cacheAsBitmap) return;
        for (var e = 0, n = this.children.length; e < n; e++) {
            this.children[e].updateTransform()
        }
    };
    t.DisplayObjectContainer.prototype.getBounds = function(e) {
        if (this.children.length === 0) return t.EmptyRectangle;
        if (e) {
            var n = this.worldTransform;
            this.worldTransform = e;
            this.updateTransform();
            this.worldTransform = n
        }
        var r = Infinity;
        var i = Infinity;
        var s = -Infinity;
        var o = -Infinity;
        var u;
        var a;
        var f;
        var l = false;
        for (var c = 0, h = this.children.length; c < h; c++) {
            var p = this.children[c];
            if (!p.visible) continue;
            l = true;
            u = this.children[c].getBounds(e);
            r = r < u.x ? r : u.x;
            i = i < u.y ? i : u.y;
            a = u.width + u.x;
            f = u.height + u.y;
            s = s > a ? s : a;
            o = o > f ? o : f
        }
        if (!l) return t.EmptyRectangle;
        var d = this._bounds;
        d.x = r;
        d.y = i;
        d.width = s - r;
        d.height = o - i;
        return d
    };
    t.DisplayObjectContainer.prototype.getLocalBounds = function() {
        var e = this.worldTransform;
        this.worldTransform = t.identityMatrix;
        for (var n = 0, r = this.children.length; n < r; n++) {
            this.children[n].updateTransform()
        }
        var i = this.getBounds();
        this.worldTransform = e;
        return i
    };
    t.DisplayObjectContainer.prototype.setStageReference = function(e) {
        this.stage = e;
        if (this._interactive) this.stage.dirty = true;
        for (var t = 0, n = this.children.length; t < n; t++) {
            var r = this.children[t];
            r.setStageReference(e)
        }
    };
    t.DisplayObjectContainer.prototype.removeStageReference = function() {
        for (var e = 0, t = this.children.length; e < t; e++) {
            var n = this.children[e];
            n.removeStageReference()
        }
        if (this._interactive) this.stage.dirty = true;
        this.stage = null
    };
    t.DisplayObjectContainer.prototype._renderWebGL = function(e) {
        if (!this.visible || this.alpha <= 0) return;
        if (this._cacheAsBitmap) {
            this._renderCachedSprite(e);
            return
        }
        var t, n;
        if (this._mask || this._filters) {
            if (this._mask) {
                e.spriteBatch.stop();
                e.maskManager.pushMask(this.mask, e);
                e.spriteBatch.start()
            }
            if (this._filters) {
                e.spriteBatch.flush();
                e.filterManager.pushFilter(this._filterBlock)
            }
            for (t = 0, n = this.children.length; t < n; t++) {
                this.children[t]._renderWebGL(e)
            }
            e.spriteBatch.stop();
            if (this._filters) e.filterManager.popFilter();
            if (this._mask) e.maskManager.popMask(e);
            e.spriteBatch.start()
        } else {
            for (t = 0, n = this.children.length; t < n; t++) {
                this.children[t]._renderWebGL(e)
            }
        }
    };
    t.DisplayObjectContainer.prototype._renderCanvas = function(e) {
        if (this.visible === false || this.alpha === 0) return;
        if (this._cacheAsBitmap) {
            this._renderCachedSprite(e);
            return
        }
        if (this._mask) {
            e.maskManager.pushMask(this._mask, e.context)
        }
        for (var t = 0, n = this.children.length; t < n; t++) {
            var r = this.children[t];
            r._renderCanvas(e)
        }
        if (this._mask) {
            e.maskManager.popMask(e.context)
        }
    };
    t.Sprite = function(e) {
        t.DisplayObjectContainer.call(this);
        this.anchor = new t.Point;
        this.texture = e;
        this._width = 0;
        this._height = 0;
        this.tint = 16777215;
        this.blendMode = t.blendModes.NORMAL;
        if (e.baseTexture.hasLoaded) {
            this.onTextureUpdate()
        } else {
            this.onTextureUpdateBind = this.onTextureUpdate.bind(this);
            this.texture.addEventListener("update", this.onTextureUpdateBind)
        }
        this.renderable = true
    };
    t.Sprite.prototype = Object.create(t.DisplayObjectContainer.prototype);
    t.Sprite.prototype.constructor = t.Sprite;
    Object.defineProperty(t.Sprite.prototype, "width", {
        get: function() {
            return this.scale.x * this.texture.frame.width
        },
        set: function(e) {
            this.scale.x = e / this.texture.frame.width;
            this._width = e
        }
    });
    Object.defineProperty(t.Sprite.prototype, "height", {
        get: function() {
            return this.scale.y * this.texture.frame.height
        },
        set: function(e) {
            this.scale.y = e / this.texture.frame.height;
            this._height = e
        }
    });
    t.Sprite.prototype.setTexture = function(e) {
        if (this.texture.baseTexture !== e.baseTexture) {
            this.textureChange = true;
            this.texture = e
        } else {
            this.texture = e
        }
        this.cachedTint = 16777215;
        this.updateFrame = true
    };
    t.Sprite.prototype.onTextureUpdate = function() {
        if (this._width) this.scale.x = this._width / this.texture.frame.width;
        if (this._height) this.scale.y = this._height / this.texture.frame.height;
        this.updateFrame = true
    };
    t.Sprite.prototype.getBounds = function(e) {
        var t = this.texture.frame.width;
        var n = this.texture.frame.height;
        var r = t * (1 - this.anchor.x);
        var i = t * -this.anchor.x;
        var s = n * (1 - this.anchor.y);
        var o = n * -this.anchor.y;
        var u = e || this.worldTransform;
        var a = u.a;
        var f = u.c;
        var l = u.b;
        var c = u.d;
        var h = u.tx;
        var p = u.ty;
        var d = a * i + l * o + h;
        var v = c * o + f * i + p;
        var m = a * r + l * o + h;
        var g = c * o + f * r + p;
        var y = a * r + l * s + h;
        var b = c * s + f * r + p;
        var w = a * i + l * s + h;
        var E = c * s + f * i + p;
        var S = -Infinity;
        var x = -Infinity;
        var T = Infinity;
        var N = Infinity;
        T = d < T ? d : T;
        T = m < T ? m : T;
        T = y < T ? y : T;
        T = w < T ? w : T;
        N = v < N ? v : N;
        N = g < N ? g : N;
        N = b < N ? b : N;
        N = E < N ? E : N;
        S = d > S ? d : S;
        S = m > S ? m : S;
        S = y > S ? y : S;
        S = w > S ? w : S;
        x = v > x ? v : x;
        x = g > x ? g : x;
        x = b > x ? b : x;
        x = E > x ? E : x;
        var C = this._bounds;
        C.x = T;
        C.width = S - T;
        C.y = N;
        C.height = x - N;
        this._currentBounds = C;
        return C
    };
    t.Sprite.prototype._renderWebGL = function(e) {
        if (!this.visible || this.alpha <= 0) return;
        var t, n;
        if (this._mask || this._filters) {
            var r = e.spriteBatch;
            if (this._mask) {
                r.stop();
                e.maskManager.pushMask(this.mask, e);
                r.start()
            }
            if (this._filters) {
                r.flush();
                e.filterManager.pushFilter(this._filterBlock)
            }
            r.render(this);
            for (t = 0, n = this.children.length; t < n; t++) {
                this.children[t]._renderWebGL(e)
            }
            r.stop();
            if (this._filters) e.filterManager.popFilter();
            if (this._mask) e.maskManager.popMask(e);
            r.start()
        } else {
            e.spriteBatch.render(this);
            for (t = 0, n = this.children.length; t < n; t++) {
                this.children[t]._renderWebGL(e)
            }
        }
    };
    t.Sprite.prototype._renderCanvas = function(e) {
        if (this.visible === false || this.alpha === 0) return;
        var n = this.texture.frame;
        var r = e.context;
        var i = this.texture;
        if (this.blendMode !== e.currentBlendMode) {
            e.currentBlendMode = this.blendMode;
            r.globalCompositeOperation = t.blendModesCanvas[e.currentBlendMode]
        }
        if (this._mask) {
            e.maskManager.pushMask(this._mask, e.context)
        }
        if (n && n.width && n.height && i.baseTexture.source) {
            r.globalAlpha = this.worldAlpha;
            var s = this.worldTransform;
            if (e.roundPixels) {
                r.setTransform(s.a, s.c, s.b, s.d, s.tx | 0, s.ty | 0)
            } else {
                r.setTransform(s.a, s.c, s.b, s.d, s.tx, s.ty)
            }
            if (e.smoothProperty && e.scaleMode !== this.texture.baseTexture.scaleMode) {
                e.scaleMode = this.texture.baseTexture.scaleMode;
                r[e.smoothProperty] = e.scaleMode === t.scaleModes.LINEAR
            }
            if (this.tint !== 16777215) {
                if (this.cachedTint !== this.tint) {
                    if (!i.baseTexture.hasLoaded) return;
                    this.cachedTint = this.tint;
                    this.tintedTexture = t.CanvasTinter.getTintedTexture(this, this.tint)
                }
                r.drawImage(this.tintedTexture, 0, 0, n.width, n.height, this.anchor.x * -n.width, this.anchor.y * -n.height, n.width, n.height)
            } else {
                if (i.trim) {
                    var o = i.trim;
                    r.drawImage(this.texture.baseTexture.source, n.x, n.y, n.width, n.height, o.x - this.anchor.x * o.width, o.y - this.anchor.y * o.height, n.width, n.height)
                } else {
                    r.drawImage(this.texture.baseTexture.source, n.x, n.y, n.width, n.height, this.anchor.x * -n.width, this.anchor.y * -n.height, n.width, n.height)
                }
            }
        }
        for (var u = 0, a = this.children.length; u < a; u++) {
            var f = this.children[u];
            f._renderCanvas(e)
        }
        if (this._mask) {
            e.maskManager.popMask(e.context)
        }
    };
    t.Sprite.fromFrame = function(e) {
        var n = t.TextureCache[e];
        if (!n) throw new Error('The frameId "' + e + '" does not exist in the texture cache' + this);
        return new t.Sprite(n)
    };
    t.Sprite.fromImage = function(e, n, r) {
        var i = t.Texture.fromImage(e, n, r);
        return new t.Sprite(i)
    };
    t.SpriteBatch = function(e) {
        t.DisplayObjectContainer.call(this);
        this.textureThing = e;
        this.ready = false
    };
    t.SpriteBatch.prototype = Object.create(t.DisplayObjectContainer.prototype);
    t.SpriteBatch.constructor = t.SpriteBatch;
    t.SpriteBatch.prototype.initWebGL = function(e) {
        this.fastSpriteBatch = new t.WebGLFastSpriteBatch(e);
        this.ready = true
    };
    t.SpriteBatch.prototype.updateTransform = function() {
        t.DisplayObject.prototype.updateTransform.call(this)
    };
    t.SpriteBatch.prototype._renderWebGL = function(e) {
        if (!this.visible || this.alpha <= 0 || !this.children.length) return;
        if (!this.ready) this.initWebGL(e.gl);
        e.spriteBatch.stop();
        e.shaderManager.activateShader(e.shaderManager.fastShader);
        this.fastSpriteBatch.begin(this, e);
        this.fastSpriteBatch.render(this);
        e.shaderManager.activateShader(e.shaderManager.defaultShader);
        e.spriteBatch.start()
    };
    t.SpriteBatch.prototype._renderCanvas = function(e) {
        var n = e.context;
        n.globalAlpha = this.worldAlpha;
        t.DisplayObject.prototype.updateTransform.call(this);
        var r = this.worldTransform;
        var i = true;
        for (var s = 0; s < this.children.length; s++) {
            var o = this.children[s];
            if (!o.visible) continue;
            var u = o.texture;
            var a = u.frame;
            n.globalAlpha = this.worldAlpha * o.alpha;
            if (o.rotation % (Math.PI * 2) === 0) {
                if (i) {
                    n.setTransform(r.a, r.c, r.b, r.d, r.tx, r.ty);
                    i = false
                }
                n.drawImage(u.baseTexture.source, a.x, a.y, a.width, a.height, o.anchor.x * -a.width * o.scale.x + o.position.x + .5 | 0, o.anchor.y * -a.height * o.scale.y + o.position.y + .5 | 0, a.width * o.scale.x, a.height * o.scale.y)
            } else {
                if (!i) i = true;
                t.DisplayObject.prototype.updateTransform.call(o);
                var f = o.worldTransform;
                if (e.roundPixels) {
                    n.setTransform(f.a, f.c, f.b, f.d, f.tx | 0, f.ty | 0)
                } else {
                    n.setTransform(f.a, f.c, f.b, f.d, f.tx, f.ty)
                }
                n.drawImage(u.baseTexture.source, a.x, a.y, a.width, a.height, o.anchor.x * -a.width + .5 | 0, o.anchor.y * -a.height + .5 | 0, a.width, a.height)
            }
        }
    };
    t.AbstractFilter = function(e, t) {
        this.passes = [this];
        this.shaders = [];
        this.dirty = true;
        this.padding = 0;
        this.uniforms = t || {};
        this.fragmentSrc = e || []
    };
    t.FilterBlock = function() {
        this.visible = true;
        this.renderable = true
    };
    t.Text = function(e, n) {
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d");
        t.Sprite.call(this, t.Texture.fromCanvas(this.canvas));
        this.setText(e);
        this.setStyle(n);
        this.updateText();
        this.dirty = false
    };
    t.Text.prototype = Object.create(t.Sprite.prototype);
    t.Text.prototype.constructor = t.Text;
    t.Text.prototype.setStyle = function(e) {
        e = e || {};
        e.font = e.font || "bold 20pt Arial";
        e.fill = e.fill || "black";
        e.align = e.align || "left";
        e.stroke = e.stroke || "black";
        e.strokeThickness = e.strokeThickness || 0;
        e.wordWrap = e.wordWrap || false;
        e.wordWrapWidth = e.wordWrapWidth || 100;
        e.wordWrapWidth = e.wordWrapWidth || 100;
        e.dropShadow = e.dropShadow || false;
        e.dropShadowAngle = e.dropShadowAngle || Math.PI / 6;
        e.dropShadowDistance = e.dropShadowDistance || 4;
        e.dropShadowColor = e.dropShadowColor || "black";
        this.style = e;
        this.dirty = true
    };
    t.Text.prototype.setText = function(e) {
        this.text = e.toString() || " ";
        this.dirty = true
    };
    t.Text.prototype.updateText = function() {
        this.context.font = this.style.font;
        var e = this.text;
        if (this.style.wordWrap) e = this.wordWrap(this.text);
        var t = e.split(/(?:\r\n|\r|\n)/);
        var n = [];
        var r = 0;
        for (var i = 0; i < t.length; i++) {
            var s = this.context.measureText(t[i]).width;
            n[i] = s;
            r = Math.max(r, s)
        }
        var o = r + this.style.strokeThickness;
        if (this.style.dropShadow) o += this.style.dropShadowDistance;
        this.canvas.width = o + this.context.lineWidth;
        var u = this.determineFontHeight("font: " + this.style.font + ";") + this.style.strokeThickness;
        var a = u * t.length;
        if (this.style.dropShadow) a += this.style.dropShadowDistance;
        this.canvas.height = a;
        if (navigator.isCocoonJS) this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.context.font = this.style.font;
        this.context.strokeStyle = this.style.stroke;
        this.context.lineWidth = this.style.strokeThickness;
        this.context.textBaseline = "top";
        var f;
        var l;
        if (this.style.dropShadow) {
            this.context.fillStyle = this.style.dropShadowColor;
            var c = Math.sin(this.style.dropShadowAngle) * this.style.dropShadowDistance;
            var h = Math.cos(this.style.dropShadowAngle) * this.style.dropShadowDistance;
            for (i = 0; i < t.length; i++) {
                f = this.style.strokeThickness / 2;
                l = this.style.strokeThickness / 2 + i * u;
                if (this.style.align === "right") {
                    f += r - n[i]
                } else if (this.style.align === "center") {
                    f += (r - n[i]) / 2
                }
                if (this.style.fill) {
                    this.context.fillText(t[i], f + c, l + h)
                }
            }
        }
        this.context.fillStyle = this.style.fill;
        for (i = 0; i < t.length; i++) {
            f = this.style.strokeThickness / 2;
            l = this.style.strokeThickness / 2 + i * u;
            if (this.style.align === "right") {
                f += r - n[i]
            } else if (this.style.align === "center") {
                f += (r - n[i]) / 2
            }
            if (this.style.stroke && this.style.strokeThickness) {
                this.context.strokeText(t[i], f, l)
            }
            if (this.style.fill) {
                this.context.fillText(t[i], f, l)
            }
        }
        this.updateTexture()
    };
    t.Text.prototype.updateTexture = function() {
        this.texture.baseTexture.width = this.canvas.width;
        this.texture.baseTexture.height = this.canvas.height;
        this.texture.frame.width = this.canvas.width;
        this.texture.frame.height = this.canvas.height;
        this._width = this.canvas.width;
        this._height = this.canvas.height;
        this.requiresUpdate = true
    };
    t.Text.prototype._renderWebGL = function(e) {
        if (this.requiresUpdate) {
            this.requiresUpdate = false;
            t.updateWebGLTexture(this.texture.baseTexture, e.gl)
        }
        t.Sprite.prototype._renderWebGL.call(this, e)
    };
    t.Text.prototype.updateTransform = function() {
        if (this.dirty) {
            this.updateText();
            this.dirty = false
        }
        t.Sprite.prototype.updateTransform.call(this)
    };
    t.Text.prototype.determineFontHeight = function(e) {
        var n = t.Text.heightCache[e];
        if (!n) {
            var r = document.getElementsByTagName("body")[0];
            var i = document.createElement("div");
            var s = document.createTextNode("M");
            i.appendChild(s);
            i.setAttribute("style", e + ";position:absolute;top:0;left:0");
            r.appendChild(i);
            n = i.offsetHeight;
            t.Text.heightCache[e] = n;
            r.removeChild(i)
        }
        return n
    };
    t.Text.prototype.wordWrap = function(e) {
        var t = "";
        var n = e.split("\n");
        for (var r = 0; r < n.length; r++) {
            var i = this.style.wordWrapWidth;
            var s = n[r].split(" ");
            for (var o = 0; o < s.length; o++) {
                var u = this.context.measureText(s[o]).width;
                var a = u + this.context.measureText(" ").width;
                if (o === 0 || a > i) {
                    if (o > 0) {
                        t += "\n"
                    }
                    t += s[o];
                    i = this.style.wordWrapWidth - u
                } else {
                    i -= a;
                    t += " " + s[o]
                }
            }
            if (r < n.length - 1) {
                t += "\n"
            }
        }
        return t
    };
    t.Text.prototype.destroy = function(e) {
        if (e) {
            this.texture.destroy()
        }
    };
    t.Text.heightCache = {};
    t.BitmapText = function(e, n) {
        t.DisplayObjectContainer.call(this);
        this._pool = [];
        this.setText(e);
        this.setStyle(n);
        this.updateText();
        this.dirty = false
    };
    t.BitmapText.prototype = Object.create(t.DisplayObjectContainer.prototype);
    t.BitmapText.prototype.constructor = t.BitmapText;
    t.BitmapText.prototype.setText = function(e) {
        this.text = e || " ";
        this.dirty = true
    };
    t.BitmapText.prototype.setStyle = function(e) {
        e = e || {};
        e.align = e.align || "left";
        this.style = e;
        var n = e.font.split(" ");
        this.fontName = n[n.length - 1];
        this.fontSize = n.length >= 2 ? parseInt(n[n.length - 2], 10) : t.BitmapText.fonts[this.fontName].size;
        this.dirty = true;
        this.tint = e.tint
    };
    t.BitmapText.prototype.updateText = function() {
        var e = t.BitmapText.fonts[this.fontName];
        var n = new t.Point;
        var r = null;
        var i = [];
        var s = 0;
        var o = [];
        var u = 0;
        var a = this.fontSize / e.size;
        for (var f = 0; f < this.text.length; f++) {
            var l = this.text.charCodeAt(f);
            if (/(?:\r\n|\r|\n)/.test(this.text.charAt(f))) {
                o.push(n.x);
                s = Math.max(s, n.x);
                u++;
                n.x = 0;
                n.y += e.lineHeight;
                r = null;
                continue
            }
            var c = e.chars[l];
            if (!c) continue;
            if (r && c[r]) {
                n.x += c.kerning[r]
            }
            i.push({
                texture: c.texture,
                line: u,
                charCode: l,
                position: new t.Point(n.x + c.xOffset, n.y + c.yOffset)
            });
            n.x += c.xAdvance;
            r = l
        }
        o.push(n.x);
        s = Math.max(s, n.x);
        var h = [];
        for (f = 0; f <= u; f++) {
            var p = 0;
            if (this.style.align === "right") {
                p = s - o[f]
            } else if (this.style.align === "center") {
                p = (s - o[f]) / 2
            }
            h.push(p)
        }
        var d = this.children.length;
        var v = i.length;
        var m = this.tint || 16777215;
        for (f = 0; f < v; f++) {
            var g = f < d ? this.children[f] : this._pool.pop();
            if (g) g.setTexture(i[f].texture);
            else g = new t.Sprite(i[f].texture);
            g.position.x = (i[f].position.x + h[i[f].line]) * a;
            g.position.y = i[f].position.y * a;
            g.scale.x = g.scale.y = a;
            g.tint = m;
            if (!g.parent) this.addChild(g)
        }
        while (this.children.length > v) {
            var y = this.getChildAt(this.children.length - 1);
            this._pool.push(y);
            this.removeChild(y)
        }
        this.textWidth = s * a;
        this.textHeight = (n.y + e.lineHeight) * a
    };
    t.BitmapText.prototype.updateTransform = function() {
        if (this.dirty) {
            this.updateText();
            this.dirty = false
        }
        t.DisplayObjectContainer.prototype.updateTransform.call(this)
    };
    t.BitmapText.fonts = {};
    t.Stage = function(e) {
        t.DisplayObjectContainer.call(this);
        this.worldTransform = new t.Matrix;
        this.interactive = true;
        this.interactionManager = new t.InteractionManager(this);
        this.dirty = true;
        this.stage = this;
        this.stage.hitArea = new t.Rectangle(0, 0, 1e5, 1e5);
        this.setBackgroundColor(e)
    };
    t.Stage.prototype = Object.create(t.DisplayObjectContainer.prototype);
    t.Stage.prototype.constructor = t.Stage;
    t.Stage.prototype.setInteractionDelegate = function(e) {
        this.interactionManager.setTargetDomElement(e)
    };
    t.Stage.prototype.updateTransform = function() {
        this.worldAlpha = 1;
        for (var e = 0, t = this.children.length; e < t; e++) {
            this.children[e].updateTransform()
        }
        if (this.dirty) {
            this.dirty = false;
            this.interactionManager.dirty = true
        }
        if (this.interactive) this.interactionManager.update()
    };
    t.Stage.prototype.setBackgroundColor = function(e) {
        this.backgroundColor = e || 0;
        this.backgroundColorSplit = t.hex2rgb(this.backgroundColor);
        var n = this.backgroundColor.toString(16);
        n = "000000".substr(0, 6 - n.length) + n;
        this.backgroundColorString = "#" + n
    };
    t.Stage.prototype.getMousePosition = function() {
        return this.interactionManager.mouse.global
    };
    var n = 0;
    var r = ["ms", "moz", "webkit", "o"];
    for (var i = 0; i < r.length && !window.requestAnimationFrame; ++i) {
        window.requestAnimationFrame = window[r[i] + "RequestAnimationFrame"];
        window.cancelAnimationFrame = window[r[i] + "CancelAnimationFrame"] || window[r[i] + "CancelRequestAnimationFrame"]
    }
    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(e) {
            var t = (new Date).getTime();
            var r = Math.max(0, 16 - (t - n));
            var i = window.setTimeout(function() {
                e(t + r)
            }, r);
            n = t + r;
            return i
        }
    }
    if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function(e) {
            clearTimeout(e)
        }
    }
    window.requestAnimFrame = window.requestAnimationFrame;
    t.hex2rgb = function(e) {
        return [(e >> 16 & 255) / 255, (e >> 8 & 255) / 255, (e & 255) / 255]
    };
    t.rgb2hex = function(e) {
        return (e[0] * 255 << 16) + (e[1] * 255 << 8) + e[2] * 255
    };
    if (typeof Function.prototype.bind !== "function") {
        Function.prototype.bind = function() {
            var e = Array.prototype.slice;
            return function(t) {
                function i() {
                    var s = r.concat(e.call(arguments));
                    n.apply(this instanceof i ? this : t, s)
                }
                var n = this,
                    r = e.call(arguments, 1);
                if (typeof n !== "function") throw new TypeError;
                i.prototype = function s(e) {
                    if (e) s.prototype = e;
                    if (!(this instanceof s)) return new s
                }(n.prototype);
                return i
            }
        }()
    }
    t.AjaxRequest = function() {
        var e = ["Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.3.0", "Microsoft.XMLHTTP"];
        if (window.ActiveXObject) {
            for (var t = 0; t < e.length; t++) {
                try {
                    return new window.ActiveXObject(e[t])
                } catch (n) {}
            }
        } else if (window.XMLHttpRequest) {
            return new window.XMLHttpRequest
        } else {
            return false
        }
    };
    t.canUseNewCanvasBlendModes = function() {
        var e = document.createElement("canvas");
        e.width = 1;
        e.height = 1;
        var t = e.getContext("2d");
        t.fillStyle = "#000";
        t.fillRect(0, 0, 1, 1);
        t.globalCompositeOperation = "multiply";
        t.fillStyle = "#fff";
        t.fillRect(0, 0, 1, 1);
        return t.getImageData(0, 0, 1, 1).data[0] === 0
    };
    t.getNextPowerOfTwo = function(e) {
        if (e > 0 && (e & e - 1) === 0) return e;
        else {
            var t = 1;
            while (t < e) t <<= 1;
            return t
        }
    };
    t.EventTarget = function() {
        var e = {};
        this.addEventListener = this.on = function(t, n) {
            if (e[t] === undefined) {
                e[t] = []
            }
            if (e[t].indexOf(n) === -1) {
                e[t].push(n)
            }
        };
        this.dispatchEvent = this.emit = function(t) {
            if (!e[t.type] || !e[t.type].length) {
                return
            }
            for (var n = 0, r = e[t.type].length; n < r; n++) {
                e[t.type][n](t)
            }
        };
        this.removeEventListener = this.off = function(t, n) {
            var r = e[t].indexOf(n);
            if (r !== -1) {
                e[t].splice(r, 1)
            }
        };
        this.removeAllEventListeners = function(t) {
            var n = e[t];
            if (n) n.length = 0
        }
    };
    t.PolyK = {};
    t.PolyK.Triangulate = function(e) {
        var n = true;
        var r = e.length >> 1;
        if (r < 3) return [];
        var i = [];
        var s = [];
        for (var o = 0; o < r; o++) s.push(o);
        o = 0;
        var u = r;
        while (u > 3) {
            var a = s[(o + 0) % u];
            var f = s[(o + 1) % u];
            var l = s[(o + 2) % u];
            var c = e[2 * a],
                h = e[2 * a + 1];
            var p = e[2 * f],
                d = e[2 * f + 1];
            var v = e[2 * l],
                m = e[2 * l + 1];
            var g = false;
            if (t.PolyK._convex(c, h, p, d, v, m, n)) {
                g = true;
                for (var y = 0; y < u; y++) {
                    var b = s[y];
                    if (b === a || b === f || b === l) continue;
                    if (t.PolyK._PointInTriangle(e[2 * b], e[2 * b + 1], c, h, p, d, v, m)) {
                        g = false;
                        break
                    }
                }
            }
            if (g) {
                i.push(a, f, l);
                s.splice((o + 1) % u, 1);
                u--;
                o = 0
            } else if (o++ > 3 * u) {
                if (n) {
                    i = [];
                    s = [];
                    for (o = 0; o < r; o++) s.push(o);
                    o = 0;
                    u = r;
                    n = false
                } else {
                    window.console.log("PIXI Warning: shape too complex to fill");
                    return []
                }
            }
        }
        i.push(s[0], s[1], s[2]);
        return i
    };
    t.PolyK._PointInTriangle = function(e, t, n, r, i, s, o, u) {
        var a = o - n;
        var f = u - r;
        var l = i - n;
        var c = s - r;
        var h = e - n;
        var p = t - r;
        var d = a * a + f * f;
        var v = a * l + f * c;
        var m = a * h + f * p;
        var g = l * l + c * c;
        var y = l * h + c * p;
        var b = 1 / (d * g - v * v);
        var w = (g * m - v * y) * b;
        var E = (d * y - v * m) * b;
        return w >= 0 && E >= 0 && w + E < 1
    };
    t.PolyK._convex = function(e, t, n, r, i, s, o) {
        return (t - r) * (i - n) + (n - e) * (s - r) >= 0 === o
    };
    t.initDefaultShaders = function() {};
    t.CompileVertexShader = function(e, n) {
        return t._CompileShader(e, n, e.VERTEX_SHADER)
    };
    t.CompileFragmentShader = function(e, n) {
        return t._CompileShader(e, n, e.FRAGMENT_SHADER)
    };
    t._CompileShader = function(e, t, n) {
        var r = t.join("\n");
        var i = e.createShader(n);
        e.shaderSource(i, r);
        e.compileShader(i);
        if (!e.getShaderParameter(i, e.COMPILE_STATUS)) {
            window.console.log(e.getShaderInfoLog(i));
            return null
        }
        return i
    };
    t.compileProgram = function(e, n, r) {
        var i = t.CompileFragmentShader(e, r);
        var s = t.CompileVertexShader(e, n);
        var o = e.createProgram();
        e.attachShader(o, s);
        e.attachShader(o, i);
        e.linkProgram(o);
        if (!e.getProgramParameter(o, e.LINK_STATUS)) {
            window.console.log("Could not initialise shaders")
        }
        return o
    };
    t.PixiShader = function(e) {
        this.gl = e;
        this.program = null;
        this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"];
        this.textureCount = 0;
        this.attributes = [];
        this.init()
    };
    t.PixiShader.prototype.init = function() {
        var e = this.gl;
        var n = t.compileProgram(e, this.vertexSrc || t.PixiShader.defaultVertexSrc, this.fragmentSrc);
        e.useProgram(n);
        this.uSampler = e.getUniformLocation(n, "uSampler");
        this.projectionVector = e.getUniformLocation(n, "projectionVector");
        this.offsetVector = e.getUniformLocation(n, "offsetVector");
        this.dimensions = e.getUniformLocation(n, "dimensions");
        this.aVertexPosition = e.getAttribLocation(n, "aVertexPosition");
        this.aTextureCoord = e.getAttribLocation(n, "aTextureCoord");
        this.colorAttribute = e.getAttribLocation(n, "aColor");
        if (this.colorAttribute === -1) {
            this.colorAttribute = 2
        }
        this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute];
        for (var r in this.uniforms) {
            this.uniforms[r].uniformLocation = e.getUniformLocation(n, r)
        }
        this.initUniforms();
        this.program = n
    };
    t.PixiShader.prototype.initUniforms = function() {
        this.textureCount = 1;
        var e = this.gl;
        var t;
        for (var n in this.uniforms) {
            t = this.uniforms[n];
            var r = t.type;
            if (r === "sampler2D") {
                t._init = false;
                if (t.value !== null) {
                    this.initSampler2D(t)
                }
            } else if (r === "mat2" || r === "mat3" || r === "mat4") {
                t.glMatrix = true;
                t.glValueLength = 1;
                if (r === "mat2") {
                    t.glFunc = e.uniformMatrix2fv
                } else if (r === "mat3") {
                    t.glFunc = e.uniformMatrix3fv
                } else if (r === "mat4") {
                    t.glFunc = e.uniformMatrix4fv
                }
            } else {
                t.glFunc = e["uniform" + r];
                if (r === "2f" || r === "2i") {
                    t.glValueLength = 2
                } else if (r === "3f" || r === "3i") {
                    t.glValueLength = 3
                } else if (r === "4f" || r === "4i") {
                    t.glValueLength = 4
                } else {
                    t.glValueLength = 1
                }
            }
        }
    };
    t.PixiShader.prototype.initSampler2D = function(e) {
        if (!e.value || !e.value.baseTexture || !e.value.baseTexture.hasLoaded) {
            return
        }
        var t = this.gl;
        t.activeTexture(t["TEXTURE" + this.textureCount]);
        t.bindTexture(t.TEXTURE_2D, e.value.baseTexture._glTextures[t.id]);
        if (e.textureData) {
            var n = e.textureData;
            var r = n.magFilter ? n.magFilter : t.LINEAR;
            var i = n.minFilter ? n.minFilter : t.LINEAR;
            var s = n.wrapS ? n.wrapS : t.CLAMP_TO_EDGE;
            var o = n.wrapT ? n.wrapT : t.CLAMP_TO_EDGE;
            var u = n.luminance ? t.LUMINANCE : t.RGBA;
            if (n.repeat) {
                s = t.REPEAT;
                o = t.REPEAT
            }
            t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, !! n.flipY);
            if (n.width) {
                var a = n.width ? n.width : 512;
                var f = n.height ? n.height : 2;
                var l = n.border ? n.border : 0;
                t.texImage2D(t.TEXTURE_2D, 0, u, a, f, l, u, t.UNSIGNED_BYTE, null)
            } else {
                t.texImage2D(t.TEXTURE_2D, 0, u, t.RGBA, t.UNSIGNED_BYTE, e.value.baseTexture.source)
            }
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, r);
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, i);
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, s);
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, o)
        }
        t.uniform1i(e.uniformLocation, this.textureCount);
        e._init = true;
        this.textureCount++
    };
    t.PixiShader.prototype.syncUniforms = function() {
        this.textureCount = 1;
        var e;
        var n = this.gl;
        for (var r in this.uniforms) {
            e = this.uniforms[r];
            if (e.glValueLength === 1) {
                if (e.glMatrix === true) {
                    e.glFunc.call(n, e.uniformLocation, e.transpose, e.value)
                } else {
                    e.glFunc.call(n, e.uniformLocation, e.value)
                }
            } else if (e.glValueLength === 2) {
                e.glFunc.call(n, e.uniformLocation, e.value.x, e.value.y)
            } else if (e.glValueLength === 3) {
                e.glFunc.call(n, e.uniformLocation, e.value.x, e.value.y, e.value.z)
            } else if (e.glValueLength === 4) {
                e.glFunc.call(n, e.uniformLocation, e.value.x, e.value.y, e.value.z, e.value.w)
            } else if (e.type === "sampler2D") {
                if (e._init) {
                    n.activeTexture(n["TEXTURE" + this.textureCount]);
                    n.bindTexture(n.TEXTURE_2D, e.value.baseTexture._glTextures[n.id] || t.createWebGLTexture(e.value.baseTexture, n));
                    n.uniform1i(e.uniformLocation, this.textureCount);
                    this.textureCount++
                } else {
                    this.initSampler2D(e)
                }
            }
        }
    };
    t.PixiShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.uniforms = null;
        this.gl = null;
        this.attributes = null
    };
    t.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec2 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;", "   vColor = vec4(color * aColor.x, aColor.x);", "}"];
    t.PixiFastShader = function(e) {
        this.gl = e;
        this.program = null;
        this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"];
        this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"];
        this.textureCount = 0;
        this.init()
    };
    t.PixiFastShader.prototype.init = function() {
        var e = this.gl;
        var n = t.compileProgram(e, this.vertexSrc, this.fragmentSrc);
        e.useProgram(n);
        this.uSampler = e.getUniformLocation(n, "uSampler");
        this.projectionVector = e.getUniformLocation(n, "projectionVector");
        this.offsetVector = e.getUniformLocation(n, "offsetVector");
        this.dimensions = e.getUniformLocation(n, "dimensions");
        this.uMatrix = e.getUniformLocation(n, "uMatrix");
        this.aVertexPosition = e.getAttribLocation(n, "aVertexPosition");
        this.aPositionCoord = e.getAttribLocation(n, "aPositionCoord");
        this.aScale = e.getAttribLocation(n, "aScale");
        this.aRotation = e.getAttribLocation(n, "aRotation");
        this.aTextureCoord = e.getAttribLocation(n, "aTextureCoord");
        this.colorAttribute = e.getAttribLocation(n, "aColor");
        if (this.colorAttribute === -1) {
            this.colorAttribute = 2
        }
        this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute];
        this.program = n
    };
    t.PixiFastShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.uniforms = null;
        this.gl = null;
        this.attributes = null
    };
    t.StripShader = function() {
        this.program = null;
        this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));", "   gl_FragColor = gl_FragColor * alpha;", "}"];
        this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "varying vec2 vTextureCoord;", "uniform vec2 offsetVector;", "varying float vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition, 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"]
    };
    t.StripShader.prototype.init = function() {
        var e = t.gl;
        var n = t.compileProgram(e, this.vertexSrc, this.fragmentSrc);
        e.useProgram(n);
        this.uSampler = e.getUniformLocation(n, "uSampler");
        this.projectionVector = e.getUniformLocation(n, "projectionVector");
        this.offsetVector = e.getUniformLocation(n, "offsetVector");
        this.colorAttribute = e.getAttribLocation(n, "aColor");
        this.aVertexPosition = e.getAttribLocation(n, "aVertexPosition");
        this.aTextureCoord = e.getAttribLocation(n, "aTextureCoord");
        this.translationMatrix = e.getUniformLocation(n, "translationMatrix");
        this.alpha = e.getUniformLocation(n, "alpha");
        this.program = n
    };
    t.PrimitiveShader = function(e) {
        this.gl = e;
        this.program = null;
        this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"];
        this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"];
        this.init()
    };
    t.PrimitiveShader.prototype.init = function() {
        var e = this.gl;
        var n = t.compileProgram(e, this.vertexSrc, this.fragmentSrc);
        e.useProgram(n);
        this.projectionVector = e.getUniformLocation(n, "projectionVector");
        this.offsetVector = e.getUniformLocation(n, "offsetVector");
        this.tintColor = e.getUniformLocation(n, "tint");
        this.aVertexPosition = e.getAttribLocation(n, "aVertexPosition");
        this.colorAttribute = e.getAttribLocation(n, "aColor");
        this.attributes = [this.aVertexPosition, this.colorAttribute];
        this.translationMatrix = e.getUniformLocation(n, "translationMatrix");
        this.alpha = e.getUniformLocation(n, "alpha");
        this.program = n
    };
    t.PrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.uniforms = null;
        this.gl = null;
        this.attribute = null
    };
    t.WebGLGraphics = function() {};
    t.WebGLGraphics.renderGraphics = function(e, n) {
        var r = n.gl;
        var i = n.projection,
            s = n.offset,
            o = n.shaderManager.primitiveShader;
        if (!e._webGL[r.id]) e._webGL[r.id] = {
            points: [],
            indices: [],
            lastIndex: 0,
            buffer: r.createBuffer(),
            indexBuffer: r.createBuffer()
        };
        var u = e._webGL[r.id];
        if (e.dirty) {
            e.dirty = false;
            if (e.clearDirty) {
                e.clearDirty = false;
                u.lastIndex = 0;
                u.points = [];
                u.indices = []
            }
            t.WebGLGraphics.updateGraphics(e, r)
        }
        n.shaderManager.activatePrimitiveShader();
        r.blendFunc(r.ONE, r.ONE_MINUS_SRC_ALPHA);
        r.uniformMatrix3fv(o.translationMatrix, false, e.worldTransform.toArray(true));
        r.uniform2f(o.projectionVector, i.x, -i.y);
        r.uniform2f(o.offsetVector, -s.x, -s.y);
        r.uniform3fv(o.tintColor, t.hex2rgb(e.tint));
        r.uniform1f(o.alpha, e.worldAlpha);
        r.bindBuffer(r.ARRAY_BUFFER, u.buffer);
        r.vertexAttribPointer(o.aVertexPosition, 2, r.FLOAT, false, 4 * 6, 0);
        r.vertexAttribPointer(o.colorAttribute, 4, r.FLOAT, false, 4 * 6, 2 * 4);
        r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, u.indexBuffer);
        r.drawElements(r.TRIANGLE_STRIP, u.indices.length, r.UNSIGNED_SHORT, 0);
        n.shaderManager.deactivatePrimitiveShader()
    };
    t.WebGLGraphics.updateGraphics = function(e, n) {
        var r = e._webGL[n.id];
        for (var i = r.lastIndex; i < e.graphicsData.length; i++) {
            var s = e.graphicsData[i];
            if (s.type === t.Graphics.POLY) {
                if (s.fill) {
                    if (s.points.length > 3) t.WebGLGraphics.buildPoly(s, r)
                }
                if (s.lineWidth > 0) {
                    t.WebGLGraphics.buildLine(s, r)
                }
            } else if (s.type === t.Graphics.RECT) {
                t.WebGLGraphics.buildRectangle(s, r)
            } else if (s.type === t.Graphics.CIRC || s.type === t.Graphics.ELIP) {
                t.WebGLGraphics.buildCircle(s, r)
            }
        }
        r.lastIndex = e.graphicsData.length;
        r.glPoints = new Float32Array(r.points);
        n.bindBuffer(n.ARRAY_BUFFER, r.buffer);
        n.bufferData(n.ARRAY_BUFFER, r.glPoints, n.STATIC_DRAW);
        r.glIndicies = new Uint16Array(r.indices);
        n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, r.indexBuffer);
        n.bufferData(n.ELEMENT_ARRAY_BUFFER, r.glIndicies, n.STATIC_DRAW)
    };
    t.WebGLGraphics.buildRectangle = function(e, n) {
        var r = e.points;
        var i = r[0];
        var s = r[1];
        var o = r[2];
        var u = r[3];
        if (e.fill) {
            var a = t.hex2rgb(e.fillColor);
            var f = e.fillAlpha;
            var l = a[0] * f;
            var c = a[1] * f;
            var h = a[2] * f;
            var p = n.points;
            var d = n.indices;
            var v = p.length / 6;
            p.push(i, s);
            p.push(l, c, h, f);
            p.push(i + o, s);
            p.push(l, c, h, f);
            p.push(i, s + u);
            p.push(l, c, h, f);
            p.push(i + o, s + u);
            p.push(l, c, h, f);
            d.push(v, v, v + 1, v + 2, v + 3, v + 3)
        }
        if (e.lineWidth) {
            var m = e.points;
            e.points = [i, s, i + o, s, i + o, s + u, i, s + u, i, s];
            t.WebGLGraphics.buildLine(e, n);
            e.points = m
        }
    };
    t.WebGLGraphics.buildCircle = function(e, n) {
        var r = e.points;
        var i = r[0];
        var s = r[1];
        var o = r[2];
        var u = r[3];
        var a = 40;
        var f = Math.PI * 2 / a;
        var l = 0;
        if (e.fill) {
            var c = t.hex2rgb(e.fillColor);
            var h = e.fillAlpha;
            var p = c[0] * h;
            var d = c[1] * h;
            var v = c[2] * h;
            var m = n.points;
            var g = n.indices;
            var y = m.length / 6;
            g.push(y);
            for (l = 0; l < a + 1; l++) {
                m.push(i, s, p, d, v, h);
                m.push(i + Math.sin(f * l) * o, s + Math.cos(f * l) * u, p, d, v, h);
                g.push(y++, y++)
            }
            g.push(y - 1)
        }
        if (e.lineWidth) {
            var b = e.points;
            e.points = [];
            for (l = 0; l < a + 1; l++) {
                e.points.push(i + Math.sin(f * l) * o, s + Math.cos(f * l) * u)
            }
            t.WebGLGraphics.buildLine(e, n);
            e.points = b
        }
    };
    t.WebGLGraphics.buildLine = function(e, n) {
        var r = 0;
        var i = e.points;
        if (i.length === 0) return;
        if (e.lineWidth % 2) {
            for (r = 0; r < i.length; r++) {
                i[r] += .5
            }
        }
        var s = new t.Point(i[0], i[1]);
        var o = new t.Point(i[i.length - 2], i[i.length - 1]);
        if (s.x === o.x && s.y === o.y) {
            i.pop();
            i.pop();
            o = new t.Point(i[i.length - 2], i[i.length - 1]);
            var u = o.x + (s.x - o.x) * .5;
            var a = o.y + (s.y - o.y) * .5;
            i.unshift(u, a);
            i.push(u, a)
        }
        var f = n.points;
        var l = n.indices;
        var c = i.length / 2;
        var h = i.length;
        var p = f.length / 6;
        var d = e.lineWidth / 2;
        var v = t.hex2rgb(e.lineColor);
        var m = e.lineAlpha;
        var g = v[0] * m;
        var y = v[1] * m;
        var b = v[2] * m;
        var w, E, S, x, T, N, C, k;
        var L, A, O, M, _, D;
        var P, H, B, j, F, I;
        var q, R, U;
        S = i[0];
        x = i[1];
        T = i[2];
        N = i[3];
        L = -(x - N);
        A = S - T;
        U = Math.sqrt(L * L + A * A);
        L /= U;
        A /= U;
        L *= d;
        A *= d;
        f.push(S - L, x - A, g, y, b, m);
        f.push(S + L, x + A, g, y, b, m);
        for (r = 1; r < c - 1; r++) {
            S = i[(r - 1) * 2];
            x = i[(r - 1) * 2 + 1];
            T = i[r * 2];
            N = i[r * 2 + 1];
            C = i[(r + 1) * 2];
            k = i[(r + 1) * 2 + 1];
            L = -(x - N);
            A = S - T;
            U = Math.sqrt(L * L + A * A);
            L /= U;
            A /= U;
            L *= d;
            A *= d;
            O = -(N - k);
            M = T - C;
            U = Math.sqrt(O * O + M * M);
            O /= U;
            M /= U;
            O *= d;
            M *= d;
            P = -A + x - (-A + N);
            H = -L + T - (-L + S);
            B = (-L + S) * (-A + N) - (-L + T) * (-A + x);
            j = -M + k - (-M + N);
            F = -O + T - (-O + C);
            I = (-O + C) * (-M + N) - (-O + T) * (-M + k);
            q = P * F - j * H;
            if (Math.abs(q) < .1) {
                q += 10.1;
                f.push(T - L, N - A, g, y, b, m);
                f.push(T + L, N + A, g, y, b, m);
                continue
            }
            w = (H * I - F * B) / q;
            E = (j * B - P * I) / q;
            R = (w - T) * (w - T) + (E - N) + (E - N);
            if (R > 140 * 140) {
                _ = L - O;
                D = A - M;
                U = Math.sqrt(_ * _ + D * D);
                _ /= U;
                D /= U;
                _ *= d;
                D *= d;
                f.push(T - _, N - D);
                f.push(g, y, b, m);
                f.push(T + _, N + D);
                f.push(g, y, b, m);
                f.push(T - _, N - D);
                f.push(g, y, b, m);
                h++
            } else {
                f.push(w, E);
                f.push(g, y, b, m);
                f.push(T - (w - T), N - (E - N));
                f.push(g, y, b, m)
            }
        }
        S = i[(c - 2) * 2];
        x = i[(c - 2) * 2 + 1];
        T = i[(c - 1) * 2];
        N = i[(c - 1) * 2 + 1];
        L = -(x - N);
        A = S - T;
        U = Math.sqrt(L * L + A * A);
        L /= U;
        A /= U;
        L *= d;
        A *= d;
        f.push(T - L, N - A);
        f.push(g, y, b, m);
        f.push(T + L, N + A);
        f.push(g, y, b, m);
        l.push(p);
        for (r = 0; r < h; r++) {
            l.push(p++)
        }
        l.push(p - 1)
    };
    t.WebGLGraphics.buildPoly = function(e, n) {
        var r = e.points;
        if (r.length < 6) return;
        var i = n.points;
        var s = n.indices;
        var o = r.length / 2;
        var u = t.hex2rgb(e.fillColor);
        var a = e.fillAlpha;
        var f = u[0] * a;
        var l = u[1] * a;
        var c = u[2] * a;
        var h = t.PolyK.Triangulate(r);
        var p = i.length / 6;
        var d = 0;
        for (d = 0; d < h.length; d += 3) {
            s.push(h[d] + p);
            s.push(h[d] + p);
            s.push(h[d + 1] + p);
            s.push(h[d + 2] + p);
            s.push(h[d + 2] + p)
        }
        for (d = 0; d < o; d++) {
            i.push(r[d * 2], r[d * 2 + 1], f, l, c, a)
        }
    };
    t.glContexts = [];
    t.WebGLRenderer = function(e, n, r, i, s) {
        if (!t.defaultRenderer) t.defaultRenderer = this;
        this.type = t.WEBGL_RENDERER;
        this.transparent = !! i;
        this.width = e || 800;
        this.height = n || 600;
        this.view = r || document.createElement("canvas");
        this.view.width = this.width;
        this.view.height = this.height;
        this.contextLost = this.handleContextLost.bind(this);
        this.contextRestoredLost = this.handleContextRestored.bind(this);
        this.view.addEventListener("webglcontextlost", this.contextLost, false);
        this.view.addEventListener("webglcontextrestored", this.contextRestoredLost, false);
        this.options = {
            alpha: this.transparent,
            antialias: !! s,
            premultipliedAlpha: !! i,
            stencil: true
        };
        try {
            this.gl = this.view.getContext("experimental-webgl", this.options)
        } catch (o) {
            try {
                this.gl = this.view.getContext("webgl", this.options)
            } catch (u) {
                throw new Error(" This browser does not support webGL. Try using the canvas renderer" + this)
            }
        }
        var a = this.gl;
        this.glContextId = a.id = t.WebGLRenderer.glContextId++;
        t.glContexts[this.glContextId] = a;
        if (!t.blendModesWebGL) {
            t.blendModesWebGL = [];
            t.blendModesWebGL[t.blendModes.NORMAL] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
            t.blendModesWebGL[t.blendModes.ADD] = [a.SRC_ALPHA, a.DST_ALPHA];
            t.blendModesWebGL[t.blendModes.MULTIPLY] = [a.DST_COLOR, a.ONE_MINUS_SRC_ALPHA];
            t.blendModesWebGL[t.blendModes.SCREEN] = [a.SRC_ALPHA, a.ONE];
            t.blendModesWebGL[t.blendModes.OVERLAY] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
            t.blendModesWebGL[t.blendModes.DARKEN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
            t.blendModesWebGL[t.blendModes.LIGHTEN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
            t.blendModesWebGL[t.blendModes.COLOR_DODGE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
            t.blendModesWebGL[t.blendModes.COLOR_BURN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
            t.blendModesWebGL[t.blendModes.HARD_LIGHT] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
            t.blendModesWebGL[t.blendModes.SOFT_LIGHT] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
            t.blendModesWebGL[t.blendModes.DIFFERENCE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
            t.blendModesWebGL[t.blendModes.EXCLUSION] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
            t.blendModesWebGL[t.blendModes.HUE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
            t.blendModesWebGL[t.blendModes.SATURATION] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
            t.blendModesWebGL[t.blendModes.COLOR] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
            t.blendModesWebGL[t.blendModes.LUMINOSITY] = [a.ONE, a.ONE_MINUS_SRC_ALPHA]
        }
        this.projection = new t.Point;
        this.projection.x = this.width / 2;
        this.projection.y = -this.height / 2;
        this.offset = new t.Point(0, 0);
        this.resize(this.width, this.height);
        this.contextLost = false;
        this.shaderManager = new t.WebGLShaderManager(a);
        this.spriteBatch = new t.WebGLSpriteBatch(a);
        this.maskManager = new t.WebGLMaskManager(a);
        this.filterManager = new t.WebGLFilterManager(a, this.transparent);
        this.renderSession = {};
        this.renderSession.gl = this.gl;
        this.renderSession.drawCount = 0;
        this.renderSession.shaderManager = this.shaderManager;
        this.renderSession.maskManager = this.maskManager;
        this.renderSession.filterManager = this.filterManager;
        this.renderSession.spriteBatch = this.spriteBatch;
        this.renderSession.renderer = this;
        a.useProgram(this.shaderManager.defaultShader.program);
        a.disable(a.DEPTH_TEST);
        a.disable(a.CULL_FACE);
        a.enable(a.BLEND);
        a.colorMask(true, true, true, this.transparent)
    };
    t.WebGLRenderer.prototype.constructor = t.WebGLRenderer;
    t.WebGLRenderer.prototype.render = function(e) {
        if (this.contextLost) return;
        if (this.__stage !== e) {
            if (e.interactive) e.interactionManager.removeEvents();
            this.__stage = e
        }
        t.WebGLRenderer.updateTextures();
        e.updateTransform();
        if (e._interactive) {
            if (!e._interactiveEventsAdded) {
                e._interactiveEventsAdded = true;
                e.interactionManager.setTarget(this)
            }
        }
        var n = this.gl;
        n.viewport(0, 0, this.width, this.height);
        n.bindFramebuffer(n.FRAMEBUFFER, null);
        if (this.transparent) {
            n.clearColor(0, 0, 0, 0)
        } else {
            n.clearColor(e.backgroundColorSplit[0], e.backgroundColorSplit[1], e.backgroundColorSplit[2], 1)
        }
        n.clear(n.COLOR_BUFFER_BIT);
        this.renderDisplayObject(e, this.projection);
        if (e.interactive) {
            if (!e._interactiveEventsAdded) {
                e._interactiveEventsAdded = true;
                e.interactionManager.setTarget(this)
            }
        } else {
            if (e._interactiveEventsAdded) {
                e._interactiveEventsAdded = false;
                e.interactionManager.setTarget(this)
            }
        }
    };
    t.WebGLRenderer.prototype.renderDisplayObject = function(e, t, n) {
        this.renderSession.drawCount = 0;
        this.renderSession.currentBlendMode = 9999;
        this.renderSession.projection = t;
        this.renderSession.offset = this.offset;
        this.spriteBatch.begin(this.renderSession);
        this.filterManager.begin(this.renderSession, n);
        e._renderWebGL(this.renderSession);
        this.spriteBatch.end()
    };
    t.WebGLRenderer.updateTextures = function() {
        var e = 0;
        for (e = 0; e < t.Texture.frameUpdates.length; e++) t.WebGLRenderer.updateTextureFrame(t.Texture.frameUpdates[e]);
        for (e = 0; e < t.texturesToDestroy.length; e++) t.WebGLRenderer.destroyTexture(t.texturesToDestroy[e]);
        t.texturesToUpdate.length = 0;
        t.texturesToDestroy.length = 0;
        t.Texture.frameUpdates.length = 0
    };
    t.WebGLRenderer.destroyTexture = function(e) {
        for (var n = e._glTextures.length - 1; n >= 0; n--) {
            var r = e._glTextures[n];
            var i = t.glContexts[n];
            if (i && r) {
                i.deleteTexture(r)
            }
        }
        e._glTextures.length = 0
    };
    t.WebGLRenderer.updateTextureFrame = function(e) {
        e.updateFrame = false;
        e._updateWebGLuvs()
    };
    t.WebGLRenderer.prototype.resize = function(e, t) {
        this.width = e;
        this.height = t;
        this.view.width = e;
        this.view.height = t;
        this.gl.viewport(0, 0, this.width, this.height);
        this.projection.x = this.width / 2;
        this.projection.y = -this.height / 2
    };
    t.createWebGLTexture = function(e, n) {
        if (e.hasLoaded) {
            e._glTextures[n.id] = n.createTexture();
            n.bindTexture(n.TEXTURE_2D, e._glTextures[n.id]);
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, e.source);
            n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, e.scaleMode === t.scaleModes.LINEAR ? n.LINEAR : n.NEAREST);
            n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, e.scaleMode === t.scaleModes.LINEAR ? n.LINEAR : n.NEAREST);
            if (!e._powerOf2) {
                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE);
                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE)
            } else {
                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.REPEAT);
                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.REPEAT)
            }
            n.bindTexture(n.TEXTURE_2D, null)
        }
        return e._glTextures[n.id]
    };
    t.updateWebGLTexture = function(e, n) {
        if (e._glTextures[n.id]) {
            n.bindTexture(n.TEXTURE_2D, e._glTextures[n.id]);
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, e.source);
            n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, e.scaleMode === t.scaleModes.LINEAR ? n.LINEAR : n.NEAREST);
            n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, e.scaleMode === t.scaleModes.LINEAR ? n.LINEAR : n.NEAREST);
            if (!e._powerOf2) {
                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE);
                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE)
            } else {
                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.REPEAT);
                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.REPEAT)
            }
            n.bindTexture(n.TEXTURE_2D, null)
        }
    };
    t.WebGLRenderer.prototype.handleContextLost = function(e) {
        e.preventDefault();
        this.contextLost = true
    };
    t.WebGLRenderer.prototype.handleContextRestored = function() {
        try {
            this.gl = this.view.getContext("experimental-webgl", this.options)
        } catch (e) {
            try {
                this.gl = this.view.getContext("webgl", this.options)
            } catch (n) {
                throw new Error(" This browser does not support webGL. Try using the canvas renderer" + this)
            }
        }
        var r = this.gl;
        r.id = t.WebGLRenderer.glContextId++;
        this.shaderManager.setContext(r);
        this.spriteBatch.setContext(r);
        this.maskManager.setContext(r);
        this.filterManager.setContext(r);
        this.renderSession.gl = this.gl;
        r.disable(r.DEPTH_TEST);
        r.disable(r.CULL_FACE);
        r.enable(r.BLEND);
        r.colorMask(true, true, true, this.transparent);
        this.gl.viewport(0, 0, this.width, this.height);
        for (var i in t.TextureCache) {
            var s = t.TextureCache[i].baseTexture;
            s._glTextures = []
        }
        this.contextLost = false
    };
    t.WebGLRenderer.prototype.destroy = function() {
        this.view.removeEventListener("webglcontextlost", this.contextLost);
        this.view.removeEventListener("webglcontextrestored", this.contextRestoredLost);
        t.glContexts[this.glContextId] = null;
        this.projection = null;
        this.offset = null;
        this.shaderManager.destroy();
        this.spriteBatch.destroy();
        this.maskManager.destroy();
        this.filterManager.destroy();
        this.shaderManager = null;
        this.spriteBatch = null;
        this.maskManager = null;
        this.filterManager = null;
        this.gl = null;
        this.renderSession = null
    };
    t.WebGLRenderer.glContextId = 0;
    t.WebGLMaskManager = function(e) {
        this.maskStack = [];
        this.maskPosition = 0;
        this.setContext(e)
    };
    t.WebGLMaskManager.prototype.setContext = function(e) {
        this.gl = e
    };
    t.WebGLMaskManager.prototype.pushMask = function(e, n) {
        var r = this.gl;
        if (this.maskStack.length === 0) {
            r.enable(r.STENCIL_TEST);
            r.stencilFunc(r.ALWAYS, 1, 1)
        }
        this.maskStack.push(e);
        r.colorMask(false, false, false, false);
        r.stencilOp(r.KEEP, r.KEEP, r.INCR);
        t.WebGLGraphics.renderGraphics(e, n);
        r.colorMask(true, true, true, true);
        r.stencilFunc(r.NOTEQUAL, 0, this.maskStack.length);
        r.stencilOp(r.KEEP, r.KEEP, r.KEEP)
    };
    t.WebGLMaskManager.prototype.popMask = function(e) {
        var n = this.gl;
        var r = this.maskStack.pop();
        if (r) {
            n.colorMask(false, false, false, false);
            n.stencilOp(n.KEEP, n.KEEP, n.DECR);
            t.WebGLGraphics.renderGraphics(r, e);
            n.colorMask(true, true, true, true);
            n.stencilFunc(n.NOTEQUAL, 0, this.maskStack.length);
            n.stencilOp(n.KEEP, n.KEEP, n.KEEP)
        }
        if (this.maskStack.length === 0) n.disable(n.STENCIL_TEST)
    };
    t.WebGLMaskManager.prototype.destroy = function() {
        this.maskStack = null;
        this.gl = null
    };
    t.WebGLShaderManager = function(e) {
        this.maxAttibs = 10;
        this.attribState = [];
        this.tempAttribState = [];
        for (var t = 0; t < this.maxAttibs; t++) {
            this.attribState[t] = false
        }
        this.setContext(e)
    };
    t.WebGLShaderManager.prototype.setContext = function(e) {
        this.gl = e;
        this.primitiveShader = new t.PrimitiveShader(e);
        this.defaultShader = new t.PixiShader(e);
        this.fastShader = new t.PixiFastShader(e);
        this.activateShader(this.defaultShader)
    };
    t.WebGLShaderManager.prototype.setAttribs = function(e) {
        var t;
        for (t = 0; t < this.tempAttribState.length; t++) {
            this.tempAttribState[t] = false
        }
        for (t = 0; t < e.length; t++) {
            var n = e[t];
            this.tempAttribState[n] = true
        }
        var r = this.gl;
        for (t = 0; t < this.attribState.length; t++) {
            if (this.attribState[t] !== this.tempAttribState[t]) {
                this.attribState[t] = this.tempAttribState[t];
                if (this.tempAttribState[t]) {
                    r.enableVertexAttribArray(t)
                } else {
                    r.disableVertexAttribArray(t)
                }
            }
        }
    };
    t.WebGLShaderManager.prototype.activateShader = function(e) {
        this.currentShader = e;
        this.gl.useProgram(e.program);
        this.setAttribs(e.attributes)
    };
    t.WebGLShaderManager.prototype.activatePrimitiveShader = function() {
        var e = this.gl;
        e.useProgram(this.primitiveShader.program);
        this.setAttribs(this.primitiveShader.attributes)
    };
    t.WebGLShaderManager.prototype.deactivatePrimitiveShader = function() {
        var e = this.gl;
        e.useProgram(this.defaultShader.program);
        this.setAttribs(this.defaultShader.attributes)
    };
    t.WebGLShaderManager.prototype.destroy = function() {
        this.attribState = null;
        this.tempAttribState = null;
        this.primitiveShader.destroy();
        this.defaultShader.destroy();
        this.fastShader.destroy();
        this.gl = null
    };
    t.WebGLSpriteBatch = function(e) {
        this.vertSize = 6;
        this.size = 2e3;
        var t = this.size * 4 * this.vertSize;
        var n = this.size * 6;
        this.vertices = new Float32Array(t);
        this.indices = new Uint16Array(n);
        this.lastIndexCount = 0;
        for (var r = 0, i = 0; r < n; r += 6, i += 4) {
            this.indices[r + 0] = i + 0;
            this.indices[r + 1] = i + 1;
            this.indices[r + 2] = i + 2;
            this.indices[r + 3] = i + 0;
            this.indices[r + 4] = i + 2;
            this.indices[r + 5] = i + 3
        }
        this.drawing = false;
        this.currentBatchSize = 0;
        this.currentBaseTexture = null;
        this.setContext(e)
    };
    t.WebGLSpriteBatch.prototype.setContext = function(e) {
        this.gl = e;
        this.vertexBuffer = e.createBuffer();
        this.indexBuffer = e.createBuffer();
        e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW);
        e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer);
        e.bufferData(e.ARRAY_BUFFER, this.vertices, e.DYNAMIC_DRAW);
        this.currentBlendMode = 99999
    };
    t.WebGLSpriteBatch.prototype.begin = function(e) {
        this.renderSession = e;
        this.shader = this.renderSession.shaderManager.defaultShader;
        this.start()
    };
    t.WebGLSpriteBatch.prototype.end = function() {
        this.flush()
    };
    t.WebGLSpriteBatch.prototype.render = function(e) {
        var t = e.texture;
        if (t.baseTexture !== this.currentBaseTexture || this.currentBatchSize >= this.size) {
            this.flush();
            this.currentBaseTexture = t.baseTexture
        }
        if (e.blendMode !== this.currentBlendMode) {
            this.setBlendMode(e.blendMode)
        }
        var n = e._uvs || e.texture._uvs;
        if (!n) return;
        var r = e.worldAlpha;
        var i = e.tint;
        var s = this.vertices;
        var o = e.anchor.x;
        var u = e.anchor.y;
        var a, f, l, c;
        if (e.texture.trim) {
            var h = e.texture.trim;
            f = h.x - o * h.width;
            a = f + t.frame.width;
            c = h.y - u * h.height;
            l = c + t.frame.height
        } else {
            a = t.frame.width * (1 - o);
            f = t.frame.width * -o;
            l = t.frame.height * (1 - u);
            c = t.frame.height * -u
        }
        var p = this.currentBatchSize * 4 * this.vertSize;
        var d = e.worldTransform;
        var v = d.a;
        var m = d.c;
        var g = d.b;
        var y = d.d;
        var b = d.tx;
        var w = d.ty;
        s[p++] = v * f + g * c + b;
        s[p++] = y * c + m * f + w;
        s[p++] = n.x0;
        s[p++] = n.y0;
        s[p++] = r;
        s[p++] = i;
        s[p++] = v * a + g * c + b;
        s[p++] = y * c + m * a + w;
        s[p++] = n.x1;
        s[p++] = n.y1;
        s[p++] = r;
        s[p++] = i;
        s[p++] = v * a + g * l + b;
        s[p++] = y * l + m * a + w;
        s[p++] = n.x2;
        s[p++] = n.y2;
        s[p++] = r;
        s[p++] = i;
        s[p++] = v * f + g * l + b;
        s[p++] = y * l + m * f + w;
        s[p++] = n.x3;
        s[p++] = n.y3;
        s[p++] = r;
        s[p++] = i;
        this.currentBatchSize++
    };
    t.WebGLSpriteBatch.prototype.renderTilingSprite = function(e) {
        var n = e.tilingTexture;
        if (n.baseTexture !== this.currentBaseTexture || this.currentBatchSize >= this.size) {
            this.flush();
            this.currentBaseTexture = n.baseTexture
        }
        if (e.blendMode !== this.currentBlendMode) {
            this.setBlendMode(e.blendMode)
        }
        if (!e._uvs) e._uvs = new t.TextureUvs;
        var r = e._uvs;
        e.tilePosition.x %= n.baseTexture.width * e.tileScaleOffset.x;
        e.tilePosition.y %= n.baseTexture.height * e.tileScaleOffset.y;
        var i = e.tilePosition.x / (n.baseTexture.width * e.tileScaleOffset.x);
        var s = e.tilePosition.y / (n.baseTexture.height * e.tileScaleOffset.y);
        var o = e.width / n.baseTexture.width / (e.tileScale.x * e.tileScaleOffset.x);
        var u = e.height / n.baseTexture.height / (e.tileScale.y * e.tileScaleOffset.y);
        r.x0 = 0 - i;
        r.y0 = 0 - s;
        r.x1 = 1 * o - i;
        r.y1 = 0 - s;
        r.x2 = 1 * o - i;
        r.y2 = 1 * u - s;
        r.x3 = 0 - i;
        r.y3 = 1 * u - s;
        var a = e.worldAlpha;
        var f = e.tint;
        var l = this.vertices;
        var c = e.width;
        var h = e.height;
        var p = e.anchor.x;
        var d = e.anchor.y;
        var v = c * (1 - p);
        var m = c * -p;
        var g = h * (1 - d);
        var y = h * -d;
        var b = this.currentBatchSize * 4 * this.vertSize;
        var w = e.worldTransform;
        var E = w.a;
        var S = w.c;
        var x = w.b;
        var T = w.d;
        var N = w.tx;
        var C = w.ty;
        l[b++] = E * m + x * y + N;
        l[b++] = T * y + S * m + C;
        l[b++] = r.x0;
        l[b++] = r.y0;
        l[b++] = a;
        l[b++] = f;
        l[b++] = E * v + x * y + N;
        l[b++] = T * y + S * v + C;
        l[b++] = r.x1;
        l[b++] = r.y1;
        l[b++] = a;
        l[b++] = f;
        l[b++] = E * v + x * g + N;
        l[b++] = T * g + S * v + C;
        l[b++] = r.x2;
        l[b++] = r.y2;
        l[b++] = a;
        l[b++] = f;
        l[b++] = E * m + x * g + N;
        l[b++] = T * g + S * m + C;
        l[b++] = r.x3;
        l[b++] = r.y3;
        l[b++] = a;
        l[b++] = f;
        this.currentBatchSize++
    };
    t.WebGLSpriteBatch.prototype.flush = function() {
        if (this.currentBatchSize === 0) return;
        var e = this.gl;
        e.bindTexture(e.TEXTURE_2D, this.currentBaseTexture._glTextures[e.id] || t.createWebGLTexture(this.currentBaseTexture, e));
        if (this.currentBatchSize > this.size * .5) {
            e.bufferSubData(e.ARRAY_BUFFER, 0, this.vertices)
        } else {
            var n = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);
            e.bufferSubData(e.ARRAY_BUFFER, 0, n)
        }
        e.drawElements(e.TRIANGLES, this.currentBatchSize * 6, e.UNSIGNED_SHORT, 0);
        this.currentBatchSize = 0;
        this.renderSession.drawCount++
    };
    t.WebGLSpriteBatch.prototype.stop = function() {
        this.flush()
    };
    t.WebGLSpriteBatch.prototype.start = function() {
        var e = this.gl;
        e.activeTexture(e.TEXTURE0);
        e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer);
        e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var n = this.renderSession.projection;
        e.uniform2f(this.shader.projectionVector, n.x, n.y);
        var r = this.vertSize * 4;
        e.vertexAttribPointer(this.shader.aVertexPosition, 2, e.FLOAT, false, r, 0);
        e.vertexAttribPointer(this.shader.aTextureCoord, 2, e.FLOAT, false, r, 2 * 4);
        e.vertexAttribPointer(this.shader.colorAttribute, 2, e.FLOAT, false, r, 4 * 4);
        if (this.currentBlendMode !== t.blendModes.NORMAL) {
            this.setBlendMode(t.blendModes.NORMAL)
        }
    };
    t.WebGLSpriteBatch.prototype.setBlendMode = function(e) {
        this.flush();
        this.currentBlendMode = e;
        var n = t.blendModesWebGL[this.currentBlendMode];
        this.gl.blendFunc(n[0], n[1])
    };
    t.WebGLSpriteBatch.prototype.destroy = function() {
        this.vertices = null;
        this.indices = null;
        this.gl.deleteBuffer(this.vertexBuffer);
        this.gl.deleteBuffer(this.indexBuffer);
        this.currentBaseTexture = null;
        this.gl = null
    };
    t.WebGLFastSpriteBatch = function(e) {
        this.vertSize = 10;
        this.maxSize = 6e3;
        this.size = this.maxSize;
        var t = this.size * 4 * this.vertSize;
        var n = this.maxSize * 6;
        this.vertices = new Float32Array(t);
        this.indices = new Uint16Array(n);
        this.vertexBuffer = null;
        this.indexBuffer = null;
        this.lastIndexCount = 0;
        for (var r = 0, i = 0; r < n; r += 6, i += 4) {
            this.indices[r + 0] = i + 0;
            this.indices[r + 1] = i + 1;
            this.indices[r + 2] = i + 2;
            this.indices[r + 3] = i + 0;
            this.indices[r + 4] = i + 2;
            this.indices[r + 5] = i + 3
        }
        this.drawing = false;
        this.currentBatchSize = 0;
        this.currentBaseTexture = null;
        this.currentBlendMode = 0;
        this.renderSession = null;
        this.shader = null;
        this.matrix = null;
        this.setContext(e)
    };
    t.WebGLFastSpriteBatch.prototype.setContext = function(e) {
        this.gl = e;
        this.vertexBuffer = e.createBuffer();
        this.indexBuffer = e.createBuffer();
        e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW);
        e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer);
        e.bufferData(e.ARRAY_BUFFER, this.vertices, e.DYNAMIC_DRAW);
        this.currentBlendMode = 99999
    };
    t.WebGLFastSpriteBatch.prototype.begin = function(e, t) {
        this.renderSession = t;
        this.shader = this.renderSession.shaderManager.fastShader;
        this.matrix = e.worldTransform.toArray(true);
        this.start()
    };
    t.WebGLFastSpriteBatch.prototype.end = function() {
        this.flush()
    };
    t.WebGLFastSpriteBatch.prototype.render = function(e) {
        var t = e.children;
        var n = t[0];
        if (!n.texture._uvs) return;
        this.currentBaseTexture = n.texture.baseTexture;
        if (n.blendMode !== this.currentBlendMode) {
            this.setBlendMode(n.blendMode)
        }
        for (var r = 0, i = t.length; r < i; r++) {
            this.renderSprite(t[r])
        }
        this.flush()
    };
    t.WebGLFastSpriteBatch.prototype.renderSprite = function(e) {
        if (!e.visible) return;
        if (e.texture.baseTexture !== this.currentBaseTexture) {
            this.flush();
            this.currentBaseTexture = e.texture.baseTexture;
            if (!e.texture._uvs) return
        }
        var t, n = this.vertices,
            r, i, s, o, u, a, f;
        t = e.texture._uvs;
        r = e.texture.frame.width;
        i = e.texture.frame.height;
        if (e.texture.trim) {
            var l = e.texture.trim;
            o = l.x - e.anchor.x * l.width;
            s = o + e.texture.frame.width;
            a = l.y - e.anchor.y * l.height;
            u = a + e.texture.frame.height
        } else {
            s = e.texture.frame.width * (1 - e.anchor.x);
            o = e.texture.frame.width * -e.anchor.x;
            u = e.texture.frame.height * (1 - e.anchor.y);
            a = e.texture.frame.height * -e.anchor.y
        }
        f = this.currentBatchSize * 4 * this.vertSize;
        n[f++] = o;
        n[f++] = a;
        n[f++] = e.position.x;
        n[f++] = e.position.y;
        n[f++] = e.scale.x;
        n[f++] = e.scale.y;
        n[f++] = e.rotation;
        n[f++] = t.x0;
        n[f++] = t.y1;
        n[f++] = e.alpha;
        n[f++] = s;
        n[f++] = a;
        n[f++] = e.position.x;
        n[f++] = e.position.y;
        n[f++] = e.scale.x;
        n[f++] = e.scale.y;
        n[f++] = e.rotation;
        n[f++] = t.x1;
        n[f++] = t.y1;
        n[f++] = e.alpha;
        n[f++] = s;
        n[f++] = u;
        n[f++] = e.position.x;
        n[f++] = e.position.y;
        n[f++] = e.scale.x;
        n[f++] = e.scale.y;
        n[f++] = e.rotation;
        n[f++] = t.x2;
        n[f++] = t.y2;
        n[f++] = e.alpha;
        n[f++] = o;
        n[f++] = u;
        n[f++] = e.position.x;
        n[f++] = e.position.y;
        n[f++] = e.scale.x;
        n[f++] = e.scale.y;
        n[f++] = e.rotation;
        n[f++] = t.x3;
        n[f++] = t.y3;
        n[f++] = e.alpha;
        this.currentBatchSize++;
        if (this.currentBatchSize >= this.size) {
            this.flush()
        }
    };
    t.WebGLFastSpriteBatch.prototype.flush = function() {
        if (this.currentBatchSize === 0) return;
        var e = this.gl;
        if (!this.currentBaseTexture._glTextures[e.id]) t.createWebGLTexture(this.currentBaseTexture, e);
        e.bindTexture(e.TEXTURE_2D, this.currentBaseTexture._glTextures[e.id]);
        if (this.currentBatchSize > this.size * .5) {
            e.bufferSubData(e.ARRAY_BUFFER, 0, this.vertices)
        } else {
            var n = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);
            e.bufferSubData(e.ARRAY_BUFFER, 0, n)
        }
        e.drawElements(e.TRIANGLES, this.currentBatchSize * 6, e.UNSIGNED_SHORT, 0);
        this.currentBatchSize = 0;
        this.renderSession.drawCount++
    };
    t.WebGLFastSpriteBatch.prototype.stop = function() {
        this.flush()
    };
    t.WebGLFastSpriteBatch.prototype.start = function() {
        var e = this.gl;
        e.activeTexture(e.TEXTURE0);
        e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer);
        e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var n = this.renderSession.projection;
        e.uniform2f(this.shader.projectionVector, n.x, n.y);
        e.uniformMatrix3fv(this.shader.uMatrix, false, this.matrix);
        var r = this.vertSize * 4;
        e.vertexAttribPointer(this.shader.aVertexPosition, 2, e.FLOAT, false, r, 0);
        e.vertexAttribPointer(this.shader.aPositionCoord, 2, e.FLOAT, false, r, 2 * 4);
        e.vertexAttribPointer(this.shader.aScale, 2, e.FLOAT, false, r, 4 * 4);
        e.vertexAttribPointer(this.shader.aRotation, 1, e.FLOAT, false, r, 6 * 4);
        e.vertexAttribPointer(this.shader.aTextureCoord, 2, e.FLOAT, false, r, 7 * 4);
        e.vertexAttribPointer(this.shader.colorAttribute, 1, e.FLOAT, false, r, 9 * 4);
        if (this.currentBlendMode !== t.blendModes.NORMAL) {
            this.setBlendMode(t.blendModes.NORMAL)
        }
    };
    t.WebGLFastSpriteBatch.prototype.setBlendMode = function(e) {
        this.flush();
        this.currentBlendMode = e;
        var n = t.blendModesWebGL[this.currentBlendMode];
        this.gl.blendFunc(n[0], n[1])
    };
    t.WebGLFilterManager = function(e, t) {
        this.transparent = t;
        this.filterStack = [];
        this.offsetX = 0;
        this.offsetY = 0;
        this.setContext(e)
    };
    t.WebGLFilterManager.prototype.setContext = function(e) {
        this.gl = e;
        this.texturePool = [];
        this.initShaderBuffers()
    };
    t.WebGLFilterManager.prototype.begin = function(e, t) {
        this.renderSession = e;
        this.defaultShader = e.shaderManager.defaultShader;
        var n = this.renderSession.projection;
        this.width = n.x * 2;
        this.height = -n.y * 2;
        this.buffer = t
    };
    t.WebGLFilterManager.prototype.pushFilter = function(e) {
        var n = this.gl;
        var r = this.renderSession.projection;
        var i = this.renderSession.offset;
        e._filterArea = e.target.filterArea || e.target.getBounds();
        this.filterStack.push(e);
        var s = e.filterPasses[0];
        this.offsetX += e._filterArea.x;
        this.offsetY += e._filterArea.y;
        var o = this.texturePool.pop();
        if (!o) {
            o = new t.FilterTexture(this.gl, this.width, this.height)
        } else {
            o.resize(this.width, this.height)
        }
        n.bindTexture(n.TEXTURE_2D, o.texture);
        var u = e._filterArea;
        var a = s.padding;
        u.x -= a;
        u.y -= a;
        u.width += a * 2;
        u.height += a * 2;
        if (u.x < 0) u.x = 0;
        if (u.width > this.width) u.width = this.width;
        if (u.y < 0) u.y = 0;
        if (u.height > this.height) u.height = this.height;
        n.bindFramebuffer(n.FRAMEBUFFER, o.frameBuffer);
        n.viewport(0, 0, u.width, u.height);
        r.x = u.width / 2;
        r.y = -u.height / 2;
        i.x = -u.x;
        i.y = -u.y;
        n.uniform2f(this.defaultShader.projectionVector, u.width / 2, -u.height / 2);
        n.uniform2f(this.defaultShader.offsetVector, -u.x, -u.y);
        n.colorMask(true, true, true, true);
        n.clearColor(0, 0, 0, 0);
        n.clear(n.COLOR_BUFFER_BIT);
        e._glFilterTexture = o
    };
    t.WebGLFilterManager.prototype.popFilter = function() {
        var e = this.gl;
        var n = this.filterStack.pop();
        var r = n._filterArea;
        var i = n._glFilterTexture;
        var s = this.renderSession.projection;
        var o = this.renderSession.offset;
        if (n.filterPasses.length > 1) {
            e.viewport(0, 0, r.width, r.height);
            e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer);
            this.vertexArray[0] = 0;
            this.vertexArray[1] = r.height;
            this.vertexArray[2] = r.width;
            this.vertexArray[3] = r.height;
            this.vertexArray[4] = 0;
            this.vertexArray[5] = 0;
            this.vertexArray[6] = r.width;
            this.vertexArray[7] = 0;
            e.bufferSubData(e.ARRAY_BUFFER, 0, this.vertexArray);
            e.bindBuffer(e.ARRAY_BUFFER, this.uvBuffer);
            this.uvArray[2] = r.width / this.width;
            this.uvArray[5] = r.height / this.height;
            this.uvArray[6] = r.width / this.width;
            this.uvArray[7] = r.height / this.height;
            e.bufferSubData(e.ARRAY_BUFFER, 0, this.uvArray);
            var u = i;
            var a = this.texturePool.pop();
            if (!a) a = new t.FilterTexture(this.gl, this.width, this.height);
            a.resize(this.width, this.height);
            e.bindFramebuffer(e.FRAMEBUFFER, a.frameBuffer);
            e.clear(e.COLOR_BUFFER_BIT);
            e.disable(e.BLEND);
            for (var f = 0; f < n.filterPasses.length - 1; f++) {
                var l = n.filterPasses[f];
                e.bindFramebuffer(e.FRAMEBUFFER, a.frameBuffer);
                e.activeTexture(e.TEXTURE0);
                e.bindTexture(e.TEXTURE_2D, u.texture);
                this.applyFilterPass(l, r, r.width, r.height);
                var c = u;
                u = a;
                a = c
            }
            e.enable(e.BLEND);
            i = u;
            this.texturePool.push(a)
        }
        var h = n.filterPasses[n.filterPasses.length - 1];
        this.offsetX -= r.x;
        this.offsetY -= r.y;
        var p = this.width;
        var d = this.height;
        var v = 0;
        var m = 0;
        var g = this.buffer;
        if (this.filterStack.length === 0) {
            e.colorMask(true, true, true, true)
        } else {
            var y = this.filterStack[this.filterStack.length - 1];
            r = y._filterArea;
            p = r.width;
            d = r.height;
            v = r.x;
            m = r.y;
            g = y._glFilterTexture.frameBuffer
        }
        s.x = p / 2;
        s.y = -d / 2;
        o.x = v;
        o.y = m;
        r = n._filterArea;
        var b = r.x - v;
        var w = r.y - m;
        e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer);
        this.vertexArray[0] = b;
        this.vertexArray[1] = w + r.height;
        this.vertexArray[2] = b + r.width;
        this.vertexArray[3] = w + r.height;
        this.vertexArray[4] = b;
        this.vertexArray[5] = w;
        this.vertexArray[6] = b + r.width;
        this.vertexArray[7] = w;
        e.bufferSubData(e.ARRAY_BUFFER, 0, this.vertexArray);
        e.bindBuffer(e.ARRAY_BUFFER, this.uvBuffer);
        this.uvArray[2] = r.width / this.width;
        this.uvArray[5] = r.height / this.height;
        this.uvArray[6] = r.width / this.width;
        this.uvArray[7] = r.height / this.height;
        e.bufferSubData(e.ARRAY_BUFFER, 0, this.uvArray);
        e.viewport(0, 0, p, d);
        e.bindFramebuffer(e.FRAMEBUFFER, g);
        e.activeTexture(e.TEXTURE0);
        e.bindTexture(e.TEXTURE_2D, i.texture);
        this.applyFilterPass(h, r, p, d);
        e.useProgram(this.defaultShader.program);
        e.uniform2f(this.defaultShader.projectionVector, p / 2, -d / 2);
        e.uniform2f(this.defaultShader.offsetVector, -v, -m);
        this.texturePool.push(i);
        n._glFilterTexture = null
    };
    t.WebGLFilterManager.prototype.applyFilterPass = function(e, n, r, i) {
        var s = this.gl;
        var o = e.shaders[s.id];
        if (!o) {
            o = new t.PixiShader(s);
            o.fragmentSrc = e.fragmentSrc;
            o.uniforms = e.uniforms;
            o.init();
            e.shaders[s.id] = o
        }
        s.useProgram(o.program);
        s.uniform2f(o.projectionVector, r / 2, -i / 2);
        s.uniform2f(o.offsetVector, 0, 0);
        if (e.uniforms.dimensions) {
            e.uniforms.dimensions.value[0] = this.width;
            e.uniforms.dimensions.value[1] = this.height;
            e.uniforms.dimensions.value[2] = this.vertexArray[0];
            e.uniforms.dimensions.value[3] = this.vertexArray[5]
        }
        o.syncUniforms();
        s.bindBuffer(s.ARRAY_BUFFER, this.vertexBuffer);
        s.vertexAttribPointer(o.aVertexPosition, 2, s.FLOAT, false, 0, 0);
        s.bindBuffer(s.ARRAY_BUFFER, this.uvBuffer);
        s.vertexAttribPointer(o.aTextureCoord, 2, s.FLOAT, false, 0, 0);
        s.bindBuffer(s.ARRAY_BUFFER, this.colorBuffer);
        s.vertexAttribPointer(o.colorAttribute, 2, s.FLOAT, false, 0, 0);
        s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        s.drawElements(s.TRIANGLES, 6, s.UNSIGNED_SHORT, 0);
        this.renderSession.drawCount++
    };
    t.WebGLFilterManager.prototype.initShaderBuffers = function() {
        var e = this.gl;
        this.vertexBuffer = e.createBuffer();
        this.uvBuffer = e.createBuffer();
        this.colorBuffer = e.createBuffer();
        this.indexBuffer = e.createBuffer();
        this.vertexArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
        e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer);
        e.bufferData(e.ARRAY_BUFFER, this.vertexArray, e.STATIC_DRAW);
        this.uvArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
        e.bindBuffer(e.ARRAY_BUFFER, this.uvBuffer);
        e.bufferData(e.ARRAY_BUFFER, this.uvArray, e.STATIC_DRAW);
        this.colorArray = new Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]);
        e.bindBuffer(e.ARRAY_BUFFER, this.colorBuffer);
        e.bufferData(e.ARRAY_BUFFER, this.colorArray, e.STATIC_DRAW);
        e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        e.bufferData(e.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), e.STATIC_DRAW)
    };
    t.WebGLFilterManager.prototype.destroy = function() {
        var e = this.gl;
        this.filterStack = null;
        this.offsetX = 0;
        this.offsetY = 0;
        for (var t = 0; t < this.texturePool.length; t++) {
            this.texturePool.destroy()
        }
        this.texturePool = null;
        e.deleteBuffer(this.vertexBuffer);
        e.deleteBuffer(this.uvBuffer);
        e.deleteBuffer(this.colorBuffer);
        e.deleteBuffer(this.indexBuffer)
    };
    t.FilterTexture = function(e, n, r, i) {
        this.gl = e;
        this.frameBuffer = e.createFramebuffer();
        this.texture = e.createTexture();
        i = i || t.scaleModes.DEFAULT;
        e.bindTexture(e.TEXTURE_2D, this.texture);
        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, i === t.scaleModes.LINEAR ? e.LINEAR : e.NEAREST);
        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, i === t.scaleModes.LINEAR ? e.LINEAR : e.NEAREST);
        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE);
        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE);
        e.bindFramebuffer(e.FRAMEBUFFER, this.framebuffer);
        e.bindFramebuffer(e.FRAMEBUFFER, this.frameBuffer);
        e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this.texture, 0);
        this.renderBuffer = e.createRenderbuffer();
        e.bindRenderbuffer(e.RENDERBUFFER, this.renderBuffer);
        e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, this.renderBuffer);
        this.resize(n, r)
    };
    t.FilterTexture.prototype.clear = function() {
        var e = this.gl;
        e.clearColor(0, 0, 0, 0);
        e.clear(e.COLOR_BUFFER_BIT)
    };
    t.FilterTexture.prototype.resize = function(e, t) {
        if (this.width === e && this.height === t) return;
        this.width = e;
        this.height = t;
        var n = this.gl;
        n.bindTexture(n.TEXTURE_2D, this.texture);
        n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, e, t, 0, n.RGBA, n.UNSIGNED_BYTE, null);
        n.bindRenderbuffer(n.RENDERBUFFER, this.renderBuffer);
        n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, e, t)
    };
    t.FilterTexture.prototype.destroy = function() {
        var e = this.gl;
        e.deleteFramebuffer(this.frameBuffer);
        e.deleteTexture(this.texture);
        this.frameBuffer = null;
        this.texture = null
    };
    t.CanvasMaskManager = function() {};
    t.CanvasMaskManager.prototype.pushMask = function(e, n) {
        n.save();
        var r = e.alpha;
        var i = e.worldTransform;
        n.setTransform(i.a, i.c, i.b, i.d, i.tx, i.ty);
        t.CanvasGraphics.renderGraphicsMask(e, n);
        n.clip();
        e.worldAlpha = r
    };
    t.CanvasMaskManager.prototype.popMask = function(e) {
        e.restore()
    };
    t.CanvasTinter = function() {};
    t.CanvasTinter.getTintedTexture = function(e, n) {
        var r = e.texture;
        n = t.CanvasTinter.roundColor(n);
        var i = "#" + ("00000" + (n | 0).toString(16)).substr(-6);
        r.tintCache = r.tintCache || {};
        if (r.tintCache[i]) return r.tintCache[i];
        var s = t.CanvasTinter.canvas || document.createElement("canvas");
        t.CanvasTinter.tintMethod(r, n, s);
        if (t.CanvasTinter.convertTintToImage) {
            var o = new Image;
            o.src = s.toDataURL();
            r.tintCache[i] = o
        } else {
            r.tintCache[i] = s;
            t.CanvasTinter.canvas = null
        }
        return s
    };
    t.CanvasTinter.tintWithMultiply = function(e, t, n) {
        var r = n.getContext("2d");
        var i = e.frame;
        n.width = i.width;
        n.height = i.height;
        r.fillStyle = "#" + ("00000" + (t | 0).toString(16)).substr(-6);
        r.fillRect(0, 0, i.width, i.height);
        r.globalCompositeOperation = "multiply";
        r.drawImage(e.baseTexture.source, i.x, i.y, i.width, i.height, 0, 0, i.width, i.height);
        r.globalCompositeOperation = "destination-atop";
        r.drawImage(e.baseTexture.source, i.x, i.y, i.width, i.height, 0, 0, i.width, i.height)
    };
    t.CanvasTinter.tintWithOverlay = function(e, t, n) {
        var r = n.getContext("2d");
        var i = e.frame;
        n.width = i.width;
        n.height = i.height;
        r.globalCompositeOperation = "copy";
        r.fillStyle = "#" + ("00000" + (t | 0).toString(16)).substr(-6);
        r.fillRect(0, 0, i.width, i.height);
        r.globalCompositeOperation = "destination-atop";
        r.drawImage(e.baseTexture.source, i.x, i.y, i.width, i.height, 0, 0, i.width, i.height)
    };
    t.CanvasTinter.tintWithPerPixel = function(e, n, r) {
        var i = r.getContext("2d");
        var s = e.frame;
        r.width = s.width;
        r.height = s.height;
        i.globalCompositeOperation = "copy";
        i.drawImage(e.baseTexture.source, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height);
        var o = t.hex2rgb(n);
        var u = o[0],
            a = o[1],
            f = o[2];
        var l = i.getImageData(0, 0, s.width, s.height);
        var c = l.data;
        for (var h = 0; h < c.length; h += 4) {
            c[h + 0] *= u;
            c[h + 1] *= a;
            c[h + 2] *= f
        }
        i.putImageData(l, 0, 0)
    };
    t.CanvasTinter.roundColor = function(e) {
        var n = t.CanvasTinter.cacheStepsPerColorChannel;
        var r = t.hex2rgb(e);
        r[0] = Math.min(255, r[0] / n * n);
        r[1] = Math.min(255, r[1] / n * n);
        r[2] = Math.min(255, r[2] / n * n);
        return t.rgb2hex(r)
    };
    t.CanvasTinter.cacheStepsPerColorChannel = 8;
    t.CanvasTinter.convertTintToImage = false;
    t.CanvasTinter.canUseMultiply = t.canUseNewCanvasBlendModes();
    t.CanvasTinter.tintMethod = t.CanvasTinter.canUseMultiply ? t.CanvasTinter.tintWithMultiply : t.CanvasTinter.tintWithPerPixel;
    t.CanvasRenderer = function(e, n, r, i) {
        t.defaultRenderer = t.defaultRenderer || this;
        this.type = t.CANVAS_RENDERER;
        this.clearBeforeRender = true;
        this.roundPixels = false;
        this.transparent = !! i;
        if (!t.blendModesCanvas) {
            t.blendModesCanvas = [];
            if (t.canUseNewCanvasBlendModes()) {
                t.blendModesCanvas[t.blendModes.NORMAL] = "source-over";
                t.blendModesCanvas[t.blendModes.ADD] = "lighter";
                t.blendModesCanvas[t.blendModes.MULTIPLY] = "multiply";
                t.blendModesCanvas[t.blendModes.SCREEN] = "screen";
                t.blendModesCanvas[t.blendModes.OVERLAY] = "overlay";
                t.blendModesCanvas[t.blendModes.DARKEN] = "darken";
                t.blendModesCanvas[t.blendModes.LIGHTEN] = "lighten";
                t.blendModesCanvas[t.blendModes.COLOR_DODGE] = "color-dodge";
                t.blendModesCanvas[t.blendModes.COLOR_BURN] = "color-burn";
                t.blendModesCanvas[t.blendModes.HARD_LIGHT] = "hard-light";
                t.blendModesCanvas[t.blendModes.SOFT_LIGHT] = "soft-light";
                t.blendModesCanvas[t.blendModes.DIFFERENCE] = "difference";
                t.blendModesCanvas[t.blendModes.EXCLUSION] = "exclusion";
                t.blendModesCanvas[t.blendModes.HUE] = "hue";
                t.blendModesCanvas[t.blendModes.SATURATION] = "saturation";
                t.blendModesCanvas[t.blendModes.COLOR] = "color";
                t.blendModesCanvas[t.blendModes.LUMINOSITY] = "luminosity"
            } else {
                t.blendModesCanvas[t.blendModes.NORMAL] = "source-over";
                t.blendModesCanvas[t.blendModes.ADD] = "lighter";
                t.blendModesCanvas[t.blendModes.MULTIPLY] = "source-over";
                t.blendModesCanvas[t.blendModes.SCREEN] = "source-over";
                t.blendModesCanvas[t.blendModes.OVERLAY] = "source-over";
                t.blendModesCanvas[t.blendModes.DARKEN] = "source-over";
                t.blendModesCanvas[t.blendModes.LIGHTEN] = "source-over";
                t.blendModesCanvas[t.blendModes.COLOR_DODGE] = "source-over";
                t.blendModesCanvas[t.blendModes.COLOR_BURN] = "source-over";
                t.blendModesCanvas[t.blendModes.HARD_LIGHT] = "source-over";
                t.blendModesCanvas[t.blendModes.SOFT_LIGHT] = "source-over";
                t.blendModesCanvas[t.blendModes.DIFFERENCE] = "source-over";
                t.blendModesCanvas[t.blendModes.EXCLUSION] = "source-over";
                t.blendModesCanvas[t.blendModes.HUE] = "source-over";
                t.blendModesCanvas[t.blendModes.SATURATION] = "source-over";
                t.blendModesCanvas[t.blendModes.COLOR] = "source-over";
                t.blendModesCanvas[t.blendModes.LUMINOSITY] = "source-over"
            }
        }
        this.width = e || 800;
        this.height = n || 600;
        this.view = r || document.createElement("canvas");
        this.context = this.view.getContext("2d", {
            alpha: this.transparent
        });
        this.refresh = true;
        this.view.width = this.width;
        this.view.height = this.height;
        this.count = 0;
        this.maskManager = new t.CanvasMaskManager;
        this.renderSession = {
            context: this.context,
            maskManager: this.maskManager,
            scaleMode: null,
            smoothProperty: null
        };
        if ("imageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "imageSmoothingEnabled";
        else if ("webkitImageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "webkitImageSmoothingEnabled";
        else if ("mozImageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "mozImageSmoothingEnabled";
        else if ("oImageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "oImageSmoothingEnabled"
    };
    t.CanvasRenderer.prototype.constructor = t.CanvasRenderer;
    t.CanvasRenderer.prototype.render = function(e) {
        t.texturesToUpdate.length = 0;
        t.texturesToDestroy.length = 0;
        e.updateTransform();
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.globalAlpha = 1;
        if (!this.transparent && this.clearBeforeRender) {
            this.context.fillStyle = e.backgroundColorString;
            this.context.fillRect(0, 0, this.width, this.height)
        } else if (this.transparent && this.clearBeforeRender) {
            this.context.clearRect(0, 0, this.width, this.height)
        }
        this.renderDisplayObject(e);
        if (e.interactive) {
            if (!e._interactiveEventsAdded) {
                e._interactiveEventsAdded = true;
                e.interactionManager.setTarget(this)
            }
        }
        if (t.Texture.frameUpdates.length > 0) {
            t.Texture.frameUpdates.length = 0
        }
    };
    t.CanvasRenderer.prototype.resize = function(e, t) {
        this.width = e;
        this.height = t;
        this.view.width = e;
        this.view.height = t
    };
    t.CanvasRenderer.prototype.renderDisplayObject = function(e, t) {
        this.renderSession.context = t || this.context;
        e._renderCanvas(this.renderSession)
    };
    t.CanvasRenderer.prototype.renderStripFlat = function(e) {
        var t = this.context;
        var n = e.verticies;
        var r = n.length / 2;
        this.count++;
        t.beginPath();
        for (var i = 1; i < r - 2; i++) {
            var s = i * 2;
            var o = n[s],
                u = n[s + 2],
                a = n[s + 4];
            var f = n[s + 1],
                l = n[s + 3],
                c = n[s + 5];
            t.moveTo(o, f);
            t.lineTo(u, l);
            t.lineTo(a, c)
        }
        t.fillStyle = "#FF0000";
        t.fill();
        t.closePath()
    };
    t.CanvasRenderer.prototype.renderStrip = function(e) {
        var t = this.context;
        var n = e.verticies;
        var r = e.uvs;
        var i = n.length / 2;
        this.count++;
        for (var s = 1; s < i - 2; s++) {
            var o = s * 2;
            var u = n[o],
                a = n[o + 2],
                f = n[o + 4];
            var l = n[o + 1],
                c = n[o + 3],
                h = n[o + 5];
            var p = r[o] * e.texture.width,
                d = r[o + 2] * e.texture.width,
                v = r[o + 4] * e.texture.width;
            var m = r[o + 1] * e.texture.height,
                g = r[o + 3] * e.texture.height,
                y = r[o + 5] * e.texture.height;
            t.save();
            t.beginPath();
            t.moveTo(u, l);
            t.lineTo(a, c);
            t.lineTo(f, h);
            t.closePath();
            t.clip();
            var b = p * g + m * v + d * y - g * v - m * d - p * y;
            var w = u * g + m * f + a * y - g * f - m * a - u * y;
            var E = p * a + u * v + d * f - a * v - u * d - p * f;
            var S = p * g * f + m * a * v + u * d * y - u * g * v - m * d * f - p * a * y;
            var x = l * g + m * h + c * y - g * h - m * c - l * y;
            var T = p * c + l * v + d * h - c * v - l * d - p * h;
            var N = p * g * h + m * c * v + l * d * y - l * g * v - m * d * h - p * c * y;
            t.transform(w / b, x / b, E / b, T / b, S / b, N / b);
            t.drawImage(e.texture.baseTexture.source, 0, 0);
            t.restore()
        }
    };
    t.CanvasBuffer = function(e, t) {
        this.width = e;
        this.height = t;
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d");
        this.canvas.width = e;
        this.canvas.height = t
    };
    t.CanvasBuffer.prototype.clear = function() {
        this.context.clearRect(0, 0, this.width, this.height)
    };
    t.CanvasBuffer.prototype.resize = function(e, t) {
        this.width = this.canvas.width = e;
        this.height = this.canvas.height = t
    };
    t.CanvasGraphics = function() {};
    t.CanvasGraphics.renderGraphics = function(e, n) {
        var r = e.worldAlpha;
        var i = "";
        for (var s = 0; s < e.graphicsData.length; s++) {
            var o = e.graphicsData[s];
            var u = o.points;
            n.strokeStyle = i = "#" + ("00000" + (o.lineColor | 0).toString(16)).substr(-6);
            n.lineWidth = o.lineWidth;
            if (o.type === t.Graphics.POLY) {
                n.beginPath();
                n.moveTo(u[0], u[1]);
                for (var a = 1; a < u.length / 2; a++) {
                    n.lineTo(u[a * 2], u[a * 2 + 1])
                }
                if (u[0] === u[u.length - 2] && u[1] === u[u.length - 1]) {
                    n.closePath()
                }
                if (o.fill) {
                    n.globalAlpha = o.fillAlpha * r;
                    n.fillStyle = i = "#" + ("00000" + (o.fillColor | 0).toString(16)).substr(-6);
                    n.fill()
                }
                if (o.lineWidth) {
                    n.globalAlpha = o.lineAlpha * r;
                    n.stroke()
                }
            } else if (o.type === t.Graphics.RECT) {
                if (o.fillColor || o.fillColor === 0) {
                    n.globalAlpha = o.fillAlpha * r;
                    n.fillStyle = i = "#" + ("00000" + (o.fillColor | 0).toString(16)).substr(-6);
                    n.fillRect(u[0], u[1], u[2], u[3])
                }
                if (o.lineWidth) {
                    n.globalAlpha = o.lineAlpha * r;
                    n.strokeRect(u[0], u[1], u[2], u[3])
                }
            } else if (o.type === t.Graphics.CIRC) {
                n.beginPath();
                n.arc(u[0], u[1], u[2], 0, 2 * Math.PI);
                n.closePath();
                if (o.fill) {
                    n.globalAlpha = o.fillAlpha * r;
                    n.fillStyle = i = "#" + ("00000" + (o.fillColor | 0).toString(16)).substr(-6);
                    n.fill()
                }
                if (o.lineWidth) {
                    n.globalAlpha = o.lineAlpha * r;
                    n.stroke()
                }
            } else if (o.type === t.Graphics.ELIP) {
                var f = o.points;
                var l = f[2] * 2;
                var c = f[3] * 2;
                var h = f[0] - l / 2;
                var p = f[1] - c / 2;
                n.beginPath();
                var d = .5522848,
                    v = l / 2 * d,
                    m = c / 2 * d,
                    g = h + l,
                    y = p + c,
                    b = h + l / 2,
                    w = p + c / 2;
                n.moveTo(h, w);
                n.bezierCurveTo(h, w - m, b - v, p, b, p);
                n.bezierCurveTo(b + v, p, g, w - m, g, w);
                n.bezierCurveTo(g, w + m, b + v, y, b, y);
                n.bezierCurveTo(b - v, y, h, w + m, h, w);
                n.closePath();
                if (o.fill) {
                    n.globalAlpha = o.fillAlpha * r;
                    n.fillStyle = i = "#" + ("00000" + (o.fillColor | 0).toString(16)).substr(-6);
                    n.fill()
                }
                if (o.lineWidth) {
                    n.globalAlpha = o.lineAlpha * r;
                    n.stroke()
                }
            }
        }
    };
    t.CanvasGraphics.renderGraphicsMask = function(e, n) {
        var r = e.graphicsData.length;
        if (r === 0) return;
        if (r > 1) {
            r = 1;
            window.console.log("Pixi.js warning: masks in canvas can only mask using the first path in the graphics object")
        }
        for (var i = 0; i < 1; i++) {
            var s = e.graphicsData[i];
            var o = s.points;
            if (s.type === t.Graphics.POLY) {
                n.beginPath();
                n.moveTo(o[0], o[1]);
                for (var u = 1; u < o.length / 2; u++) {
                    n.lineTo(o[u * 2], o[u * 2 + 1])
                }
                if (o[0] === o[o.length - 2] && o[1] === o[o.length - 1]) {
                    n.closePath()
                }
            } else if (s.type === t.Graphics.RECT) {
                n.beginPath();
                n.rect(o[0], o[1], o[2], o[3]);
                n.closePath()
            } else if (s.type === t.Graphics.CIRC) {
                n.beginPath();
                n.arc(o[0], o[1], o[2], 0, 2 * Math.PI);
                n.closePath()
            } else if (s.type === t.Graphics.ELIP) {
                var a = s.points;
                var f = a[2] * 2;
                var l = a[3] * 2;
                var c = a[0] - f / 2;
                var h = a[1] - l / 2;
                n.beginPath();
                var p = .5522848,
                    d = f / 2 * p,
                    v = l / 2 * p,
                    m = c + f,
                    g = h + l,
                    y = c + f / 2,
                    b = h + l / 2;
                n.moveTo(c, b);
                n.bezierCurveTo(c, b - v, y - d, h, y, h);
                n.bezierCurveTo(y + d, h, m, b - v, m, b);
                n.bezierCurveTo(m, b + v, y + d, g, y, g);
                n.bezierCurveTo(y - d, g, c, b + v, c, b);
                n.closePath()
            }
        }
    };
    t.Graphics = function() {
        t.DisplayObjectContainer.call(this);
        this.renderable = true;
        this.fillAlpha = 1;
        this.lineWidth = 0;
        this.lineColor = "black";
        this.graphicsData = [];
        this.tint = 16777215;
        this.blendMode = t.blendModes.NORMAL;
        this.currentPath = {
            points: []
        };
        this._webGL = [];
        this.isMask = false;
        this.bounds = null;
        this.boundsPadding = 10
    };
    t.Graphics.prototype = Object.create(t.DisplayObjectContainer.prototype);
    t.Graphics.prototype.constructor = t.Graphics;
    Object.defineProperty(t.Graphics.prototype, "cacheAsBitmap", {
        get: function() {
            return this._cacheAsBitmap
        },
        set: function(e) {
            this._cacheAsBitmap = e;
            if (this._cacheAsBitmap) {
                this._generateCachedSprite()
            } else {
                this.destroyCachedSprite();
                this.dirty = true
            }
        }
    });
    t.Graphics.prototype.lineStyle = function(e, n, r) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.lineWidth = e || 0;
        this.lineColor = n || 0;
        this.lineAlpha = arguments.length < 3 ? 1 : r;
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [],
            type: t.Graphics.POLY
        };
        this.graphicsData.push(this.currentPath);
        return this
    };
    t.Graphics.prototype.moveTo = function(e, n) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.currentPath = this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [],
            type: t.Graphics.POLY
        };
        this.currentPath.points.push(e, n);
        this.graphicsData.push(this.currentPath);
        return this
    };
    t.Graphics.prototype.lineTo = function(e, t) {
        this.currentPath.points.push(e, t);
        this.dirty = true;
        return this
    };
    t.Graphics.prototype.beginFill = function(e, t) {
        this.filling = true;
        this.fillColor = e || 0;
        this.fillAlpha = arguments.length < 2 ? 1 : t;
        return this
    };
    t.Graphics.prototype.endFill = function() {
        this.filling = false;
        this.fillColor = null;
        this.fillAlpha = 1;
        return this
    };
    t.Graphics.prototype.drawRect = function(e, n, r, i) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [e, n, r, i],
            type: t.Graphics.RECT
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = true;
        return this
    };
    t.Graphics.prototype.drawCircle = function(e, n, r) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [e, n, r, r],
            type: t.Graphics.CIRC
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = true;
        return this
    };
    t.Graphics.prototype.drawEllipse = function(e, n, r, i) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [e, n, r, i],
            type: t.Graphics.ELIP
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = true;
        return this
    };
    t.Graphics.prototype.clear = function() {
        this.lineWidth = 0;
        this.filling = false;
        this.dirty = true;
        this.clearDirty = true;
        this.graphicsData = [];
        this.bounds = null;
        return this
    };
    t.Graphics.prototype.generateTexture = function() {
        var e = this.getBounds();
        var n = new t.CanvasBuffer(e.width, e.height);
        var r = t.Texture.fromCanvas(n.canvas);
        n.context.translate(-e.x, -e.y);
        t.CanvasGraphics.renderGraphics(this, n.context);
        return r
    };
    t.Graphics.prototype._renderWebGL = function(e) {
        if (this.visible === false || this.alpha === 0 || this.isMask === true) return;
        if (this._cacheAsBitmap) {
            if (this.dirty) {
                this._generateCachedSprite();
                t.updateWebGLTexture(this._cachedSprite.texture.baseTexture, e.gl);
                this.dirty = false
            }
            this._cachedSprite.alpha = this.alpha;
            t.Sprite.prototype._renderWebGL.call(this._cachedSprite, e);
            return
        } else {
            e.spriteBatch.stop();
            if (this._mask) e.maskManager.pushMask(this.mask, e);
            if (this._filters) e.filterManager.pushFilter(this._filterBlock);
            if (this.blendMode !== e.spriteBatch.currentBlendMode) {
                e.spriteBatch.currentBlendMode = this.blendMode;
                var n = t.blendModesWebGL[e.spriteBatch.currentBlendMode];
                e.spriteBatch.gl.blendFunc(n[0], n[1])
            }
            t.WebGLGraphics.renderGraphics(this, e);
            if (this.children.length) {
                e.spriteBatch.start();
                for (var r = 0, i = this.children.length; r < i; r++) {
                    this.children[r]._renderWebGL(e)
                }
                e.spriteBatch.stop()
            }
            if (this._filters) e.filterManager.popFilter();
            if (this._mask) e.maskManager.popMask(e);
            e.drawCount++;
            e.spriteBatch.start()
        }
    };
    t.Graphics.prototype._renderCanvas = function(e) {
        if (this.visible === false || this.alpha === 0 || this.isMask === true) return;
        var n = e.context;
        var r = this.worldTransform;
        if (this.blendMode !== e.currentBlendMode) {
            e.currentBlendMode = this.blendMode;
            n.globalCompositeOperation = t.blendModesCanvas[e.currentBlendMode]
        }
        n.setTransform(r.a, r.c, r.b, r.d, r.tx, r.ty);
        t.CanvasGraphics.renderGraphics(this, n);
        for (var i = 0, s = this.children.length; i < s; i++) {
            this.children[i]._renderCanvas(e)
        }
    };
    t.Graphics.prototype.getBounds = function(e) {
        if (!this.bounds) this.updateBounds();
        var t = this.bounds.x;
        var n = this.bounds.width + this.bounds.x;
        var r = this.bounds.y;
        var i = this.bounds.height + this.bounds.y;
        var s = e || this.worldTransform;
        var o = s.a;
        var u = s.c;
        var a = s.b;
        var f = s.d;
        var l = s.tx;
        var c = s.ty;
        var h = o * n + a * i + l;
        var p = f * i + u * n + c;
        var d = o * t + a * i + l;
        var v = f * i + u * t + c;
        var m = o * t + a * r + l;
        var g = f * r + u * t + c;
        var y = o * n + a * r + l;
        var b = f * r + u * n + c;
        var w = h;
        var E = p;
        var S = h;
        var x = p;
        S = d < S ? d : S;
        S = m < S ? m : S;
        S = y < S ? y : S;
        x = v < x ? v : x;
        x = g < x ? g : x;
        x = b < x ? b : x;
        w = d > w ? d : w;
        w = m > w ? m : w;
        w = y > w ? y : w;
        E = v > E ? v : E;
        E = g > E ? g : E;
        E = b > E ? b : E;
        var T = this._bounds;
        T.x = S;
        T.width = w - S;
        T.y = x;
        T.height = E - x;
        return T
    };
    t.Graphics.prototype.updateBounds = function() {
        var e = Infinity;
        var n = -Infinity;
        var r = Infinity;
        var i = -Infinity;
        var s, o, u, a, f;
        for (var l = 0; l < this.graphicsData.length; l++) {
            var c = this.graphicsData[l];
            var h = c.type;
            var p = c.lineWidth;
            s = c.points;
            if (h === t.Graphics.RECT) {
                o = s[0] - p / 2;
                u = s[1] - p / 2;
                a = s[2] + p;
                f = s[3] + p;
                e = o < e ? o : e;
                n = o + a > n ? o + a : n;
                r = u < r ? o : r;
                i = u + f > i ? u + f : i
            } else if (h === t.Graphics.CIRC || h === t.Graphics.ELIP) {
                o = s[0];
                u = s[1];
                a = s[2] + p / 2;
                f = s[3] + p / 2;
                e = o - a < e ? o - a : e;
                n = o + a > n ? o + a : n;
                r = u - f < r ? u - f : r;
                i = u + f > i ? u + f : i
            } else {
                for (var d = 0; d < s.length; d += 2) {
                    o = s[d];
                    u = s[d + 1];
                    e = o - p < e ? o - p : e;
                    n = o + p > n ? o + p : n;
                    r = u - p < r ? u - p : r;
                    i = u + p > i ? u + p : i
                }
            }
        }
        var v = this.boundsPadding;
        this.bounds = new t.Rectangle(e - v, r - v, n - e + v * 2, i - r + v * 2)
    };
    t.Graphics.prototype._generateCachedSprite = function() {
        var e = this.getLocalBounds();
        if (!this._cachedSprite) {
            var n = new t.CanvasBuffer(e.width, e.height);
            var r = t.Texture.fromCanvas(n.canvas);
            this._cachedSprite = new t.Sprite(r);
            this._cachedSprite.buffer = n;
            this._cachedSprite.worldTransform = this.worldTransform
        } else {
            this._cachedSprite.buffer.resize(e.width, e.height)
        }
        this._cachedSprite.anchor.x = -(e.x / e.width);
        this._cachedSprite.anchor.y = -(e.y / e.height);
        this._cachedSprite.buffer.context.translate(-e.x, -e.y);
        t.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);
        this._cachedSprite.alpha = this.alpha
    };
    t.Graphics.prototype.destroyCachedSprite = function() {
        this._cachedSprite.texture.destroy(true);
        this._cachedSprite = null
    };
    t.Graphics.POLY = 0;
    t.Graphics.RECT = 1;
    t.Graphics.CIRC = 2;
    t.Graphics.ELIP = 3;
    t.TilingSprite = function(e, n, r) {
        t.Sprite.call(this, e);
        this.width = n || 100;
        this.height = r || 100;
        this.tileScale = new t.Point(1, 1);
        this.tileScaleOffset = new t.Point(1, 1);
        this.tilePosition = new t.Point(0, 0);
        this.renderable = true;
        this.tint = 16777215;
        this.blendMode = t.blendModes.NORMAL
    };
    t.TilingSprite.prototype = Object.create(t.Sprite.prototype);
    t.TilingSprite.prototype.constructor = t.TilingSprite;
    Object.defineProperty(t.TilingSprite.prototype, "width", {
        get: function() {
            return this._width
        },
        set: function(e) {
            this._width = e
        }
    });
    Object.defineProperty(t.TilingSprite.prototype, "height", {
        get: function() {
            return this._height
        },
        set: function(e) {
            this._height = e
        }
    });
    t.TilingSprite.prototype.onTextureUpdate = function() {
        this.updateFrame = true
    };
    t.TilingSprite.prototype.setTexture = function(e) {
        if (this.texture === e) return;
        this.texture = e;
        this.refreshTexture = true;
        this.cachedTint = 16777215
    };
    t.TilingSprite.prototype._renderWebGL = function(e) {
        if (this.visible === false || this.alpha === 0) return;
        var n, r;
        if (this.mask) {
            e.spriteBatch.stop();
            e.maskManager.pushMask(this.mask, e);
            e.spriteBatch.start()
        }
        if (this.filters) {
            e.spriteBatch.flush();
            e.filterManager.pushFilter(this._filterBlock)
        }
        if (!this.tilingTexture || this.refreshTexture) {
            this.generateTilingTexture(true);
            if (this.tilingTexture && this.tilingTexture.needsUpdate) {
                t.updateWebGLTexture(this.tilingTexture.baseTexture, e.gl);
                this.tilingTexture.needsUpdate = false
            }
        } else e.spriteBatch.renderTilingSprite(this);
        for (n = 0, r = this.children.length; n < r; n++) {
            this.children[n]._renderWebGL(e)
        }
        e.spriteBatch.stop();
        if (this.filters) e.filterManager.popFilter();
        if (this.mask) e.maskManager.popMask(e);
        e.spriteBatch.start()
    };
    t.TilingSprite.prototype._renderCanvas = function(e) {
        if (this.visible === false || this.alpha === 0) return;
        var n = e.context;
        if (this._mask) {
            e.maskManager.pushMask(this._mask, n)
        }
        n.globalAlpha = this.worldAlpha;
        var r = this.worldTransform;
        n.setTransform(r.a, r.c, r.b, r.d, r.tx, r.ty);
        if (!this.__tilePattern || this.refreshTexture) {
            this.generateTilingTexture(false);
            if (this.tilingTexture) {
                this.__tilePattern = n.createPattern(this.tilingTexture.baseTexture.source, "repeat")
            } else {
                return
            }
        }
        if (this.blendMode !== e.currentBlendMode) {
            e.currentBlendMode = this.blendMode;
            n.globalCompositeOperation = t.blendModesCanvas[e.currentBlendMode]
        }
        n.beginPath();
        var i = this.tilePosition;
        var s = this.tileScale;
        i.x %= this.tilingTexture.baseTexture.width;
        i.y %= this.tilingTexture.baseTexture.height;
        n.scale(s.x, s.y);
        n.translate(i.x, i.y);
        n.fillStyle = this.__tilePattern;
        n.fillRect(-i.x + this.anchor.x * -this._width, -i.y + this.anchor.y * -this._height, this._width / s.x, this._height / s.y);
        n.scale(1 / s.x, 1 / s.y);
        n.translate(-i.x, -i.y);
        n.closePath();
        if (this._mask) {
            e.maskManager.popMask(e.context)
        }
    };
    t.TilingSprite.prototype.getBounds = function() {
        var e = this._width;
        var t = this._height;
        var n = e * (1 - this.anchor.x);
        var r = e * -this.anchor.x;
        var i = t * (1 - this.anchor.y);
        var s = t * -this.anchor.y;
        var o = this.worldTransform;
        var u = o.a;
        var a = o.c;
        var f = o.b;
        var l = o.d;
        var c = o.tx;
        var h = o.ty;
        var p = u * r + f * s + c;
        var d = l * s + a * r + h;
        var v = u * n + f * s + c;
        var m = l * s + a * n + h;
        var g = u * n + f * i + c;
        var y = l * i + a * n + h;
        var b = u * r + f * i + c;
        var w = l * i + a * r + h;
        var E = -Infinity;
        var S = -Infinity;
        var x = Infinity;
        var T = Infinity;
        x = p < x ? p : x;
        x = v < x ? v : x;
        x = g < x ? g : x;
        x = b < x ? b : x;
        T = d < T ? d : T;
        T = m < T ? m : T;
        T = y < T ? y : T;
        T = w < T ? w : T;
        E = p > E ? p : E;
        E = v > E ? v : E;
        E = g > E ? g : E;
        E = b > E ? b : E;
        S = d > S ? d : S;
        S = m > S ? m : S;
        S = y > S ? y : S;
        S = w > S ? w : S;
        var N = this._bounds;
        N.x = x;
        N.width = E - x;
        N.y = T;
        N.height = S - T;
        this._currentBounds = N;
        return N
    };
    t.TilingSprite.prototype.generateTilingTexture = function(e) {
        var n = this.texture;
        if (!n.baseTexture.hasLoaded) return;
        var r = n.baseTexture;
        var i = n.frame;
        var s, o;
        var u = i.width !== r.width || i.height !== r.height;
        var a = false;
        if (!e) {
            if (u) {
                s = i.width;
                o = i.height;
                a = true
            }
        } else {
            s = t.getNextPowerOfTwo(i.width);
            o = t.getNextPowerOfTwo(i.height);
            if (i.width !== s && i.height !== o) a = true
        }
        if (a) {
            var f;
            if (this.tilingTexture && this.tilingTexture.isTiling) {
                f = this.tilingTexture.canvasBuffer;
                f.resize(s, o);
                this.tilingTexture.baseTexture.width = s;
                this.tilingTexture.baseTexture.height = o;
                this.tilingTexture.needsUpdate = true
            } else {
                f = new t.CanvasBuffer(s, o);
                this.tilingTexture = t.Texture.fromCanvas(f.canvas);
                this.tilingTexture.canvasBuffer = f;
                this.tilingTexture.isTiling = true
            }
            f.context.drawImage(n.baseTexture.source, i.x, i.y, i.width, i.height, 0, 0, s, o);
            this.tileScaleOffset.x = i.width / s;
            this.tileScaleOffset.y = i.height / o
        } else {
            if (this.tilingTexture && this.tilingTexture.isTiling) {
                this.tilingTexture.destroy(true)
            }
            this.tileScaleOffset.x = 1;
            this.tileScaleOffset.y = 1;
            this.tilingTexture = n
        }
        this.refreshTexture = false;
        this.tilingTexture.baseTexture._powerOf2 = true
    };
    t.BaseTextureCache = {};
    t.texturesToUpdate = [];
    t.texturesToDestroy = [];
    t.BaseTextureCacheIdGenerator = 0;
    t.BaseTexture = function(e, n) {
        t.EventTarget.call(this);
        this.width = 100;
        this.height = 100;
        this.scaleMode = n || t.scaleModes.DEFAULT;
        this.hasLoaded = false;
        this.source = e;
        this.id = t.BaseTextureCacheIdGenerator++;
        this._glTextures = [];
        if (!e) return;
        if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height) {
            this.hasLoaded = true;
            this.width = this.source.width;
            this.height = this.source.height;
            t.texturesToUpdate.push(this)
        } else {
            var r = this;
            this.source.onload = function() {
                r.hasLoaded = true;
                r.width = r.source.width;
                r.height = r.source.height;
                t.texturesToUpdate.push(r);
                r.dispatchEvent({
                    type: "loaded",
                    content: r
                })
            }
        }
        this.imageUrl = null;
        this._powerOf2 = false
    };
    t.BaseTexture.prototype.constructor = t.BaseTexture;
    t.BaseTexture.prototype.destroy = function() {
        if (this.imageUrl) {
            delete t.BaseTextureCache[this.imageUrl];
            this.imageUrl = null;
            this.source.src = null
        }
        this.source = null;
        t.texturesToDestroy.push(this)
    };
    t.BaseTexture.prototype.updateSourceImage = function(e) {
        this.hasLoaded = false;
        this.source.src = null;
        this.source.src = e
    };
    t.BaseTexture.fromImage = function(e, n, r) {
        var i = t.BaseTextureCache[e];
        if (n === undefined && e.indexOf("data:") === -1) n = true;
        if (!i) {
            var s = new Image;
            if (n) {
                s.crossOrigin = ""
            }
            s.src = e;
            i = new t.BaseTexture(s, r);
            i.imageUrl = e;
            t.BaseTextureCache[e] = i
        }
        return i
    };
    t.BaseTexture.fromCanvas = function(e, n) {
        if (!e._pixiId) {
            e._pixiId = "canvas_" + t.TextureCacheIdGenerator++
        }
        var r = t.BaseTextureCache[e._pixiId];
        if (!r) {
            r = new t.BaseTexture(e, n);
            t.BaseTextureCache[e._pixiId] = r
        }
        return r
    };
    t.TextureCache = {};
    t.FrameCache = {};
    t.TextureCacheIdGenerator = 0;
    t.Texture = function(e, n) {
        t.EventTarget.call(this);
        if (!n) {
            this.noFrame = true;
            n = new t.Rectangle(0, 0, 1, 1)
        }
        if (e instanceof t.Texture) e = e.baseTexture;
        this.baseTexture = e;
        this.frame = n;
        this.trim = null;
        this.scope = this;
        this._uvs = null;
        if (e.hasLoaded) {
            if (this.noFrame) n = new t.Rectangle(0, 0, e.width, e.height);
            this.setFrame(n)
        } else {
            var r = this;
            e.addEventListener("loaded", function() {
                r.onBaseTextureLoaded()
            })
        }
    };
    t.Texture.prototype.constructor = t.Texture;
    t.Texture.prototype.onBaseTextureLoaded = function() {
        var e = this.baseTexture;
        e.removeEventListener("loaded", this.onLoaded);
        if (this.noFrame) this.frame = new t.Rectangle(0, 0, e.width, e.height);
        this.setFrame(this.frame);
        this.scope.dispatchEvent({
            type: "update",
            content: this
        })
    };
    t.Texture.prototype.destroy = function(e) {
        if (e) this.baseTexture.destroy()
    };
    t.Texture.prototype.setFrame = function(e) {
        this.frame = e;
        this.width = e.width;
        this.height = e.height;
        if (e.x + e.width > this.baseTexture.width || e.y + e.height > this.baseTexture.height) {
            throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this)
        }
        this.updateFrame = true;
        t.Texture.frameUpdates.push(this)
    };
    t.Texture.prototype._updateWebGLuvs = function() {
        if (!this._uvs) this._uvs = new t.TextureUvs;
        var e = this.frame;
        var n = this.baseTexture.width;
        var r = this.baseTexture.height;
        this._uvs.x0 = e.x / n;
        this._uvs.y0 = e.y / r;
        this._uvs.x1 = (e.x + e.width) / n;
        this._uvs.y1 = e.y / r;
        this._uvs.x2 = (e.x + e.width) / n;
        this._uvs.y2 = (e.y + e.height) / r;
        this._uvs.x3 = e.x / n;
        this._uvs.y3 = (e.y + e.height) / r
    };
    t.Texture.fromImage = function(e, n, r) {
        var i = t.TextureCache[e];
        if (!i) {
            i = new t.Texture(t.BaseTexture.fromImage(e, n, r));
            t.TextureCache[e] = i
        }
        return i
    };
    t.Texture.fromFrame = function(e) {
        var n = t.TextureCache[e];
        if (!n) throw new Error('The frameId "' + e + '" does not exist in the texture cache ');
        return n
    };
    t.Texture.fromCanvas = function(e, n) {
        var r = t.BaseTexture.fromCanvas(e, n);
        return new t.Texture(r)
    };
    t.Texture.addTextureToCache = function(e, n) {
        t.TextureCache[n] = e
    };
    t.Texture.removeTextureFromCache = function(e) {
        var n = t.TextureCache[e];
        delete t.TextureCache[e];
        delete t.BaseTextureCache[e];
        return n
    };
    t.Texture.frameUpdates = [];
    t.TextureUvs = function() {
        this.x0 = 0;
        this.y0 = 0;
        this.x1 = 0;
        this.y1 = 0;
        this.x2 = 0;
        this.y2 = 0;
        this.x3 = 0;
        this.y4 = 0
    };
    t.RenderTexture = function(e, n, r, i) {
        t.EventTarget.call(this);
        this.width = e || 100;
        this.height = n || 100;
        this.frame = new t.Rectangle(0, 0, this.width, this.height);
        this.baseTexture = new t.BaseTexture;
        this.baseTexture.width = this.width;
        this.baseTexture.height = this.height;
        this.baseTexture._glTextures = [];
        this.baseTexture.scaleMode = i || t.scaleModes.DEFAULT;
        this.baseTexture.hasLoaded = true;
        this.renderer = r || t.defaultRenderer;
        if (this.renderer.type === t.WEBGL_RENDERER) {
            var s = this.renderer.gl;
            this.textureBuffer = new t.FilterTexture(s, this.width, this.height, this.baseTexture.scaleMode);
            this.baseTexture._glTextures[s.id] = this.textureBuffer.texture;
            this.render = this.renderWebGL;
            this.projection = new t.Point(this.width / 2, -this.height / 2)
        } else {
            this.render = this.renderCanvas;
            this.textureBuffer = new t.CanvasBuffer(this.width, this.height);
            this.baseTexture.source = this.textureBuffer.canvas
        }
        t.Texture.frameUpdates.push(this)
    };
    t.RenderTexture.prototype = Object.create(t.Texture.prototype);
    t.RenderTexture.prototype.constructor = t.RenderTexture;
    t.RenderTexture.prototype.resize = function(e, n, r) {
        if (e === this.width && n === this.height) {
            return
        }
        this.width = e;
        this.height = n;
        this.frame.width = this.width;
        this.frame.height = this.height;
        if (r) {
            this.baseTexture.width = this.width;
            this.baseTexture.height = this.height
        }
        if (this.renderer.type === t.WEBGL_RENDERER) {
            this.projection.x = this.width / 2;
            this.projection.y = -this.height / 2
        }
        this.textureBuffer.resize(this.width, this.height)
    };
    t.RenderTexture.prototype.clear = function() {
        if (this.renderer.type === t.WEBGL_RENDERER) {
            this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer)
        }
        this.textureBuffer.clear()
    };
    t.RenderTexture.prototype.renderWebGL = function(e, n, r) {
        var i = this.renderer.gl;
        i.colorMask(true, true, true, true);
        i.viewport(0, 0, this.width, this.height);
        i.bindFramebuffer(i.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        if (r) this.textureBuffer.clear();
        var s = e.children;
        var o = e.worldTransform;
        e.worldTransform = t.RenderTexture.tempMatrix;
        e.worldTransform.d = -1;
        e.worldTransform.ty = this.projection.y * -2;
        if (n) {
            e.worldTransform.tx = n.x;
            e.worldTransform.ty -= n.y
        }
        for (var u = 0, a = s.length; u < a; u++) {
            s[u].updateTransform()
        }
        t.WebGLRenderer.updateTextures();
        this.renderer.renderDisplayObject(e, this.projection, this.textureBuffer.frameBuffer);
        e.worldTransform = o
    };
    t.RenderTexture.prototype.renderCanvas = function(e, n, r) {
        var i = e.children;
        var s = e.worldTransform;
        e.worldTransform = t.RenderTexture.tempMatrix;
        if (n) {
            e.worldTransform.tx = n.x;
            e.worldTransform.ty = n.y
        }
        for (var o = 0, u = i.length; o < u; o++) {
            i[o].updateTransform()
        }
        if (r) this.textureBuffer.clear();
        var a = this.textureBuffer.context;
        this.renderer.renderDisplayObject(e, a);
        a.setTransform(1, 0, 0, 1, 0, 0);
        e.worldTransform = s
    };
    t.RenderTexture.tempMatrix = new t.Matrix;
    if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
            exports = module.exports = t
        }
        exports.PIXI = t
    } else if (typeof define !== "undefined" && define.amd) {
        define("PIXI", function() {
            return e.PIXI = t
        }())
    } else {
        e.PIXI = t
    }
}).call(this);
(function() {
    var e = this;
    var t = t || {
        VERSION: "2.0.5",
        GAMES: [],
        AUTO: 0,
        CANVAS: 1,
        WEBGL: 2,
        HEADLESS: 3,
        NONE: 0,
        LEFT: 1,
        RIGHT: 2,
        UP: 3,
        DOWN: 4,
        SPRITE: 0,
        BUTTON: 1,
        IMAGE: 2,
        GRAPHICS: 3,
        TEXT: 4,
        TILESPRITE: 5,
        BITMAPTEXT: 6,
        GROUP: 7,
        RENDERTEXTURE: 8,
        TILEMAP: 9,
        TILEMAPLAYER: 10,
        EMITTER: 11,
        POLYGON: 12,
        BITMAPDATA: 13,
        CANVAS_FILTER: 14,
        WEBGL_FILTER: 15,
        ELLIPSE: 16,
        SPRITEBATCH: 17,
        RETROFONT: 18,
        POINTER: 19,
        blendModes: {
            NORMAL: 0,
            ADD: 1,
            MULTIPLY: 2,
            SCREEN: 3,
            OVERLAY: 4,
            DARKEN: 5,
            LIGHTEN: 6,
            COLOR_DODGE: 7,
            COLOR_BURN: 8,
            HARD_LIGHT: 9,
            SOFT_LIGHT: 10,
            DIFFERENCE: 11,
            EXCLUSION: 12,
            HUE: 13,
            SATURATION: 14,
            COLOR: 15,
            LUMINOSITY: 16
        },
        scaleModes: {
            DEFAULT: 0,
            LINEAR: 0,
            NEAREST: 1
        }
    };
    PIXI.InteractionManager = PIXI.InteractionManager ||
        function() {};
    t.Utils = {
        transposeArray: function(e) {
            var t = new Array(e[0].length);
            for (var n = 0; n < e[0].length; n++) {
                t[n] = new Array(e.length - 1);
                for (var r = e.length - 1; r > -1; r--) {
                    t[n][r] = e[r][n]
                }
            }
            return t
        },
        rotateArray: function(e, n) {
            if (typeof n !== "string") {
                n = (n % 360 + 360) % 360
            }
            if (n === 90 || n === -270 || n === "rotateLeft") {
                e = t.Utils.transposeArray(e);
                e = e.reverse()
            } else if (n === -90 || n === 270 || n === "rotateRight") {
                e = e.reverse();
                e = t.Utils.transposeArray(e)
            } else if (Math.abs(n) === 180 || n === "rotate180") {
                for (var r = 0; r < e.length; r++) {
                    e[r].reverse()
                }
                e = e.reverse()
            }
            return e
        },
        parseDimension: function(e, t) {
            var n = 0;
            var r = 0;
            if (typeof e === "string") {
                if (e.substr(-1) === "%") {
                    n = parseInt(e, 10) / 100;
                    if (t === 0) {
                        r = window.innerWidth * n
                    } else {
                        r = window.innerHeight * n
                    }
                } else {
                    r = parseInt(e, 10)
                }
            } else {
                r = e
            }
            return r
        },
        shuffle: function(e) {
            for (var t = e.length - 1; t > 0; t--) {
                var n = Math.floor(Math.random() * (t + 1));
                var r = e[t];
                e[t] = e[n];
                e[n] = r
            }
            return e
        },
        pad: function(e, t, n, r) {
            if (typeof t == "undefined") {
                var t = 0
            }
            if (typeof n == "undefined") {
                var n = " "
            }
            if (typeof r == "undefined") {
                var r = 3
            }
            var i = 0;
            if (t + 1 >= e.length) {
                switch (r) {
                    case 1:
                        e = (new Array(t + 1 - e.length)).join(n) + e;
                        break;
                    case 3:
                        var s = Math.ceil((i = t - e.length) / 2);
                        var o = i - s;
                        e = (new Array(o + 1)).join(n) + e + (new Array(s + 1)).join(n);
                        break;
                    default:
                        e = e + (new Array(t + 1 - e.length)).join(n);
                        break
                }
            }
            return e
        },
        isPlainObject: function(e) {
            if (typeof e !== "object" || e.nodeType || e === e.window) {
                return false
            }
            try {
                if (e.constructor && !{}.hasOwnProperty.call(e.constructor.prototype, "isPrototypeOf")) {
                    return false
                }
            } catch (t) {
                return false
            }
            return true
        },
        extend: function() {
            var e, n, r, i, s, o, u = arguments[0] || {},
                a = 1,
                f = arguments.length,
                l = false;
            if (typeof u === "boolean") {
                l = u;
                u = arguments[1] || {};
                a = 2
            }
            if (f === a) {
                u = this;
                --a
            }
            for (; a < f; a++) {
                if ((e = arguments[a]) != null) {
                    for (n in e) {
                        r = u[n];
                        i = e[n];
                        if (u === i) {
                            continue
                        }
                        if (l && i && (t.Utils.isPlainObject(i) || (s = Array.isArray(i)))) {
                            if (s) {
                                s = false;
                                o = r && Array.isArray(r) ? r : []
                            } else {
                                o = r && t.Utils.isPlainObject(r) ? r : {}
                            }
                            u[n] = t.Utils.extend(l, o, i)
                        } else if (i !== undefined) {
                            u[n] = i
                        }
                    }
                }
            }
            return u
        }
    };
    if (typeof Function.prototype.bind != "function") {
        Function.prototype.bind = function() {
            var e = Array.prototype.slice;
            return function(t) {
                function i() {
                    var s = r.concat(e.call(arguments));
                    n.apply(this instanceof i ? this : t, s)
                }
                var n = this,
                    r = e.call(arguments, 1);
                if (typeof n != "function") {
                    throw new TypeError
                }
                i.prototype = function s(e) {
                    if (e) {
                        s.prototype = e
                    }
                    if (!(this instanceof s)) {
                        return new s
                    }
                }(n.prototype);
                return i
            }
        }()
    }
    if (!Array.isArray) {
        Array.isArray = function(e) {
            return Object.prototype.toString.call(e) == "[object Array]"
        }
    }
    if (!Array.prototype.forEach) {
        Array.prototype.forEach = function(e) {
            "use strict";
            if (this === void 0 || this === null) {
                throw new TypeError
            }
            var t = Object(this);
            var n = t.length >>> 0;
            if (typeof e !== "function") {
                throw new TypeError
            }
            var r = arguments.length >= 2 ? arguments[1] : void 0;
            for (var i = 0; i < n; i++) {
                if (i in t) {
                    e.call(r, t[i], i, t)
                }
            }
        }
    }
    if (typeof window.Uint32Array !== "function") {
        var n = function(e) {
            var t = new Array;
            window[e] = function(e) {
                if (typeof e === "number") {
                    Array.call(this, e);
                    this.length = e;
                    for (var t = 0; t < this.length; t++) {
                        this[t] = 0
                    }
                } else {
                    Array.call(this, e.length);
                    this.length = e.length;
                    for (var t = 0; t < this.length; t++) {
                        this[t] = e[t]
                    }
                }
            };
            window[e].prototype = t;
            window[e].constructor = window[e]
        };
        n("Uint32Array");
        n("Int16Array")
    }
    if (!window.console) {
        window.console = {};
        window.console.log = window.console.assert = function() {};
        window.console.warn = window.console.assert = function() {}
    }
    t.Circle = function(e, t, n) {
        e = e || 0;
        t = t || 0;
        n = n || 0;
        this.x = e;
        this.y = t;
        this._diameter = n;
        if (n > 0) {
            this._radius = n * .5
        } else {
            this._radius = 0
        }
    };
    t.Circle.prototype = {
        circumference: function() {
            return 2 * Math.PI * this._radius
        },
        setTo: function(e, t, n) {
            this.x = e;
            this.y = t;
            this._diameter = n;
            this._radius = n * .5;
            return this
        },
        copyFrom: function(e) {
            return this.setTo(e.x, e.y, e.diameter)
        },
        copyTo: function(e) {
            e.x = this.x;
            e.y = this.y;
            e.diameter = this._diameter;
            return e
        },
        distance: function(e, n) {
            if (typeof n === "undefined") {
                n = false
            }
            if (n) {
                return t.Math.distanceRounded(this.x, this.y, e.x, e.y)
            } else {
                return t.Math.distance(this.x, this.y, e.x, e.y)
            }
        },
        clone: function(e) {
            if (typeof e === "undefined") {
                e = new t.Circle(this.x, this.y, this.diameter)
            } else {
                e.setTo(this.x, this.y, this.diameter)
            }
            return e
        },
        contains: function(e, n) {
            return t.Circle.contains(this, e, n)
        },
        circumferencePoint: function(e, n, r) {
            return t.Circle.circumferencePoint(this, e, n, r)
        },
        offset: function(e, t) {
            this.x += e;
            this.y += t;
            return this
        },
        offsetPoint: function(e) {
            return this.offset(e.x, e.y)
        },
        toString: function() {
            return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
        }
    };
    t.Circle.prototype.constructor = t.Circle;
    Object.defineProperty(t.Circle.prototype, "diameter", {
        get: function() {
            return this._diameter
        },
        set: function(e) {
            if (e > 0) {
                this._diameter = e;
                this._radius = e * .5
            }
        }
    });
    Object.defineProperty(t.Circle.prototype, "radius", {
        get: function() {
            return this._radius
        },
        set: function(e) {
            if (e > 0) {
                this._radius = e;
                this._diameter = e * 2
            }
        }
    });
    Object.defineProperty(t.Circle.prototype, "left", {
        get: function() {
            return this.x - this._radius
        },
        set: function(e) {
            if (e > this.x) {
                this._radius = 0;
                this._diameter = 0
            } else {
                this.radius = this.x - e
            }
        }
    });
    Object.defineProperty(t.Circle.prototype, "right", {
        get: function() {
            return this.x + this._radius
        },
        set: function(e) {
            if (e < this.x) {
                this._radius = 0;
                this._diameter = 0
            } else {
                this.radius = e - this.x
            }
        }
    });
    Object.defineProperty(t.Circle.prototype, "top", {
        get: function() {
            return this.y - this._radius
        },
        set: function(e) {
            if (e > this.y) {
                this._radius = 0;
                this._diameter = 0
            } else {
                this.radius = this.y - e
            }
        }
    });
    Object.defineProperty(t.Circle.prototype, "bottom", {
        get: function() {
            return this.y + this._radius
        },
        set: function(e) {
            if (e < this.y) {
                this._radius = 0;
                this._diameter = 0
            } else {
                this.radius = e - this.y
            }
        }
    });
    Object.defineProperty(t.Circle.prototype, "area", {
        get: function() {
            if (this._radius > 0) {
                return Math.PI * this._radius * this._radius
            } else {
                return 0
            }
        }
    });
    Object.defineProperty(t.Circle.prototype, "empty", {
        get: function() {
            return this._diameter === 0
        },
        set: function(e) {
            if (e === true) {
                this.setTo(0, 0, 0)
            }
        }
    });
    t.Circle.contains = function(e, t, n) {
        if (e.radius > 0 && t >= e.left && t <= e.right && n >= e.top && n <= e.bottom) {
            var r = (e.x - t) * (e.x - t);
            var i = (e.y - n) * (e.y - n);
            return r + i <= e.radius * e.radius
        } else {
            return false
        }
    };
    t.Circle.equals = function(e, t) {
        return e.x == t.x && e.y == t.y && e.diameter == t.diameter
    };
    t.Circle.intersects = function(e, n) {
        return t.Math.distance(e.x, e.y, n.x, n.y) <= e.radius + n.radius
    };
    t.Circle.circumferencePoint = function(e, n, r, i) {
        if (typeof r === "undefined") {
            r = false
        }
        if (typeof i === "undefined") {
            i = new t.Point
        }
        if (r === true) {
            n = t.Math.degToRad(n)
        }
        i.x = e.x + e.radius * Math.cos(n);
        i.y = e.y + e.radius * Math.sin(n);
        return i
    };
    t.Circle.intersectsRectangle = function(e, t) {
        var n = Math.abs(e.x - t.x - t.halfWidth);
        var r = t.halfWidth + e.radius;
        if (n > r) {
            return false
        }
        var i = Math.abs(e.y - t.y - t.halfHeight);
        var s = t.halfHeight + e.radius;
        if (i > s) {
            return false
        }
        if (n <= t.halfWidth || i <= t.halfHeight) {
            return true
        }
        var o = n - t.halfWidth;
        var u = i - t.halfHeight;
        var a = o * o;
        var f = u * u;
        var l = e.radius * e.radius;
        return a + f <= l
    };
    PIXI.Circle = t.Circle;
    t.Point = function(e, t) {
        e = e || 0;
        t = t || 0;
        this.x = e;
        this.y = t
    };
    t.Point.prototype = {
        copyFrom: function(e) {
            return this.setTo(e.x, e.y)
        },
        invert: function() {
            return this.setTo(this.y, this.x)
        },
        setTo: function(e, t) {
            this.x = e || 0;
            this.y = t || (t !== 0 ? this.x : 0);
            return this
        },
        set: function(e, t) {
            this.x = e || 0;
            this.y = t || (t !== 0 ? this.x : 0);
            return this
        },
        add: function(e, t) {
            this.x += e;
            this.y += t;
            return this
        },
        subtract: function(e, t) {
            this.x -= e;
            this.y -= t;
            return this
        },
        multiply: function(e, t) {
            this.x *= e;
            this.y *= t;
            return this
        },
        divide: function(e, t) {
            this.x /= e;
            this.y /= t;
            return this
        },
        clampX: function(e, n) {
            this.x = t.Math.clamp(this.x, e, n);
            return this
        },
        clampY: function(e, n) {
            this.y = t.Math.clamp(this.y, e, n);
            return this
        },
        clamp: function(e, n) {
            this.x = t.Math.clamp(this.x, e, n);
            this.y = t.Math.clamp(this.y, e, n);
            return this
        },
        clone: function(e) {
            if (typeof e === "undefined") {
                e = new t.Point(this.x, this.y)
            } else {
                e.setTo(this.x, this.y)
            }
            return e
        },
        copyTo: function(e) {
            e.x = this.x;
            e.y = this.y;
            return e
        },
        distance: function(e, n) {
            return t.Point.distance(this, e, n)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y
        },
        angle: function(e, n) {
            if (typeof n === "undefined") {
                n = false
            }
            if (n) {
                return t.Math.radToDeg(Math.atan2(e.y - this.y, e.x - this.x))
            } else {
                return Math.atan2(e.y - this.y, e.x - this.x)
            }
        },
        angleSq: function(e) {
            return this.subtract(e).angle(e.subtract(this))
        },
        rotate: function(e, n, r, i, s) {
            return t.Point.rotate(this, e, n, r, i, s)
        },
        getMagnitude: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        getMagnitudeSq: function() {
            return this.x * this.x + this.y * this.y
        },
        setMagnitude: function(e) {
            return this.normalize().multiply(e, e)
        },
        normalize: function() {
            if (!this.isZero()) {
                var e = this.getMagnitude();
                this.x /= e;
                this.y /= e
            }
            return this
        },
        isZero: function() {
            return this.x === 0 && this.y === 0
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y
        },
        cross: function(e) {
            return this.x * e.y - this.y * e.x
        },
        perp: function() {
            return this.setTo(-this.y, this.x)
        },
        rperp: function() {
            return this.setTo(this.y, -this.x)
        },
        normalRightHand: function() {
            return this.setTo(this.y * -1, this.x)
        },
        toString: function() {
            return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
        }
    };
    t.Point.prototype.constructor = t.Point;
    t.Point.add = function(e, n, r) {
        if (typeof r === "undefined") {
            r = new t.Point
        }
        r.x = e.x + n.x;
        r.y = e.y + n.y;
        return r
    };
    t.Point.subtract = function(e, n, r) {
        if (typeof r === "undefined") {
            r = new t.Point
        }
        r.x = e.x - n.x;
        r.y = e.y - n.y;
        return r
    };
    t.Point.multiply = function(e, n, r) {
        if (typeof r === "undefined") {
            r = new t.Point
        }
        r.x = e.x * n.x;
        r.y = e.y * n.y;
        return r
    };
    t.Point.divide = function(e, n, r) {
        if (typeof r === "undefined") {
            r = new t.Point
        }
        r.x = e.x / n.x;
        r.y = e.y / n.y;
        return r
    };
    t.Point.equals = function(e, t) {
        return e.x === t.x && e.y === t.y
    };
    t.Point.angle = function(e, t) {
        return Math.atan2(e.y - t.y, e.x - t.x)
    };
    t.Point.angleSq = function(e, t) {
        return e.subtract(t).angle(t.subtract(e))
    };
    t.Point.negative = function(e, n) {
        if (typeof n === "undefined") {
            n = new t.Point
        }
        return n.setTo(-e.x, -e.y)
    };
    t.Point.multiplyAdd = function(e, n, r, i) {
        if (typeof i === "undefined") {
            i = new t.Point
        }
        return i.setTo(e.x + n.x * r, e.y + n.y * r)
    };
    t.Point.interpolate = function(e, n, r, i) {
        if (typeof i === "undefined") {
            i = new t.Point
        }
        return i.setTo(e.x + (n.x - e.x) * r, e.y + (n.y - e.y) * r)
    };
    t.Point.perp = function(e, n) {
        if (typeof n === "undefined") {
            n = new t.Point
        }
        return n.setTo(-e.y, e.x)
    };
    t.Point.rperp = function(e, n) {
        if (typeof n === "undefined") {
            n = new t.Point
        }
        return n.setTo(e.y, -e.x)
    };
    t.Point.distance = function(e, n, r) {
        if (typeof r === "undefined") {
            r = false
        }
        if (r) {
            return t.Math.distanceRounded(e.x, e.y, n.x, n.y)
        } else {
            return t.Math.distance(e.x, e.y, n.x, n.y)
        }
    };
    t.Point.project = function(e, n, r) {
        if (typeof r === "undefined") {
            r = new t.Point
        }
        var i = e.dot(n) / n.getMagnitudeSq();
        if (i !== 0) {
            r.setTo(i * n.x, i * n.y)
        }
        return r
    };
    t.Point.projectUnit = function(e, n, r) {
        if (typeof r === "undefined") {
            r = new t.Point
        }
        var i = e.dot(n);
        if (i !== 0) {
            r.setTo(i * n.x, i * n.y)
        }
        return r
    };
    t.Point.normalRightHand = function(e, n) {
        if (typeof n === "undefined") {
            n = new t.Point
        }
        return n.setTo(e.y * -1, e.x)
    };
    t.Point.normalize = function(e, n) {
        if (typeof n === "undefined") {
            n = new t.Point
        }
        var r = e.getMagnitude();
        if (r !== 0) {
            n.setTo(e.x / r, e.y / r)
        }
        return n
    };
    t.Point.rotate = function(e, n, r, i, s, o) {
        s = s || false;
        o = o || null;
        if (s) {
            i = t.Math.degToRad(i)
        }
        if (o === null) {
            o = Math.sqrt((n - e.x) * (n - e.x) + (r - e.y) * (r - e.y))
        }
        return e.setTo(n + o * Math.cos(i), r + o * Math.sin(i))
    };
    t.Point.centroid = function(e, n) {
        if (typeof n === "undefined") {
            n = new t.Point
        }
        if (Object.prototype.toString.call(e) !== "[object Array]") {
            throw new Error("Phaser.Point. Parameter 'points' must be an array")
        }
        var r = e.length;
        if (r < 1) {
            throw new Error("Phaser.Point. Parameter 'points' array must not be empty")
        }
        if (r === 1) {
            n.copyFrom(e[0]);
            return n
        }
        for (var i = 0; i < r; i++) {
            t.Point.add(n, e[i], n)
        }
        n.divide(r, r);
        return n
    };
    PIXI.Point = t.Point;
    t.Rectangle = function(e, t, n, r) {
        e = e || 0;
        t = t || 0;
        n = n || 0;
        r = r || 0;
        this.x = e;
        this.y = t;
        this.width = n;
        this.height = r
    };
    t.Rectangle.prototype = {
        offset: function(e, t) {
            this.x += e;
            this.y += t;
            return this
        },
        offsetPoint: function(e) {
            return this.offset(e.x, e.y)
        },
        setTo: function(e, t, n, r) {
            this.x = e;
            this.y = t;
            this.width = n;
            this.height = r;
            return this
        },
        floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y)
        },
        floorAll: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.width = Math.floor(this.width);
            this.height = Math.floor(this.height)
        },
        copyFrom: function(e) {
            return this.setTo(e.x, e.y, e.width, e.height)
        },
        copyTo: function(e) {
            e.x = this.x;
            e.y = this.y;
            e.width = this.width;
            e.height = this.height;
            return e
        },
        inflate: function(e, n) {
            return t.Rectangle.inflate(this, e, n)
        },
        size: function(e) {
            return t.Rectangle.size(this, e)
        },
        clone: function(e) {
            return t.Rectangle.clone(this, e)
        },
        contains: function(e, n) {
            return t.Rectangle.contains(this, e, n)
        },
        containsRect: function(e) {
            return t.Rectangle.containsRect(this, e)
        },
        equals: function(e) {
            return t.Rectangle.equals(this, e)
        },
        intersection: function(e, n) {
            return t.Rectangle.intersection(this, e, n)
        },
        intersects: function(e, n) {
            return t.Rectangle.intersects(this, e, n)
        },
        intersectsRaw: function(e, n, r, i, s) {
            return t.Rectangle.intersectsRaw(this, e, n, r, i, s)
        },
        union: function(e, n) {
            return t.Rectangle.union(this, e, n)
        },
        toString: function() {
            return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
        }
    };
    Object.defineProperty(t.Rectangle.prototype, "halfWidth", {
        get: function() {
            return Math.round(this.width / 2)
        }
    });
    Object.defineProperty(t.Rectangle.prototype, "halfHeight", {
        get: function() {
            return Math.round(this.height / 2)
        }
    });
    Object.defineProperty(t.Rectangle.prototype, "bottom", {
        get: function() {
            return this.y + this.height
        },
        set: function(e) {
            if (e <= this.y) {
                this.height = 0
            } else {
                this.height = this.y - e
            }
        }
    });
    Object.defineProperty(t.Rectangle.prototype, "bottomRight", {
        get: function() {
            return new t.Point(this.right, this.bottom)
        },
        set: function(e) {
            this.right = e.x;
            this.bottom = e.y
        }
    });
    Object.defineProperty(t.Rectangle.prototype, "left", {
        get: function() {
            return this.x
        },
        set: function(e) {
            if (e >= this.right) {
                this.width = 0
            } else {
                this.width = this.right - e
            }
            this.x = e
        }
    });
    Object.defineProperty(t.Rectangle.prototype, "right", {
        get: function() {
            return this.x + this.width
        },
        set: function(e) {
            if (e <= this.x) {
                this.width = 0
            } else {
                this.width = this.x + e
            }
        }
    });
    Object.defineProperty(t.Rectangle.prototype, "volume", {
        get: function() {
            return this.width * this.height
        }
    });
    Object.defineProperty(t.Rectangle.prototype, "perimeter", {
        get: function() {
            return this.width * 2 + this.height * 2
        }
    });
    Object.defineProperty(t.Rectangle.prototype, "centerX", {
        get: function() {
            return this.x + this.halfWidth
        },
        set: function(e) {
            this.x = e - this.halfWidth
        }
    });
    Object.defineProperty(t.Rectangle.prototype, "centerY", {
        get: function() {
            return this.y + this.halfHeight
        },
        set: function(e) {
            this.y = e - this.halfHeight
        }
    });
    Object.defineProperty(t.Rectangle.prototype, "top", {
        get: function() {
            return this.y
        },
        set: function(e) {
            if (e >= this.bottom) {
                this.height = 0;
                this.y = e
            } else {
                this.height = this.bottom - e
            }
        }
    });
    Object.defineProperty(t.Rectangle.prototype, "topLeft", {
        get: function() {
            return new t.Point(this.x, this.y)
        },
        set: function(e) {
            this.x = e.x;
            this.y = e.y
        }
    });
    Object.defineProperty(t.Rectangle.prototype, "empty", {
        get: function() {
            return !this.width || !this.height
        },
        set: function(e) {
            if (e === true) {
                this.setTo(0, 0, 0, 0)
            }
        }
    });
    t.Rectangle.prototype.constructor = t.Rectangle;
    t.Rectangle.inflate = function(e, t, n) {
        e.x -= t;
        e.width += 2 * t;
        e.y -= n;
        e.height += 2 * n;
        return e
    };
    t.Rectangle.inflatePoint = function(e, n) {
        return t.Rectangle.inflate(e, n.x, n.y)
    };
    t.Rectangle.size = function(e, n) {
        if (typeof n === "undefined") {
            n = new t.Point(e.width, e.height)
        } else {
            n.setTo(e.width, e.height)
        }
        return n
    };
    t.Rectangle.clone = function(e, n) {
        if (typeof n === "undefined") {
            n = new t.Rectangle(e.x, e.y, e.width, e.height)
        } else {
            n.setTo(e.x, e.y, e.width, e.height)
        }
        return n
    };
    t.Rectangle.contains = function(e, t, n) {
        if (e.width <= 0 || e.height <= 0) {
            return false
        }
        return t >= e.x && t <= e.right && n >= e.y && n <= e.bottom
    };
    t.Rectangle.containsRaw = function(e, t, n, r, i, s) {
        return i >= e && i <= e + n && s >= t && s <= t + r
    };
    t.Rectangle.containsPoint = function(e, n) {
        return t.Rectangle.contains(e, n.x, n.y)
    };
    t.Rectangle.containsRect = function(e, t) {
        if (e.volume > t.volume) {
            return false
        }
        return e.x >= t.x && e.y >= t.y && e.right <= t.right && e.bottom <= t.bottom
    };
    t.Rectangle.equals = function(e, t) {
        return e.x == t.x && e.y == t.y && e.width == t.width && e.height == t.height
    };
    t.Rectangle.intersection = function(e, n, r) {
        if (typeof r === "undefined") {
            r = new t.Rectangle
        }
        if (t.Rectangle.intersects(e, n)) {
            r.x = Math.max(e.x, n.x);
            r.y = Math.max(e.y, n.y);
            r.width = Math.min(e.right, n.right) - r.x;
            r.height = Math.min(e.bottom, n.bottom) - r.y
        }
        return r
    };
    t.Rectangle.intersects = function(e, t) {
        if (e.width <= 0 || e.height <= 0 || t.width <= 0 || t.height <= 0) {
            return false
        }
        return !(e.right < t.x || e.bottom < t.y || e.x > t.right || e.y > t.bottom)
    };
    t.Rectangle.intersectsRaw = function(e, t, n, r, i, s) {
        if (typeof s === "undefined") {
            s = 0
        }
        return !(t > e.right + s || n < e.left - s || r > e.bottom + s || i < e.top - s)
    };
    t.Rectangle.union = function(e, n, r) {
        if (typeof r === "undefined") {
            r = new t.Rectangle
        }
        return r.setTo(Math.min(e.x, n.x), Math.min(e.y, n.y), Math.max(e.right, n.right) - Math.min(e.left, n.left), Math.max(e.bottom, n.bottom) - Math.min(e.top, n.top))
    };
    PIXI.Rectangle = t.Rectangle;
    PIXI.EmptyRectangle = new t.Rectangle(0, 0, 0, 0);
    t.Line = function(e, n, r, i) {
        e = e || 0;
        n = n || 0;
        r = r || 0;
        i = i || 0;
        this.start = new t.Point(e, n);
        this.end = new t.Point(r, i)
    };
    t.Line.prototype = {
        setTo: function(e, t, n, r) {
            this.start.setTo(e, t);
            this.end.setTo(n, r);
            return this
        },
        fromSprite: function(e, t, n) {
            if (typeof n === "undefined") {
                n = false
            }
            if (n) {
                return this.setTo(e.center.x, e.center.y, t.center.x, t.center.y)
            } else {
                return this.setTo(e.x, e.y, t.x, t.y)
            }
        },
        intersects: function(e, n, r) {
            return t.Line.intersectsPoints(this.start, this.end, e.start, e.end, n, r)
        },
        pointOnLine: function(e, t) {
            return (e - this.start.x) * (this.end.y - this.start.y) === (this.end.x - this.start.x) * (t - this.start.y)
        },
        pointOnSegment: function(e, t) {
            var n = Math.min(this.start.x, this.end.x);
            var r = Math.max(this.start.x, this.end.x);
            var i = Math.min(this.start.y, this.end.y);
            var s = Math.max(this.start.y, this.end.y);
            return this.pointOnLine(e, t) && e >= n && e <= r && t >= i && t <= s
        },
        coordinatesOnLine: function(e, t) {
            if (typeof e === "undefined") {
                e = 1
            }
            if (typeof t === "undefined") {
                t = []
            }
            var n = Math.round(this.start.x);
            var r = Math.round(this.start.y);
            var i = Math.round(this.end.x);
            var s = Math.round(this.end.y);
            var o = Math.abs(i - n);
            var u = Math.abs(s - r);
            var a = n < i ? 1 : -1;
            var f = r < s ? 1 : -1;
            var l = o - u;
            t.push([n, r]);
            var c = 1;
            while (!(n == i && r == s)) {
                var h = l << 1;
                if (h > -u) {
                    l -= u;
                    n += a
                }
                if (h < o) {
                    l += o;
                    r += f
                }
                if (c % e === 0) {
                    t.push([n, r])
                }
                c++
            }
            return t
        }
    };
    Object.defineProperty(t.Line.prototype, "length", {
        get: function() {
            return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
        }
    });
    Object.defineProperty(t.Line.prototype, "angle", {
        get: function() {
            return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x)
        }
    });
    Object.defineProperty(t.Line.prototype, "slope", {
        get: function() {
            return (this.end.y - this.start.y) / (this.end.x - this.start.x)
        }
    });
    Object.defineProperty(t.Line.prototype, "perpSlope", {
        get: function() {
            return -((this.end.x - this.start.x) / (this.end.y - this.start.y))
        }
    });
    Object.defineProperty(t.Line.prototype, "x", {
        get: function() {
            return Math.min(this.start.x, this.end.x)
        }
    });
    Object.defineProperty(t.Line.prototype, "y", {
        get: function() {
            return Math.min(this.start.y, this.end.y)
        }
    });
    Object.defineProperty(t.Line.prototype, "left", {
        get: function() {
            return Math.min(this.start.x, this.end.x)
        }
    });
    Object.defineProperty(t.Line.prototype, "right", {
        get: function() {
            return Math.max(this.start.x, this.end.x)
        }
    });
    Object.defineProperty(t.Line.prototype, "top", {
        get: function() {
            return Math.min(this.start.y, this.end.y)
        }
    });
    Object.defineProperty(t.Line.prototype, "bottom", {
        get: function() {
            return Math.max(this.start.y, this.end.y)
        }
    });
    Object.defineProperty(t.Line.prototype, "width", {
        get: function() {
            return Math.abs(this.start.x - this.end.x)
        }
    });
    Object.defineProperty(t.Line.prototype, "height", {
        get: function() {
            return Math.abs(this.start.y - this.end.y)
        }
    });
    t.Line.intersectsPoints = function(e, n, r, i, s, o) {
        if (typeof s === "undefined") {
            s = true
        }
        if (typeof o === "undefined") {
            o = new t.Point
        }
        var u = n.y - e.y;
        var a = i.y - r.y;
        var f = e.x - n.x;
        var l = r.x - i.x;
        var c = n.x * e.y - e.x * n.y;
        var h = i.x * r.y - r.x * i.y;
        var p = u * l - a * f;
        if (p === 0) {
            return null
        }
        o.x = (f * h - l * c) / p;
        o.y = (a * c - u * h) / p;
        if (s) {
            if (o.x < Math.min(e.x, n.x) || o.x > Math.max(e.x, n.x) || o.y < Math.min(e.y, n.y) || o.y > Math.max(e.y, n.y) || o.x < Math.min(r.x, i.x) || o.x > Math.max(r.x, i.x) || o.y < Math.min(r.y, i.y) || o.y > Math.max(r.y, i.y)) {
                return null
            }
        }
        return o
    };
    t.Line.intersects = function(e, n, r, i) {
        return t.Line.intersectsPoints(e.start, e.end, n.start, n.end, r, i)
    };
    t.Ellipse = function(e, n, r, i) {
        this.type = t.ELLIPSE;
        e = e || 0;
        n = n || 0;
        r = r || 0;
        i = i || 0;
        this.x = e;
        this.y = n;
        this.width = r;
        this.height = i
    };
    t.Ellipse.prototype = {
        setTo: function(e, t, n, r) {
            this.x = e;
            this.y = t;
            this.width = n;
            this.height = r;
            return this
        },
        copyFrom: function(e) {
            return this.setTo(e.x, e.y, e.width, e.height)
        },
        copyTo: function(e) {
            e.x = this.x;
            e.y = this.y;
            e.width = this.width;
            e.height = this.height;
            return e
        },
        clone: function(e) {
            if (typeof e === "undefined") {
                e = new t.Ellipse(this.x, this.y, this.width, this.height)
            } else {
                e.setTo(this.x, this.y, this.width, this.height)
            }
            return e
        },
        contains: function(e, n) {
            return t.Ellipse.contains(this, e, n)
        },
        toString: function() {
            return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
        }
    };
    t.Ellipse.prototype.constructor = t.Ellipse;
    Object.defineProperty(t.Ellipse.prototype, "left", {
        get: function() {
            return this.x
        },
        set: function(e) {
            this.x = e
        }
    });
    Object.defineProperty(t.Ellipse.prototype, "right", {
        get: function() {
            return this.x + this.width
        },
        set: function(e) {
            if (e < this.x) {
                this.width = 0
            } else {
                this.width = this.x + e
            }
        }
    });
    Object.defineProperty(t.Ellipse.prototype, "top", {
        get: function() {
            return this.y
        },
        set: function(e) {
            this.y = e
        }
    });
    Object.defineProperty(t.Ellipse.prototype, "bottom", {
        get: function() {
            return this.y + this.height
        },
        set: function(e) {
            if (e < this.y) {
                this.height = 0
            } else {
                this.height = this.y + e
            }
        }
    });
    Object.defineProperty(t.Ellipse.prototype, "empty", {
        get: function() {
            return this.width === 0 || this.height === 0
        },
        set: function(e) {
            if (e === true) {
                this.setTo(0, 0, 0, 0)
            }
        }
    });
    t.Ellipse.contains = function(e, t, n) {
        if (e.width <= 0 || e.height <= 0) {
            return false
        }
        var r = (t - e.x) / e.width - .5;
        var i = (n - e.y) / e.height - .5;
        r *= r;
        i *= i;
        return r + i < .25
    };
    t.Ellipse.prototype.getBounds = function() {
        return new t.Rectangle(this.x, this.y, this.width, this.height)
    };
    PIXI.Ellipse = t.Ellipse;
    t.Polygon = function(e) {
        this.type = t.POLYGON;
        if (!(e instanceof Array)) {
            e = Array.prototype.slice.call(arguments)
        }
        if (typeof e[0] === "number") {
            var n = [];
            for (var r = 0, i = e.length; r < i; r += 2) {
                n.push(new t.Point(e[r], e[r + 1]))
            }
            e = n
        }
        this._points = e
    };
    t.Polygon.prototype = {
        clone: function() {
            var e = [];
            for (var n = 0; n < this.points.length; n++) {
                e.push(this.points[n].clone())
            }
            return new t.Polygon(e)
        },
        contains: function(e, t) {
            var n = false;
            for (var r = 0, i = this.points.length - 1; r < this.points.length; i = r++) {
                var s = this.points[r].x;
                var o = this.points[r].y;
                var u = this.points[i].x;
                var a = this.points[i].y;
                var f = o > t !== a > t && e < (u - s) * (t - o) / (a - o) + s;
                if (f) {
                    n = !n
                }
            }
            return n
        }
    };
    t.Polygon.prototype.constructor = t.Polygon;
    Object.defineProperty(t.Polygon.prototype, "points", {
        get: function() {
            return this._points
        },
        set: function(e) {
            if (!(e instanceof Array)) {
                e = Array.prototype.slice.call(arguments)
            }
            if (typeof e[0] === "number") {
                var n = [];
                for (var r = 0, i = e.length; r < i; r += 2) {
                    n.push(new t.Point(e[r], e[r + 1]))
                }
                e = n
            }
            this._points = e
        }
    });
    Object.defineProperty(t.Polygon.prototype, "area", {
        get: function() {
            var e;
            var t;
            var n;
            var r;
            var i;
            var s = Number.MAX_VALUE;
            var o = 0;
            for (i = 0; i < this.points.length; i++) {
                if (this.points[i].y < s) {
                    s = this.points[i].y
                }
            }
            for (i = 0; i < this.points.length; i++) {
                e = this.points[i];
                if (i === this.points.length - 1) {
                    t = this.points[0]
                } else {
                    t = this.points[i + 1]
                }
                n = (e.y - s + (t.y - s)) / 2;
                r = e.x - t.x;
                o += n * r
            }
            return o
        }
    });
    PIXI.Polygon = t.Polygon;
    t.Camera = function(e, n, r, i, s, o) {
        this.game = e;
        this.world = e.world;
        this.id = 0;
        this.view = new t.Rectangle(r, i, s, o);
        this.screenView = new t.Rectangle(r, i, s, o);
        this.bounds = new t.Rectangle(r, i, s, o);
        this.deadzone = null;
        this.visible = true;
        this.atLimit = {
            x: false,
            y: false
        };
        this.target = null;
        this._edge = 0;
        this.displayObject = null;
        this.scale = null
    };
    t.Camera.FOLLOW_LOCKON = 0;
    t.Camera.FOLLOW_PLATFORMER = 1;
    t.Camera.FOLLOW_TOPDOWN = 2;
    t.Camera.FOLLOW_TOPDOWN_TIGHT = 3;
    t.Camera.prototype = {
        follow: function(e, n) {
            if (typeof n === "undefined") {
                n = t.Camera.FOLLOW_LOCKON
            }
            this.target = e;
            var r;
            switch (n) {
                case t.Camera.FOLLOW_PLATFORMER:
                    var i = this.width / 8;
                    var s = this.height / 3;
                    this.deadzone = new t.Rectangle((this.width - i) / 2, (this.height - s) / 2 - s * .25, i, s);
                    break;
                case t.Camera.FOLLOW_TOPDOWN:
                    r = Math.max(this.width, this.height) / 4;
                    this.deadzone = new t.Rectangle((this.width - r) / 2, (this.height - r) / 2, r, r);
                    break;
                case t.Camera.FOLLOW_TOPDOWN_TIGHT:
                    r = Math.max(this.width, this.height) / 8;
                    this.deadzone = new t.Rectangle((this.width - r) / 2, (this.height - r) / 2, r, r);
                    break;
                case t.Camera.FOLLOW_LOCKON:
                    this.deadzone = null;
                    break;
                default:
                    this.deadzone = null;
                    break
            }
        },
        unfollow: function() {
            this.target = null
        },
        focusOn: function(e) {
            this.setPosition(Math.round(e.x - this.view.halfWidth), Math.round(e.y - this.view.halfHeight))
        },
        focusOnXY: function(e, t) {
            this.setPosition(Math.round(e - this.view.halfWidth), Math.round(t - this.view.halfHeight))
        },
        update: function() {
            if (this.target) {
                this.updateTarget()
            }
            if (this.bounds) {
                this.checkBounds()
            }
            this.displayObject.position.x = -this.view.x;
            this.displayObject.position.y = -this.view.y
        },
        updateTarget: function() {
            if (this.deadzone) {
                this._edge = this.target.x - this.deadzone.x;
                if (this.view.x > this._edge) {
                    this.view.x = this._edge
                }
                this._edge = this.target.x + this.target.width - this.deadzone.x - this.deadzone.width;
                if (this.view.x < this._edge) {
                    this.view.x = this._edge
                }
                this._edge = this.target.y - this.deadzone.y;
                if (this.view.y > this._edge) {
                    this.view.y = this._edge
                }
                this._edge = this.target.y + this.target.height - this.deadzone.y - this.deadzone.height;
                if (this.view.y < this._edge) {
                    this.view.y = this._edge
                }
            } else {
                this.focusOnXY(this.target.x, this.target.y)
            }
        },
        setBoundsToWorld: function() {
            this.bounds.setTo(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height)
        },
        checkBounds: function() {
            this.atLimit.x = false;
            this.atLimit.y = false;
            if (this.view.x <= this.bounds.x) {
                this.atLimit.x = true;
                this.view.x = this.bounds.x
            }
            if (this.view.right >= this.bounds.right) {
                this.atLimit.x = true;
                this.view.x = this.bounds.right - this.width
            }
            if (this.view.y <= this.bounds.top) {
                this.atLimit.y = true;
                this.view.y = this.bounds.top
            }
            if (this.view.bottom >= this.bounds.bottom) {
                this.atLimit.y = true;
                this.view.y = this.bounds.bottom - this.height
            }
            this.view.floor()
        },
        setPosition: function(e, t) {
            this.view.x = e;
            this.view.y = t;
            if (this.bounds) {
                this.checkBounds()
            }
        },
        setSize: function(e, t) {
            this.view.width = e;
            this.view.height = t
        },
        reset: function() {
            this.target = null;
            this.view.x = 0;
            this.view.y = 0
        }
    };
    t.Camera.prototype.constructor = t.Camera;
    Object.defineProperty(t.Camera.prototype, "x", {
        get: function() {
            return this.view.x
        },
        set: function(e) {
            this.view.x = e;
            if (this.bounds) {
                this.checkBounds()
            }
        }
    });
    Object.defineProperty(t.Camera.prototype, "y", {
        get: function() {
            return this.view.y
        },
        set: function(e) {
            this.view.y = e;
            if (this.bounds) {
                this.checkBounds()
            }
        }
    });
    Object.defineProperty(t.Camera.prototype, "width", {
        get: function() {
            return this.view.width
        },
        set: function(e) {
            this.view.width = e
        }
    });
    Object.defineProperty(t.Camera.prototype, "height", {
        get: function() {
            return this.view.height
        },
        set: function(e) {
            this.view.height = e
        }
    });
    t.State = function() {
        this.game = null;
        this.add = null;
        this.make = null;
        this.camera = null;
        this.cache = null;
        this.input = null;
        this.load = null;
        this.math = null;
        this.sound = null;
        this.scale = null;
        this.stage = null;
        this.time = null;
        this.tweens = null;
        this.world = null;
        this.particles = null;
        this.physics = null;
        this.rnd = null
    };
    t.State.prototype = {
        preload: function() {},
        loadUpdate: function() {},
        loadRender: function() {},
        create: function() {},
        update: function() {},
        render: function() {},
        paused: function() {},
        pauseUpdate: function() {},
        shutdown: function() {}
    };
    t.State.prototype.constructor = t.State;
    t.StateManager = function(e, t) {
        this.game = e;
        this.states = {};
        this._pendingState = null;
        if (typeof t !== "undefined" && t !== null) {
            this._pendingState = t
        }
        this._clearWorld = false;
        this._clearCache = false;
        this._created = false;
        this._args = [];
        this.current = "";
        this.onInitCallback = null;
        this.onPreloadCallback = null;
        this.onCreateCallback = null;
        this.onUpdateCallback = null;
        this.onRenderCallback = null;
        this.onPreRenderCallback = null;
        this.onLoadUpdateCallback = null;
        this.onLoadRenderCallback = null;
        this.onPausedCallback = null;
        this.onResumedCallback = null;
        this.onPauseUpdateCallback = null;
        this.onShutDownCallback = null
    };
    t.StateManager.prototype = {
        boot: function() {
            this.game.onPause.add(this.pause, this);
            this.game.onResume.add(this.resume, this);
            this.game.load.onLoadComplete.add(this.loadComplete, this);
            if (this._pendingState !== null) {
                if (typeof this._pendingState === "string") {
                    this.start(this._pendingState, false, false)
                } else {
                    this.add("default", this._pendingState, true)
                }
            }
        },
        add: function(e, n, r) {
            if (typeof r === "undefined") {
                r = false
            }
            var i;
            if (n instanceof t.State) {
                i = n
            } else if (typeof n === "object") {
                i = n;
                i.game = this.game
            } else if (typeof n === "function") {
                i = new n(this.game)
            }
            this.states[e] = i;
            if (r) {
                if (this.game.isBooted) {
                    this.start(e)
                } else {
                    this._pendingState = e
                }
            }
            return i
        },
        remove: function(e) {
            if (this.current === e) {
                this.callbackContext = null;
                this.onInitCallback = null;
                this.onShutDownCallback = null;
                this.onPreloadCallback = null;
                this.onLoadRenderCallback = null;
                this.onLoadUpdateCallback = null;
                this.onCreateCallback = null;
                this.onUpdateCallback = null;
                this.onRenderCallback = null;
                this.onPausedCallback = null;
                this.onResumedCallback = null;
                this.onPauseUpdateCallback = null
            }
            delete this.states[e]
        },
        start: function(e, t, n) {
            if (typeof t === "undefined") {
                t = true
            }
            if (typeof n === "undefined") {
                n = false
            }
            if (this.checkState(e)) {
                this._pendingState = e;
                this._clearWorld = t;
                this._clearCache = n;
                if (arguments.length > 3) {
                    this._args = Array.prototype.splice.call(arguments, 3)
                }
            }
        },
        restart: function(e, t) {
            if (typeof e === "undefined") {
                e = true
            }
            if (typeof t === "undefined") {
                t = false
            }
            this._pendingState = this.current;
            this._clearWorld = e;
            this._clearCache = t;
            if (arguments.length > 2) {
                this._args = Array.prototype.splice.call(arguments, 2)
            }
        },
        dummy: function() {},
        preUpdate: function() {
            if (this._pendingState && this.game.isBooted) {
                if (this.current) {
                    this.onShutDownCallback.call(this.callbackContext, this.game);
                    this.game.tweens.removeAll();
                    this.game.camera.reset();
                    this.game.input.reset(true);
                    this.game.physics.clear();
                    this.game.time.removeAll();
                    if (this._clearWorld) {
                        this.game.world.shutdown();
                        if (this._clearCache === true) {
                            this.game.cache.destroy()
                        }
                    }
                }
                this.setCurrentState(this._pendingState);
                if (this.onPreloadCallback) {
                    this.game.load.reset();
                    this.onPreloadCallback.call(this.callbackContext, this.game);
                    if (this.game.load.totalQueuedFiles() === 0) {
                        this.loadComplete()
                    } else {
                        this.game.load.start()
                    }
                } else {
                    this.loadComplete()
                }
                if (this.current === this._pendingState) {
                    this._pendingState = null
                }
            }
        },
        checkState: function(e) {
            if (this.states[e]) {
                var t = false;
                if (this.states[e]["preload"]) {
                    t = true
                }
                if (this.states[e]["create"]) {
                    t = true
                }
                if (this.states[e]["update"]) {
                    t = true
                }
                if (this.states[e]["render"]) {
                    t = true
                }
                if (t === false) {
                    console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render");
                    return false
                }
                return true
            } else {
                console.warn("Phaser.StateManager - No state found with the key: " + e);
                return false
            }
        },
        link: function(e) {
            this.states[e].game = this.game;
            this.states[e].add = this.game.add;
            this.states[e].make = this.game.make;
            this.states[e].camera = this.game.camera;
            this.states[e].cache = this.game.cache;
            this.states[e].input = this.game.input;
            this.states[e].load = this.game.load;
            this.states[e].math = this.game.math;
            this.states[e].sound = this.game.sound;
            this.states[e].scale = this.game.scale;
            this.states[e].state = this;
            this.states[e].stage = this.game.stage;
            this.states[e].time = this.game.time;
            this.states[e].tweens = this.game.tweens;
            this.states[e].world = this.game.world;
            this.states[e].particles = this.game.particles;
            this.states[e].rnd = this.game.rnd;
            this.states[e].physics = this.game.physics
        },
        setCurrentState: function(e) {
            this.callbackContext = this.states[e];
            this.link(e);
            this.onInitCallback = this.states[e]["init"] || this.dummy;
            this.onPreloadCallback = this.states[e]["preload"] || null;
            this.onLoadRenderCallback = this.states[e]["loadRender"] || null;
            this.onLoadUpdateCallback = this.states[e]["loadUpdate"] || null;
            this.onCreateCallback = this.states[e]["create"] || null;
            this.onUpdateCallback = this.states[e]["update"] || null;
            this.onPreRenderCallback = this.states[e]["preRender"] || null;
            this.onRenderCallback = this.states[e]["render"] || null;
            this.onPausedCallback = this.states[e]["paused"] || null;
            this.onResumedCallback = this.states[e]["resumed"] || null;
            this.onPauseUpdateCallback = this.states[e]["pauseUpdate"] || null;
            this.onShutDownCallback = this.states[e]["shutdown"] || this.dummy;
            this.current = e;
            this._created = false;
            this.onInitCallback.apply(this.callbackContext, this._args);
            this._args = []
        },
        getCurrentState: function() {
            return this.states[this.current]
        },
        loadComplete: function() {
            if (this._created === false && this.onCreateCallback) {
                this._created = true;
                this.onCreateCallback.call(this.callbackContext, this.game)
            } else {
                this._created = true
            }
        },
        pause: function() {
            if (this._created && this.onPausedCallback) {
                this.onPausedCallback.call(this.callbackContext, this.game)
            }
        },
        resume: function() {
            if (this._created && this.onResumedCallback) {
                this.onResumedCallback.call(this.callbackContext, this.game)
            }
        },
        update: function() {
            if (this._created && this.onUpdateCallback) {
                this.onUpdateCallback.call(this.callbackContext, this.game)
            } else {
                if (this.onLoadUpdateCallback) {
                    this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                }
            }
        },
        pauseUpdate: function() {
            if (this._created && this.onPauseUpdateCallback) {
                this.onPauseUpdateCallback.call(this.callbackContext, this.game)
            } else {
                if (this.onLoadUpdateCallback) {
                    this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                }
            }
        },
        preRender: function() {
            if (this.onPreRenderCallback) {
                this.onPreRenderCallback.call(this.callbackContext, this.game)
            }
        },
        render: function() {
            if (this._created && this.onRenderCallback) {
                if (this.game.renderType === t.CANVAS) {
                    this.game.context.save();
                    this.game.context.setTransform(1, 0, 0, 1, 0, 0)
                }
                this.onRenderCallback.call(this.callbackContext, this.game);
                if (this.game.renderType === t.CANVAS) {
                    this.game.context.restore()
                }
            } else {
                if (this.onLoadRenderCallback) {
                    this.onLoadRenderCallback.call(this.callbackContext, this.game)
                }
            }
        },
        destroy: function() {
            this.callbackContext = null;
            this.onInitCallback = null;
            this.onShutDownCallback = null;
            this.onPreloadCallback = null;
            this.onLoadRenderCallback = null;
            this.onLoadUpdateCallback = null;
            this.onCreateCallback = null;
            this.onUpdateCallback = null;
            this.onRenderCallback = null;
            this.onPausedCallback = null;
            this.onResumedCallback = null;
            this.onPauseUpdateCallback = null;
            this.game = null;
            this.states = {};
            this._pendingState = null
        }
    };
    t.StateManager.prototype.constructor = t.StateManager;
    t.LinkedList = function() {
        this.next = null;
        this.prev = null;
        this.first = null;
        this.last = null;
        this.total = 0
    };
    t.LinkedList.prototype = {
        add: function(e) {
            if (this.total === 0 && this.first === null && this.last === null) {
                this.first = e;
                this.last = e;
                this.next = e;
                e.prev = this;
                this.total++;
                return e
            }
            this.last.next = e;
            e.prev = this.last;
            this.last = e;
            this.total++;
            return e
        },
        reset: function() {
            this.first = null;
            this.last = null;
            this.next = null;
            this.prev = null;
            this.total = 0
        },
        remove: function(e) {
            if (this.total === 1) {
                this.reset();
                e.next = e.prev = null;
                return
            }
            if (e === this.first) {
                this.first = this.first.next
            } else if (e === this.last) {
                this.last = this.last.prev
            }
            if (e.prev) {
                e.prev.next = e.next
            }
            if (e.next) {
                e.next.prev = e.prev
            }
            e.next = e.prev = null;
            if (this.first === null) {
                this.last = null
            }
            this.total--
        },
        callAll: function(e) {
            if (!this.first || !this.last) {
                return
            }
            var t = this.first;
            do {
                if (t && t[e]) {
                    t[e].call(t)
                }
                t = t.next
            } while (t != this.last.next)
        }
    };
    t.LinkedList.prototype.constructor = t.LinkedList;
    t.ArrayList = function() {
        this.total = 0;
        this.position = 0;
        this.list = []
    };
    t.ArrayList.prototype = {
        add: function(e) {
            if (!this.exists(e)) {
                this.list.push(e);
                this.total++
            }
            return e
        },
        getIndex: function(e) {
            return this.list.indexOf(e)
        },
        exists: function(e) {
            return this.list.indexOf(e) > -1
        },
        reset: function() {
            this.list.length = 0;
            this.total = 0
        },
        remove: function(e) {
            var t = this.list.indexOf(e);
            if (t > -1) {
                this.list.splice(t, 1);
                this.total--;
                return e
            }
        },
        callAll: function(e) {
            var t = Array.prototype.splice.call(arguments, 1);
            var n = this.list.length;
            while (n--) {
                if (this.list[n] && this.list[n][e]) {
                    this.list[n][e].apply(this.list[n], t)
                }
            }
        }
    };
    Object.defineProperty(t.ArrayList.prototype, "first", {
        get: function() {
            this.position = 0;
            if (this.total > 0) {
                return this.list[0]
            } else {
                return null
            }
        }
    });
    Object.defineProperty(t.ArrayList.prototype, "next", {
        get: function() {
            if (this.position < this.total) {
                this.position++;
                return this.list[this.position]
            } else {
                return null
            }
        }
    });
    t.ArrayList.prototype.constructor = t.ArrayList;
    t.Signal = function() {
        this._bindings = [];
        this._prevParams = null;
        var e = this;
        this.dispatch = function() {
            t.Signal.prototype.dispatch.apply(e, arguments)
        }
    };
    t.Signal.prototype = {
        memorize: false,
        _shouldPropagate: true,
        active: true,
        validateListener: function(e, t) {
            if (typeof e !== "function") {
                throw new Error("listener is a required param of {fn}() and should be a Function.".replace("{fn}", t))
            }
        },
        _registerListener: function(e, n, r, i) {
            var s = this._indexOfListener(e, r),
                o;
            if (s !== -1) {
                o = this._bindings[s];
                if (o.isOnce() !== n) {
                    throw new Error("You cannot add" + (n ? "" : "Once") + "() then add" + (!n ? "" : "Once") + "() the same listener without removing the relationship first.")
                }
            } else {
                o = new t.SignalBinding(this, e, n, r, i);
                this._addBinding(o)
            }
            if (this.memorize && this._prevParams) {
                o.execute(this._prevParams)
            }
            return o
        },
        _addBinding: function(e) {
            var t = this._bindings.length;
            do {--t
            } while (this._bindings[t] && e._priority <= this._bindings[t]._priority);
            this._bindings.splice(t + 1, 0, e)
        },
        _indexOfListener: function(e, t) {
            var n = this._bindings.length,
                r;
            while (n--) {
                r = this._bindings[n];
                if (r._listener === e && r.context === t) {
                    return n
                }
            }
            return -1
        },
        has: function(e, t) {
            return this._indexOfListener(e, t) !== -1
        },
        add: function(e, t, n) {
            this.validateListener(e, "add");
            return this._registerListener(e, false, t, n)
        },
        addOnce: function(e, t, n) {
            this.validateListener(e, "addOnce");
            return this._registerListener(e, true, t, n)
        },
        remove: function(e, t) {
            this.validateListener(e, "remove");
            var n = this._indexOfListener(e, t);
            if (n !== -1) {
                this._bindings[n]._destroy();
                this._bindings.splice(n, 1)
            }
            return e
        },
        removeAll: function() {
            var e = this._bindings.length;
            while (e--) {
                this._bindings[e]._destroy()
            }
            this._bindings.length = 0
        },
        getNumListeners: function() {
            return this._bindings.length
        },
        halt: function() {
            this._shouldPropagate = false
        },
        dispatch: function() {
            if (!this.active) {
                return
            }
            var e = Array.prototype.slice.call(arguments);
            var t = this._bindings.length;
            var n;
            if (this.memorize) {
                this._prevParams = e
            }
            if (!t) {
                return
            }
            n = this._bindings.slice();
            this._shouldPropagate = true;
            do {
                t--
            } while (n[t] && this._shouldPropagate && n[t].execute(e) !== false)
        },
        forget: function() {
            this._prevParams = null
        },
        dispose: function() {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams
        },
        toString: function() {
            return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
        }
    };
    t.Signal.prototype.constructor = t.Signal;
    t.SignalBinding = function(e, t, n, r, i) {
        this._listener = t;
        this._isOnce = n;
        this.context = r;
        this._signal = e;
        this._priority = i || 0
    };
    t.SignalBinding.prototype = {
        active: true,
        params: null,
        execute: function(e) {
            var t, n;
            if (this.active && !! this._listener) {
                n = this.params ? this.params.concat(e) : e;
                t = this._listener.apply(this.context, n);
                if (this._isOnce) {
                    this.detach()
                }
            }
            return t
        },
        detach: function() {
            return this.isBound() ? this._signal.remove(this._listener, this.context) : null
        },
        isBound: function() {
            return !!this._signal && !! this._listener
        },
        isOnce: function() {
            return this._isOnce
        },
        getListener: function() {
            return this._listener
        },
        getSignal: function() {
            return this._signal
        },
        _destroy: function() {
            delete this._signal;
            delete this._listener;
            delete this.context
        },
        toString: function() {
            return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
        }
    };
    t.SignalBinding.prototype.constructor = t.SignalBinding;
    t.Filter = function(e, n, r) {
        this.game = e;
        this.type = t.WEBGL_FILTER;
        this.passes = [this];
        this.shaders = [];
        this.dirty = true;
        this.padding = 0;
        this.uniforms = {
            time: {
                type: "1f",
                value: 0
            },
            resolution: {
                type: "2f",
                value: {
                    x: 256,
                    y: 256
                }
            },
            mouse: {
                type: "2f",
                value: {
                    x: 0,
                    y: 0
                }
            }
        };
        this.fragmentSrc = r || []
    };
    t.Filter.prototype = {
        init: function() {},
        setResolution: function(e, t) {
            this.uniforms.resolution.value.x = e;
            this.uniforms.resolution.value.y = t
        },
        update: function(e) {
            if (typeof e !== "undefined") {
                if (e.x > 0) {
                    this.uniforms.mouse.x = e.x.toFixed(2)
                }
                if (e.y > 0) {
                    this.uniforms.mouse.y = e.y.toFixed(2)
                }
            }
            this.uniforms.time.value = this.game.time.totalElapsedSeconds()
        },
        destroy: function() {
            this.game = null
        }
    };
    t.Filter.prototype.constructor = t.Filter;
    Object.defineProperty(t.Filter.prototype, "width", {
        get: function() {
            return this.uniforms.resolution.value.x
        },
        set: function(e) {
            this.uniforms.resolution.value.x = e
        }
    });
    Object.defineProperty(t.Filter.prototype, "height", {
        get: function() {
            return this.uniforms.resolution.value.y
        },
        set: function(e) {
            this.uniforms.resolution.value.y = e
        }
    });
    t.Plugin = function(e, t) {
        if (typeof t === "undefined") {
            t = null
        }
        this.game = e;
        this.parent = t;
        this.active = false;
        this.visible = false;
        this.hasPreUpdate = false;
        this.hasUpdate = false;
        this.hasPostUpdate = false;
        this.hasRender = false;
        this.hasPostRender = false
    };
    t.Plugin.prototype = {
        preUpdate: function() {},
        update: function() {},
        render: function() {},
        postRender: function() {},
        destroy: function() {
            this.game = null;
            this.parent = null;
            this.active = false;
            this.visible = false
        }
    };
    t.Plugin.prototype.constructor = t.Plugin;
    t.PluginManager = function(e) {
        this.game = e;
        this.plugins = [];
        this._len = 0;
        this._i = 0
    };
    t.PluginManager.prototype = {
        add: function(e) {
            var t = Array.prototype.splice.call(arguments, 1);
            var n = false;
            if (typeof e === "function") {
                e = new e(this.game, this)
            } else {
                e.game = this.game;
                e.parent = this
            }
            if (typeof e["preUpdate"] === "function") {
                e.hasPreUpdate = true;
                n = true
            }
            if (typeof e["update"] === "function") {
                e.hasUpdate = true;
                n = true
            }
            if (typeof e["postUpdate"] === "function") {
                e.hasPostUpdate = true;
                n = true
            }
            if (typeof e["render"] === "function") {
                e.hasRender = true;
                n = true
            }
            if (typeof e["postRender"] === "function") {
                e.hasPostRender = true;
                n = true
            }
            if (n) {
                if (e.hasPreUpdate || e.hasUpdate || e.hasPostUpdate) {
                    e.active = true
                }
                if (e.hasRender || e.hasPostRender) {
                    e.visible = true
                }
                this._len = this.plugins.push(e);
                if (typeof e["init"] === "function") {
                    e.init.apply(e, t)
                }
                return e
            } else {
                return null
            }
        },
        remove: function(e) {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i] === e) {
                    e.destroy();
                    this.plugins.splice(this._i, 1);
                    this._len--;
                    return
                }
            }
        },
        removeAll: function() {
            this._i = this._len;
            while (this._i--) {
                this.plugins[this._i].destroy()
            }
            this.plugins.length = 0;
            this._len = 0
        },
        preUpdate: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate) {
                    this.plugins[this._i].preUpdate()
                }
            }
        },
        update: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].active && this.plugins[this._i].hasUpdate) {
                    this.plugins[this._i].update()
                }
            }
        },
        postUpdate: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate) {
                    this.plugins[this._i].postUpdate()
                }
            }
        },
        render: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].visible && this.plugins[this._i].hasRender) {
                    this.plugins[this._i].render()
                }
            }
        },
        postRender: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].visible && this.plugins[this._i].hasPostRender) {
                    this.plugins[this._i].postRender()
                }
            }
        },
        destroy: function() {
            this.removeAll();
            this.game = null
        }
    };
    t.PluginManager.prototype.constructor = t.PluginManager;
    t.Stage = function(e, n, r) {
        this.game = e;
        this.offset = new t.Point;
        this.bounds = new t.Rectangle(0, 0, n, r);
        PIXI.Stage.call(this, 0, false);
        this.name = "_stage_root";
        this.interactive = false;
        this.disableVisibilityChange = false;
        this.checkOffsetInterval = 2500;
        this.exists = true;
        this.currentRenderOrderID = 0;
        this._hiddenVar = "hidden";
        this._nextOffsetCheck = 0;
        this._backgroundColor = 0;
        if (e.config) {
            this.parseConfig(e.config)
        } else {
            this.game.canvas = t.Canvas.create(n, r);
            this.game.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%"
        }
    };
    t.Stage.prototype = Object.create(PIXI.Stage.prototype);
    t.Stage.prototype.constructor = t.Stage;
    t.Stage.prototype.preUpdate = function() {
        this.currentRenderOrderID = 0;
        var e = this.children.length;
        for (var t = 0; t < e; t++) {
            this.children[t].preUpdate()
        }
    };
    t.Stage.prototype.update = function() {
        var e = this.children.length;
        while (e--) {
            this.children[e].update()
        }
    };
    t.Stage.prototype.postUpdate = function() {
        if (this.game.world.camera.target) {
            this.game.world.camera.target.postUpdate();
            this.game.world.camera.update();
            var e = this.children.length;
            while (e--) {
                if (this.children[e] !== this.game.world.camera.target) {
                    this.children[e].postUpdate()
                }
            }
        } else {
            this.game.world.camera.update();
            var e = this.children.length;
            while (e--) {
                this.children[e].postUpdate()
            }
        }
        if (this.checkOffsetInterval !== false) {
            if (this.game.time.now > this._nextOffsetCheck) {
                t.Canvas.getOffset(this.game.canvas, this.offset);
                this.bounds.x = this.offset.x;
                this.bounds.y = this.offset.y;
                this._nextOffsetCheck = this.game.time.now + this.checkOffsetInterval
            }
        }
    };
    t.Stage.prototype.parseConfig = function(e) {
        if (e["canvasID"]) {
            this.game.canvas = t.Canvas.create(this.game.width, this.game.height, e["canvasID"])
        } else {
            this.game.canvas = t.Canvas.create(this.game.width, this.game.height)
        }
        if (e["canvasStyle"]) {
            this.game.canvas.stlye = e["canvasStyle"]
        } else {
            this.game.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%"
        }
        if (e["checkOffsetInterval"]) {
            this.checkOffsetInterval = e["checkOffsetInterval"]
        }
        if (e["disableVisibilityChange"]) {
            this.disableVisibilityChange = e["disableVisibilityChange"]
        }
        if (e["fullScreenScaleMode"]) {
            this.fullScreenScaleMode = e["fullScreenScaleMode"]
        }
        if (e["scaleMode"]) {
            this.scaleMode = e["scaleMode"]
        }
        if (e["backgroundColor"]) {
            this.backgroundColor = e["backgroundColor"]
        }
    };
    t.Stage.prototype.boot = function() {
        t.Canvas.getOffset(this.game.canvas, this.offset);
        this.bounds.setTo(this.offset.x, this.offset.y, this.game.width, this.game.height);
        var e = this;
        this._onChange = function(t) {
            return e.visibilityChange(t)
        };
        t.Canvas.setUserSelect(this.game.canvas, "none");
        t.Canvas.setTouchAction(this.game.canvas, "none");
        this.checkVisibility()
    };
    t.Stage.prototype.checkVisibility = function() {
        if (document.webkitHidden !== undefined) {
            this._hiddenVar = "webkitvisibilitychange"
        } else if (document.mozHidden !== undefined) {
            this._hiddenVar = "mozvisibilitychange"
        } else if (document.msHidden !== undefined) {
            this._hiddenVar = "msvisibilitychange"
        } else if (document.hidden !== undefined) {
            this._hiddenVar = "visibilitychange"
        } else {
            this._hiddenVar = null
        }
        if (this._hiddenVar) {
            document.addEventListener(this._hiddenVar, this._onChange, false)
        }
        window.onpagehide = this._onChange;
        window.onpageshow = this._onChange;
        window.onblur = this._onChange;
        window.onfocus = this._onChange
    };
    t.Stage.prototype.visibilityChange = function(e) {
        if (this.disableVisibilityChange) {
            return
        }
        if (e.type === "pagehide" || e.type === "blur" || e.type === "pageshow" || e.type === "focus") {
            if (e.type === "pagehide" || e.type === "blur") {
                this.game.focusLoss(e)
            } else if (e.type === "pageshow" || e.type === "focus") {
                this.game.focusGain(e)
            }
            return
        }
        if (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden) {
            this.game.gamePaused(e)
        } else {
            this.game.gameResumed(e)
        }
    };
    t.Stage.prototype.setBackgroundColor = function(e) {
        if (typeof e === "string") {
            var n = t.Color.hexToColor(e);
            this._backgroundColor = t.Color.getColor(n.r, n.g, n.b)
        } else {
            var n = t.Color.getRGB(e);
            this._backgroundColor = e
        }
        this.backgroundColorSplit = [n.r / 255, n.g / 255, n.b / 255];
        this.backgroundColorString = t.Color.RGBtoString(n.r, n.g, n.b, 255, "#")
    };
    Object.defineProperty(t.Stage.prototype, "backgroundColor", {
        get: function() {
            return this._backgroundColor
        },
        set: function(e) {
            if (!this.game.transparent) {
                this.setBackgroundColor(e)
            }
        }
    });
    Object.defineProperty(t.Stage.prototype, "smoothed", {
        get: function() {
            return !PIXI.scaleModes.LINEAR
        },
        set: function(e) {
            if (e) {
                PIXI.scaleModes.LINEAR = 0
            } else {
                PIXI.scaleModes.LINEAR = 1
            }
        }
    });
    t.Group = function(e, n, r, i, s, o) {
        if (typeof i === "undefined") {
            i = false
        }
        if (typeof s === "undefined") {
            s = false
        }
        if (typeof o === "undefined") {
            o = t.Physics.ARCADE
        }
        this.game = e;
        if (typeof n === "undefined") {
            n = e.world
        }
        this.name = r || "group";
        PIXI.DisplayObjectContainer.call(this);
        if (i) {
            this.game.stage.addChild(this)
        } else {
            if (n) {
                n.addChild(this)
            }
        }
        this.z = 0;
        this.type = t.GROUP;
        this.alive = true;
        this.exists = true;
        this.classType = t.Sprite;
        this.scale = new t.Point(1, 1);
        this.cursor = null;
        this.cameraOffset = new t.Point;
        this.enableBody = s;
        this.enableBodyDebug = false;
        this.physicsBodyType = o;
        this._sortProperty = "z";
        this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0, 0]
    };
    t.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    t.Group.prototype.constructor = t.Group;
    t.Group.RETURN_NONE = 0;
    t.Group.RETURN_TOTAL = 1;
    t.Group.RETURN_CHILD = 2;
    t.Group.SORT_ASCENDING = -1;
    t.Group.SORT_DESCENDING = 1;
    t.Group.prototype.add = function(e) {
        if (e.parent !== this) {
            if (this.enableBody) {
                this.game.physics.enable(e, this.physicsBodyType)
            }
            this.addChild(e);
            e.z = this.children.length;
            if (e.events) {
                e.events.onAddedToGroup.dispatch(e, this)
            }
            if (this.cursor === null) {
                this.cursor = e
            }
        }
        return e
    };
    t.Group.prototype.addAt = function(e, t) {
        if (e.parent !== this) {
            if (this.enableBody) {
                this.game.physics.enable(e, this.physicsBodyType)
            }
            this.addChildAt(e, t);
            this.updateZ();
            if (e.events) {
                e.events.onAddedToGroup.dispatch(e, this)
            }
            if (this.cursor === null) {
                this.cursor = e
            }
        }
        return e
    };
    t.Group.prototype.getAt = function(e) {
        if (e < 0 || e >= this.children.length) {
            return -1
        } else {
            return this.getChildAt(e)
        }
    };
    t.Group.prototype.create = function(e, t, n, r, i) {
        if (typeof i === "undefined") {
            i = true
        }
        var s = new this.classType(this.game, e, t, n, r);
        if (this.enableBody) {
            this.game.physics.enable(s, this.physicsBodyType)
        }
        s.exists = i;
        s.visible = i;
        s.alive = i;
        this.addChild(s);
        s.z = this.children.length;
        if (s.events) {
            s.events.onAddedToGroup.dispatch(s, this)
        }
        if (this.cursor === null) {
            this.cursor = s
        }
        return s
    };
    t.Group.prototype.createMultiple = function(e, t, n, r) {
        if (typeof r === "undefined") {
            r = false
        }
        for (var i = 0; i < e; i++) {
            this.create(0, 0, t, n, r)
        }
    };
    t.Group.prototype.updateZ = function() {
        var e = this.children.length;
        while (e--) {
            this.children[e].z = e
        }
    };
    t.Group.prototype.resetCursor = function(e) {
        if (typeof e === "undefined") {
            e = 0
        }
        if (e > this.children.length - 1) {
            e = 0
        }
        if (this.cursor) {
            this._cache[8] = e;
            this.cursor = this.children[this._cache[8]];
            return this.cursor
        }
    };
    t.Group.prototype.next = function() {
        if (this.cursor) {
            if (this._cache[8] >= this.children.length - 1) {
                this._cache[8] = 0
            } else {
                this._cache[8]++
            }
            this.cursor = this.children[this._cache[8]];
            return this.cursor
        }
    };
    t.Group.prototype.previous = function() {
        if (this.cursor) {
            if (this._cache[8] === 0) {
                this._cache[8] = this.children.length - 1
            } else {
                this._cache[8]--
            }
            this.cursor = this.children[this._cache[8]];
            return this.cursor
        }
    };
    t.Group.prototype.swap = function(e, t) {
        var n = this.swapChildren(e, t);
        if (n) {
            this.updateZ()
        }
        return n
    };
    t.Group.prototype.bringToTop = function(e) {
        if (e.parent === this && this.getIndex(e) < this.children.length) {
            this.remove(e);
            this.add(e)
        }
        return e
    };
    t.Group.prototype.sendToBack = function(e) {
        if (e.parent === this && this.getIndex(e) > 0) {
            this.remove(e);
            this.addAt(e, 0)
        }
        return e
    };
    t.Group.prototype.moveUp = function(e) {
        if (e.parent === this && this.getIndex(e) < this.children.length - 1) {
            var t = this.getIndex(e);
            var n = this.getAt(t + 1);
            if (n) {
                this.swap(e, n)
            }
        }
        return e
    };
    t.Group.prototype.moveDown = function(e) {
        if (e.parent === this && this.getIndex(e) > 0) {
            var t = this.getIndex(e);
            var n = this.getAt(t - 1);
            if (n) {
                this.swap(e, n)
            }
        }
        return e
    };
    t.Group.prototype.xy = function(e, t, n) {
        if (e < 0 || e > this.children.length) {
            return -1
        } else {
            this.getChildAt(e).x = t;
            this.getChildAt(e).y = n
        }
    };
    t.Group.prototype.reverse = function() {
        this.children.reverse();
        this.updateZ()
    };
    t.Group.prototype.getIndex = function(e) {
        return this.children.indexOf(e)
    };
    t.Group.prototype.replace = function(e, n) {
        var r = this.getIndex(e);
        if (r !== -1) {
            if (n.parent !== undefined) {
                n.events.onRemovedFromGroup.dispatch(n, this);
                n.parent.removeChild(n);
                if (n.parent instanceof t.Group) {
                    n.parent.updateZ()
                }
            }
            var i = e;
            this.remove(i);
            this.addAt(n, r);
            return i
        }
    };
    t.Group.prototype.hasProperty = function(e, t) {
        var n = t.length;
        if (n === 1 && t[0] in e) {
            return true
        } else if (n === 2 && t[0] in e && t[1] in e[t[0]]) {
            return true
        } else if (n === 3 && t[0] in e && t[1] in e[t[0]] && t[2] in e[t[0]][t[1]]) {
            return true
        } else if (n === 4 && t[0] in e && t[1] in e[t[0]] && t[2] in e[t[0]][t[1]] && t[3] in e[t[0]][t[1]][t[2]]) {
            return true
        }
        return false
    };
    t.Group.prototype.setProperty = function(e, t, n, r, i) {
        if (typeof i === "undefined") {
            i = false
        }
        r = r || 0;
        if (!this.hasProperty(e, t) && (!i || r > 0)) {
            return false
        }
        var s = t.length;
        if (s === 1) {
            if (r === 0) {
                e[t[0]] = n
            } else if (r == 1) {
                e[t[0]] += n
            } else if (r == 2) {
                e[t[0]] -= n
            } else if (r == 3) {
                e[t[0]] *= n
            } else if (r == 4) {
                e[t[0]] /= n
            }
        } else if (s === 2) {
            if (r === 0) {
                e[t[0]][t[1]] = n
            } else if (r == 1) {
                e[t[0]][t[1]] += n
            } else if (r == 2) {
                e[t[0]][t[1]] -= n
            } else if (r == 3) {
                e[t[0]][t[1]] *= n
            } else if (r == 4) {
                e[t[0]][t[1]] /= n
            }
        } else if (s === 3) {
            if (r === 0) {
                e[t[0]][t[1]][t[2]] = n
            } else if (r == 1) {
                e[t[0]][t[1]][t[2]] += n
            } else if (r == 2) {
                e[t[0]][t[1]][t[2]] -= n
            } else if (r == 3) {
                e[t[0]][t[1]][t[2]] *= n
            } else if (r == 4) {
                e[t[0]][t[1]][t[2]] /= n
            }
        } else if (s === 4) {
            if (r === 0) {
                e[t[0]][t[1]][t[2]][t[3]] = n
            } else if (r == 1) {
                e[t[0]][t[1]][t[2]][t[3]] += n
            } else if (r == 2) {
                e[t[0]][t[1]][t[2]][t[3]] -= n
            } else if (r == 3) {
                e[t[0]][t[1]][t[2]][t[3]] *= n
            } else if (r == 4) {
                e[t[0]][t[1]][t[2]][t[3]] /= n
            }
        }
        return true
    };
    t.Group.prototype.set = function(e, t, n, r, i, s, o) {
        if (typeof o === "undefined") {
            o = false
        }
        t = t.split(".");
        if (typeof r === "undefined") {
            r = false
        }
        if (typeof i === "undefined") {
            i = false
        }
        if ((r === false || r && e.alive) && (i === false || i && e.visible)) {
            return this.setProperty(e, t, n, s, o)
        }
    };
    t.Group.prototype.setAll = function(e, t, n, r, i, s) {
        if (typeof n === "undefined") {
            n = false
        }
        if (typeof r === "undefined") {
            r = false
        }
        if (typeof s === "undefined") {
            s = false
        }
        e = e.split(".");
        i = i || 0;
        for (var o = 0, u = this.children.length; o < u; o++) {
            if ((!n || n && this.children[o].alive) && (!r || r && this.children[o].visible)) {
                this.setProperty(this.children[o], e, t, i, s)
            }
        }
    };
    t.Group.prototype.setAllChildren = function(e, n, r, i, s, o) {
        if (typeof r === "undefined") {
            r = false
        }
        if (typeof i === "undefined") {
            i = false
        }
        if (typeof o === "undefined") {
            o = false
        }
        s = s || 0;
        for (var u = 0, a = this.children.length; u < a; u++) {
            if ((!r || r && this.children[u].alive) && (!i || i && this.children[u].visible)) {
                if (this.children[u] instanceof t.Group) {
                    this.children[u].setAllChildren(e, n, r, i, s, o)
                } else {
                    this.setProperty(this.children[u], e.split("."), n, s, o)
                }
            }
        }
    };
    t.Group.prototype.addAll = function(e, t, n, r) {
        this.setAll(e, t, n, r, 1)
    };
    t.Group.prototype.subAll = function(e, t, n, r) {
        this.setAll(e, t, n, r, 2)
    };
    t.Group.prototype.multiplyAll = function(e, t, n, r) {
        this.setAll(e, t, n, r, 3)
    };
    t.Group.prototype.divideAll = function(e, t, n, r) {
        this.setAll(e, t, n, r, 4)
    };
    t.Group.prototype.callAllExists = function(e, t) {
        var n = Array.prototype.splice.call(arguments, 2);
        for (var r = 0, i = this.children.length; r < i; r++) {
            if (this.children[r].exists === t && this.children[r][e]) {
                this.children[r][e].apply(this.children[r], n)
            }
        }
    };
    t.Group.prototype.callbackFromArray = function(e, t, n) {
        if (n == 1) {
            if (e[t[0]]) {
                return e[t[0]]
            }
        } else if (n == 2) {
            if (e[t[0]][t[1]]) {
                return e[t[0]][t[1]]
            }
        } else if (n == 3) {
            if (e[t[0]][t[1]][t[2]]) {
                return e[t[0]][t[1]][t[2]]
            }
        } else if (n == 4) {
            if (e[t[0]][t[1]][t[2]][t[3]]) {
                return e[t[0]][t[1]][t[2]][t[3]]
            }
        } else {
            if (e[t]) {
                return e[t]
            }
        }
        return false
    };
    t.Group.prototype.callAll = function(e, t) {
        if (typeof e === "undefined") {
            return
        }
        e = e.split(".");
        var n = e.length;
        if (typeof t === "undefined" || t === null || t === "") {
            t = null
        } else {
            if (typeof t === "string") {
                t = t.split(".");
                var r = t.length
            }
        }
        var i = Array.prototype.splice.call(arguments, 2);
        var s = null;
        var o = null;
        for (var u = 0, a = this.children.length; u < a; u++) {
            s = this.callbackFromArray(this.children[u], e, n);
            if (t && s) {
                o = this.callbackFromArray(this.children[u], t, r);
                if (s) {
                    s.apply(o, i)
                }
            } else if (s) {
                s.apply(this.children[u], i)
            }
        }
    };
    t.Group.prototype.preUpdate = function() {
        if (!this.exists || !this.parent.exists) {
            this.renderOrderID = -1;
            return false
        }
        var e = this.children.length;
        while (e--) {
            this.children[e].preUpdate()
        }
        return true
    };
    t.Group.prototype.update = function() {
        var e = this.children.length;
        while (e--) {
            this.children[e].update()
        }
    };
    t.Group.prototype.postUpdate = function() {
        if (this._cache[7] === 1) {
            this.x = this.game.camera.view.x + this.cameraOffset.x;
            this.y = this.game.camera.view.y + this.cameraOffset.y
        }
        var e = this.children.length;
        while (e--) {
            this.children[e].postUpdate()
        }
    };
    t.Group.prototype.forEach = function(e, t, n) {
        if (typeof n === "undefined") {
            n = false
        }
        var r = Array.prototype.splice.call(arguments, 3);
        r.unshift(null);
        for (var i = 0, s = this.children.length; i < s; i++) {
            if (!n || n && this.children[i].exists) {
                r[0] = this.children[i];
                e.apply(t, r)
            }
        }
    };
    t.Group.prototype.forEachExists = function(e, n) {
        var r = Array.prototype.splice.call(arguments, 2);
        r.unshift(null);
        this.iterate("exists", true, t.Group.RETURN_TOTAL, e, n, r)
    };
    t.Group.prototype.forEachAlive = function(e, n) {
        var r = Array.prototype.splice.call(arguments, 2);
        r.unshift(null);
        this.iterate("alive", true, t.Group.RETURN_TOTAL, e, n, r)
    };
    t.Group.prototype.forEachDead = function(e, n) {
        var r = Array.prototype.splice.call(arguments, 2);
        r.unshift(null);
        this.iterate("alive", false, t.Group.RETURN_TOTAL, e, n, r)
    };
    t.Group.prototype.sort = function(e, n) {
        if (this.children.length < 2) {
            return
        }
        if (typeof e === "undefined") {
            e = "z"
        }
        if (typeof n === "undefined") {
            n = t.Group.SORT_ASCENDING
        }
        this._sortProperty = e;
        if (n === t.Group.SORT_ASCENDING) {
            this.children.sort(this.ascendingSortHandler.bind(this))
        } else {
            this.children.sort(this.descendingSortHandler.bind(this))
        }
        this.updateZ()
    };
    t.Group.prototype.customSort = function(e, t) {
        if (this.children.length < 2) {
            return
        }
        this.children.sort(e.bind(t));
        this.updateZ()
    };
    t.Group.prototype.ascendingSortHandler = function(e, t) {
        if (e[this._sortProperty] < t[this._sortProperty]) {
            return -1
        } else if (e[this._sortProperty] > t[this._sortProperty]) {
            return 1
        } else {
            if (e.z < t.z) {
                return -1
            } else {
                return 1
            }
        }
    };
    t.Group.prototype.descendingSortHandler = function(e, t) {
        if (e[this._sortProperty] < t[this._sortProperty]) {
            return 1
        } else if (e[this._sortProperty] > t[this._sortProperty]) {
            return -1
        } else {
            return 0
        }
    };
    t.Group.prototype.iterate = function(e, n, r, i, s, o) {
        if (r === t.Group.RETURN_TOTAL && this.children.length === 0) {
            return 0
        }
        if (typeof i === "undefined") {
            i = false
        }
        var u = 0;
        for (var a = 0, f = this.children.length; a < f; a++) {
            if (this.children[a][e] === n) {
                u++;
                if (i) {
                    o[0] = this.children[a];
                    i.apply(s, o)
                }
                if (r === t.Group.RETURN_CHILD) {
                    return this.children[a]
                }
            }
        }
        if (r === t.Group.RETURN_TOTAL) {
            return u
        } else if (r === t.Group.RETURN_CHILD) {
            return null
        }
    };
    t.Group.prototype.getFirstExists = function(e) {
        if (typeof e !== "boolean") {
            e = true
        }
        return this.iterate("exists", e, t.Group.RETURN_CHILD)
    };
    t.Group.prototype.getFirstAlive = function() {
        return this.iterate("alive", true, t.Group.RETURN_CHILD)
    };
    t.Group.prototype.getFirstDead = function() {
        return this.iterate("alive", false, t.Group.RETURN_CHILD)
    };
    t.Group.prototype.getTop = function() {
        if (this.children.length > 0) {
            return this.children[this.children.length - 1]
        }
    };
    t.Group.prototype.getBottom = function() {
        if (this.children.length > 0) {
            return this.children[0]
        }
    };
    t.Group.prototype.countLiving = function() {
        return this.iterate("alive", true, t.Group.RETURN_TOTAL)
    };
    t.Group.prototype.countDead = function() {
        return this.iterate("alive", false, t.Group.RETURN_TOTAL)
    };
    t.Group.prototype.getRandom = function(e, t) {
        if (this.children.length === 0) {
            return null
        }
        e = e || 0;
        t = t || this.children.length;
        return this.game.math.getRandom(this.children, e, t)
    };
    t.Group.prototype.remove = function(e, t) {
        if (typeof t === "undefined") {
            t = false
        }
        if (this.children.length === 0 || this.children.indexOf(e) === -1) {
            return false
        }
        if (e.events && !e.destroyPhase) {
            e.events.onRemovedFromGroup.dispatch(e, this)
        }
        var n = this.removeChild(e);
        this.updateZ();
        if (this.cursor === e) {
            this.next()
        }
        if (t && n) {
            n.destroy(true)
        }
        return true
    };
    t.Group.prototype.removeAll = function(e) {
        if (typeof e === "undefined") {
            e = false
        }
        if (this.children.length === 0) {
            return
        }
        do {
            if (this.children[0].events) {
                this.children[0].events.onRemovedFromGroup.dispatch(this.children[0], this)
            }
            var t = this.removeChild(this.children[0]);
            if (e && t) {
                t.destroy(true)
            }
        } while (this.children.length > 0);
        this.cursor = null
    };
    t.Group.prototype.removeBetween = function(e, t, n) {
        if (typeof t === "undefined") {
            t = this.children.length
        }
        if (typeof n === "undefined") {
            n = false
        }
        if (this.children.length === 0) {
            return
        }
        if (e > t || e < 0 || t > this.children.length) {
            return false
        }
        var r = t;
        while (r >= e) {
            if (this.children[r].events) {
                this.children[r].events.onRemovedFromGroup.dispatch(this.children[r], this)
            }
            var i = this.removeChild(this.children[r]);
            if (n && i) {
                i.destroy(true)
            }
            if (this.cursor === this.children[r]) {
                this.cursor = null
            }
            r--
        }
        this.updateZ()
    };
    t.Group.prototype.destroy = function(e, t) {
        if (this.game === null) {
            return
        }
        if (typeof e === "undefined") {
            e = true
        }
        if (typeof t === "undefined") {
            t = false
        }
        this.removeAll(e);
        this.cursor = null;
        if (!t) {
            if (this.parent) {
                this.parent.removeChild(this)
            }
            this.game = null;
            this.exists = false
        }
    };
    Object.defineProperty(t.Group.prototype, "total", {
        get: function() {
            return this.iterate("exists", true, t.Group.RETURN_TOTAL)
        }
    });
    Object.defineProperty(t.Group.prototype, "length", {
        get: function() {
            return this.children.length
        }
    });
    Object.defineProperty(t.Group.prototype, "angle", {
        get: function() {
            return t.Math.radToDeg(this.rotation)
        },
        set: function(e) {
            this.rotation = t.Math.degToRad(e)
        }
    });
    Object.defineProperty(t.Group.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7]
        },
        set: function(e) {
            if (e) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y)
            } else {
                this._cache[7] = 0
            }
        }
    });
    t.World = function(e) {
        t.Group.call(this, e, null, "__world", false);
        this.bounds = new t.Rectangle(0, 0, e.width, e.height);
        this.camera = null
    };
    t.World.prototype = Object.create(t.Group.prototype);
    t.World.prototype.constructor = t.World;
    t.World.prototype.boot = function() {
        this.camera = new t.Camera(this.game, 0, 0, 0, this.game.width, this.game.height);
        this.camera.displayObject = this;
        this.camera.scale = this.scale;
        this.game.camera = this.camera;
        this.game.stage.addChild(this)
    };
    t.World.prototype.setBounds = function(e, t, n, r) {
        if (n < this.game.width) {
            n = this.game.width
        }
        if (r < this.game.height) {
            r = this.game.height
        }
        this.bounds.setTo(e, t, n, r);
        if (this.camera.bounds) {
            this.camera.bounds.setTo(e, t, n, r)
        }
        this.game.physics.setBoundsToWorld()
    };
    t.World.prototype.shutdown = function() {
        this.destroy(true, true)
    };
    t.World.prototype.wrap = function(e, t, n) {
        if (typeof t === "undefined") {
            t = 0
        }
        if (typeof n === "undefined") {
            n = false
        }
        if (!n) {
            if (e.x + t < this.bounds.x) {
                e.x = this.bounds.right + t
            } else if (e.x - t > this.bounds.right) {
                e.x = this.bounds.left - t
            }
            if (e.y + t < this.bounds.top) {
                e.y = this.bounds.bottom + t
            } else if (e.y - t > this.bounds.bottom) {
                e.y = this.bounds.top - t
            }
        } else {
            e.getBounds();
            if (e._currentBounds.right < this.bounds.x) {
                e.x = this.bounds.right
            } else if (e._currentBounds.x > this.bounds.right) {
                e.x = this.bounds.left
            }
            if (e._currentBounds.bottom < this.bounds.top) {
                e.y = this.bounds.bottom
            } else if (e._currentBounds.top > this.bounds.bottom) {
                e.y = this.bounds.top
            }
        }
    };
    Object.defineProperty(t.World.prototype, "width", {
        get: function() {
            return this.bounds.width
        },
        set: function(e) {
            this.bounds.width = e
        }
    });
    Object.defineProperty(t.World.prototype, "height", {
        get: function() {
            return this.bounds.height
        },
        set: function(e) {
            this.bounds.height = e
        }
    });
    Object.defineProperty(t.World.prototype, "centerX", {
        get: function() {
            return this.bounds.halfWidth
        }
    });
    Object.defineProperty(t.World.prototype, "centerY", {
        get: function() {
            return this.bounds.halfHeight
        }
    });
    Object.defineProperty(t.World.prototype, "randomX", {
        get: function() {
            if (this.bounds.x < 0) {
                return this.game.rnd.integerInRange(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x))
            } else {
                return this.game.rnd.integerInRange(this.bounds.x, this.bounds.width)
            }
        }
    });
    Object.defineProperty(t.World.prototype, "randomY", {
        get: function() {
            if (this.bounds.y < 0) {
                return this.game.rnd.integerInRange(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y))
            } else {
                return this.game.rnd.integerInRange(this.bounds.y, this.bounds.height)
            }
        }
    });
    t.ScaleManager = function(e, n, r) {
        this.game = e;
        this.width = n;
        this.height = r;
        this.minWidth = null;
        this.maxWidth = null;
        this.minHeight = null;
        this.maxHeight = null;
        this.forceLandscape = false;
        this.forcePortrait = false;
        this.incorrectOrientation = false;
        this.pageAlignHorizontally = false;
        this.pageAlignVertically = false;
        this.maxIterations = 5;
        this.orientationSprite = null;
        this.enterLandscape = new t.Signal;
        this.enterPortrait = new t.Signal;
        this.enterIncorrectOrientation = new t.Signal;
        this.leaveIncorrectOrientation = new t.Signal;
        this.hasResized = new t.Signal;
        this.fullScreenTarget = this.game.canvas;
        this.enterFullScreen = new t.Signal;
        this.leaveFullScreen = new t.Signal;
        this.orientation = 0;
        if (window["orientation"]) {
            this.orientation = window["orientation"]
        } else {
            if (window.outerWidth > window.outerHeight) {
                this.orientation = 90
            }
        }
        this.scaleFactor = new t.Point(1, 1);
        this.scaleFactorInversed = new t.Point(1, 1);
        this.margin = new t.Point(0, 0);
        this.bounds = new t.Rectangle(0, 0, n, r);
        this.aspectRatio = 0;
        this.sourceAspectRatio = n / r;
        this.event = null;
        this.scaleMode = t.ScaleManager.NO_SCALE;
        this.fullScreenScaleMode = t.ScaleManager.NO_SCALE;
        this._startHeight = 0;
        this._width = 0;
        this._height = 0;
        this._check = null;
        var i = this;
        window.addEventListener("orientationchange", function(e) {
            return i.checkOrientation(e)
        }, false);
        window.addEventListener("resize", function(e) {
            return i.checkResize(e)
        }, false);
        document.addEventListener("webkitfullscreenchange", function(e) {
            return i.fullScreenChange(e)
        }, false);
        document.addEventListener("mozfullscreenchange", function(e) {
            return i.fullScreenChange(e)
        }, false);
        document.addEventListener("fullscreenchange", function(e) {
            return i.fullScreenChange(e)
        }, false)
    };
    t.ScaleManager.EXACT_FIT = 0;
    t.ScaleManager.NO_SCALE = 1;
    t.ScaleManager.SHOW_ALL = 2;
    t.ScaleManager.prototype = {
        startFullScreen: function(e) {
            if (this.isFullScreen || !this.game.device.fullscreen) {
                return
            }
            if (typeof e !== "undefined" && this.game.renderType === t.CANVAS) {
                this.game.stage.smoothed = e
            }
            this._width = this.width;
            this._height = this.height;
            if (this.game.device.fullscreenKeyboard) {
                this.fullScreenTarget[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT)
            } else {
                this.fullScreenTarget[this.game.device.requestFullscreen]()
            }
        },
        stopFullScreen: function() {
            this.fullScreenTarget[this.game.device.cancelFullscreen]()
        },
        fullScreenChange: function(e) {
            this.event = e;
            if (this.isFullScreen) {
                if (this.fullScreenScaleMode === t.ScaleManager.EXACT_FIT) {
                    this.fullScreenTarget.style["width"] = "100%";
                    this.fullScreenTarget.style["height"] = "100%";
                    this.width = window.outerWidth;
                    this.height = window.outerHeight;
                    this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height);
                    this.aspectRatio = this.width / this.height;
                    this.scaleFactor.x = this.game.width / this.width;
                    this.scaleFactor.y = this.game.height / this.height;
                    this.checkResize()
                } else if (this.fullScreenScaleMode === t.ScaleManager.SHOW_ALL) {
                    this.setShowAll();
                    this.refresh()
                }
                this.enterFullScreen.dispatch(this.width, this.height)
            } else {
                this.fullScreenTarget.style["width"] = this.game.width + "px";
                this.fullScreenTarget.style["height"] = this.game.height + "px";
                this.width = this._width;
                this.height = this._height;
                this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height);
                this.aspectRatio = this.width / this.height;
                this.scaleFactor.x = this.game.width / this.width;
                this.scaleFactor.y = this.game.height / this.height;
                this.leaveFullScreen.dispatch(this.width, this.height)
            }
        },
        forceOrientation: function(e, n, r) {
            if (typeof n === "undefined") {
                n = false
            }
            this.forceLandscape = e;
            this.forcePortrait = n;
            if (typeof r !== "undefined") {
                if (r === null || this.game.cache.checkImageKey(r) === false) {
                    r = "__default"
                }
                this.orientationSprite = new t.Image(this.game, this.game.width / 2, this.game.height / 2, PIXI.TextureCache[r]);
                this.orientationSprite.anchor.set(.5);
                this.checkOrientationState();
                if (this.incorrectOrientation) {
                    this.orientationSprite.visible = true;
                    this.game.world.visible = false
                } else {
                    this.orientationSprite.visible = false;
                    this.game.world.visible = true
                }
                this.game.stage.addChild(this.orientationSprite)
            }
        },
        checkOrientationState: function() {
            if (this.incorrectOrientation) {
                if (this.forceLandscape && window.innerWidth > window.innerHeight || this.forcePortrait && window.innerHeight > window.innerWidth) {
                    this.incorrectOrientation = false;
                    this.leaveIncorrectOrientation.dispatch();
                    if (this.orientationSprite) {
                        this.orientationSprite.visible = false;
                        this.game.world.visible = true
                    }
                    if (this.scaleMode !== t.ScaleManager.NO_SCALE) {
                        this.refresh()
                    }
                }
            } else {
                if (this.forceLandscape && window.innerWidth < window.innerHeight || this.forcePortrait && window.innerHeight < window.innerWidth) {
                    this.incorrectOrientation = true;
                    this.enterIncorrectOrientation.dispatch();
                    if (this.orientationSprite && this.orientationSprite.visible === false) {
                        this.orientationSprite.visible = true;
                        this.game.world.visible = false
                    }
                    if (this.scaleMode !== t.ScaleManager.NO_SCALE) {
                        this.refresh()
                    }
                }
            }
        },
        checkOrientation: function(e) {
            this.event = e;
            this.orientation = window["orientation"];
            if (this.isLandscape) {
                this.enterLandscape.dispatch(this.orientation, true, false)
            } else {
                this.enterPortrait.dispatch(this.orientation, false, true)
            }
            if (this.scaleMode !== t.ScaleManager.NO_SCALE) {
                this.refresh()
            }
        },
        checkResize: function(e) {
            this.event = e;
            if (window.outerWidth > window.outerHeight) {
                this.orientation = 90
            } else {
                this.orientation = 0
            }
            if (this.isLandscape) {
                this.enterLandscape.dispatch(this.orientation, true, false)
            } else {
                this.enterPortrait.dispatch(this.orientation, false, true)
            }
            if (this.scaleMode !== t.ScaleManager.NO_SCALE) {
                this.refresh()
            }
            this.checkOrientationState()
        },
        refresh: function() {
            if (!this.game.device.iPad && !this.game.device.webApp && !this.game.device.desktop) {
                if (this.game.device.android && !this.game.device.chrome) {
                    window.scrollTo(0, 1)
                } else {
                    window.scrollTo(0, 0)
                }
            }
            if (this._check === null && this.maxIterations > 0) {
                this._iterations = this.maxIterations;
                var e = this;
                this._check = window.setInterval(function() {
                    return e.setScreenSize()
                }, 10);
                this.setScreenSize()
            }
        },
        setScreenSize: function(e) {
            if (typeof e === "undefined") {
                e = false
            }
            if (!this.game.device.iPad && !this.game.device.webApp && !this.game.device.desktop) {
                if (this.game.device.android && !this.game.device.chrome) {
                    window.scrollTo(0, 1)
                } else {
                    window.scrollTo(0, 0)
                }
            }
            this._iterations--;
            if (e || window.innerHeight > this._startHeight || this._iterations < 0) {
                document.documentElement["style"].minHeight = window.innerHeight + "px";
                if (this.incorrectOrientation) {
                    this.setMaximum()
                } else if (!this.isFullScreen) {
                    if (this.scaleMode === t.ScaleManager.EXACT_FIT) {
                        this.setExactFit()
                    } else if (this.scaleMode === t.ScaleManager.SHOW_ALL) {
                        this.setShowAll()
                    }
                } else {
                    if (this.fullScreenScaleMode === t.ScaleManager.EXACT_FIT) {
                        this.setExactFit()
                    } else if (this.fullScreenScaleMode === t.ScaleManager.SHOW_ALL) {
                        this.setShowAll()
                    }
                }
                this.setSize();
                clearInterval(this._check);
                this._check = null
            }
        },
        setSize: function() {
            if (!this.incorrectOrientation) {
                if (this.maxWidth && this.width > this.maxWidth) {
                    this.width = this.maxWidth
                }
                if (this.maxHeight && this.height > this.maxHeight) {
                    this.height = this.maxHeight
                }
                if (this.minWidth && this.width < this.minWidth) {
                    this.width = this.minWidth
                }
                if (this.minHeight && this.height < this.minHeight) {
                    this.height = this.minHeight
                }
            }
            this.game.canvas.style.width = this.width + "px";
            this.game.canvas.style.height = this.height + "px";
            this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height);
            if (this.pageAlignHorizontally) {
                if (this.width < window.innerWidth && !this.incorrectOrientation) {
                    this.margin.x = Math.round((window.innerWidth - this.width) / 2);
                    this.game.canvas.style.marginLeft = this.margin.x + "px"
                } else {
                    this.margin.x = 0;
                    this.game.canvas.style.marginLeft = "0px"
                }
            }
            if (this.pageAlignVertically) {
                if (this.height < window.innerHeight && !this.incorrectOrientation) {
                    this.margin.y = Math.round((window.innerHeight - this.height) / 2);
                    this.game.canvas.style.marginTop = this.margin.y + "px"
                } else {
                    this.margin.y = 0;
                    this.game.canvas.style.marginTop = "0px"
                }
            }
            t.Canvas.getOffset(this.game.canvas, this.game.stage.offset);
            this.bounds.setTo(this.game.stage.offset.x, this.game.stage.offset.y, this.width, this.height);
            this.aspectRatio = this.width / this.height;
            this.scaleFactor.x = this.game.width / this.width;
            this.scaleFactor.y = this.game.height / this.height;
            this.scaleFactorInversed.x = this.width / this.game.width;
            this.scaleFactorInversed.y = this.height / this.game.height;
            this.hasResized.dispatch(this.width, this.height);
            this.checkOrientationState()
        },
        setMaximum: function() {
            this.width = window.innerWidth;
            this.height = window.innerHeight
        },
        setShowAll: function() {
            var e = Math.min(window.innerHeight / this.game.height, window.innerWidth / this.game.width);
            this.width = Math.round(this.game.width * e);
            this.height = Math.round(this.game.height * e)
        },
        setExactFit: function() {
            var e = window.innerWidth;
            var t = window.innerHeight;
            if (this.maxWidth && e > this.maxWidth) {
                this.width = this.maxWidth
            } else {
                this.width = e
            }
            if (this.maxHeight && t > this.maxHeight) {
                this.height = this.maxHeight
            } else {
                this.height = t
            }
        }
    };
    t.ScaleManager.prototype.constructor = t.ScaleManager;
    Object.defineProperty(t.ScaleManager.prototype, "isFullScreen", {
        get: function() {
            return document["fullscreenElement"] || document["mozFullScreenElement"] || document["webkitFullscreenElement"]
        }
    });
    Object.defineProperty(t.ScaleManager.prototype, "isPortrait", {
        get: function() {
            return this.orientation === 0 || this.orientation === 180
        }
    });
    Object.defineProperty(t.ScaleManager.prototype, "isLandscape", {
        get: function() {
            return this.orientation === 90 || this.orientation === -90
        }
    });
    t.Game = function(e, n, r, i, s, o, u, a) {
        this.id = t.GAMES.push(this) - 1;
        this.config = null;
        this.physicsConfig = a;
        this.parent = "";
        this.width = 800;
        this.height = 600;
        this.transparent = false;
        this.antialias = true;
        this.renderer = null;
        this.renderType = t.AUTO;
        this.state = null;
        this.isBooted = false;
        this.isRunning = false;
        this.raf = null;
        this.add = null;
        this.make = null;
        this.cache = null;
        this.input = null;
        this.load = null;
        this.math = null;
        this.net = null;
        this.scale = null;
        this.sound = null;
        this.stage = null;
        this.time = null;
        this.tweens = null;
        this.world = null;
        this.physics = null;
        this.rnd = null;
        this.device = null;
        this.camera = null;
        this.canvas = null;
        this.context = null;
        this.debug = null;
        this.particles = null;
        this.stepping = false;
        this.pendingStep = false;
        this.stepCount = 0;
        this.onPause = null;
        this.onResume = null;
        this.onBlur = null;
        this.onFocus = null;
        this._paused = false;
        this._codePaused = false;
        if (arguments.length === 1 && typeof arguments[0] === "object") {
            this.parseConfig(arguments[0])
        } else {
            if (typeof e !== "undefined") {
                this.width = e
            }
            if (typeof n !== "undefined") {
                this.height = n
            }
            if (typeof r !== "undefined") {
                this.renderer = r;
                this.renderType = r
            }
            if (typeof i !== "undefined") {
                this.parent = i
            }
            if (typeof o !== "undefined") {
                this.transparent = o
            }
            if (typeof u !== "undefined") {
                this.antialias = u
            }
            this.rnd = new t.RandomDataGenerator([(Date.now() * Math.random()).toString()]);
            this.state = new t.StateManager(this, s)
        }
        var f = this;
        this._onBoot = function() {
            return f.boot()
        };
        if (document.readyState === "complete" || document.readyState === "interactive") {
            window.setTimeout(this._onBoot, 0)
        } else {
            document.addEventListener("DOMContentLoaded", this._onBoot, false);
            window.addEventListener("load", this._onBoot, false)
        }
        return this
    };
    t.Game.prototype = {
        parseConfig: function(e) {
            this.config = e;
            if (e["width"]) {
                this.width = t.Utils.parseDimension(e["width"], 0)
            }
            if (e["height"]) {
                this.height = t.Utils.parseDimension(e["height"], 1)
            }
            if (e["renderer"]) {
                this.renderer = e["renderer"];
                this.renderType = e["renderer"]
            }
            if (e["parent"]) {
                this.parent = e["parent"]
            }
            if (e["transparent"]) {
                this.transparent = e["transparent"]
            }
            if (e["antialias"]) {
                this.antialias = e["antialias"]
            }
            if (e["physicsConfig"]) {
                this.physicsConfig = e["physicsConfig"]
            }
            var n = [(Date.now() * Math.random()).toString()];
            if (e["seed"]) {
                n = e["seed"]
            }
            this.rnd = new t.RandomDataGenerator(n);
            var r = null;
            if (e["state"]) {
                r = e["state"]
            }
            this.state = new t.StateManager(this, r)
        },
        boot: function() {
            if (this.isBooted) {
                return
            }
            if (!document.body) {
                window.setTimeout(this._onBoot, 20)
            } else {
                document.removeEventListener("DOMContentLoaded", this._onBoot);
                window.removeEventListener("load", this._onBoot);
                this.onPause = new t.Signal;
                this.onResume = new t.Signal;
                this.onBlur = new t.Signal;
                this.onFocus = new t.Signal;
                this.isBooted = true;
                this.device = new t.Device(this);
                this.math = t.Math;
                this.stage = new t.Stage(this, this.width, this.height);
                this.scale = new t.ScaleManager(this, this.width, this.height);
                this.setUpRenderer();
                this.device.checkFullScreenSupport();
                this.world = new t.World(this);
                this.add = new t.GameObjectFactory(this);
                this.make = new t.GameObjectCreator(this);
                this.cache = new t.Cache(this);
                this.load = new t.Loader(this);
                this.time = new t.Time(this);
                this.tweens = new t.TweenManager(this);
                this.input = new t.Input(this);
                this.sound = new t.SoundManager(this);
                this.physics = new t.Physics(this, this.physicsConfig);
                this.particles = new t.Particles(this);
                this.plugins = new t.PluginManager(this);
                this.net = new t.Net(this);
                this.debug = new t.Utils.Debug(this);
                this.scratch = new t.BitmapData(this, "__root", 1024, 1024);
                this.time.boot();
                this.stage.boot();
                this.world.boot();
                this.input.boot();
                this.sound.boot();
                this.state.boot();
                this.debug.boot();
                this.showDebugHeader();
                this.isRunning = true;
                if (this.config && (this.config["forceSetTimeOut"] || this.device.android)) {
                    this.raf = new t.RequestAnimationFrame(this, this.config["forceSetTimeOut"] || this.device.android)
                } else {
                    this.raf = new t.RequestAnimationFrame(this, false)
                }
                this.raf.start()
            }
        },
        showDebugHeader: function() {
            var e = t.VERSION;
            var n = "Canvas";
            var r = "HTML Audio";
            var i = 1;
            if (this.renderType === t.WEBGL) {
                n = "WebGL";
                i++
            } else if (this.renderType == t.HEADLESS) {
                n = "Headless"
            }
            if (this.device.webAudio) {
                r = "WebAudio";
                i++
            }
            if (this.device.chrome) {
                var s = ["%c %c %c Phaser v" + e + " - " + n + " - " + r + "  %c %c " + " http://phaser.io  %c %c ♥%c♥%c♥ ", "background: #0cf300", "background: #00bc17", "color: #ffffff; background: #00711f;", "background: #00bc17", "background: #0cf300", "background: #00bc17"];
                for (var o = 0; o < 3; o++) {
                    if (o < i) {
                        s.push("color: #ff2424; background: #fff")
                    } else {
                        s.push("color: #959595; background: #fff")
                    }
                }
                console.log.apply(console, s)
            } else if (window["console"]) {
                console.log("Phaser v" + e + " - Renderer: " + n + " - Audio: " + r + " - http://phaser.io")
            }
        },
        setUpRenderer: function() {
            if (this.device.trident) {
                this.renderType = t.CANVAS
            }
            if (this.renderType === t.HEADLESS || this.renderType === t.CANVAS || this.renderType === t.AUTO && this.device.webGL === false) {
                if (this.device.canvas) {
                    if (this.renderType === t.AUTO) {
                        this.renderType = t.CANVAS
                    }
                    this.renderer = new PIXI.CanvasRenderer(this.width, this.height, this.canvas, this.transparent);
                    this.context = this.renderer.context
                } else {
                    throw new Error("Phaser.Game - cannot create Canvas or WebGL context, aborting.")
                }
            } else {
                this.renderType = t.WEBGL;
                this.renderer = new PIXI.WebGLRenderer(this.width, this.height, this.canvas, this.transparent, this.antialias);
                this.context = null
            }
            if (this.renderType !== t.HEADLESS) {
                this.stage.smoothed = this.antialias;
                t.Canvas.addToDOM(this.canvas, this.parent, true);
                t.Canvas.setTouchAction(this.canvas)
            }
        },
        update: function(e) {
            this.time.update(e);
            if (!this._paused && !this.pendingStep) {
                if (this.stepping) {
                    this.pendingStep = true
                }
                this.debug.preUpdate();
                this.physics.preUpdate();
                this.state.preUpdate();
                this.plugins.preUpdate();
                this.stage.preUpdate();
                this.state.update();
                this.stage.update();
                this.tweens.update();
                this.sound.update();
                this.input.update();
                this.physics.update();
                this.particles.update();
                this.plugins.update();
                this.stage.postUpdate();
                this.plugins.postUpdate()
            } else {
                this.state.pauseUpdate();
                this.debug.preUpdate()
            }
            if (this.renderType != t.HEADLESS) {
                this.renderer.render(this.stage);
                this.plugins.render();
                this.state.render();
                this.plugins.postRender()
            }
        },
        enableStep: function() {
            this.stepping = true;
            this.pendingStep = false;
            this.stepCount = 0
        },
        disableStep: function() {
            this.stepping = false;
            this.pendingStep = false
        },
        step: function() {
            this.pendingStep = false;
            this.stepCount++
        },
        destroy: function() {
            this.raf.stop();
            this.input.destroy();
            this.state.destroy();
            this.physics.destroy();
            this.state = null;
            this.cache = null;
            this.input = null;
            this.load = null;
            this.sound = null;
            this.stage = null;
            this.time = null;
            this.world = null;
            this.isBooted = false
        },
        gamePaused: function(e) {
            if (!this._paused) {
                this._paused = true;
                this.time.gamePaused();
                this.sound.mute = true;
                this.onPause.dispatch(e)
            }
        },
        gameResumed: function(e) {
            if (this._paused && !this._codePaused) {
                this._paused = false;
                this.time.gameResumed();
                this.input.reset();
                this.sound.mute = !soundEnabled;
                this.onResume.dispatch(e)
            }
        },
        focusLoss: function(e) {
            this.onBlur.dispatch(e);
            this.gamePaused(e)
        },
        focusGain: function(e) {
            this.onFocus.dispatch(e);
            this.gameResumed(e)
        }
    };
    t.Game.prototype.constructor = t.Game;
    Object.defineProperty(t.Game.prototype, "paused", {
        get: function() {
            return this._paused
        },
        set: function(e) {
            if (e === true) {
                if (this._paused === false) {
                    this._paused = true;
                    this._codePaused = true;
                    this.sound.setMute();
                    this.time.gamePaused();
                    this.onPause.dispatch(this)
                }
            } else {
                if (this._paused) {
                    this._paused = false;
                    this._codePaused = false;
                    this.input.reset();
                    this.sound.unsetMute();
                    this.time.gameResumed();
                    this.onResume.dispatch(this)
                }
            }
        }
    });
    t.Input = function(e) {
        this.game = e;
        this.hitCanvas = null;
        this.hitContext = null;
        this.moveCallbacks = [];
        this.moveCallback = null;
        this.moveCallbackContext = this;
        this.pollRate = 0;
        this.disabled = false;
        this.multiInputOverride = t.Input.MOUSE_TOUCH_COMBINE;
        this.position = null;
        this.speed = null;
        this.circle = null;
        this.scale = null;
        this.maxPointers = 10;
        this.currentPointers = 0;
        this.tapRate = 200;
        this.doubleTapRate = 300;
        this.holdRate = 2e3;
        this.justPressedRate = 200;
        this.justReleasedRate = 200;
        this.recordPointerHistory = false;
        this.recordRate = 100;
        this.recordLimit = 100;
        this.pointer1 = null;
        this.pointer2 = null;
        this.pointer3 = null;
        this.pointer4 = null;
        this.pointer5 = null;
        this.pointer6 = null;
        this.pointer7 = null;
        this.pointer8 = null;
        this.pointer9 = null;
        this.pointer10 = null;
        this.activePointer = null;
        this.mousePointer = null;
        this.mouse = null;
        this.keyboard = null;
        this.touch = null;
        this.mspointer = null;
        this.gamepad = null;
        this.resetLocked = false;
        this.onDown = null;
        this.onUp = null;
        this.onTap = null;
        this.onHold = null;
        this.minPriorityID = 0;
        this.interactiveItems = new t.ArrayList;
        this._localPoint = new t.Point;
        this._pollCounter = 0;
        this._oldPosition = null;
        this._x = 0;
        this._y = 0
    };
    t.Input.MOUSE_OVERRIDES_TOUCH = 0;
    t.Input.TOUCH_OVERRIDES_MOUSE = 1;
    t.Input.MOUSE_TOUCH_COMBINE = 2;
    t.Input.prototype = {
        boot: function() {
            this.mousePointer = new t.Pointer(this.game, 0);
            this.pointer1 = new t.Pointer(this.game, 1);
            this.pointer2 = new t.Pointer(this.game, 2);
            this.mouse = new t.Mouse(this.game);
            this.keyboard = new t.Keyboard(this.game);
            this.touch = new t.Touch(this.game);
            this.mspointer = new t.MSPointer(this.game);
            this.gamepad = new t.Gamepad(this.game);
            this.onDown = new t.Signal;
            this.onUp = new t.Signal;
            this.onTap = new t.Signal;
            this.onHold = new t.Signal;
            this.scale = new t.Point(1, 1);
            this.speed = new t.Point;
            this.position = new t.Point;
            this._oldPosition = new t.Point;
            this.circle = new t.Circle(0, 0, 44);
            this.activePointer = this.mousePointer;
            this.currentPointers = 0;
            this.hitCanvas = document.createElement("canvas");
            this.hitCanvas.width = 1;
            this.hitCanvas.height = 1;
            this.hitContext = this.hitCanvas.getContext("2d");
            this.mouse.start();
            this.keyboard.start();
            this.touch.start();
            this.mspointer.start();
            this.mousePointer.active = true
        },
        destroy: function() {
            this.mouse.stop();
            this.keyboard.stop();
            this.touch.stop();
            this.mspointer.stop();
            this.gamepad.stop();
            this.moveCallbacks = [];
            this.moveCallback = null
        },
        setMoveCallback: function(e, t) {
            this.moveCallback = e;
            this.moveCallbackContext = t
        },
        addMoveCallback: function(e, t) {
            return this.moveCallbacks.push({
                callback: e,
                context: t
            }) - 1
        },
        deleteMoveCallback: function(e) {
            if (this.moveCallbacks[e]) {
                this.moveCallbacks.splice(e, 1)
            }
        },
        addPointer: function() {
            var e = 0;
            for (var n = 10; n > 0; n--) {
                if (this["pointer" + n] === null) {
                    e = n
                }
            }
            if (e === 0) {
                console.warn("You can only have 10 Pointer objects");
                return null
            } else {
                this["pointer" + e] = new t.Pointer(this.game, e);
                return this["pointer" + e]
            }
        },
        update: function() {
            this.keyboard.update();
            if (this.pollRate > 0 && this._pollCounter < this.pollRate) {
                this._pollCounter++;
                return
            }
            this.speed.x = this.position.x - this._oldPosition.x;
            this.speed.y = this.position.y - this._oldPosition.y;
            this._oldPosition.copyFrom(this.position);
            this.mousePointer.update();
            if (this.gamepad.active) {
                this.gamepad.update()
            }
            this.pointer1.update();
            this.pointer2.update();
            if (this.pointer3) {
                this.pointer3.update()
            }
            if (this.pointer4) {
                this.pointer4.update()
            }
            if (this.pointer5) {
                this.pointer5.update()
            }
            if (this.pointer6) {
                this.pointer6.update()
            }
            if (this.pointer7) {
                this.pointer7.update()
            }
            if (this.pointer8) {
                this.pointer8.update()
            }
            if (this.pointer9) {
                this.pointer9.update()
            }
            if (this.pointer10) {
                this.pointer10.update()
            }
            this._pollCounter = 0
        },
        reset: function(e) {
            if (!this.game.isBooted || this.resetLocked) {
                return
            }
            if (typeof e === "undefined") {
                e = false
            }
            this.keyboard.reset(e);
            this.mousePointer.reset();
            this.gamepad.reset();
            for (var n = 1; n <= 10; n++) {
                if (this["pointer" + n]) {
                    this["pointer" + n].reset()
                }
            }
            this.currentPointers = 0;
            if (this.game.canvas.style.cursor !== "none") {
                this.game.canvas.style.cursor = "inherit"
            }
            if (e) {
                this.onDown.dispose();
                this.onUp.dispose();
                this.onTap.dispose();
                this.onHold.dispose();
                this.onDown = new t.Signal;
                this.onUp = new t.Signal;
                this.onTap = new t.Signal;
                this.onHold = new t.Signal;
                this.moveCallbacks = []
            }
            this._pollCounter = 0
        },
        resetSpeed: function(e, t) {
            this._oldPosition.setTo(e, t);
            this.speed.setTo(0, 0)
        },
        startPointer: function(e) {
            if (this.maxPointers < 10 && this.totalActivePointers == this.maxPointers) {
                return null
            }
            if (this.pointer1.active === false) {
                return this.pointer1.start(e)
            } else if (this.pointer2.active === false) {
                return this.pointer2.start(e)
            } else {
                for (var t = 3; t <= 10; t++) {
                    if (this["pointer" + t] && this["pointer" + t].active === false) {
                        return this["pointer" + t].start(e)
                    }
                }
            }
            return null
        },
        updatePointer: function(e) {
            if (this.pointer1.active && this.pointer1.identifier == e.identifier) {
                return this.pointer1.move(e)
            } else if (this.pointer2.active && this.pointer2.identifier == e.identifier) {
                return this.pointer2.move(e)
            } else {
                for (var t = 3; t <= 10; t++) {
                    if (this["pointer" + t] && this["pointer" + t].active && this["pointer" + t].identifier == e.identifier) {
                        return this["pointer" + t].move(e)
                    }
                }
            }
            return null
        },
        stopPointer: function(e) {
            if (this.pointer1.active && this.pointer1.identifier == e.identifier) {
                return this.pointer1.stop(e)
            } else if (this.pointer2.active && this.pointer2.identifier == e.identifier) {
                return this.pointer2.stop(e)
            } else {
                for (var t = 3; t <= 10; t++) {
                    if (this["pointer" + t] && this["pointer" + t].active && this["pointer" + t].identifier == e.identifier) {
                        return this["pointer" + t].stop(e)
                    }
                }
            }
            return null
        },
        getPointer: function(e) {
            e = e || false;
            if (this.pointer1.active == e) {
                return this.pointer1
            } else if (this.pointer2.active == e) {
                return this.pointer2
            } else {
                for (var t = 3; t <= 10; t++) {
                    if (this["pointer" + t] && this["pointer" + t].active == e) {
                        return this["pointer" + t]
                    }
                }
            }
            return null
        },
        getPointerFromIdentifier: function(e) {
            if (this.pointer1.identifier === e) {
                return this.pointer1
            } else if (this.pointer2.identifier === e) {
                return this.pointer2
            } else {
                for (var t = 3; t <= 10; t++) {
                    if (this["pointer" + t] && this["pointer" + t].identifier === e) {
                        return this["pointer" + t]
                    }
                }
            }
            return null
        },
        getPointerFromId: function(e) {
            if (this.pointer1.pointerId === e) {
                return this.pointer1
            } else if (this.pointer2.pointerId === e) {
                return this.pointer2
            } else {
                for (var t = 3; t <= 10; t++) {
                    if (this["pointer" + t] && this["pointer" + t].pointerId === e) {
                        return this["pointer" + t]
                    }
                }
            }
            return null
        },
        getLocalPosition: function(e, n, r) {
            if (typeof r === "undefined") {
                r = new t.Point
            }
            var i = e.worldTransform;
            var s = 1 / (i.a * i.d + i.b * -i.c);
            return r.setTo(i.d * s * n.x + -i.b * s * n.y + (i.ty * i.b - i.tx * i.d) * s, i.a * s * n.y + -i.c * s * n.x + (-i.ty * i.a + i.tx * i.c) * s)
        },
        hitTest: function(e, n, r) {
            if (!e.worldVisible) {
                return false
            }
            this.getLocalPosition(e, n, this._localPoint);
            r.copyFrom(this._localPoint);
            if (e.hitArea && e.hitArea.contains) {
                if (e.hitArea.contains(this._localPoint.x, this._localPoint.y)) {
                    return true
                }
                return false
            } else if (e instanceof t.TileSprite) {
                var i = e.width;
                var s = e.height;
                var o = -i * e.anchor.x;
                if (this._localPoint.x > o && this._localPoint.x < o + i) {
                    var u = -s * e.anchor.y;
                    if (this._localPoint.y > u && this._localPoint.y < u + s) {
                        return true
                    }
                }
            } else if (e instanceof PIXI.Sprite) {
                var i = e.texture.frame.width;
                var s = e.texture.frame.height;
                var o = -i * e.anchor.x;
                if (this._localPoint.x > o && this._localPoint.x < o + i) {
                    var u = -s * e.anchor.y;
                    if (this._localPoint.y > u && this._localPoint.y < u + s) {
                        return true
                    }
                }
            }
            for (var a = 0, f = e.children.length; a < f; a++) {
                if (this.hitTest(e.children[a], n, r)) {
                    return true
                }
            }
            return false
        }
    };
    t.Input.prototype.constructor = t.Input;
    Object.defineProperty(t.Input.prototype, "x", {
        get: function() {
            return this._x
        },
        set: function(e) {
            this._x = Math.floor(e)
        }
    });
    Object.defineProperty(t.Input.prototype, "y", {
        get: function() {
            return this._y
        },
        set: function(e) {
            this._y = Math.floor(e)
        }
    });
    Object.defineProperty(t.Input.prototype, "pollLocked", {
        get: function() {
            return this.pollRate > 0 && this._pollCounter < this.pollRate
        }
    });
    Object.defineProperty(t.Input.prototype, "totalInactivePointers", {
        get: function() {
            return 10 - this.currentPointers
        }
    });
    Object.defineProperty(t.Input.prototype, "totalActivePointers", {
        get: function() {
            this.currentPointers = 0;
            for (var e = 1; e <= 10; e++) {
                if (this["pointer" + e] && this["pointer" + e].active) {
                    this.currentPointers++
                }
            }
            return this.currentPointers
        }
    });
    Object.defineProperty(t.Input.prototype, "worldX", {
        get: function() {
            return this.game.camera.view.x + this.x
        }
    });
    Object.defineProperty(t.Input.prototype, "worldY", {
        get: function() {
            return this.game.camera.view.y + this.y
        }
    });
    t.Key = function(e, n) {
        this.game = e;
        this.enabled = true;
        this.event = null;
        this.isDown = false;
        this.isUp = true;
        this.altKey = false;
        this.ctrlKey = false;
        this.shiftKey = false;
        this.timeDown = 0;
        this.duration = 0;
        this.timeUp = -2500;
        this.repeats = 0;
        this.keyCode = n;
        this.onDown = new t.Signal;
        this.onHoldCallback = null;
        this.onHoldContext = null;
        this.onUp = new t.Signal
    };
    t.Key.prototype = {
        update: function() {
            if (!this.enabled) {
                return
            }
            if (this.isDown) {
                this.duration = this.game.time.now - this.timeDown;
                this.repeats++;
                if (this.onHoldCallback) {
                    this.onHoldCallback.call(this.onHoldContext, this)
                }
            }
        },
        processKeyDown: function(e) {
            if (!this.enabled) {
                return
            }
            this.event = e;
            if (this.isDown) {
                return
            }
            this.altKey = e.altKey;
            this.ctrlKey = e.ctrlKey;
            this.shiftKey = e.shiftKey;
            this.isDown = true;
            this.isUp = false;
            this.timeDown = this.game.time.now;
            this.duration = 0;
            this.repeats = 0;
            this.onDown.dispatch(this)
        },
        processKeyUp: function(e) {
            if (!this.enabled) {
                return
            }
            this.event = e;
            if (this.isUp) {
                return
            }
            this.isDown = false;
            this.isUp = true;
            this.timeUp = this.game.time.now;
            this.duration = this.game.time.now - this.timeDown;
            this.onUp.dispatch(this)
        },
        reset: function(e) {
            if (typeof e === "undefined") {
                e = true
            }
            this.isDown = false;
            this.isUp = true;
            this.timeUp = this.game.time.now;
            this.duration = this.game.time.now - this.timeDown;
            this.enabled = true;
            if (e) {
                this.onDown.removeAll();
                this.onUp.removeAll();
                this.onHoldCallback = null;
                this.onHoldContext = null
            }
        },
        justPressed: function(e) {
            if (typeof e === "undefined") {
                e = 50
            }
            return this.isDown && this.duration < e
        },
        justReleased: function(e) {
            if (typeof e === "undefined") {
                e = 50
            }
            return !this.isDown && this.game.time.now - this.timeUp < e
        }
    };
    t.Key.prototype.constructor = t.Key;
    t.Keyboard = function(e) {
        this.game = e;
        this.disabled = false;
        this.event = null;
        this.callbackContext = this;
        this.onDownCallback = null;
        this.onUpCallback = null;
        this._keys = [];
        this._capture = [];
        this._onKeyDown = null;
        this._onKeyUp = null;
        this._i = 0
    };
    t.Keyboard.prototype = {
        addCallbacks: function(e, t, n) {
            this.callbackContext = e;
            this.onDownCallback = t;
            if (typeof n !== "undefined") {
                this.onUpCallback = n
            }
        },
        addKey: function(e) {
            if (!this._keys[e]) {
                this._keys[e] = new t.Key(this.game, e);
                this.addKeyCapture(e)
            }
            return this._keys[e]
        },
        removeKey: function(e) {
            if (this._keys[e]) {
                this._keys[e] = null;
                this.removeKeyCapture(e)
            }
        },
        createCursorKeys: function() {
            return {
                up: this.addKey(t.Keyboard.UP),
                down: this.addKey(t.Keyboard.DOWN),
                left: this.addKey(t.Keyboard.LEFT),
                right: this.addKey(t.Keyboard.RIGHT)
            }
        },
        start: function() {
            if (this._onKeyDown !== null) {
                return
            }
            var e = this;
            this._onKeyDown = function(t) {
                return e.processKeyDown(t)
            };
            this._onKeyUp = function(t) {
                return e.processKeyUp(t)
            };
            window.addEventListener("keydown", this._onKeyDown, false);
            window.addEventListener("keyup", this._onKeyUp, false)
        },
        stop: function() {
            window.removeEventListener("keydown", this._onKeyDown);
            window.removeEventListener("keyup", this._onKeyUp);
            this._onKeyDown = null;
            this._onKeyUp = null
        },
        destroy: function() {
            this.stop();
            this.clearCaptures();
            this._keys.length = 0;
            this._i = 0
        },
        addKeyCapture: function(e) {
            if (typeof e === "object") {
                for (var t in e) {
                    this._capture[e[t]] = true
                }
            } else {
                this._capture[e] = true
            }
        },
        removeKeyCapture: function(e) {
            delete this._capture[e]
        },
        clearCaptures: function() {
            this._capture = {}
        },
        update: function() {
            this._i = this._keys.length;
            while (this._i--) {
                if (this._keys[this._i]) {
                    this._keys[this._i].update()
                }
            }
        },
        processKeyDown: function(e) {
            this.event = e;
            if (this.game.input.disabled || this.disabled) {
                return
            }
            if (this._capture[e.keyCode]) {
                e.preventDefault()
            }
            if (this.onDownCallback) {
                this.onDownCallback.call(this.callbackContext, e)
            }
            if (!this._keys[e.keyCode]) {
                this._keys[e.keyCode] = new t.Key(this.game, e.keyCode)
            }
            this._keys[e.keyCode].processKeyDown(e)
        },
        processKeyUp: function(e) {
            this.event = e;
            if (this.game.input.disabled || this.disabled) {
                return
            }
            if (this._capture[e.keyCode]) {
                e.preventDefault()
            }
            if (this.onUpCallback) {
                this.onUpCallback.call(this.callbackContext, e)
            }
            if (!this._keys[e.keyCode]) {
                this._keys[e.keyCode] = new t.Key(this.game, e.keyCode)
            }
            this._keys[e.keyCode].processKeyUp(e)
        },
        reset: function(e) {
            if (typeof e === "undefined") {
                e = true
            }
            this.event = null;
            var t = this._keys.length;
            while (t--) {
                if (this._keys[t]) {
                    this._keys[t].reset(e)
                }
            }
        },
        justPressed: function(e, t) {
            if (typeof t === "undefined") {
                t = 50
            }
            if (this._keys[e]) {
                return this._keys[e].justPressed(t)
            } else {
                return false
            }
        },
        justReleased: function(e, t) {
            if (typeof t === "undefined") {
                t = 50
            }
            if (this._keys[e]) {
                return this._keys[e].justReleased(t)
            } else {
                return false
            }
        },
        isDown: function(e) {
            if (this._keys[e]) {
                return this._keys[e].isDown
            }
            return false
        }
    };
    t.Keyboard.prototype.constructor = t.Keyboard;
    t.Keyboard.A = "A".charCodeAt(0);
    t.Keyboard.B = "B".charCodeAt(0);
    t.Keyboard.C = "C".charCodeAt(0);
    t.Keyboard.D = "D".charCodeAt(0);
    t.Keyboard.E = "E".charCodeAt(0);
    t.Keyboard.F = "F".charCodeAt(0);
    t.Keyboard.G = "G".charCodeAt(0);
    t.Keyboard.H = "H".charCodeAt(0);
    t.Keyboard.I = "I".charCodeAt(0);
    t.Keyboard.J = "J".charCodeAt(0);
    t.Keyboard.K = "K".charCodeAt(0);
    t.Keyboard.L = "L".charCodeAt(0);
    t.Keyboard.M = "M".charCodeAt(0);
    t.Keyboard.N = "N".charCodeAt(0);
    t.Keyboard.O = "O".charCodeAt(0);
    t.Keyboard.P = "P".charCodeAt(0);
    t.Keyboard.Q = "Q".charCodeAt(0);
    t.Keyboard.R = "R".charCodeAt(0);
    t.Keyboard.S = "S".charCodeAt(0);
    t.Keyboard.T = "T".charCodeAt(0);
    t.Keyboard.U = "U".charCodeAt(0);
    t.Keyboard.V = "V".charCodeAt(0);
    t.Keyboard.W = "W".charCodeAt(0);
    t.Keyboard.X = "X".charCodeAt(0);
    t.Keyboard.Y = "Y".charCodeAt(0);
    t.Keyboard.Z = "Z".charCodeAt(0);
    t.Keyboard.ZERO = "0".charCodeAt(0);
    t.Keyboard.ONE = "1".charCodeAt(0);
    t.Keyboard.TWO = "2".charCodeAt(0);
    t.Keyboard.THREE = "3".charCodeAt(0);
    t.Keyboard.FOUR = "4".charCodeAt(0);
    t.Keyboard.FIVE = "5".charCodeAt(0);
    t.Keyboard.SIX = "6".charCodeAt(0);
    t.Keyboard.SEVEN = "7".charCodeAt(0);
    t.Keyboard.EIGHT = "8".charCodeAt(0);
    t.Keyboard.NINE = "9".charCodeAt(0);
    t.Keyboard.NUMPAD_0 = 96;
    t.Keyboard.NUMPAD_1 = 97;
    t.Keyboard.NUMPAD_2 = 98;
    t.Keyboard.NUMPAD_3 = 99;
    t.Keyboard.NUMPAD_4 = 100;
    t.Keyboard.NUMPAD_5 = 101;
    t.Keyboard.NUMPAD_6 = 102;
    t.Keyboard.NUMPAD_7 = 103;
    t.Keyboard.NUMPAD_8 = 104;
    t.Keyboard.NUMPAD_9 = 105;
    t.Keyboard.NUMPAD_MULTIPLY = 106;
    t.Keyboard.NUMPAD_ADD = 107;
    t.Keyboard.NUMPAD_ENTER = 108;
    t.Keyboard.NUMPAD_SUBTRACT = 109;
    t.Keyboard.NUMPAD_DECIMAL = 110;
    t.Keyboard.NUMPAD_DIVIDE = 111;
    t.Keyboard.F1 = 112;
    t.Keyboard.F2 = 113;
    t.Keyboard.F3 = 114;
    t.Keyboard.F4 = 115;
    t.Keyboard.F5 = 116;
    t.Keyboard.F6 = 117;
    t.Keyboard.F7 = 118;
    t.Keyboard.F8 = 119;
    t.Keyboard.F9 = 120;
    t.Keyboard.F10 = 121;
    t.Keyboard.F11 = 122;
    t.Keyboard.F12 = 123;
    t.Keyboard.F13 = 124;
    t.Keyboard.F14 = 125;
    t.Keyboard.F15 = 126;
    t.Keyboard.COLON = 186;
    t.Keyboard.EQUALS = 187;
    t.Keyboard.UNDERSCORE = 189;
    t.Keyboard.QUESTION_MARK = 191;
    t.Keyboard.TILDE = 192;
    t.Keyboard.OPEN_BRACKET = 219;
    t.Keyboard.BACKWARD_SLASH = 220;
    t.Keyboard.CLOSED_BRACKET = 221;
    t.Keyboard.QUOTES = 222;
    t.Keyboard.BACKSPACE = 8;
    t.Keyboard.TAB = 9;
    t.Keyboard.CLEAR = 12;
    t.Keyboard.ENTER = 13;
    t.Keyboard.SHIFT = 16;
    t.Keyboard.CONTROL = 17;
    t.Keyboard.ALT = 18;
    t.Keyboard.CAPS_LOCK = 20;
    t.Keyboard.ESC = 27;
    t.Keyboard.SPACEBAR = 32;
    t.Keyboard.PAGE_UP = 33;
    t.Keyboard.PAGE_DOWN = 34;
    t.Keyboard.END = 35;
    t.Keyboard.HOME = 36;
    t.Keyboard.LEFT = 37;
    t.Keyboard.UP = 38;
    t.Keyboard.RIGHT = 39;
    t.Keyboard.DOWN = 40;
    t.Keyboard.INSERT = 45;
    t.Keyboard.DELETE = 46;
    t.Keyboard.HELP = 47;
    t.Keyboard.NUM_LOCK = 144;
    t.Mouse = function(e) {
        this.game = e;
        this.callbackContext = this.game;
        this.mouseDownCallback = null;
        this.mouseMoveCallback = null;
        this.mouseUpCallback = null;
        this.mouseOutCallback = null;
        this.mouseOverCallback = null;
        this.capture = false;
        this.button = -1;
        this.disabled = false;
        this.locked = false;
        this.stopOnGameOut = false;
        this.pointerLock = new t.Signal;
        this.event = null;
        this._onMouseDown = null;
        this._onMouseMove = null;
        this._onMouseUp = null;
        this._onMouseOut = null;
        this._onMouseOver = null
    };
    t.Mouse.NO_BUTTON = -1;
    t.Mouse.LEFT_BUTTON = 0;
    t.Mouse.MIDDLE_BUTTON = 1;
    t.Mouse.RIGHT_BUTTON = 2;
    t.Mouse.prototype = {
        start: function() {
            if (this.game.device.android && this.game.device.chrome === false) {
                return
            }
            if (this._onMouseDown !== null) {
                return
            }
            var e = this;
            this._onMouseDown = function(t) {
                return e.onMouseDown(t)
            };
            this._onMouseMove = function(t) {
                return e.onMouseMove(t)
            };
            this._onMouseUp = function(t) {
                return e.onMouseUp(t)
            };
            this._onMouseOut = function(t) {
                return e.onMouseOut(t)
            };
            this._onMouseOver = function(t) {
                return e.onMouseOver(t)
            };
            this.game.canvas.addEventListener("mousedown", this._onMouseDown, true);
            this.game.canvas.addEventListener("mousemove", this._onMouseMove, true);
            this.game.canvas.addEventListener("mouseup", this._onMouseUp, true);
            this.game.canvas.addEventListener("mouseover", this._onMouseOver, true);
            this.game.canvas.addEventListener("mouseout", this._onMouseOut, true)
        },
        onMouseDown: function(e) {
            this.event = e;
            if (this.capture) {
                e.preventDefault()
            }
            this.button = e.button;
            if (this.mouseDownCallback) {
                this.mouseDownCallback.call(this.callbackContext, e)
            }
            if (this.game.input.disabled || this.disabled) {
                return
            }
            e["identifier"] = 0;
            this.game.input.mousePointer.start(e)
        },
        onMouseMove: function(e) {
            this.event = e;
            if (this.capture) {
                e.preventDefault()
            }
            if (this.mouseMoveCallback) {
                this.mouseMoveCallback.call(this.callbackContext, e)
            }
            if (this.game.input.disabled || this.disabled) {
                return
            }
            e["identifier"] = 0;
            this.game.input.mousePointer.move(e)
        },
        onMouseUp: function(e) {
            this.event = e;
            if (this.capture) {
                e.preventDefault()
            }
            this.button = t.Mouse.NO_BUTTON;
            if (this.mouseUpCallback) {
                this.mouseUpCallback.call(this.callbackContext, e)
            }
            if (this.game.input.disabled || this.disabled) {
                return
            }
            e["identifier"] = 0;
            this.game.input.mousePointer.stop(e)
        },
        onMouseOut: function(e) {
            this.event = e;
            if (this.capture) {
                e.preventDefault()
            }
            if (this.mouseOutCallback) {
                this.mouseOutCallback.call(this.callbackContext, e)
            }
            if (this.game.input.disabled || this.disabled) {
                return
            }
            this.game.input.mousePointer.withinGame = false;
            if (this.stopOnGameOut) {
                e["identifier"] = 0;
                this.game.input.mousePointer.stop(e)
            }
        },
        onMouseOver: function(e) {
            this.event = e;
            if (this.capture) {
                e.preventDefault()
            }
            if (this.mouseOverCallback) {
                this.mouseOverCallback.call(this.callbackContext, e)
            }
            if (this.game.input.disabled || this.disabled) {
                return
            }
            this.game.input.mousePointer.withinGame = true
        },
        requestPointerLock: function() {
            if (this.game.device.pointerLock) {
                var e = this.game.canvas;
                e.requestPointerLock = e.requestPointerLock || e.mozRequestPointerLock || e.webkitRequestPointerLock;
                e.requestPointerLock();
                var t = this;
                this._pointerLockChange = function(e) {
                    return t.pointerLockChange(e)
                };
                document.addEventListener("pointerlockchange", this._pointerLockChange, true);
                document.addEventListener("mozpointerlockchange", this._pointerLockChange, true);
                document.addEventListener("webkitpointerlockchange", this._pointerLockChange, true)
            }
        },
        pointerLockChange: function(e) {
            var t = this.game.canvas;
            if (document.pointerLockElement === t || document.mozPointerLockElement === t || document.webkitPointerLockElement === t) {
                this.locked = true;
                this.pointerLock.dispatch(true, e)
            } else {
                this.locked = false;
                this.pointerLock.dispatch(false, e)
            }
        },
        releasePointerLock: function() {
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
            document.exitPointerLock();
            document.removeEventListener("pointerlockchange", this._pointerLockChange, true);
            document.removeEventListener("mozpointerlockchange", this._pointerLockChange, true);
            document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, true)
        },
        stop: function() {
            this.game.canvas.removeEventListener("mousedown", this._onMouseDown, true);
            this.game.canvas.removeEventListener("mousemove", this._onMouseMove, true);
            this.game.canvas.removeEventListener("mouseup", this._onMouseUp, true);
            this.game.canvas.removeEventListener("mouseover", this._onMouseOver, true);
            this.game.canvas.removeEventListener("mouseout", this._onMouseOut, true)
        }
    };
    t.Mouse.prototype.constructor = t.Mouse;
    t.MSPointer = function(e) {
        this.game = e;
        this.callbackContext = this.game;
        this.disabled = false;
        this._onMSPointerDown = null;
        this._onMSPointerMove = null;
        this._onMSPointerUp = null
    };
    t.MSPointer.prototype = {
        start: function() {
            if (this._onMSPointerDown !== null) {
                return
            }
            var e = this;
            if (this.game.device.mspointer === true) {
                this._onMSPointerDown = function(t) {
                    return e.onPointerDown(t)
                };
                this._onMSPointerMove = function(t) {
                    return e.onPointerMove(t)
                };
                this._onMSPointerUp = function(t) {
                    return e.onPointerUp(t)
                };
                this.game.renderer.view.addEventListener("MSPointerDown", this._onMSPointerDown, false);
                this.game.renderer.view.addEventListener("MSPointerMove", this._onMSPointerMove, false);
                this.game.renderer.view.addEventListener("MSPointerUp", this._onMSPointerUp, false);
                this.game.renderer.view.addEventListener("pointerDown", this._onMSPointerDown, false);
                this.game.renderer.view.addEventListener("pointerMove", this._onMSPointerMove, false);
                this.game.renderer.view.addEventListener("pointerUp", this._onMSPointerUp, false);
                this.game.renderer.view.style["-ms-content-zooming"] = "none";
                this.game.renderer.view.style["-ms-touch-action"] = "none"
            }
        },
        onPointerDown: function(e) {
            if (this.game.input.disabled || this.disabled) {
                return
            }
            e.preventDefault();
            e.identifier = e.pointerId;
            this.game.input.startPointer(e)
        },
        onPointerMove: function(e) {
            if (this.game.input.disabled || this.disabled) {
                return
            }
            e.preventDefault();
            e.identifier = e.pointerId;
            this.game.input.updatePointer(e)
        },
        onPointerUp: function(e) {
            if (this.game.input.disabled || this.disabled) {
                return
            }
            e.preventDefault();
            e.identifier = e.pointerId;
            this.game.input.stopPointer(e)
        },
        stop: function() {
            this.game.canvas.removeEventListener("MSPointerDown", this._onMSPointerDown);
            this.game.canvas.removeEventListener("MSPointerMove", this._onMSPointerMove);
            this.game.canvas.removeEventListener("MSPointerUp", this._onMSPointerUp);
            this.game.canvas.removeEventListener("pointerDown", this._onMSPointerDown);
            this.game.canvas.removeEventListener("pointerMove", this._onMSPointerMove);
            this.game.canvas.removeEventListener("pointerUp", this._onMSPointerUp)
        }
    };
    t.MSPointer.prototype.constructor = t.MSPointer;
    t.Pointer = function(e, n) {
        this.game = e;
        this.id = n;
        this.type = t.POINTER;
        this.exists = true;
        this.identifier = 0;
        this.pointerId = null;
        this.target = null;
        this.button = null;
        this._holdSent = false;
        this._history = [];
        this._nextDrop = 0;
        this._stateReset = false;
        this.withinGame = false;
        this.clientX = -1;
        this.clientY = -1;
        this.pageX = -1;
        this.pageY = -1;
        this.screenX = -1;
        this.screenY = -1;
        this.rawMovementX = 0;
        this.rawMovementY = 0;
        this.movementX = 0;
        this.movementY = 0;
        this.x = -1;
        this.y = -1;
        this.isMouse = false;
        this.isDown = false;
        this.isUp = true;
        this.timeDown = 0;
        this.timeUp = 0;
        this.previousTapTime = 0;
        this.totalTouches = 0;
        this.msSinceLastClick = Number.MAX_VALUE;
        this.targetObject = null;
        this.active = false;
        this.position = new t.Point;
        this.positionDown = new t.Point;
        this.positionUp = new t.Point;
        this.circle = new t.Circle(0, 0, 44);
        if (n === 0) {
            this.isMouse = true
        }
    };
    t.Pointer.prototype = {
        start: function(e) {
            if (e["pointerId"]) {
                this.pointerId = e.pointerId
            }
            this.identifier = e.identifier;
            this.target = e.target;
            if (typeof e.button !== "undefined") {
                this.button = e.button
            }
            this._history = [];
            this.active = true;
            this.withinGame = true;
            this.isDown = true;
            this.isUp = false;
            this.msSinceLastClick = this.game.time.now - this.timeDown;
            this.timeDown = this.game.time.now;
            this._holdSent = false;
            this.move(e, true);
            this.positionDown.setTo(this.x, this.y);
            if (this.game.input.multiInputOverride === t.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === t.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === t.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers === 0) {
                this.game.input.x = this.x;
                this.game.input.y = this.y;
                this.game.input.position.setTo(this.x, this.y);
                this.game.input.onDown.dispatch(this, e);
                this.game.input.resetSpeed(this.x, this.y)
            }
            this._stateReset = false;
            this.totalTouches++;
            if (!this.isMouse) {
                this.game.input.currentPointers++
            }
            if (this.targetObject !== null) {
                this.targetObject._touchedHandler(this)
            }
            return this
        },
        update: function() {
            if (this.active) {
                if (this._holdSent === false && this.duration >= this.game.input.holdRate) {
                    if (this.game.input.multiInputOverride == t.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride == t.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride == t.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers === 0) {
                        this.game.input.onHold.dispatch(this)
                    }
                    this._holdSent = true
                }
                if (this.game.input.recordPointerHistory && this.game.time.now >= this._nextDrop) {
                    this._nextDrop = this.game.time.now + this.game.input.recordRate;
                    this._history.push({
                        x: this.position.x,
                        y: this.position.y
                    });
                    if (this._history.length > this.game.input.recordLimit) {
                        this._history.shift()
                    }
                }
            }
        },
        move: function(e, n) {
            if (this.game.input.pollLocked) {
                return
            }
            if (typeof n === "undefined") {
                n = false
            }
            if (typeof e.button !== "undefined") {
                this.button = e.button
            }
            this.clientX = e.clientX;
            this.clientY = e.clientY;
            this.pageX = e.pageX;
            this.pageY = e.pageY;
            this.screenX = e.screenX;
            this.screenY = e.screenY;
            if (this.isMouse && this.game.input.mouse.locked && !n) {
                this.rawMovementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
                this.rawMovementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;
                this.movementX += this.rawMovementX;
                this.movementY += this.rawMovementY
            }
            this.x = (this.pageX - this.game.stage.offset.x) * this.game.input.scale.x;
            this.y = (this.pageY - this.game.stage.offset.y) * this.game.input.scale.y;
            this.position.setTo(this.x, this.y);
            this.circle.x = this.x;
            this.circle.y = this.y;
            if (this.game.input.multiInputOverride === t.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === t.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === t.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers === 0) {
                this.game.input.activePointer = this;
                this.game.input.x = this.x;
                this.game.input.y = this.y;
                this.game.input.position.setTo(this.game.input.x, this.game.input.y);
                this.game.input.circle.x = this.game.input.x;
                this.game.input.circle.y = this.game.input.y
            }
            this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY);
            if (this.game.paused) {
                return this
            }
            if (this.game.input.moveCallback) {
                this.game.input.moveCallback.call(this.game.input.moveCallbackContext, this, this.x, this.y)
            }
            var r = this.game.input.moveCallbacks.length;
            while (r--) {
                this.game.input.moveCallbacks[r].callback.call(this.game.input.moveCallbacks[r].context, this, this.x, this.y)
            }
            if (this.targetObject !== null && this.targetObject.isDragged === true) {
                if (this.targetObject.update(this) === false) {
                    this.targetObject = null
                }
                return this
            }
            this._highestRenderOrderID = Number.MAX_SAFE_INTEGER;
            this._highestRenderObject = null;
            this._highestInputPriorityID = -1;
            if (this.game.input.interactiveItems.total > 0) {
                var i = this.game.input.interactiveItems.first;
                do {
                    if (i && i.validForInput(this._highestInputPriorityID, this._highestRenderOrderID)) {
                        if (!n && i.checkPointerOver(this) || n && i.checkPointerDown(this)) {
                            this._highestRenderOrderID = i.sprite._cache[3];
                            this._highestInputPriorityID = i.priorityID;
                            this._highestRenderObject = i
                        }
                    }
                    i = this.game.input.interactiveItems.next
                } while (i !== null)
            }
            if (this._highestRenderObject === null) {
                if (this.targetObject) {
                    this.targetObject._pointerOutHandler(this);
                    this.targetObject = null
                }
            } else {
                if (this.targetObject === null) {
                    this.targetObject = this._highestRenderObject;
                    this._highestRenderObject._pointerOverHandler(this)
                } else {
                    if (this.targetObject === this._highestRenderObject) {
                        if (this._highestRenderObject.update(this) === false) {
                            this.targetObject = null
                        }
                    } else {
                        this.targetObject._pointerOutHandler(this);
                        this.targetObject = this._highestRenderObject;
                        this.targetObject._pointerOverHandler(this)
                    }
                }
            }
            return this
        },
        leave: function(e) {
            this.withinGame = false;
            this.move(e, false)
        },
        stop: function(e) {
            if (this._stateReset) {
                e.preventDefault();
                return
            }
            this.timeUp = this.game.time.now;
            if (this.game.input.multiInputOverride === t.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === t.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === t.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers === 0) {
                this.game.input.onUp.dispatch(this, e);
                if (this.duration >= 0 && this.duration <= this.game.input.tapRate) {
                    if (this.timeUp - this.previousTapTime < this.game.input.doubleTapRate) {
                        this.game.input.onTap.dispatch(this, true)
                    } else {
                        this.game.input.onTap.dispatch(this, false)
                    }
                    this.previousTapTime = this.timeUp
                }
            }
            if (this.id > 0) {
                this.active = false
            }
            this.withinGame = false;
            this.isDown = false;
            this.isUp = true;
            this.pointerId = null;
            this.identifier = null;
            this.positionUp.setTo(this.x, this.y);
            if (this.isMouse === false) {
                this.game.input.currentPointers--
            }
            this.game.input.interactiveItems.callAll("_releasedHandler", this);
            this.targetObject = null;
            return this
        },
        justPressed: function(e) {
            e = e || this.game.input.justPressedRate;
            return this.isDown === true && this.timeDown + e > this.game.time.now
        },
        justReleased: function(e) {
            e = e || this.game.input.justReleasedRate;
            return this.isUp === true && this.timeUp + e > this.game.time.now
        },
        reset: function() {
            if (this.isMouse === false) {
                this.active = false
            }
            this.pointerId = null;
            this.identifier = null;
            this.isDown = false;
            this.isUp = true;
            this.totalTouches = 0;
            this._holdSent = false;
            this._history.length = 0;
            this._stateReset = true;
            if (this.targetObject) {
                this.targetObject._releasedHandler(this)
            }
            this.targetObject = null
        },
        resetMovement: function() {
            this.movementX = 0;
            this.movementY = 0
        }
    };
    t.Pointer.prototype.constructor = t.Pointer;
    Object.defineProperty(t.Pointer.prototype, "duration", {
        get: function() {
            if (this.isUp) {
                return -1
            }
            return this.game.time.now - this.timeDown
        }
    });
    Object.defineProperty(t.Pointer.prototype, "worldX", {
        get: function() {
            return this.game.world.camera.x + this.x
        }
    });
    Object.defineProperty(t.Pointer.prototype, "worldY", {
        get: function() {
            return this.game.world.camera.y + this.y
        }
    });
    t.Touch = function(e) {
        this.game = e;
        this.disabled = false;
        this.callbackContext = this.game;
        this.touchStartCallback = null;
        this.touchMoveCallback = null;
        this.touchEndCallback = null;
        this.touchEnterCallback = null;
        this.touchLeaveCallback = null;
        this.touchCancelCallback = null;
        this.preventDefault = true;
        this.event = null;
        this._onTouchStart = null;
        this._onTouchMove = null;
        this._onTouchEnd = null;
        this._onTouchEnter = null;
        this._onTouchLeave = null;
        this._onTouchCancel = null;
        this._onTouchMove = null
    };
    t.Touch.prototype = {
        start: function() {
            if (this._onTouchStart !== null) {
                return
            }
            var e = this;
            if (this.game.device.touch) {
                this._onTouchStart = function(t) {
                    return e.onTouchStart(t)
                };
                this._onTouchMove = function(t) {
                    return e.onTouchMove(t)
                };
                this._onTouchEnd = function(t) {
                    return e.onTouchEnd(t)
                };
                this._onTouchEnter = function(t) {
                    return e.onTouchEnter(t)
                };
                this._onTouchLeave = function(t) {
                    return e.onTouchLeave(t)
                };
                this._onTouchCancel = function(t) {
                    return e.onTouchCancel(t)
                };
                this.game.canvas.addEventListener("touchstart", this._onTouchStart, false);
                this.game.canvas.addEventListener("touchmove", this._onTouchMove, false);
                this.game.canvas.addEventListener("touchend", this._onTouchEnd, false);
                this.game.canvas.addEventListener("touchenter", this._onTouchEnter, false);
                this.game.canvas.addEventListener("touchleave", this._onTouchLeave, false);
                this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, false)
            }
        },
        consumeDocumentTouches: function() {
            this._documentTouchMove = function(e) {
                e.preventDefault()
            };
            document.addEventListener("touchmove", this._documentTouchMove, false)
        },
        onTouchStart: function(e) {
            this.event = e;
            if (this.touchStartCallback) {
                this.touchStartCallback.call(this.callbackContext, e)
            }
            if (this.game.input.disabled || this.disabled) {
                return
            }
            if (this.preventDefault) {
                e.preventDefault()
            }
            for (var t = 0; t < e.changedTouches.length; t++) {
                this.game.input.startPointer(e.changedTouches[t])
            }
        },
        onTouchCancel: function(e) {
            this.event = e;
            if (this.touchCancelCallback) {
                this.touchCancelCallback.call(this.callbackContext, e)
            }
            if (this.game.input.disabled || this.disabled) {
                return
            }
            if (this.preventDefault) {
                e.preventDefault()
            }
            for (var t = 0; t < e.changedTouches.length; t++) {
                this.game.input.stopPointer(e.changedTouches[t])
            }
        },
        onTouchEnter: function(e) {
            console.log("touch enter", e);
            this.event = e;
            if (this.touchEnterCallback) {
                this.touchEnterCallback.call(this.callbackContext, e)
            }
            if (this.game.input.disabled || this.disabled) {
                return
            }
            if (this.preventDefault) {
                e.preventDefault()
            }
        },
        onTouchLeave: function(e) {
            this.event = e;
            if (this.touchLeaveCallback) {
                this.touchLeaveCallback.call(this.callbackContext, e)
            }
            if (this.preventDefault) {
                e.preventDefault()
            }
        },
        onTouchMove: function(e) {
            this.event = e;
            if (this.touchMoveCallback) {
                this.touchMoveCallback.call(this.callbackContext, e)
            }
            if (this.preventDefault) {
                e.preventDefault()
            }
            for (var t = 0; t < e.changedTouches.length; t++) {
                this.game.input.updatePointer(e.changedTouches[t])
            }
        },
        onTouchEnd: function(e) {
            this.event = e;
            if (this.touchEndCallback) {
                this.touchEndCallback.call(this.callbackContext, e)
            }
            if (this.preventDefault) {
                e.preventDefault()
            }
            for (var t = 0; t < e.changedTouches.length; t++) {
                this.game.input.stopPointer(e.changedTouches[t])
            }
        },
        stop: function() {
            if (this.game.device.touch) {
                this.game.canvas.removeEventListener("touchstart", this._onTouchStart);
                this.game.canvas.removeEventListener("touchmove", this._onTouchMove);
                this.game.canvas.removeEventListener("touchend", this._onTouchEnd);
                this.game.canvas.removeEventListener("touchenter", this._onTouchEnter);
                this.game.canvas.removeEventListener("touchleave", this._onTouchLeave);
                this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel)
            }
        }
    };
    t.Touch.prototype.constructor = t.Touch;
    t.Gamepad = function(e) {
        this.game = e;
        this._gamepads = [new t.SinglePad(e, this), new t.SinglePad(e, this), new t.SinglePad(e, this), new t.SinglePad(e, this)];
        this._gamepadIndexMap = {};
        this._rawPads = [];
        this._active = false;
        this.disabled = false;
        this._gamepadSupportAvailable = !! navigator.webkitGetGamepads || !! navigator.webkitGamepads || navigator.userAgent.indexOf("Firefox/") != -1 || !! navigator.getGamepads;
        this._prevRawGamepadTypes = [];
        this._prevTimestamps = [];
        this.callbackContext = this;
        this.onConnectCallback = null;
        this.onDisconnectCallback = null;
        this.onDownCallback = null;
        this.onUpCallback = null;
        this.onAxisCallback = null;
        this.onFloatCallback = null;
        this._ongamepadconnected = null;
        this._gamepaddisconnected = null
    };
    t.Gamepad.prototype = {
        addCallbacks: function(e, t) {
            if (typeof t !== "undefined") {
                this.onConnectCallback = typeof t.onConnect === "function" ? t.onConnect : this.onConnectCallback;
                this.onDisconnectCallback = typeof t.onDisconnect === "function" ? t.onDisconnect : this.onDisconnectCallback;
                this.onDownCallback = typeof t.onDown === "function" ? t.onDown : this.onDownCallback;
                this.onUpCallback = typeof t.onUp === "function" ? t.onUp : this.onUpCallback;
                this.onAxisCallback = typeof t.onAxis === "function" ? t.onAxis : this.onAxisCallback;
                this.onFloatCallback = typeof t.onFloat === "function" ? t.onFloat : this.onFloatCallback
            }
        },
        start: function() {
            if (this._active) {
                return
            }
            this._active = true;
            var e = this;
            this._ongamepadconnected = function(t) {
                var n = t.gamepad;
                e._rawPads.push(n);
                e._gamepads[n.index].connect(n)
            };
            window.addEventListener("gamepadconnected", this._ongamepadconnected, false);
            this._ongamepaddisconnected = function(t) {
                var n = t.gamepad;
                for (var r in e._rawPads) {
                    if (e._rawPads[r].index === n.index) {
                        e._rawPads.splice(r, 1)
                    }
                }
                e._gamepads[n.index].disconnect()
            };
            window.addEventListener("gamepaddisconnected", this._ongamepaddisconnected, false)
        },
        update: function() {
            this._pollGamepads();
            for (var e = 0; e < this._gamepads.length; e++) {
                if (this._gamepads[e]._connected) {
                    this._gamepads[e].pollStatus()
                }
            }
        },
        _pollGamepads: function() {
            var e = navigator.getGamepads || navigator.webkitGetGamepads && navigator.webkitGetGamepads() || navigator.webkitGamepads;
            if (e) {
                this._rawPads = [];
                var t = false;
                for (var n = 0; n < e.length; n++) {
                    if (typeof e[n] !== this._prevRawGamepadTypes[n]) {
                        t = true;
                        this._prevRawGamepadTypes[n] = typeof e[n]
                    }
                    if (e[n]) {
                        this._rawPads.push(e[n])
                    }
                    if (n === 3) {
                        break
                    }
                }
                if (t) {
                    var r = {
                        rawIndices: {},
                        padIndices: {}
                    };
                    var i;
                    for (var s = 0; s < this._gamepads.length; s++) {
                        i = this._gamepads[s];
                        if (i.connected) {
                            for (var o = 0; o < this._rawPads.length; o++) {
                                if (this._rawPads[o].index === i.index) {
                                    r.rawIndices[i.index] = true;
                                    r.padIndices[s] = true
                                }
                            }
                        }
                    }
                    for (var u = 0; u < this._gamepads.length; u++) {
                        i = this._gamepads[u];
                        if (r.padIndices[u]) {
                            continue
                        }
                        if (this._rawPads.length < 1) {
                            i.disconnect()
                        }
                        for (var a = 0; a < this._rawPads.length; a++) {
                            if (r.padIndices[u]) {
                                break
                            }
                            var f = this._rawPads[a];
                            if (f) {
                                if (r.rawIndices[f.index]) {
                                    i.disconnect();
                                    continue
                                } else {
                                    i.connect(f);
                                    r.rawIndices[f.index] = true;
                                    r.padIndices[u] = true
                                }
                            } else {
                                i.disconnect()
                            }
                        }
                    }
                }
            }
        },
        setDeadZones: function(e) {
            for (var t = 0; t < this._gamepads.length; t++) {
                this._gamepads[t].deadZone = e
            }
        },
        stop: function() {
            this._active = false;
            window.removeEventListener("gamepadconnected", this._ongamepadconnected);
            window.removeEventListener("gamepaddisconnected", this._ongamepaddisconnected)
        },
        reset: function() {
            this.update();
            for (var e = 0; e < this._gamepads.length; e++) {
                this._gamepads[e].reset()
            }
        },
        justPressed: function(e, t) {
            for (var n = 0; n < this._gamepads.length; n++) {
                if (this._gamepads[n].justPressed(e, t) === true) {
                    return true
                }
            }
            return false
        },
        justReleased: function(e, t) {
            for (var n = 0; n < this._gamepads.length; n++) {
                if (this._gamepads[n].justReleased(e, t) === true) {
                    return true
                }
            }
            return false
        },
        isDown: function(e) {
            for (var t = 0; t < this._gamepads.length; t++) {
                if (this._gamepads[t].isDown(e) === true) {
                    return true
                }
            }
            return false
        }
    };
    t.Gamepad.prototype.constructor = t.Gamepad;
    Object.defineProperty(t.Gamepad.prototype, "active", {
        get: function() {
            return this._active
        }
    });
    Object.defineProperty(t.Gamepad.prototype, "supported", {
        get: function() {
            return this._gamepadSupportAvailable
        }
    });
    Object.defineProperty(t.Gamepad.prototype, "padsConnected", {
        get: function() {
            return this._rawPads.length
        }
    });
    Object.defineProperty(t.Gamepad.prototype, "pad1", {
        get: function() {
            return this._gamepads[0]
        }
    });
    Object.defineProperty(t.Gamepad.prototype, "pad2", {
        get: function() {
            return this._gamepads[1]
        }
    });
    Object.defineProperty(t.Gamepad.prototype, "pad3", {
        get: function() {
            return this._gamepads[2]
        }
    });
    Object.defineProperty(t.Gamepad.prototype, "pad4", {
        get: function() {
            return this._gamepads[3]
        }
    });
    t.Gamepad.BUTTON_0 = 0;
    t.Gamepad.BUTTON_1 = 1;
    t.Gamepad.BUTTON_2 = 2;
    t.Gamepad.BUTTON_3 = 3;
    t.Gamepad.BUTTON_4 = 4;
    t.Gamepad.BUTTON_5 = 5;
    t.Gamepad.BUTTON_6 = 6;
    t.Gamepad.BUTTON_7 = 7;
    t.Gamepad.BUTTON_8 = 8;
    t.Gamepad.BUTTON_9 = 9;
    t.Gamepad.BUTTON_10 = 10;
    t.Gamepad.BUTTON_11 = 11;
    t.Gamepad.BUTTON_12 = 12;
    t.Gamepad.BUTTON_13 = 13;
    t.Gamepad.BUTTON_14 = 14;
    t.Gamepad.BUTTON_15 = 15;
    t.Gamepad.AXIS_0 = 0;
    t.Gamepad.AXIS_1 = 1;
    t.Gamepad.AXIS_2 = 2;
    t.Gamepad.AXIS_3 = 3;
    t.Gamepad.AXIS_4 = 4;
    t.Gamepad.AXIS_5 = 5;
    t.Gamepad.AXIS_6 = 6;
    t.Gamepad.AXIS_7 = 7;
    t.Gamepad.AXIS_8 = 8;
    t.Gamepad.AXIS_9 = 9;
    t.Gamepad.XBOX360_A = 0;
    t.Gamepad.XBOX360_B = 1;
    t.Gamepad.XBOX360_X = 2;
    t.Gamepad.XBOX360_Y = 3;
    t.Gamepad.XBOX360_LEFT_BUMPER = 4;
    t.Gamepad.XBOX360_RIGHT_BUMPER = 5;
    t.Gamepad.XBOX360_LEFT_TRIGGER = 6;
    t.Gamepad.XBOX360_RIGHT_TRIGGER = 7;
    t.Gamepad.XBOX360_BACK = 8;
    t.Gamepad.XBOX360_START = 9;
    t.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10;
    t.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11;
    t.Gamepad.XBOX360_DPAD_LEFT = 14;
    t.Gamepad.XBOX360_DPAD_RIGHT = 15;
    t.Gamepad.XBOX360_DPAD_UP = 12;
    t.Gamepad.XBOX360_DPAD_DOWN = 13;
    t.Gamepad.XBOX360_STICK_LEFT_X = 0;
    t.Gamepad.XBOX360_STICK_LEFT_Y = 1;
    t.Gamepad.XBOX360_STICK_RIGHT_X = 2;
    t.Gamepad.XBOX360_STICK_RIGHT_Y = 3;
    t.SinglePad = function(e, t) {
        this.game = e;
        this._padParent = t;
        this._index = null;
        this._rawPad = null;
        this._connected = false;
        this._prevTimestamp = null;
        this._rawButtons = [];
        this._buttons = [];
        this._axes = [];
        this._hotkeys = [];
        this.callbackContext = this;
        this.onConnectCallback = null;
        this.onDisconnectCallback = null;
        this.onDownCallback = null;
        this.onUpCallback = null;
        this.onAxisCallback = null;
        this.onFloatCallback = null;
        this.deadZone = .26
    };
    t.SinglePad.prototype = {
        addCallbacks: function(e, t) {
            if (typeof t !== "undefined") {
                this.onConnectCallback = typeof t.onConnect === "function" ? t.onConnect : this.onConnectCallback;
                this.onDisconnectCallback = typeof t.onDisconnect === "function" ? t.onDisconnect : this.onDisconnectCallback;
                this.onDownCallback = typeof t.onDown === "function" ? t.onDown : this.onDownCallback;
                this.onUpCallback = typeof t.onUp === "function" ? t.onUp : this.onUpCallback;
                this.onAxisCallback = typeof t.onAxis === "function" ? t.onAxis : this.onAxisCallback;
                this.onFloatCallback = typeof t.onFloat === "function" ? t.onFloat : this.onFloatCallback
            }
        },
        addButton: function(e) {
            this._hotkeys[e] = new t.GamepadButton(this.game, e);
            return this._hotkeys[e]
        },
        pollStatus: function() {
            if (this._rawPad.timestamp && this._rawPad.timestamp == this._prevTimestamp) {
                return
            }
            for (var e = 0; e < this._rawPad.buttons.length; e += 1) {
                var t = this._rawPad.buttons[e];
                if (this._rawButtons[e] !== t) {
                    if (t === 1) {
                        this.processButtonDown(e, t)
                    } else if (t === 0) {
                        this.processButtonUp(e, t)
                    } else {
                        this.processButtonFloat(e, t)
                    }
                    this._rawButtons[e] = t
                }
            }
            var n = this._rawPad.axes;
            for (var r = 0; r < n.length; r += 1) {
                var i = n[r];
                if (i > 0 && i > this.deadZone || i < 0 && i < -this.deadZone) {
                    this.processAxisChange({
                        axis: r,
                        value: i
                    })
                } else {
                    this.processAxisChange({
                        axis: r,
                        value: 0
                    })
                }
            }
            this._prevTimestamp = this._rawPad.timestamp
        },
        connect: function(e) {
            var t = !this._connected;
            this._index = e.index;
            this._connected = true;
            this._rawPad = e;
            this._rawButtons = e.buttons;
            this._axes = e.axes;
            if (t && this._padParent.onConnectCallback) {
                this._padParent.onConnectCallback.call(this._padParent.callbackContext, this._index)
            }
            if (t && this.onConnectCallback) {
                this.onConnectCallback.call(this.callbackContext)
            }
        },
        disconnect: function() {
            var e = this._connected;
            this._connected = false;
            this._rawPad = undefined;
            this._rawButtons = [];
            this._buttons = [];
            var t = this._index;
            this._index = null;
            if (e && this._padParent.onDisconnectCallback) {
                this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, t)
            }
            if (e && this.onDisconnectCallback) {
                this.onDisconnectCallback.call(this.callbackContext)
            }
        },
        processAxisChange: function(e) {
            if (this.game.input.disabled || this.game.input.gamepad.disabled) {
                return
            }
            if (this._axes[e.axis] === e.value) {
                return
            }
            this._axes[e.axis] = e.value;
            if (this._padParent.onAxisCallback) {
                this._padParent.onAxisCallback.call(this._padParent.callbackContext, e, this._index)
            }
            if (this.onAxisCallback) {
                this.onAxisCallback.call(this.callbackContext, e)
            }
        },
        processButtonDown: function(e, t) {
            if (this.game.input.disabled || this.game.input.gamepad.disabled) {
                return
            }
            if (this._padParent.onDownCallback) {
                this._padParent.onDownCallback.call(this._padParent.callbackContext, e, t, this._index)
            }
            if (this.onDownCallback) {
                this.onDownCallback.call(this.callbackContext, e, t)
            }
            if (this._buttons[e] && this._buttons[e].isDown) {
                this._buttons[e].duration = this.game.time.now - this._buttons[e].timeDown
            } else {
                if (!this._buttons[e]) {
                    this._buttons[e] = {
                        isDown: true,
                        timeDown: this.game.time.now,
                        timeUp: 0,
                        duration: 0,
                        value: t
                    }
                } else {
                    this._buttons[e].isDown = true;
                    this._buttons[e].timeDown = this.game.time.now;
                    this._buttons[e].duration = 0;
                    this._buttons[e].value = t
                }
            }
            if (this._hotkeys[e]) {
                this._hotkeys[e].processButtonDown(t)
            }
        },
        processButtonUp: function(e, t) {
            if (this.game.input.disabled || this.game.input.gamepad.disabled) {
                return
            }
            if (this._padParent.onUpCallback) {
                this._padParent.onUpCallback.call(this._padParent.callbackContext, e, t, this._index)
            }
            if (this.onUpCallback) {
                this.onUpCallback.call(this.callbackContext, e, t)
            }
            if (this._hotkeys[e]) {
                this._hotkeys[e].processButtonUp(t)
            }
            if (this._buttons[e]) {
                this._buttons[e].isDown = false;
                this._buttons[e].timeUp = this.game.time.now;
                this._buttons[e].value = t
            } else {
                this._buttons[e] = {
                    isDown: false,
                    timeDown: this.game.time.now,
                    timeUp: this.game.time.now,
                    duration: 0,
                    value: t
                }
            }
        },
        processButtonFloat: function(e, t) {
            if (this.game.input.disabled || this.game.input.gamepad.disabled) {
                return
            }
            if (this._padParent.onFloatCallback) {
                this._padParent.onFloatCallback.call(this._padParent.callbackContext, e, t, this._index)
            }
            if (this.onFloatCallback) {
                this.onFloatCallback.call(this.callbackContext, e, t)
            }
            if (!this._buttons[e]) {
                this._buttons[e] = {
                    value: t
                }
            } else {
                this._buttons[e].value = t
            }
            if (this._hotkeys[e]) {
                this._hotkeys[e].processButtonFloat(t)
            }
        },
        axis: function(e) {
            if (this._axes[e]) {
                return this._axes[e]
            }
            return false
        },
        isDown: function(e) {
            if (this._buttons[e]) {
                return this._buttons[e].isDown
            }
            return false
        },
        justReleased: function(e, t) {
            if (typeof t === "undefined") {
                t = 250
            }
            return this._buttons[e] && this._buttons[e].isDown === false && this.game.time.now - this._buttons[e].timeUp < t
        },
        justPressed: function(e, t) {
            if (typeof t === "undefined") {
                t = 250
            }
            return this._buttons[e] && this._buttons[e].isDown && this._buttons[e].duration < t
        },
        buttonValue: function(e) {
            if (this._buttons[e]) {
                return this._buttons[e].value
            }
            return false
        },
        reset: function() {
            for (var e = 0; e < this._buttons.length; e++) {
                this._buttons[e] = 0
            }
            for (var t = 0; t < this._axes.length; t++) {
                this._axes[t] = 0
            }
        }
    };
    t.SinglePad.prototype.constructor = t.SinglePad;
    Object.defineProperty(t.SinglePad.prototype, "connected", {
        get: function() {
            return this._connected
        }
    });
    Object.defineProperty(t.SinglePad.prototype, "index", {
        get: function() {
            return this._index
        }
    });
    t.GamepadButton = function(e, n) {
        this.game = e;
        this.isDown = false;
        this.isUp = true;
        this.timeDown = 0;
        this.duration = 0;
        this.timeUp = 0;
        this.repeats = 0;
        this.value = 0;
        this.buttonCode = n;
        this.onDown = new t.Signal;
        this.onUp = new t.Signal;
        this.onFloat = new t.Signal
    };
    t.GamepadButton.prototype = {
        processButtonDown: function(e) {
            if (this.isDown) {
                this.duration = this.game.time.now - this.timeDown;
                this.repeats++
            } else {
                this.isDown = true;
                this.isUp = false;
                this.timeDown = this.game.time.now;
                this.duration = 0;
                this.repeats = 0;
                this.value = e;
                this.onDown.dispatch(this, e)
            }
        },
        processButtonUp: function(e) {
            this.isDown = false;
            this.isUp = true;
            this.timeUp = this.game.time.now;
            this.value = e;
            this.onUp.dispatch(this, e)
        },
        processButtonFloat: function(e) {
            this.value = e;
            this.onFloat.dispatch(this, e)
        },
        justPressed: function(e) {
            if (typeof e === "undefined") {
                e = 250
            }
            return this.isDown && this.duration < e
        },
        justReleased: function(e) {
            if (typeof e === "undefined") {
                e = 250
            }
            return this.isDown === false && this.game.time.now - this.timeUp < e
        }
    };
    t.GamepadButton.prototype.constructor = t.GamepadButton;
    t.InputHandler = function(e) {
        this.sprite = e;
        this.game = e.game;
        this.enabled = false;
        this.priorityID = 0;
        this.useHandCursor = false;
        this._setHandCursor = false;
        this.isDragged = false;
        this.allowHorizontalDrag = true;
        this.allowVerticalDrag = true;
        this.bringToTop = false;
        this.snapOffset = null;
        this.snapOnDrag = false;
        this.snapOnRelease = false;
        this.snapX = 0;
        this.snapY = 0;
        this.snapOffsetX = 0;
        this.snapOffsetY = 0;
        this.pixelPerfectOver = false;
        this.pixelPerfectClick = false;
        this.pixelPerfectAlpha = 255;
        this.draggable = false;
        this.boundsRect = null;
        this.boundsSprite = null;
        this.consumePointerEvent = false;
        this._dragPhase = false;
        this._wasEnabled = false;
        this._tempPoint = new t.Point;
        this._pointerData = [];
        this._pointerData.push({
            id: 0,
            x: 0,
            y: 0,
            isDown: false,
            isUp: false,
            isOver: false,
            isOut: false,
            timeOver: 0,
            timeOut: 0,
            timeDown: 0,
            timeUp: 0,
            downDuration: 0,
            isDragged: false
        })
    };
    t.InputHandler.prototype = {
        start: function(e, n) {
            e = e || 0;
            if (typeof n === "undefined") {
                n = false
            }
            if (this.enabled === false) {
                this.game.input.interactiveItems.add(this);
                this.useHandCursor = n;
                this.priorityID = e;
                for (var r = 0; r < 10; r++) {
                    this._pointerData[r] = {
                        id: r,
                        x: 0,
                        y: 0,
                        isDown: false,
                        isUp: false,
                        isOver: false,
                        isOut: false,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: false
                    }
                }
                this.snapOffset = new t.Point;
                this.enabled = true;
                this._wasEnabled = true;
                if (this.sprite.events && this.sprite.events.onInputOver === null) {
                    this.sprite.events.onInputOver = new t.Signal;
                    this.sprite.events.onInputOut = new t.Signal;
                    this.sprite.events.onInputDown = new t.Signal;
                    this.sprite.events.onInputUp = new t.Signal;
                    this.sprite.events.onDragStart = new t.Signal;
                    this.sprite.events.onDragStop = new t.Signal
                }
            }
            this.sprite.events.onAddedToGroup.add(this.addedToGroup, this);
            this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this);
            return this.sprite
        },
        addedToGroup: function() {
            if (this._dragPhase) {
                return
            }
            if (this._wasEnabled && !this.enabled) {
                this.start()
            }
        },
        removedFromGroup: function() {
            if (this._dragPhase) {
                return
            }
            if (this.enabled) {
                this._wasEnabled = true;
                this.stop()
            } else {
                this._wasEnabled = false
            }
        },
        reset: function() {
            this.enabled = false;
            for (var e = 0; e < 10; e++) {
                this._pointerData[e] = {
                    id: e,
                    x: 0,
                    y: 0,
                    isDown: false,
                    isUp: false,
                    isOver: false,
                    isOut: false,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: false
                }
            }
        },
        stop: function() {
            if (this.enabled === false) {
                return
            } else {
                this.enabled = false;
                this.game.input.interactiveItems.remove(this)
            }
        },
        destroy: function() {
            if (this.sprite) {
                if (this._setHandCursor) {
                    this.game.canvas.style.cursor = "default";
                    this._setHandCursor = false
                }
                this.enabled = false;
                this.game.input.interactiveItems.remove(this);
                this._pointerData.length = 0;
                this.boundsRect = null;
                this.boundsSprite = null;
                this.sprite = null
            }
        },
        validForInput: function(e, t) {
            if (this.sprite.scale.x === 0 || this.sprite.scale.y === 0 || this.priorityID < this.game.input.minPriorityID) {
                return false
            }
            if (this.pixelPerfectClick || this.pixelPerfectOver) {
                return true
            }
            if (this.priorityID > e || this.priorityID === e && this.sprite._cache[3] < t) {
                return true
            }
            return false
        },
        pointerX: function(e) {
            e = e || 0;
            return this._pointerData[e].x
        },
        pointerY: function(e) {
            e = e || 0;
            return this._pointerData[e].y
        },
        pointerDown: function(e) {
            e = e || 0;
            return this._pointerData[e].isDown
        },
        pointerUp: function(e) {
            e = e || 0;
            return this._pointerData[e].isUp
        },
        pointerTimeDown: function(e) {
            e = e || 0;
            return this._pointerData[e].timeDown
        },
        pointerTimeUp: function(e) {
            e = e || 0;
            return this._pointerData[e].timeUp
        },
        pointerOver: function(e) {
            if (this.enabled) {
                if (typeof e === "undefined") {
                    for (var t = 0; t < 10; t++) {
                        if (this._pointerData[t].isOver) {
                            return true
                        }
                    }
                } else {
                    return this._pointerData[e].isOver
                }
            }
            return false
        },
        pointerOut: function(e) {
            if (this.enabled) {
                if (typeof e === "undefined") {
                    for (var t = 0; t < 10; t++) {
                        if (this._pointerData[t].isOut) {
                            return true
                        }
                    }
                } else {
                    return this._pointerData[e].isOut
                }
            }
            return false
        },
        pointerTimeOver: function(e) {
            e = e || 0;
            return this._pointerData[e].timeOver
        },
        pointerTimeOut: function(e) {
            e = e || 0;
            return this._pointerData[e].timeOut
        },
        pointerDragged: function(e) {
            e = e || 0;
            return this._pointerData[e].isDragged
        },
        checkPointerDown: function(e) {
            if (!this.enabled || !this.sprite || !this.sprite.parent || !this.sprite.visible || !this.sprite.parent.visible) {
                return false
            }
            if (this.game.input.hitTest(this.sprite, e, this._tempPoint)) {
                if (this.pixelPerfectClick) {
                    return this.checkPixel(this._tempPoint.x, this._tempPoint.y)
                } else {
                    return true
                }
            }
            return false
        },
        checkPointerOver: function(e) {
            if (!this.enabled || !this.sprite || !this.sprite.parent || !this.sprite.visible || !this.sprite.parent.visible) {
                return false
            }
            if (this.game.input.hitTest(this.sprite, e, this._tempPoint)) {
                if (this.pixelPerfectOver) {
                    return this.checkPixel(this._tempPoint.x, this._tempPoint.y)
                } else {
                    return true
                }
            }
            return false
        },
        checkPixel: function(e, t, n) {
            if (this.sprite.texture.baseTexture.source) {
                this.game.input.hitContext.clearRect(0, 0, 1, 1);
                if (e === null && t === null) {
                    this.game.input.getLocalPosition(this.sprite, n, this._tempPoint);
                    var e = this._tempPoint.x;
                    var t = this._tempPoint.y
                }
                if (this.sprite.anchor.x !== 0) {
                    e -= -this.sprite.texture.frame.width * this.sprite.anchor.x
                }
                if (this.sprite.anchor.y !== 0) {
                    t -= -this.sprite.texture.frame.height * this.sprite.anchor.y
                }
                e += this.sprite.texture.frame.x;
                t += this.sprite.texture.frame.y;
                this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, e, t, 1, 1, 0, 0, 1, 1);
                var r = this.game.input.hitContext.getImageData(0, 0, 1, 1);
                if (r.data[3] >= this.pixelPerfectAlpha) {
                    return true
                }
            }
            return false
        },
        update: function(e) {
            if (this.sprite === null || this.sprite.parent === undefined) {
                return
            }
            if (!this.enabled || !this.sprite.visible || !this.sprite.parent.visible) {
                this._pointerOutHandler(e);
                return false
            }
            if (this.draggable && this._draggedPointerID == e.id) {
                return this.updateDrag(e)
            } else if (this._pointerData[e.id].isOver === true) {
                if (this.checkPointerOver(e)) {
                    this._pointerData[e.id].x = e.x - this.sprite.x;
                    this._pointerData[e.id].y = e.y - this.sprite.y;
                    return true
                } else {
                    this._pointerOutHandler(e);
                    return false
                }
            }
        },
        _pointerOverHandler: function(e) {
            if (this.sprite === null) {
                return
            }
            if (this._pointerData[e.id].isOver === false) {
                this._pointerData[e.id].isOver = true;
                this._pointerData[e.id].isOut = false;
                this._pointerData[e.id].timeOver = this.game.time.now;
                this._pointerData[e.id].x = e.x - this.sprite.x;
                this._pointerData[e.id].y = e.y - this.sprite.y;
                if (this.useHandCursor && this._pointerData[e.id].isDragged === false) {
                    this.game.canvas.style.cursor = "pointer";
                    this._setHandCursor = true
                }
                if (this.sprite && this.sprite.events) {
                    this.sprite.events.onInputOver.dispatch(this.sprite, e)
                }
            }
        },
        _pointerOutHandler: function(e) {
            if (this.sprite === null) {
                return
            }
            this._pointerData[e.id].isOver = false;
            this._pointerData[e.id].isOut = true;
            this._pointerData[e.id].timeOut = this.game.time.now;
            if (this.useHandCursor && this._pointerData[e.id].isDragged === false) {
                this.game.canvas.style.cursor = "default";
                this._setHandCursor = false
            }
            if (this.sprite && this.sprite.events) {
                this.sprite.events.onInputOut.dispatch(this.sprite, e)
            }
        },
        _touchedHandler: function(e) {
            if (this.sprite === null) {
                return
            }
            if (this._pointerData[e.id].isDown === false && this._pointerData[e.id].isOver === true) {
                if (this.pixelPerfectClick && !this.checkPixel(null, null, e)) {
                    return
                }
                this._pointerData[e.id].isDown = true;
                this._pointerData[e.id].isUp = false;
                this._pointerData[e.id].timeDown = this.game.time.now;
                if (this.sprite && this.sprite.events) {
                    this.sprite.events.onInputDown.dispatch(this.sprite, e)
                }
                if (this.draggable && this.isDragged === false) {
                    this.startDrag(e)
                }
                if (this.bringToTop) {
                    this.sprite.bringToTop()
                }
            }
            return this.consumePointerEvent
        },
        _releasedHandler: function(e) {
            if (this.sprite === null) {
                return
            }
            if (this._pointerData[e.id].isDown && e.isUp) {
                this._pointerData[e.id].isDown = false;
                this._pointerData[e.id].isUp = true;
                this._pointerData[e.id].timeUp = this.game.time.now;
                this._pointerData[e.id].downDuration = this._pointerData[e.id].timeUp - this._pointerData[e.id].timeDown;
                if (this.checkPointerOver(e)) {
                    if (this.sprite && this.sprite.events) {
                        this.sprite.events.onInputUp.dispatch(this.sprite, e, true)
                    }
                } else {
                    if (this.sprite && this.sprite.events) {
                        this.sprite.events.onInputUp.dispatch(this.sprite, e, false)
                    }
                    if (this.useHandCursor) {
                        this.game.canvas.style.cursor = "default";
                        this._setHandCursor = false
                    }
                }
                if (this.draggable && this.isDragged && this._draggedPointerID === e.id) {
                    this.stopDrag(e)
                }
            }
        },
        updateDrag: function(e) {
            if (e.isUp) {
                this.stopDrag(e);
                return false
            }
            if (this.sprite.fixedToCamera) {
                if (this.allowHorizontalDrag) {
                    this.sprite.cameraOffset.x = e.x + this._dragPoint.x + this.dragOffset.x
                }
                if (this.allowVerticalDrag) {
                    this.sprite.cameraOffset.y = e.y + this._dragPoint.y + this.dragOffset.y
                }
                if (this.boundsRect) {
                    this.checkBoundsRect()
                }
                if (this.boundsSprite) {
                    this.checkBoundsSprite()
                }
                if (this.snapOnDrag) {
                    this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
                    this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY
                }
            } else {
                if (this.allowHorizontalDrag) {
                    this.sprite.x = e.x + this._dragPoint.x + this.dragOffset.x
                }
                if (this.allowVerticalDrag) {
                    this.sprite.y = e.y + this._dragPoint.y + this.dragOffset.y
                }
                if (this.boundsRect) {
                    this.checkBoundsRect()
                }
                if (this.boundsSprite) {
                    this.checkBoundsSprite()
                }
                if (this.snapOnDrag) {
                    this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
                    this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY
                }
            }
            return true
        },
        justOver: function(e, t) {
            e = e || 0;
            t = t || 500;
            return this._pointerData[e].isOver && this.overDuration(e) < t
        },
        justOut: function(e, t) {
            e = e || 0;
            t = t || 500;
            return this._pointerData[e].isOut && this.game.time.now - this._pointerData[e].timeOut < t
        },
        justPressed: function(e, t) {
            e = e || 0;
            t = t || 500;
            return this._pointerData[e].isDown && this.downDuration(e) < t
        },
        justReleased: function(e, t) {
            e = e || 0;
            t = t || 500;
            return this._pointerData[e].isUp && this.game.time.now - this._pointerData[e].timeUp < t
        },
        overDuration: function(e) {
            e = e || 0;
            if (this._pointerData[e].isOver) {
                return this.game.time.now - this._pointerData[e].timeOver
            }
            return -1
        },
        downDuration: function(e) {
            e = e || 0;
            if (this._pointerData[e].isDown) {
                return this.game.time.now - this._pointerData[e].timeDown
            }
            return -1
        },
        enableDrag: function(e, n, r, i, s, o) {
            if (typeof e == "undefined") {
                e = false
            }
            if (typeof n == "undefined") {
                n = false
            }
            if (typeof r == "undefined") {
                r = false
            }
            if (typeof i == "undefined") {
                i = 255
            }
            if (typeof s == "undefined") {
                s = null
            }
            if (typeof o == "undefined") {
                o = null
            }
            this._dragPoint = new t.Point;
            this.draggable = true;
            this.bringToTop = n;
            this.dragOffset = new t.Point;
            this.dragFromCenter = e;
            this.pixelPerfect = r;
            this.pixelPerfectAlpha = i;
            if (s) {
                this.boundsRect = s
            }
            if (o) {
                this.boundsSprite = o
            }
        },
        disableDrag: function() {
            if (this._pointerData) {
                for (var e = 0; e < 10; e++) {
                    this._pointerData[e].isDragged = false
                }
            }
            this.draggable = false;
            this.isDragged = false;
            this._draggedPointerID = -1
        },
        startDrag: function(e) {
            this.isDragged = true;
            this._draggedPointerID = e.id;
            this._pointerData[e.id].isDragged = true;
            if (this.sprite.fixedToCamera) {
                if (this.dragFromCenter) {
                    this.sprite.centerOn(e.x, e.y);
                    this._dragPoint.setTo(this.sprite.cameraOffset.x - e.x, this.sprite.cameraOffset.y - e.y)
                } else {
                    this._dragPoint.setTo(this.sprite.cameraOffset.x - e.x, this.sprite.cameraOffset.y - e.y)
                }
            } else {
                if (this.dragFromCenter) {
                    var t = this.sprite.getBounds();
                    this.sprite.x = e.x + (this.sprite.x - t.centerX);
                    this.sprite.y = e.y + (this.sprite.y - t.centerY);
                    this._dragPoint.setTo(this.sprite.x - e.x, this.sprite.y - e.y)
                } else {
                    this._dragPoint.setTo(this.sprite.x - e.x, this.sprite.y - e.y)
                }
            }
            this.updateDrag(e);
            if (this.bringToTop) {
                this._dragPhase = true;
                this.sprite.bringToTop()
            }
            this.sprite.events.onDragStart.dispatch(this.sprite, e)
        },
        stopDrag: function(e) {
            this.isDragged = false;
            this._draggedPointerID = -1;
            this._pointerData[e.id].isDragged = false;
            this._dragPhase = false;
            if (this.snapOnRelease) {
                if (this.sprite.fixedToCamera) {
                    this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
                    this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY
                } else {
                    this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
                    this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY
                }
            }
            this.sprite.events.onDragStop.dispatch(this.sprite, e);
            if (this.checkPointerOver(e) === false) {
                this._pointerOutHandler(e)
            }
        },
        setDragLock: function(e, t) {
            if (typeof e == "undefined") {
                e = true
            }
            if (typeof t == "undefined") {
                t = true
            }
            this.allowHorizontalDrag = e;
            this.allowVerticalDrag = t
        },
        enableSnap: function(e, t, n, r, i, s) {
            if (typeof n == "undefined") {
                n = true
            }
            if (typeof r == "undefined") {
                r = false
            }
            if (typeof i == "undefined") {
                i = 0
            }
            if (typeof s == "undefined") {
                s = 0
            }
            this.snapX = e;
            this.snapY = t;
            this.snapOffsetX = i;
            this.snapOffsetY = s;
            this.snapOnDrag = n;
            this.snapOnRelease = r
        },
        disableSnap: function() {
            this.snapOnDrag = false;
            this.snapOnRelease = false
        },
        checkBoundsRect: function() {
            if (this.sprite.fixedToCamera) {
                if (this.sprite.cameraOffset.x < this.boundsRect.left) {
                    this.sprite.cameraOffset.x = this.boundsRect.cameraOffset.x
                } else if (this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right) {
                    this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width
                }
                if (this.sprite.cameraOffset.y < this.boundsRect.top) {
                    this.sprite.cameraOffset.y = this.boundsRect.top
                } else if (this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom) {
                    this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height
                }
            } else {
                if (this.sprite.x < this.boundsRect.left) {
                    this.sprite.x = this.boundsRect.x
                } else if (this.sprite.x + this.sprite.width > this.boundsRect.right) {
                    this.sprite.x = this.boundsRect.right - this.sprite.width
                }
                if (this.sprite.y < this.boundsRect.top) {
                    this.sprite.y = this.boundsRect.top
                } else if (this.sprite.y + this.sprite.height > this.boundsRect.bottom) {
                    this.sprite.y = this.boundsRect.bottom - this.sprite.height
                }
            }
        },
        checkBoundsSprite: function() {
            if (this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera) {
                if (this.sprite.cameraOffset.x < this.boundsSprite.camerOffset.x) {
                    this.sprite.cameraOffset.x = this.boundsSprite.camerOffset.x
                } else if (this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.camerOffset.x + this.boundsSprite.width) {
                    this.sprite.cameraOffset.x = this.boundsSprite.camerOffset.x + this.boundsSprite.width - this.sprite.width
                }
                if (this.sprite.cameraOffset.y < this.boundsSprite.camerOffset.y) {
                    this.sprite.cameraOffset.y = this.boundsSprite.camerOffset.y
                } else if (this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.camerOffset.y + this.boundsSprite.height) {
                    this.sprite.cameraOffset.y = this.boundsSprite.camerOffset.y + this.boundsSprite.height - this.sprite.height
                }
            } else {
                if (this.sprite.x < this.boundsSprite.x) {
                    this.sprite.x = this.boundsSprite.x
                } else if (this.sprite.x + this.sprite.width > this.boundsSprite.x + this.boundsSprite.width) {
                    this.sprite.x = this.boundsSprite.x + this.boundsSprite.width - this.sprite.width
                }
                if (this.sprite.y < this.boundsSprite.y) {
                    this.sprite.y = this.boundsSprite.y
                } else if (this.sprite.y + this.sprite.height > this.boundsSprite.y + this.boundsSprite.height) {
                    this.sprite.y = this.boundsSprite.y + this.boundsSprite.height - this.sprite.height
                }
            }
        }
    };
    t.InputHandler.prototype.constructor = t.InputHandler;
    t.Events = function(e) {
        this.parent = e;
        this.onAddedToGroup = new t.Signal;
        this.onRemovedFromGroup = new t.Signal;
        this.onKilled = new t.Signal;
        this.onRevived = new t.Signal;
        this.onOutOfBounds = new t.Signal;
        this.onEnterBounds = new t.Signal;
        this.onInputOver = null;
        this.onInputOut = null;
        this.onInputDown = null;
        this.onInputUp = null;
        this.onDragStart = null;
        this.onDragStop = null;
        this.onAnimationStart = null;
        this.onAnimationComplete = null;
        this.onAnimationLoop = null
    };
    t.Events.prototype = {
        destroy: function() {
            this.parent = null;
            this.onAddedToGroup.dispose();
            this.onRemovedFromGroup.dispose();
            this.onKilled.dispose();
            this.onRevived.dispose();
            this.onOutOfBounds.dispose();
            if (this.onInputOver) {
                this.onInputOver.dispose();
                this.onInputOut.dispose();
                this.onInputDown.dispose();
                this.onInputUp.dispose();
                this.onDragStart.dispose();
                this.onDragStop.dispose()
            }
            if (this.onAnimationStart) {
                this.onAnimationStart.dispose();
                this.onAnimationComplete.dispose();
                this.onAnimationLoop.dispose()
            }
        }
    };
    t.Events.prototype.constructor = t.Events;
    t.GameObjectFactory = function(e) {
        this.game = e;
        this.world = this.game.world
    };
    t.GameObjectFactory.prototype = {
        existing: function(e) {
            return this.world.add(e)
        },
        image: function(e, n, r, i, s) {
            if (typeof s === "undefined") {
                s = this.world
            }
            return s.add(new t.Image(this.game, e, n, r, i))
        },
        sprite: function(e, t, n, r, i) {
            if (typeof i === "undefined") {
                i = this.world
            }
            return i.create(e, t, n, r)
        },
        tween: function(e) {
            return this.game.tweens.create(e)
        },
        group: function(e, n, r, i, s) {
            return new t.Group(this.game, e, n, r, i, s)
        },
        physicsGroup: function(e, n, r, i) {
            return new t.Group(this.game, n, r, i, true, e)
        },
        spriteBatch: function(e, n, r) {
            if (typeof n === "undefined") {
                n = "group"
            }
            if (typeof r === "undefined") {
                r = false
            }
            return new t.SpriteBatch(this.game, e, n, r)
        },
        audio: function(e, t, n, r) {
            return this.game.sound.add(e, t, n, r)
        },
        sound: function(e, t, n, r) {
            return this.game.sound.add(e, t, n, r)
        },
        tileSprite: function(e, n, r, i, s, o, u) {
            if (typeof u === "undefined") {
                u = this.world
            }
            return u.add(new t.TileSprite(this.game, e, n, r, i, s, o))
        },
        text: function(e, n, r, i, s) {
            if (typeof s === "undefined") {
                s = this.world
            }
            return s.add(new t.Text(this.game, e, n, r, i))
        },
        button: function(e, n, r, i, s, o, u, a, f, l) {
            if (typeof l === "undefined") {
                l = this.world
            }
            return l.add(new t.Button(this.game, e, n, r, i, s, o, u, a, f))
        },
        graphics: function(e, n, r) {
            if (typeof r === "undefined") {
                r = this.world
            }
            return r.add(new t.Graphics(this.game, e, n))
        },
        emitter: function(e, n, r) {
            return this.game.particles.add(new t.Particles.Arcade.Emitter(this.game, e, n, r))
        },
        retroFont: function(e, n, r, i, s, o, u, a, f) {
            return new t.RetroFont(this.game, e, n, r, i, s, o, u, a, f)
        },
        bitmapText: function(e, n, r, i, s, o) {
            if (typeof o === "undefined") {
                o = this.world
            }
            return o.add(new t.BitmapText(this.game, e, n, r, i, s))
        },
        tilemap: function(e, n, r, i, s) {
            return new t.Tilemap(this.game, e, n, r, i, s)
        },
        renderTexture: function(e, n, r, i) {
            if (typeof r === "undefined" || r === "") {
                r = this.game.rnd.uuid()
            }
            if (typeof i === "undefined") {
                i = false
            }
            var s = new t.RenderTexture(this.game, e, n, r);
            if (i) {
                this.game.cache.addRenderTexture(r, s)
            }
            return s
        },
        bitmapData: function(e, n, r, i) {
            if (typeof i === "undefined") {
                i = false
            }
            if (typeof r === "undefined" || r === "") {
                r = this.game.rnd.uuid()
            }
            var s = new t.BitmapData(this.game, r, e, n);
            if (i) {
                this.game.cache.addBitmapData(r, s)
            }
            return s
        },
        filter: function(e) {
            var n = Array.prototype.splice.call(arguments, 1);
            var e = new t.Filter[e](this.game);
            e.init.apply(e, n);
            return e
        }
    };
    t.GameObjectFactory.prototype.constructor = t.GameObjectFactory;
    t.GameObjectCreator = function(e) {
        this.game = e;
        this.world = this.game.world
    };
    t.GameObjectCreator.prototype = {
        image: function(e, n, r, i) {
            return new t.Image(this.game, e, n, r, i)
        },
        sprite: function(e, n, r, i) {
            return new t.Sprite(this.game, e, n, r, i)
        },
        tween: function(e) {
            return new t.Tween(e, this.game)
        },
        group: function(e, n, r, i, s) {
            return new t.Group(this.game, null, n, r, i, s)
        },
        spriteBatch: function(e, n, r) {
            if (typeof n === "undefined") {
                n = "group"
            }
            if (typeof r === "undefined") {
                r = false
            }
            return new t.SpriteBatch(this.game, e, n, r)
        },
        audio: function(e, t, n, r) {
            return this.game.sound.add(e, t, n, r)
        },
        sound: function(e, t, n, r) {
            return this.game.sound.add(e, t, n, r)
        },
        tileSprite: function(e, n, r, i, s, o) {
            return new t.TileSprite(this.game, e, n, r, i, s, o)
        },
        text: function(e, n, r, i) {
            return new t.Text(this.game, e, n, r, i)
        },
        button: function(e, n, r, i, s, o, u, a, f) {
            return new t.Button(this.game, e, n, r, i, s, o, u, a, f)
        },
        graphics: function(e, n) {
            return new t.Graphics(this.game, e, n)
        },
        emitter: function(e, n, r) {
            return new t.Particles.Arcade.Emitter(this.game, e, n, r)
        },
        retroFont: function(e, n, r, i, s, o, u, a, f) {
            return new t.RetroFont(this.game, e, n, r, i, s, o, u, a, f)
        },
        bitmapText: function(e, n, r, i, s) {
            return new t.BitmapText(this.game, e, n, r, i, s)
        },
        tilemap: function(e, n, r, i, s) {
            return new t.Tilemap(this.game, e, n, r, i, s)
        },
        renderTexture: function(e, n, r, i) {
            if (typeof r === "undefined" || r === "") {
                r = this.game.rnd.uuid()
            }
            if (typeof i === "undefined") {
                i = false
            }
            var s = new t.RenderTexture(this.game, e, n, r);
            if (i) {
                this.game.cache.addRenderTexture(r, s)
            }
            return s
        },
        bitmapData: function(e, n, r, i) {
            if (typeof i === "undefined") {
                i = false
            }
            if (typeof r === "undefined" || r === "") {
                r = this.game.rnd.uuid()
            }
            var s = new t.BitmapData(this.game, r, e, n);
            if (i) {
                this.game.cache.addBitmapData(r, s)
            }
            return s
        },
        filter: function(e) {
            var n = Array.prototype.splice.call(arguments, 1);
            var e = new t.Filter[e](this.game);
            e.init.apply(e, n);
            return e
        }
    };
    t.GameObjectCreator.prototype.constructor = t.GameObjectCreator;
    t.BitmapData = function(e, n, r, i) {
        if (typeof r === "undefined") {
            r = 100
        }
        if (typeof i === "undefined") {
            i = 100
        }
        this.game = e;
        this.key = n;
        this.width = r;
        this.height = i;
        this.canvas = t.Canvas.create(r, i, "", true);
        this.context = this.canvas.getContext("2d");
        this.ctx = this.context;
        this.imageData = this.context.getImageData(0, 0, r, i);
        this.data = this.imageData.data;
        this.pixels = null;
        if (this.imageData.data.buffer) {
            this.buffer = this.imageData.data.buffer;
            this.pixels = new Uint32Array(this.buffer)
        } else {
            if (window["ArrayBuffer"]) {
                this.buffer = new ArrayBuffer(this.imageData.data.length);
                this.pixels = new Uint32Array(this.buffer)
            } else {
                this.pixels = this.imageData.data
            }
        }
        this.baseTexture = new PIXI.BaseTexture(this.canvas);
        this.texture = new PIXI.Texture(this.baseTexture);
        this.textureFrame = new t.Frame(0, 0, 0, r, i, "bitmapData", e.rnd.uuid());
        this.type = t.BITMAPDATA;
        this.disableTextureUpload = false;
        this.dirty = false;
        this.cls = this.clear;
        this.update = this.refreshBuffer;
        this._tempR = 0;
        this._tempG = 0;
        this._tempB = 0
    };
    t.BitmapData.prototype = {
        add: function(e) {
            if (Array.isArray(e)) {
                for (var t = 0; t < e.length; t++) {
                    if (e[t]["loadTexture"]) {
                        e[t].loadTexture(this)
                    }
                }
            } else {
                e.loadTexture(this)
            }
        },
        clear: function() {
            this.context.clearRect(0, 0, this.width, this.height);
            this.dirty = true
        },
        fill: function(e, t, n, r) {
            if (typeof r === "undefined") {
                r = 1
            }
            this.context.fillStyle = "rgba(" + e + "," + t + "," + n + "," + r + ")";
            this.context.fillRect(0, 0, this.width, this.height);
            this.dirty = true
        },
        resize: function(e, t) {
            if (e !== this.width || t !== this.height) {
                this.width = e;
                this.height = t;
                this.canvas.width = e;
                this.canvas.height = t;
                this.textureFrame.width = e;
                this.textureFrame.height = t;
                this.refreshBuffer()
            }
            this.dirty = true
        },
        refreshBuffer: function(e, t, n, r) {
            if (typeof e === "undefined") {
                e = 0
            }
            if (typeof t === "undefined") {
                t = 0
            }
            if (typeof n === "undefined") {
                n = this.width
            }
            if (typeof r === "undefined") {
                r = this.height
            }
            this.imageData = this.context.getImageData(e, t, n, r);
            this.data = this.imageData.data;
            if (this.imageData.data.buffer) {
                this.buffer = this.imageData.data.buffer;
                this.pixels = new Uint32Array(this.buffer)
            } else {
                if (window["ArrayBuffer"]) {
                    this.buffer = new ArrayBuffer(this.imageData.data.length);
                    this.pixels = new Uint32Array(this.buffer)
                } else {
                    this.pixels = this.imageData.data
                }
            }
        },
        processPixelRGB: function(e, n, r, i, s, o) {
            if (typeof r === "undefined") {
                r = 0
            }
            if (typeof i === "undefined") {
                i = 0
            }
            if (typeof s === "undefined") {
                s = this.width
            }
            if (typeof o === "undefined") {
                o = this.height
            }
            var u = r + s;
            var a = i + o;
            var f = t.Color.createColor();
            var l = {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            };
            var c = false;
            for (var h = i; h < a; h++) {
                for (var p = r; p < u; p++) {
                    t.Color.unpackPixel(this.getPixel32(p, h), f);
                    l = e.call(n, f, p, h);
                    if (l !== false && l !== null && l !== undefined) {
                        this.setPixel32(p, h, l.r, l.g, l.b, l.a, false);
                        c = true
                    }
                }
            }
            if (c) {
                this.context.putImageData(this.imageData, 0, 0);
                this.dirty = true
            }
        },
        processPixel: function(e, t, n, r, i, s) {
            if (typeof n === "undefined") {
                n = 0
            }
            if (typeof r === "undefined") {
                r = 0
            }
            if (typeof i === "undefined") {
                i = this.width
            }
            if (typeof s === "undefined") {
                s = this.height
            }
            var o = n + i;
            var u = r + s;
            var a = 0;
            var f = 0;
            var l = false;
            for (var c = r; c < u; c++) {
                for (var h = n; h < o; h++) {
                    a = this.getPixel32(h, c);
                    f = e.call(t, a, h, c);
                    if (f !== a) {
                        this.pixels[c * this.width + h] = f;
                        l = true
                    }
                }
            }
            if (l) {
                this.context.putImageData(this.imageData, 0, 0);
                this.dirty = true
            }
        },
        replaceRGB: function(e, n, r, i, s, o, u, a, f) {
            var l = 0;
            var c = 0;
            var h = this.width;
            var p = this.height;
            var d = t.Color.packPixel(e, n, r, i);
            if (f !== undefined && f instanceof t.Rectangle) {
                l = f.x;
                c = f.y;
                h = f.width;
                p = f.height
            }
            for (var v = 0; v < p; v++) {
                for (var m = 0; m < h; m++) {
                    if (this.getPixel32(l + m, c + v) === d) {
                        this.setPixel32(l + m, c + v, s, o, u, a, false)
                    }
                }
            }
            this.context.putImageData(this.imageData, 0, 0);
            this.dirty = true
        },
        setHSL: function(e, n, r, i) {
            if (typeof e === "undefined" || e === null) {
                e = false
            }
            if (typeof n === "undefined" || n === null) {
                n = false
            }
            if (typeof r === "undefined" || r === null) {
                r = false
            }
            if (!e && !n && !r) {
                return
            }
            if (typeof i === "undefined") {
                i = new t.Rectangle(0, 0, this.width, this.height)
            }
            var s = t.Color.createColor();
            for (var o = i.y; o < i.bottom; o++) {
                for (var u = i.x; u < i.right; u++) {
                    t.Color.unpackPixel(this.getPixel32(u, o), s, true);
                    if (e) {
                        s.h = e
                    }
                    if (n) {
                        s.s = n
                    }
                    if (r) {
                        s.l = r
                    }
                    t.Color.HSLtoRGB(s.h, s.s, s.l, s);
                    this.setPixel32(u, o, s.r, s.g, s.b, s.a, false)
                }
            }
            this.context.putImageData(this.imageData, 0, 0);
            this.dirty = true
        },
        shiftHSL: function(e, n, r, i) {
            if (typeof e === "undefined" || e === null) {
                e = false
            }
            if (typeof n === "undefined" || n === null) {
                n = false
            }
            if (typeof r === "undefined" || r === null) {
                r = false
            }
            if (!e && !n && !r) {
                return
            }
            if (typeof i === "undefined") {
                i = new t.Rectangle(0, 0, this.width, this.height)
            }
            var s = t.Color.createColor();
            for (var o = i.y; o < i.bottom; o++) {
                for (var u = i.x; u < i.right; u++) {
                    t.Color.unpackPixel(this.getPixel32(u, o), s, true);
                    if (e) {
                        s.h = this.game.math.wrap(s.h + e, 0, 1)
                    }
                    if (n) {
                        s.s = this.game.math.limitValue(s.s + n, 0, 1)
                    }
                    if (r) {
                        s.l = this.game.math.limitValue(s.l + r, 0, 1)
                    }
                    t.Color.HSLtoRGB(s.h, s.s, s.l, s);
                    this.setPixel32(u, o, s.r, s.g, s.b, s.a, false)
                }
            }
            this.context.putImageData(this.imageData, 0, 0);
            this.dirty = true
        },
        setPixel32: function(e, n, r, i, s, o, u) {
            if (typeof u === "undefined") {
                u = true
            }
            if (e >= 0 && e <= this.width && n >= 0 && n <= this.height) {
                if (t.Device.LITTLE_ENDIAN) {
                    this.pixels[n * this.width + e] = o << 24 | s << 16 | i << 8 | r
                } else {
                    this.pixels[n * this.width + e] = r << 24 | i << 16 | s << 8 | o
                }
                if (u) {
                    this.context.putImageData(this.imageData, 0, 0);
                    this.dirty = true
                }
            }
        },
        setPixel: function(e, t, n, r, i, s) {
            this.setPixel32(e, t, n, r, i, 255, s)
        },
        getPixel: function(e, n, r) {
            if (!r) {
                r = t.Color.createColor()
            }
            var i = ~~ (e + n * this.width);
            i *= 4;
            if (this.data[i]) {
                r.r = this.data[i];
                r.g = this.data[++i];
                r.b = this.data[++i];
                r.a = this.data[++i]
            }
            return r
        },
        getPixel32: function(e, t) {
            if (e >= 0 && e <= this.width && t >= 0 && t <= this.height) {
                return this.pixels[t * this.width + e]
            }
        },
        getPixelRGB: function(e, n, r, i, s) {
            return t.Color.unpackPixel(this.getPixel32(e, n), r, i, s)
        },
        getPixels: function(e) {
            return this.context.getImageData(e.x, e.y, e.width, e.height)
        },
        copyPixels: function(e, t, n, r) {
            if (typeof e === "string") {
                e = this.game.cache.getImage(e)
            }
            if (e) {
                this.context.drawImage(e, t.x, t.y, t.width, t.height, n, r, t.width, t.height)
            }
            this.dirty = true
        },
        draw: function(e, t, n) {
            if (typeof t === "undefined") {
                t = 0
            }
            if (typeof n === "undefined") {
                n = 0
            }
            if (typeof e === "string") {
                e = this.game.cache.getImage(e)
            }
            if (e) {
                this.context.drawImage(e, 0, 0, e.width, e.height, t, n, e.width, e.height)
            }
            this.dirty = true
        },
        drawSprite: function(e, t, n) {
            if (typeof t === "undefined") {
                t = 0
            }
            if (typeof n === "undefined") {
                n = 0
            }
            var r = e.texture.frame;
            this.context.drawImage(e.texture.baseTexture.source, r.x, r.y, r.width, r.height, t, n, r.width, r.height);
            this.dirty = true
        },
        alphaMask: function(e, t) {
            var n = this.context.globalCompositeOperation;
            if (typeof t === "string") {
                t = this.game.cache.getImage(t)
            }
            if (t) {
                this.context.drawImage(t, 0, 0)
            }
            this.context.globalCompositeOperation = "source-atop";
            if (typeof e === "string") {
                e = this.game.cache.getImage(e)
            }
            if (e) {
                this.context.drawImage(e, 0, 0)
            }
            this.context.globalCompositeOperation = n;
            this.dirty = true
        },
        extract: function(e, t, n, r, i) {
            if (typeof i === "undefined") {
                i = 255
            }
            this.processPixelRGB(function(s, o, u) {
                if (s.r === t && s.g === n && s.b === r) {
                    e.setPixel32(o, u, t, n, r, i, false)
                }
                return false
            }, this);
            e.context.putImageData(e.imageData, 0, 0);
            e.dirty = true;
            return e
        },
        rect: function(e, t, n, r, i) {
            if (typeof i !== "undefined") {
                this.context.fillStyle = i
            }
            this.context.fillRect(e, t, n, r);
            this.context.fill()
        },
        circle: function(e, t, n, r) {
            if (typeof r !== "undefined") {
                this.context.fillStyle = r
            }
            this.context.beginPath();
            this.context.arc(e, t, n, 0, Math.PI * 2, false);
            this.context.closePath();
            this.context.fill()
        },
        render: function() {
            if (!this.disableTextureUpload && this.game.renderType === t.WEBGL && this.dirty) {
                PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl);
                this.dirty = false
            }
        }
    };
    t.BitmapData.prototype.constructor = t.BitmapData;
    t.Sprite = function(e, n, r, i, s) {
        n = n || 0;
        r = r || 0;
        i = i || null;
        s = s || null;
        this.game = e;
        this.name = "";
        this.type = t.SPRITE;
        this.z = 0;
        this.events = new t.Events(this);
        this.animations = new t.AnimationManager(this);
        this.key = i;
        this._frame = 0;
        this._frameName = "";
        PIXI.Sprite.call(this, PIXI.TextureCache["__default"]);
        this.loadTexture(i, s);
        this.position.set(n, r);
        this.world = new t.Point(n, r);
        this.autoCull = false;
        this.input = null;
        this.body = null;
        this.health = 1;
        this.lifespan = 0;
        this.checkWorldBounds = false;
        this.outOfBoundsKill = false;
        this.debug = false;
        this.cameraOffset = new t.Point;
        this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0];
        this._bounds = new t.Rectangle
    };
    t.Sprite.prototype = Object.create(PIXI.Sprite.prototype);
    t.Sprite.prototype.constructor = t.Sprite;
    t.Sprite.prototype.preUpdate = function() {
        if (this._cache[4] === 1 && this.exists) {
            this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y);
            this.worldTransform.tx = this.world.x;
            this.worldTransform.ty = this.world.y;
            this._cache[0] = this.world.x;
            this._cache[1] = this.world.y;
            this._cache[2] = this.rotation;
            if (this.body) {
                this.body.preUpdate()
            }
            this._cache[4] = 0;
            return false
        }
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this._cache[3] = -1;
            return false
        }
        if (this.lifespan > 0) {
            this.lifespan -= this.game.time.elapsed;
            if (this.lifespan <= 0) {
                this.kill();
                return false
            }
        }
        if (this.autoCull || this.checkWorldBounds) {
            this._bounds.copyFrom(this.getBounds())
        }
        if (this.autoCull) {
            this.renderable = this.game.world.camera.screenView.intersects(this._bounds)
        }
        if (this.checkWorldBounds) {
            if (this._cache[5] === 1 && this.game.world.bounds.intersects(this._bounds)) {
                this._cache[5] = 0;
                this.events.onEnterBounds.dispatch(this)
            } else if (this._cache[5] === 0 && !this.game.world.bounds.intersects(this._bounds)) {
                this._cache[5] = 1;
                this.events.onOutOfBounds.dispatch(this);
                if (this.outOfBoundsKill) {
                    this.kill();
                    return false
                }
            }
        }
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++
        }
        this.animations.update();
        if (this.body) {
            this.body.preUpdate()
        }
        for (var e = 0, t = this.children.length; e < t; e++) {
            this.children[e].preUpdate()
        }
        return true
    };
    t.Sprite.prototype.update = function() {};
    t.Sprite.prototype.postUpdate = function() {
        if (this.key instanceof t.BitmapData) {
            this.key.render()
        }
        if (this.exists && this.body) {
            this.body.postUpdate()
        }
        if (this._cache[7] === 1) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y
        }
        for (var e = 0, n = this.children.length; e < n; e++) {
            this.children[e].postUpdate()
        }
    };
    t.Sprite.prototype.loadTexture = function(e, n) {
        n = n || 0;
        if (e instanceof t.RenderTexture) {
            this.key = e.key;
            this.setTexture(e);
            return
        } else if (e instanceof t.BitmapData) {
            this.key = e;
            this.setTexture(e.texture);
            return
        } else if (e instanceof PIXI.Texture) {
            this.key = e;
            this.setTexture(e);
            return
        } else {
            if (e === null || typeof e === "undefined") {
                this.key = "__default";
                this.setTexture(PIXI.TextureCache[this.key]);
                return
            } else if (typeof e === "string" && !this.game.cache.checkImageKey(e)) {
                this.key = "__missing";
                this.setTexture(PIXI.TextureCache[this.key]);
                return
            }
            if (this.game.cache.isSpriteSheet(e)) {
                this.key = e;
                this.animations.loadFrameData(this.game.cache.getFrameData(e));
                if (typeof n === "string") {
                    this.frameName = n
                } else {
                    this.frame = n
                }
            } else {
                this.key = e;
                this.setTexture(PIXI.TextureCache[e]);
                return
            }
        }
    };
    t.Sprite.prototype.crop = function(e) {
        if (typeof e === "undefined" || e === null) {
            if (this.texture.hasOwnProperty("sourceWidth")) {
                this.texture.setFrame(new t.Rectangle(0, 0, this.texture.sourceWidth, this.texture.sourceHeight))
            }
        } else {
            if (this.texture instanceof PIXI.Texture) {
                var n = {};
                t.Utils.extend(true, n, this.texture);
                n.sourceWidth = n.width;
                n.sourceHeight = n.height;
                n.frame = e;
                n.width = e.width;
                n.height = e.height;
                this.texture = n;
                this.texture.updateFrame = true;
                PIXI.Texture.frameUpdates.push(this.texture)
            } else {
                this.texture.setFrame(e)
            }
        }
    };
    t.Sprite.prototype.revive = function(e) {
        if (typeof e === "undefined") {
            e = 1
        }
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.health = e;
        if (this.events) {
            this.events.onRevived.dispatch(this)
        }
        return this
    };
    t.Sprite.prototype.kill = function() {
        this.alive = false;
        this.exists = false;
        this.visible = false;
        if (this.events) {
            this.events.onKilled.dispatch(this)
        }
        return this
    };
    t.Sprite.prototype.destroy = function(e) {
        if (this.game === null || this._cache[8] === 1) {
            return
        }
        if (typeof e === "undefined") {
            e = true
        }
        this._cache[8] = 1;
        if (this.parent) {
            if (this.parent instanceof t.Group) {
                this.parent.remove(this)
            } else {
                this.parent.removeChild(this)
            }
        }
        if (this.input) {
            this.input.destroy()
        }
        if (this.animations) {
            this.animations.destroy()
        }
        if (this.body) {
            this.body.destroy()
        }
        if (this.events) {
            this.events.destroy()
        }
        var n = this.children.length;
        if (e) {
            while (n--) {
                this.children[n].destroy(e)
            }
        } else {
            while (n--) {
                this.removeChild(this.children[n])
            }
        }
        this.alive = false;
        this.exists = false;
        this.visible = false;
        this.filters = null;
        this.mask = null;
        this.game = null;
        this._cache[8] = 0
    };
    t.Sprite.prototype.damage = function(e) {
        if (this.alive) {
            this.health -= e;
            if (this.health <= 0) {
                this.kill()
            }
        }
        return this
    };
    t.Sprite.prototype.reset = function(e, t, n) {
        if (typeof n === "undefined") {
            n = 1
        }
        this.world.setTo(e, t);
        this.position.x = e;
        this.position.y = t;
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.renderable = true;
        this._outOfBoundsFired = false;
        this.health = n;
        if (this.body) {
            this.body.reset(e, t, false, false)
        }
        this._cache[4] = 1;
        return this
    };
    t.Sprite.prototype.bringToTop = function() {
        if (this.parent) {
            this.parent.bringToTop(this)
        }
        return this
    };
    t.Sprite.prototype.play = function(e, t, n, r) {
        if (this.animations) {
            return this.animations.play(e, t, n, r)
        }
    };
    t.Sprite.prototype.overlap = function(e) {
        return t.Rectangle.intersects(this.getBounds(), e.getBounds())
    };
    Object.defineProperty(t.Sprite.prototype, "angle", {
        get: function() {
            return t.Math.wrapAngle(t.Math.radToDeg(this.rotation))
        },
        set: function(e) {
            this.rotation = t.Math.degToRad(t.Math.wrapAngle(e))
        }
    });
    Object.defineProperty(t.Sprite.prototype, "deltaX", {
        get: function() {
            return this.world.x - this._cache[0]
        }
    });
    Object.defineProperty(t.Sprite.prototype, "deltaY", {
        get: function() {
            return this.world.y - this._cache[1]
        }
    });
    Object.defineProperty(t.Sprite.prototype, "deltaZ", {
        get: function() {
            return this.rotation - this._cache[2]
        }
    });
    Object.defineProperty(t.Sprite.prototype, "inWorld", {
        get: function() {
            return this.game.world.bounds.intersects(this.getBounds())
        }
    });
    Object.defineProperty(t.Sprite.prototype, "inCamera", {
        get: function() {
            return this.game.world.camera.screenView.intersects(this.getBounds())
        }
    });
    Object.defineProperty(t.Sprite.prototype, "frame", {
        get: function() {
            return this.animations.frame
        },
        set: function(e) {
            this.animations.frame = e
        }
    });
    Object.defineProperty(t.Sprite.prototype, "frameName", {
        get: function() {
            return this.animations.frameName
        },
        set: function(e) {
            this.animations.frameName = e
        }
    });
    Object.defineProperty(t.Sprite.prototype, "renderOrderID", {
        get: function() {
            return this._cache[3]
        }
    });
    Object.defineProperty(t.Sprite.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled
        },
        set: function(e) {
            if (e) {
                if (this.input === null) {
                    this.input = new t.InputHandler(this);
                    this.input.start()
                } else if (this.input && !this.input.enabled) {
                    this.input.start()
                }
            } else {
                if (this.input && this.input.enabled) {
                    this.input.stop()
                }
            }
        }
    });
    Object.defineProperty(t.Sprite.prototype, "exists", {
        get: function() {
            return !!this._cache[6]
        },
        set: function(e) {
            if (e) {
                this._cache[6] = 1;
                if (this.body && this.body.type === t.Physics.P2JS) {
                    this.body.addToWorld()
                }
                this.visible = true
            } else {
                this._cache[6] = 0;
                if (this.body && this.body.type === t.Physics.P2JS) {
                    this.body.removeFromWorld()
                }
                this.visible = false
            }
        }
    });
    Object.defineProperty(t.Sprite.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7]
        },
        set: function(e) {
            if (e) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y)
            } else {
                this._cache[7] = 0
            }
        }
    });
    Object.defineProperty(t.Sprite.prototype, "smoothed", {
        get: function() {
            return !this.texture.baseTexture.scaleMode
        },
        set: function(e) {
            if (e) {
                if (this.texture) {
                    this.texture.baseTexture.scaleMode = 0
                }
            } else {
                if (this.texture) {
                    this.texture.baseTexture.scaleMode = 1
                }
            }
        }
    });
    Object.defineProperty(t.Sprite.prototype, "x", {
        get: function() {
            return this.position.x
        },
        set: function(e) {
            this.position.x = e;
            if (this.body && this.body.type === t.Physics.ARCADE && this.body.phase === 2) {
                this.body._reset = 1
            }
        }
    });
    Object.defineProperty(t.Sprite.prototype, "y", {
        get: function() {
            return this.position.y
        },
        set: function(e) {
            this.position.y = e;
            if (this.body && this.body.type === t.Physics.ARCADE && this.body.phase === 2) {
                this.body._reset = 1
            }
        }
    });
    Object.defineProperty(t.Sprite.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8]
        }
    });
    t.Image = function(e, n, r, i, s) {
        n = n || 0;
        r = r || 0;
        i = i || null;
        s = s || null;
        this.game = e;
        this.exists = true;
        this.name = "";
        this.type = t.IMAGE;
        this.z = 0;
        this.events = new t.Events(this);
        this.key = i;
        this._frame = 0;
        this._frameName = "";
        PIXI.Sprite.call(this, PIXI.TextureCache["__default"]);
        this.loadTexture(i, s);
        this.position.set(n, r);
        this.world = new t.Point(n, r);
        this.autoCull = false;
        this.input = null;
        this.cameraOffset = new t.Point;
        this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0]
    };
    t.Image.prototype = Object.create(PIXI.Sprite.prototype);
    t.Image.prototype.constructor = t.Image;
    t.Image.prototype.preUpdate = function() {
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this._cache[3] = -1;
            return false
        }
        if (this.autoCull) {
            this.renderable = this.game.world.camera.screenView.intersects(this.getBounds())
        }
        this.world.setTo(this.game.camera.x + this.worldTransform[2], this.game.camera.y + this.worldTransform[5]);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++
        }
        for (var e = 0, t = this.children.length; e < t; e++) {
            this.children[e].preUpdate()
        }
        return true
    };
    t.Image.prototype.update = function() {};
    t.Image.prototype.postUpdate = function() {
        if (this.key instanceof t.BitmapData) {
            this.key.render()
        }
        if (this._cache[7] === 1) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y
        }
        for (var e = 0, n = this.children.length; e < n; e++) {
            this.children[e].postUpdate()
        }
    };
    t.Image.prototype.loadTexture = function(e, n) {
        n = n || 0;
        if (e instanceof t.RenderTexture) {
            this.key = e.key;
            this.setTexture(e);
            return
        } else if (e instanceof t.BitmapData) {
            this.key = e;
            this.setTexture(e.texture);
            return
        } else if (e instanceof PIXI.Texture) {
            this.key = e;
            this.setTexture(e);
            return
        } else {
            if (e === null || typeof e === "undefined") {
                this.key = "__default";
                this.setTexture(PIXI.TextureCache[this.key]);
                return
            } else if (typeof e === "string" && !this.game.cache.checkImageKey(e)) {
                this.key = "__missing";
                this.setTexture(PIXI.TextureCache[this.key]);
                return
            }
            if (this.game.cache.isSpriteSheet(e)) {
                this.key = e;
                var r = this.game.cache.getFrameData(e);
                if (typeof n === "string") {
                    this._frame = 0;
                    this._frameName = n;
                    this.setTexture(PIXI.TextureCache[r.getFrameByName(n).uuid]);
                    return
                } else {
                    this._frame = n;
                    this._frameName = "";
                    this.setTexture(PIXI.TextureCache[r.getFrame(n).uuid]);
                    return
                }
            } else {
                this.key = e;
                this.setTexture(PIXI.TextureCache[e]);
                return
            }
        }
    };
    t.Image.prototype.crop = function(e) {
        if (typeof e === "undefined" || e === null) {
            if (this.texture.hasOwnProperty("sourceWidth")) {
                this.texture.setFrame(new t.Rectangle(0, 0, this.texture.sourceWidth, this.texture.sourceHeight))
            }
        } else {
            if (this.texture instanceof PIXI.Texture) {
                var n = {};
                t.Utils.extend(true, n, this.texture);
                n.sourceWidth = n.width;
                n.sourceHeight = n.height;
                n.frame = e;
                n.width = e.width;
                n.height = e.height;
                this.texture = n;
                this.texture.updateFrame = true;
                PIXI.Texture.frameUpdates.push(this.texture)
            } else {
                this.texture.setFrame(e)
            }
        }
    };
    t.Image.prototype.revive = function() {
        this.alive = true;
        this.exists = true;
        this.visible = true;
        if (this.events) {
            this.events.onRevived.dispatch(this)
        }
        return this
    };
    t.Image.prototype.kill = function() {
        this.alive = false;
        this.exists = false;
        this.visible = false;
        if (this.events) {
            this.events.onKilled.dispatch(this)
        }
        return this
    };
    t.Image.prototype.destroy = function(e) {
        if (this.game === null || this.destroyPhase) {
            return
        }
        if (typeof e === "undefined") {
            e = true
        }
        this._cache[8] = 1;
        if (this.parent) {
            if (this.parent instanceof t.Group) {
                this.parent.remove(this)
            } else {
                this.parent.removeChild(this)
            }
        }
        if (this.events) {
            this.events.destroy()
        }
        if (this.input) {
            this.input.destroy()
        }
        var n = this.children.length;
        if (e) {
            while (n--) {
                this.children[n].destroy(e)
            }
        } else {
            while (n--) {
                this.removeChild(this.children[n])
            }
        }
        this.alive = false;
        this.exists = false;
        this.visible = false;
        this.filters = null;
        this.mask = null;
        this.game = null;
        this._cache[8] = 0
    };
    t.Image.prototype.reset = function(e, t) {
        this.world.setTo(e, t);
        this.position.x = e;
        this.position.y = t;
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.renderable = true;
        return this
    };
    t.Image.prototype.bringToTop = function() {
        if (this.parent) {
            this.parent.bringToTop(this)
        }
        return this
    };
    Object.defineProperty(t.Image.prototype, "angle", {
        get: function() {
            return t.Math.wrapAngle(t.Math.radToDeg(this.rotation))
        },
        set: function(e) {
            this.rotation = t.Math.degToRad(t.Math.wrapAngle(e))
        }
    });
    Object.defineProperty(t.Image.prototype, "deltaX", {
        get: function() {
            return this.world.x - this._cache[0]
        }
    });
    Object.defineProperty(t.Image.prototype, "deltaY", {
        get: function() {
            return this.world.y - this._cache[1]
        }
    });
    Object.defineProperty(t.Image.prototype, "deltaZ", {
        get: function() {
            return this.rotation - this._cache[2]
        }
    });
    Object.defineProperty(t.Image.prototype, "inWorld", {
        get: function() {
            return this.game.world.bounds.intersects(this.getBounds())
        }
    });
    Object.defineProperty(t.Image.prototype, "inCamera", {
        get: function() {
            return this.game.world.camera.screenView.intersects(this.getBounds())
        }
    });
    Object.defineProperty(t.Image.prototype, "frame", {
        get: function() {
            return this._frame
        },
        set: function(e) {
            if (e !== this.frame && this.game.cache.isSpriteSheet(this.key)) {
                var t = this.game.cache.getFrameData(this.key);
                if (t && e < t.total && t.getFrame(e)) {
                    this.setTexture(PIXI.TextureCache[t.getFrame(e).uuid]);
                    this._frame = e
                }
            }
        }
    });
    Object.defineProperty(t.Image.prototype, "frameName", {
        get: function() {
            return this._frameName
        },
        set: function(e) {
            if (e !== this.frameName && this.game.cache.isSpriteSheet(this.key)) {
                var t = this.game.cache.getFrameData(this.key);
                if (t && t.getFrameByName(e)) {
                    this.setTexture(PIXI.TextureCache[t.getFrameByName(e).uuid]);
                    this._frameName = e
                }
            }
        }
    });
    Object.defineProperty(t.Image.prototype, "renderOrderID", {
        get: function() {
            return this._cache[3]
        }
    });
    Object.defineProperty(t.Image.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled
        },
        set: function(e) {
            if (e) {
                if (this.input === null) {
                    this.input = new t.InputHandler(this);
                    this.input.start()
                } else if (this.input && !this.input.enabled) {
                    this.input.start()
                }
            } else {
                if (this.input && this.input.enabled) {
                    this.input.stop()
                }
            }
        }
    });
    Object.defineProperty(t.Image.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7]
        },
        set: function(e) {
            if (e) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y)
            } else {
                this._cache[7] = 0
            }
        }
    });
    Object.defineProperty(t.Image.prototype, "smoothed", {
        get: function() {
            return !this.texture.baseTexture.scaleMode
        },
        set: function(e) {
            if (e) {
                if (this.texture) {
                    this.texture.baseTexture.scaleMode = 0
                }
            } else {
                if (this.texture) {
                    this.texture.baseTexture.scaleMode = 1
                }
            }
        }
    });
    Object.defineProperty(t.Image.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8]
        }
    });
    t.TileSprite = function(e, n, r, i, s, o, u) {
        n = n || 0;
        r = r || 0;
        i = i || 256;
        s = s || 256;
        o = o || null;
        u = u || null;
        this.game = e;
        this.name = "";
        this.type = t.TILESPRITE;
        this.z = 0;
        this.events = new t.Events(this);
        this.animations = new t.AnimationManager(this);
        this.key = o;
        this._frame = 0;
        this._frameName = "";
        this._scroll = new t.Point;
        PIXI.TilingSprite.call(this, PIXI.TextureCache["__default"], i, s);
        this.loadTexture(o, u);
        this.position.set(n, r);
        this.input = null;
        this.world = new t.Point(n, r);
        this.autoCull = false;
        this.checkWorldBounds = false;
        this.cameraOffset = new t.Point;
        this.body = null;
        this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0]
    };
    t.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype);
    t.TileSprite.prototype.constructor = t.TileSprite;
    t.TileSprite.prototype.preUpdate = function() {
        if (this._cache[4] === 1 && this.exists) {
            this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y);
            this.worldTransform.tx = this.world.x;
            this.worldTransform.ty = this.world.y;
            this._cache[0] = this.world.x;
            this._cache[1] = this.world.y;
            this._cache[2] = this.rotation;
            if (this.body) {
                this.body.preUpdate()
            }
            this._cache[4] = 0;
            return false
        }
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this._cache[3] = -1;
            return false
        }
        if (this.autoCull || this.checkWorldBounds) {
            this._bounds.copyFrom(this.getBounds())
        }
        if (this.autoCull) {
            this.renderable = this.game.world.camera.screenView.intersects(this._bounds)
        }
        if (this.checkWorldBounds) {
            if (this._cache[5] === 1 && this.game.world.bounds.intersects(this._bounds)) {
                this._cache[5] = 0;
                this.events.onEnterBounds.dispatch(this)
            } else if (this._cache[5] === 0 && !this.game.world.bounds.intersects(this._bounds)) {
                this._cache[5] = 1;
                this.events.onOutOfBounds.dispatch(this)
            }
        }
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++
        }
        this.animations.update();
        if (this._scroll.x !== 0) {
            this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed
        }
        if (this._scroll.y !== 0) {
            this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed
        }
        if (this.body) {
            this.body.preUpdate()
        }
        for (var e = 0, t = this.children.length; e < t; e++) {
            this.children[e].preUpdate()
        }
        return true
    };
    t.TileSprite.prototype.update = function() {};
    t.TileSprite.prototype.postUpdate = function() {
        if (this.exists && this.body) {
            this.body.postUpdate()
        }
        if (this._cache[7] === 1) {
            this.position.x = this.game.camera.view.x + this.cameraOffset.x;
            this.position.y = this.game.camera.view.y + this.cameraOffset.y
        }
        for (var e = 0, t = this.children.length; e < t; e++) {
            this.children[e].postUpdate()
        }
    };
    t.TileSprite.prototype.autoScroll = function(e, t) {
        this._scroll.set(e, t)
    };
    t.TileSprite.prototype.stopScroll = function() {
        this._scroll.set(0, 0)
    };
    t.TileSprite.prototype.loadTexture = function(e, n) {
        n = n || 0;
        if (e instanceof t.RenderTexture) {
            this.key = e.key;
            this.setTexture(e);
            return
        } else if (e instanceof t.BitmapData) {
            this.key = e;
            this.setTexture(e.texture);
            return
        } else if (e instanceof PIXI.Texture) {
            this.key = e;
            this.setTexture(e);
            return
        } else {
            if (e === null || typeof e === "undefined") {
                this.key = "__default";
                this.setTexture(PIXI.TextureCache[this.key]);
                return
            } else if (typeof e === "string" && !this.game.cache.checkImageKey(e)) {
                this.key = "__missing";
                this.setTexture(PIXI.TextureCache[this.key]);
                return
            }
            if (this.game.cache.isSpriteSheet(e)) {
                this.key = e;
                this.animations.loadFrameData(this.game.cache.getFrameData(e));
                if (typeof n === "string") {
                    this.frameName = n
                } else {
                    this.frame = n
                }
            } else {
                this.key = e;
                this.setTexture(PIXI.TextureCache[e]);
                return
            }
        }
    };
    t.TileSprite.prototype.destroy = function(e) {
        if (this.game === null || this.destroyPhase) {
            return
        }
        if (typeof e === "undefined") {
            e = true
        }
        this._cache[8] = 1;
        if (this.filters) {
            this.filters = null
        }
        if (this.parent) {
            if (this.parent instanceof t.Group) {
                this.parent.remove(this)
            } else {
                this.parent.removeChild(this)
            }
        }
        this.animations.destroy();
        this.events.destroy();
        var n = this.children.length;
        if (e) {
            while (n--) {
                this.children[n].destroy(e)
            }
        } else {
            while (n--) {
                this.removeChild(this.children[n])
            }
        }
        this.exists = false;
        this.visible = false;
        this.filters = null;
        this.mask = null;
        this.game = null;
        this._cache[8] = 0
    };
    t.TileSprite.prototype.play = function(e, t, n, r) {
        return this.animations.play(e, t, n, r)
    };
    t.TileSprite.prototype.reset = function(e, t) {
        this.world.setTo(e, t);
        this.position.x = e;
        this.position.y = t;
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.renderable = true;
        this._outOfBoundsFired = false;
        this.tilePosition.x = 0;
        this.tilePosition.y = 0;
        if (this.body) {
            this.body.reset(e, t, false, false)
        }
        this._cache[4] = 1;
        return this
    };
    Object.defineProperty(t.TileSprite.prototype, "angle", {
        get: function() {
            return t.Math.wrapAngle(t.Math.radToDeg(this.rotation))
        },
        set: function(e) {
            this.rotation = t.Math.degToRad(t.Math.wrapAngle(e))
        }
    });
    Object.defineProperty(t.TileSprite.prototype, "frame", {
        get: function() {
            return this.animations.frame
        },
        set: function(e) {
            if (e !== this.animations.frame) {
                this.animations.frame = e
            }
        }
    });
    Object.defineProperty(t.TileSprite.prototype, "frameName", {
        get: function() {
            return this.animations.frameName
        },
        set: function(e) {
            if (e !== this.animations.frameName) {
                this.animations.frameName = e
            }
        }
    });
    Object.defineProperty(t.TileSprite.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7]
        },
        set: function(e) {
            if (e) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y)
            } else {
                this._cache[7] = 0
            }
        }
    });
    Object.defineProperty(t.TileSprite.prototype, "exists", {
        get: function() {
            return !!this._cache[6]
        },
        set: function(e) {
            if (e) {
                this._cache[6] = 1;
                if (this.body && this.body.type === t.Physics.P2JS) {
                    this.body.addToWorld()
                }
                this.visible = true
            } else {
                this._cache[6] = 0;
                if (this.body && this.body.type === t.Physics.P2JS) {
                    this.body.safeRemove = true
                }
                this.visible = false
            }
        }
    });
    Object.defineProperty(t.TileSprite.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled
        },
        set: function(e) {
            if (e) {
                if (this.input === null) {
                    this.input = new t.InputHandler(this);
                    this.input.start()
                } else if (this.input && !this.input.enabled) {
                    this.input.start()
                }
            } else {
                if (this.input && this.input.enabled) {
                    this.input.stop()
                }
            }
        }
    });
    Object.defineProperty(t.TileSprite.prototype, "x", {
        get: function() {
            return this.position.x
        },
        set: function(e) {
            this.position.x = e;
            if (this.body && this.body.type === t.Physics.ARCADE && this.body.phase === 2) {
                this.body._reset = 1
            }
        }
    });
    Object.defineProperty(t.TileSprite.prototype, "y", {
        get: function() {
            return this.position.y
        },
        set: function(e) {
            this.position.y = e;
            if (this.body && this.body.type === t.Physics.ARCADE && this.body.phase === 2) {
                this.body._reset = 1
            }
        }
    });
    Object.defineProperty(t.TileSprite.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8]
        }
    });
    t.Text = function(e, n, r, i, s) {
        n = n || 0;
        r = r || 0;
        i = i || " ";
        s = s || {};
        if (i.length === 0) {
            i = " "
        } else {
            i = i.toString()
        }
        this.game = e;
        this.exists = true;
        this.name = "";
        this.type = t.TEXT;
        this.z = 0;
        this.world = new t.Point(n, r);
        this._text = i;
        this._font = "";
        this._fontSize = 32;
        this._fontWeight = "normal";
        this._lineSpacing = 0;
        this.events = new t.Events(this);
        this.input = null;
        this.cameraOffset = new t.Point;
        this.setStyle(s);
        PIXI.Text.call(this, i, this.style);
        this.position.set(n, r);
        this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0]
    };
    t.Text.prototype = Object.create(PIXI.Text.prototype);
    t.Text.prototype.constructor = t.Text;
    t.Text.prototype.preUpdate = function() {
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this.renderOrderID = -1;
            return false
        }
        if (this.autoCull) {
            this.renderable = this.game.world.camera.screenView.intersects(this.getBounds())
        }
        this.world.setTo(this.game.camera.x + this.worldTransform[2], this.game.camera.y + this.worldTransform[5]);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++
        }
        for (var e = 0, t = this.children.length; e < t; e++) {
            this.children[e].preUpdate()
        }
        return true
    };
    t.Text.prototype.update = function() {};
    t.Text.prototype.postUpdate = function() {
        if (this._cache[7] === 1) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y
        }
        for (var e = 0, t = this.children.length; e < t; e++) {
            this.children[e].postUpdate()
        }
    };
    t.Text.prototype.destroy = function(e) {
        if (this.game === null || this.destroyPhase) {
            return
        }
        if (typeof e === "undefined") {
            e = true
        }
        this._cache[8] = 1;
        if (this.parent) {
            if (this.parent instanceof t.Group) {
                this.parent.remove(this)
            } else {
                this.parent.removeChild(this)
            }
        }
        this.texture.destroy();
        if (this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas)
        } else {
            this.canvas = null;
            this.context = null
        }
        var n = this.children.length;
        if (e) {
            while (n--) {
                this.children[n].destroy(e)
            }
        } else {
            while (n--) {
                this.removeChild(this.children[n])
            }
        }
        this.exists = false;
        this.visible = false;
        this.filters = null;
        this.mask = null;
        this.game = null;
        this._cache[8] = 0
    };
    t.Text.prototype.setShadow = function(e, t, n, r) {
        this.style.shadowOffsetX = e || 0;
        this.style.shadowOffsetY = t || 0;
        this.style.shadowColor = n || "rgba(0,0,0,0)";
        this.style.shadowBlur = r || 0;
        this.dirty = true
    };
    t.Text.prototype.setStyle = function(e) {
        e = e || {};
        e.font = e.font || "bold 20pt Arial";
        e.fill = e.fill || "black";
        e.align = e.align || "left";
        e.stroke = e.stroke || "black";
        e.strokeThickness = e.strokeThickness || 0;
        e.wordWrap = e.wordWrap || false;
        e.wordWrapWidth = e.wordWrapWidth || 100;
        e.shadowOffsetX = e.shadowOffsetX || 0;
        e.shadowOffsetY = e.shadowOffsetY || 0;
        e.shadowColor = e.shadowColor || "rgba(0,0,0,0)";
        e.shadowBlur = e.shadowBlur || 0;
        this.style = e;
        this.dirty = true
    };
    t.Text.prototype.updateText = function() {
        this.context.font = this.style.font;
        var e = this.text;
        if (this.style.wordWrap) {
            e = this.runWordWrap(this.text)
        }
        var t = e.split(/(?:\r\n|\r|\n)/);
        var n = [];
        var r = 0;
        for (var i = 0; i < t.length; i++) {
            var s = this.context.measureText(t[i]).width;
            n[i] = s;
            r = Math.max(r, s)
        }
        this.canvas.width = r + this.style.strokeThickness;
        var o = this.determineFontHeight("font: " + this.style.font + ";") + this.style.strokeThickness + this._lineSpacing + this.style.shadowOffsetY;
        this.canvas.height = o * t.length;
        if (navigator.isCocoonJS) {
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
        }
        this.context.fillStyle = this.style.fill;
        this.context.font = this.style.font;
        this.context.strokeStyle = this.style.stroke;
        this.context.lineWidth = this.style.strokeThickness;
        this.context.shadowOffsetX = this.style.shadowOffsetX;
        this.context.shadowOffsetY = this.style.shadowOffsetY;
        this.context.shadowColor = this.style.shadowColor;
        this.context.shadowBlur = this.style.shadowBlur;
        this.context.textBaseline = "top";
        this.context.lineCap = "round";
        this.context.lineJoin = "round";
        for (i = 0; i < t.length; i++) {
            var u = new PIXI.Point(this.style.strokeThickness / 2, this.style.strokeThickness / 2 + i * o);
            if (this.style.align === "right") {
                u.x += r - n[i]
            } else if (this.style.align === "center") {
                u.x += (r - n[i]) / 2
            }
            u.y += this._lineSpacing;
            if (this.style.stroke && this.style.strokeThickness) {
                this.context.strokeText(t[i], u.x, u.y)
            }
            if (this.style.fill) {
                this.context.fillText(t[i], u.x, u.y)
            }
        }
        this.updateTexture()
    };
    t.Text.prototype.runWordWrap = function(e) {
        var t = "";
        var n = e.split("\n");
        for (var r = 0; r < n.length; r++) {
            var i = this.style.wordWrapWidth;
            var s = n[r].split(" ");
            for (var o = 0; o < s.length; o++) {
                var u = this.context.measureText(s[o]).width;
                var a = u + this.context.measureText(" ").width;
                if (a > i) {
                    if (o > 0) {
                        t += "\n"
                    }
                    t += s[o] + " ";
                    i = this.style.wordWrapWidth - u
                } else {
                    i -= a;
                    t += s[o] + " "
                }
            }
            if (r < n.length - 1) {
                t += "\n"
            }
        }
        return t
    };
    Object.defineProperty(t.Text.prototype, "angle", {
        get: function() {
            return t.Math.radToDeg(this.rotation)
        },
        set: function(e) {
            this.rotation = t.Math.degToRad(e)
        }
    });
    Object.defineProperty(t.Text.prototype, "text", {
        get: function() {
            return this._text
        },
        set: function(e) {
            if (e !== this._text) {
                this._text = e.toString() || " ";
                this.dirty = true;
                this.updateTransform()
            }
        }
    });
    Object.defineProperty(t.Text.prototype, "font", {
        get: function() {
            return this._font
        },
        set: function(e) {
            if (e !== this._font) {
                this._font = e.trim();
                this.style.font = this._fontWeight + " " + this._fontSize + "px '" + this._font + "'";
                this.dirty = true;
                this.updateTransform()
            }
        }
    });
    Object.defineProperty(t.Text.prototype, "fontSize", {
        get: function() {
            return this._fontSize
        },
        set: function(e) {
            e = parseInt(e, 10);
            if (e !== this._fontSize) {
                this._fontSize = e;
                this.style.font = this._fontWeight + " " + this._fontSize + "px '" + this._font + "'";
                this.dirty = true;
                this.updateTransform()
            }
        }
    });
    Object.defineProperty(t.Text.prototype, "fontWeight", {
        get: function() {
            return this._fontWeight
        },
        set: function(e) {
            if (e !== this._fontWeight) {
                this._fontWeight = e;
                this.style.font = this._fontWeight + " " + this._fontSize + "px '" + this._font + "'";
                this.dirty = true;
                this.updateTransform()
            }
        }
    });
    Object.defineProperty(t.Text.prototype, "fill", {
        get: function() {
            return this.style.fill
        },
        set: function(e) {
            if (e !== this.style.fill) {
                this.style.fill = e;
                this.dirty = true
            }
        }
    });
    Object.defineProperty(t.Text.prototype, "align", {
        get: function() {
            return this.style.align
        },
        set: function(e) {
            if (e !== this.style.align) {
                this.style.align = e;
                this.dirty = true
            }
        }
    });
    Object.defineProperty(t.Text.prototype, "stroke", {
        get: function() {
            return this.style.stroke
        },
        set: function(e) {
            if (e !== this.style.stroke) {
                this.style.stroke = e;
                this.dirty = true
            }
        }
    });
    Object.defineProperty(t.Text.prototype, "strokeThickness", {
        get: function() {
            return this.style.strokeThickness
        },
        set: function(e) {
            if (e !== this.style.strokeThickness) {
                this.style.strokeThickness = e;
                this.dirty = true
            }
        }
    });
    Object.defineProperty(t.Text.prototype, "wordWrap", {
        get: function() {
            return this.style.wordWrap
        },
        set: function(e) {
            if (e !== this.style.wordWrap) {
                this.style.wordWrap = e;
                this.dirty = true
            }
        }
    });
    Object.defineProperty(t.Text.prototype, "wordWrapWidth", {
        get: function() {
            return this.style.wordWrapWidth
        },
        set: function(e) {
            if (e !== this.style.wordWrapWidth) {
                this.style.wordWrapWidth = e;
                this.dirty = true
            }
        }
    });
    Object.defineProperty(t.Text.prototype, "lineSpacing", {
        get: function() {
            return this._lineSpacing
        },
        set: function(e) {
            if (e !== this._lineSpacing) {
                this._lineSpacing = parseFloat(e);
                this.dirty = true;
                this.updateTransform()
            }
        }
    });
    Object.defineProperty(t.Text.prototype, "shadowOffsetX", {
        get: function() {
            return this.style.shadowOffsetX
        },
        set: function(e) {
            if (e !== this.style.shadowOffsetX) {
                this.style.shadowOffsetX = e;
                this.dirty = true
            }
        }
    });
    Object.defineProperty(t.Text.prototype, "shadowOffsetY", {
        get: function() {
            return this.style.shadowOffsetY
        },
        set: function(e) {
            if (e !== this.style.shadowOffsetY) {
                this.style.shadowOffsetY = e;
                this.dirty = true
            }
        }
    });
    Object.defineProperty(t.Text.prototype, "shadowColor", {
        get: function() {
            return this.style.shadowColor
        },
        set: function(e) {
            if (e !== this.style.shadowColor) {
                this.style.shadowColor = e;
                this.dirty = true
            }
        }
    });
    Object.defineProperty(t.Text.prototype, "shadowBlur", {
        get: function() {
            return this.style.shadowBlur
        },
        set: function(e) {
            if (e !== this.style.shadowBlur) {
                this.style.shadowBlur = e;
                this.dirty = true
            }
        }
    });
    Object.defineProperty(t.Text.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled
        },
        set: function(e) {
            if (e) {
                if (this.input === null) {
                    this.input = new t.InputHandler(this);
                    this.input.start()
                } else if (this.input && !this.input.enabled) {
                    this.input.start()
                }
            } else {
                if (this.input && this.input.enabled) {
                    this.input.stop()
                }
            }
        }
    });
    Object.defineProperty(t.Text.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7]
        },
        set: function(e) {
            if (e) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y)
            } else {
                this._cache[7] = 0
            }
        }
    });
    Object.defineProperty(t.Text.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8]
        }
    });
    t.BitmapText = function(e, n, r, i, s, o) {
        n = n || 0;
        r = r || 0;
        i = i || "";
        s = s || "";
        o = o || 32;
        this.game = e;
        this.exists = true;
        this.name = "";
        this.type = t.BITMAPTEXT;
        this.z = 0;
        this.world = new t.Point(n, r);
        this._text = s;
        this._font = i;
        this._fontSize = o;
        this._align = "left";
        this._tint = 16777215;
        this.events = new t.Events(this);
        this.input = null;
        this.cameraOffset = new t.Point;
        PIXI.BitmapText.call(this, s);
        this.position.set(n, r);
        this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0]
    };
    t.BitmapText.prototype = Object.create(PIXI.BitmapText.prototype);
    t.BitmapText.prototype.constructor = t.BitmapText;
    t.BitmapText.prototype.setStyle = function() {
        this.style = {
            align: this._align
        };
        this.fontName = this._font;
        this.fontSize = this._fontSize;
        this.dirty = true
    };
    t.BitmapText.prototype.preUpdate = function() {
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this.renderOrderID = -1;
            return false
        }
        if (this.autoCull) {
            this.renderable = this.game.world.camera.screenView.intersects(this.getBounds())
        }
        this.world.setTo(this.game.camera.x + this.worldTransform[2], this.game.camera.y + this.worldTransform[5]);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++
        }
        return true
    };
    t.BitmapText.prototype.update = function() {};
    t.BitmapText.prototype.postUpdate = function() {
        if (this._cache[7] === 1) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y
        }
    };
    t.BitmapText.prototype.destroy = function(e) {
        if (this.game === null || this.destroyPhase) {
            return
        }
        if (typeof e === "undefined") {
            e = true
        }
        this._cache[8] = 1;
        if (this.parent) {
            if (this.parent instanceof t.Group) {
                this.parent.remove(this)
            } else {
                this.parent.removeChild(this)
            }
        }
        var n = this.children.length;
        if (e) {
            while (n--) {
                if (this.children[n].destroy) {
                    this.children[n].destroy(e)
                } else {
                    this.removeChild(this.children[n])
                }
            }
        } else {
            while (n--) {
                this.removeChild(this.children[n])
            }
        }
        this.exists = false;
        this.visible = false;
        this.filters = null;
        this.mask = null;
        this.game = null;
        this._cache[8] = 0
    };
    Object.defineProperty(t.BitmapText.prototype, "align", {
        get: function() {
            return this._align
        },
        set: function(e) {
            if (e !== this._align) {
                this._align = e;
                this.setStyle()
            }
        }
    });
    Object.defineProperty(t.BitmapText.prototype, "tint", {
        get: function() {
            return this._tint
        },
        set: function(e) {
            if (e !== this._tint) {
                this._tint = e;
                this.dirty = true
            }
        }
    });
    Object.defineProperty(t.BitmapText.prototype, "angle", {
        get: function() {
            return t.Math.radToDeg(this.rotation)
        },
        set: function(e) {
            this.rotation = t.Math.degToRad(e)
        }
    });
    Object.defineProperty(t.BitmapText.prototype, "font", {
        get: function() {
            return this._font
        },
        set: function(e) {
            if (e !== this._font) {
                this._font = e.trim();
                this.style.font = this._fontSize + "px '" + this._font + "'";
                this.dirty = true
            }
        }
    });
    Object.defineProperty(t.BitmapText.prototype, "fontSize", {
        get: function() {
            return this._fontSize
        },
        set: function(e) {
            e = parseInt(e, 10);
            if (e !== this._fontSize) {
                this._fontSize = e;
                this.style.font = this._fontSize + "px '" + this._font + "'";
                this.dirty = true
            }
        }
    });
    Object.defineProperty(t.BitmapText.prototype, "text", {
        get: function() {
            return this._text
        },
        set: function(e) {
            if (e !== this._text) {
                this._text = e.toString() || " ";
                this.dirty = true
            }
        }
    });
    Object.defineProperty(t.BitmapText.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled
        },
        set: function(e) {
            if (e) {
                if (this.input === null) {
                    this.input = new t.InputHandler(this);
                    this.input.start()
                } else if (this.input && !this.input.enabled) {
                    this.input.start()
                }
            } else {
                if (this.input && this.input.enabled) {
                    this.input.stop()
                }
            }
        }
    });
    Object.defineProperty(t.BitmapText.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7]
        },
        set: function(e) {
            if (e) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y)
            } else {
                this._cache[7] = 0
            }
        }
    });
    Object.defineProperty(t.BitmapText.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8]
        }
    });
    t.Button = function(e, n, r, i, s, o, u, a, f, l) {
        n = n || 0;
        r = r || 0;
        i = i || null;
        s = s || null;
        o = o || this;
        t.Image.call(this, e, n, r, i, a);
        this.type = t.BUTTON;
        this._onOverFrameName = null;
        this._onOutFrameName = null;
        this._onDownFrameName = null;
        this._onUpFrameName = null;
        this._onOverFrameID = null;
        this._onOutFrameID = null;
        this._onDownFrameID = null;
        this._onUpFrameID = null;
        this.onOverMouseOnly = false;
        this.onOverSound = null;
        this.onOutSound = null;
        this.onDownSound = canPlaySound ? buttonSound : null;
        this.onUpSound = null;
        this.onOverSoundMarker = "";
        this.onOutSoundMarker = "";
        this.onDownSoundMarker = "";
        this.onUpSoundMarker = "";
        this.onInputOver = new t.Signal;
        this.onInputOut = new t.Signal;
        this.onInputDown = new t.Signal;
        this.onInputUp = new t.Signal;
        this.freezeFrames = false;
        this.forceOut = false;
        this.inputEnabled = true;
        this.input.useHandCursor = true;
        this.input.start(0, true);
        this.setFrames(u, a, f, l);
        if (s !== null) {
            this.onInputUp.add(s, o)
        }
        this.events.onInputOver.add(this.onInputOverHandler, this);
        this.events.onInputOut.add(this.onInputOutHandler, this);
        this.events.onInputDown.add(this.onInputDownHandler, this);
        this.events.onInputUp.add(this.onInputUpHandler, this)
    };
    t.Button.prototype = Object.create(t.Image.prototype);
    t.Button.prototype.constructor = t.Button;
    t.Button.prototype.clearFrames = function() {
        this._onOverFrameName = null;
        this._onOverFrameID = null;
        this._onOutFrameName = null;
        this._onOutFrameID = null;
        this._onDownFrameName = null;
        this._onDownFrameID = null;
        this._onUpFrameName = null;
        this._onUpFrameID = null
    };
    t.Button.prototype.setFrames = function(e, t, n, r) {
        this.clearFrames();
        if (e !== null) {
            if (typeof e === "string") {
                this._onOverFrameName = e;
                if (this.input.pointerOver()) {
                    this.frameName = e
                }
            } else {
                this._onOverFrameID = e;
                if (this.input.pointerOver()) {
                    this.frame = e
                }
            }
        }
        if (t !== null) {
            if (typeof t === "string") {
                this._onOutFrameName = t;
                if (this.input.pointerOver() === false) {
                    this.frameName = t
                }
            } else {
                this._onOutFrameID = t;
                if (this.input.pointerOver() === false) {
                    this.frame = t
                }
            }
        }
        if (n !== null) {
            if (typeof n === "string") {
                this._onDownFrameName = n;
                if (this.input.pointerDown()) {
                    this.frameName = n
                }
            } else {
                this._onDownFrameID = n;
                if (this.input.pointerDown()) {
                    this.frame = n
                }
            }
        }
        if (r !== null) {
            if (typeof r === "string") {
                this._onUpFrameName = r;
                if (this.input.pointerUp()) {
                    this.frameName = r
                }
            } else {
                this._onUpFrameID = r;
                if (this.input.pointerUp()) {
                    this.frame = r
                }
            }
        }
    };
    t.Button.prototype.setSounds = function(e, t, n, r, i, s, o, u) {
        this.setOverSound(e, t);
        this.setOutSound(i, s);
        this.setDownSound(n, r);
        this.setUpSound(o, u)
    };
    t.Button.prototype.setOverSound = function(e, n) {
        this.onOverSound = null;
        this.onOverSoundMarker = "";
        if (e instanceof t.Sound) {
            this.onOverSound = e
        }
        if (typeof n === "string") {
            this.onOverSoundMarker = n
        }
    };
    t.Button.prototype.setOutSound = function(e, n) {
        this.onOutSound = null;
        this.onOutSoundMarker = "";
        if (e instanceof t.Sound) {
            this.onOutSound = e
        }
        if (typeof n === "string") {
            this.onOutSoundMarker = n
        }
    };
    t.Button.prototype.setDownSound = function(e, n) {
        this.onDownSound = null;
        this.onDownSoundMarker = "";
        if (e instanceof t.Sound) {
            this.onDownSound = e
        }
        if (typeof n === "string") {
            this.onDownSoundMarker = n
        }
    };
    t.Button.prototype.setUpSound = function(e, n) {
        this.onUpSound = null;
        this.onUpSoundMarker = "";
        if (e instanceof t.Sound) {
            this.onUpSound = e
        }
        if (typeof n === "string") {
            this.onUpSoundMarker = n
        }
    };
    t.Button.prototype.onInputOverHandler = function(e, t) {
        if (this.freezeFrames === false) {
            this.setState(1)
        }
        if (this.onOverMouseOnly && !t.isMouse) {
            return
        }
        if (this.onOverSound) {
            this.onOverSound.play(this.onOverSoundMarker)
        }
        if (this.onInputOver) {
            this.onInputOver.dispatch(this, t)
        }
    };
    t.Button.prototype.onInputOutHandler = function(e, t) {
        if (this.freezeFrames === false) {
            this.setState(2)
        }
        if (this.onOutSound) {
            this.onOutSound.play(this.onOutSoundMarker)
        }
        if (this.onInputOut) {
            this.onInputOut.dispatch(this, t)
        }
    };
    t.Button.prototype.onInputDownHandler = function(e, t) {
        if (this.freezeFrames === false) {
            this.setState(3)
        }
        if (this.onDownSound) {
            this.onDownSound.play(this.onDownSoundMarker)
        }
        if (this.onInputDown) {
            this.onInputDown.dispatch(this, t)
        }
    };
    t.Button.prototype.onInputUpHandler = function(e, t, n) {
        if (this.onUpSound) {
            this.onUpSound.play(this.onUpSoundMarker)
        }
        if (this.onInputUp) {
            this.onInputUp.dispatch(this, t, n)
        }
        if (this.freezeFrames) {
            return
        }
        if (this.forceOut) {
            this.setState(2)
        } else {
            if (this._onUpFrameName !== null || this._onUpFrameID !== null) {
                this.setState(4)
            } else {
                if (n) {
                    this.setState(1)
                } else {
                    this.setState(2)
                }
            }
        }
    };
    t.Button.prototype.setState = function(e) {
        if (e === 1) {
            if (this._onOverFrameName != null) {
                this.frameName = this._onOverFrameName
            } else if (this._onOverFrameID != null) {
                this.frame = this._onOverFrameID
            }
        } else if (e === 2) {
            if (this._onOutFrameName != null) {
                this.frameName = this._onOutFrameName
            } else if (this._onOutFrameID != null) {
                this.frame = this._onOutFrameID
            }
        } else if (e === 3) {
            if (this._onDownFrameName != null) {
                this.frameName = this._onDownFrameName
            } else if (this._onDownFrameID != null) {
                this.frame = this._onDownFrameID
            }
        } else if (e === 4) {
            if (this._onUpFrameName != null) {
                this.frameName = this._onUpFrameName
            } else if (this._onUpFrameID != null) {
                this.frame = this._onUpFrameID
            }
        }
    };
    t.Graphics = function(e, n, r) {
        n = n || 0;
        r = r || 0;
        this.game = e;
        this.exists = true;
        this.name = "";
        this.type = t.GRAPHICS;
        this.z = 0;
        this.world = new t.Point(n, r);
        this.cameraOffset = new t.Point;
        PIXI.Graphics.call(this);
        this.position.set(n, r);
        this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0]
    };
    t.Graphics.prototype = Object.create(PIXI.Graphics.prototype);
    t.Graphics.prototype.constructor = t.Graphics;
    t.Graphics.prototype.preUpdate = function() {
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this.renderOrderID = -1;
            return false
        }
        if (this.autoCull) {
            this.renderable = this.game.world.camera.screenView.intersects(this.getBounds())
        }
        this.world.setTo(this.game.camera.x + this.worldTransform[2], this.game.camera.y + this.worldTransform[5]);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++
        }
        return true
    };
    t.Graphics.prototype.update = function() {};
    t.Graphics.prototype.postUpdate = function() {
        if (this._cache[7] === 1) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y
        }
    };
    t.Graphics.prototype.destroy = function(e) {
        if (this.game === null || this.destroyPhase) {
            return
        }
        if (typeof e === "undefined") {
            e = true
        }
        this._cache[8] = 1;
        this.clear();
        if (this.parent) {
            if (this.parent instanceof t.Group) {
                this.parent.remove(this)
            } else {
                this.parent.removeChild(this)
            }
        }
        var n = this.children.length;
        if (e) {
            while (n--) {
                this.children[n].destroy(e)
            }
        } else {
            while (n--) {
                this.removeChild(this.children[n])
            }
        }
        this.exists = false;
        this.visible = false;
        this.game = null;
        this._cache[8] = 0
    };
    t.Graphics.prototype.drawPolygon = function(e) {
        this.moveTo(e.points[0].x, e.points[0].y);
        for (var t = 1; t < e.points.length; t += 1) {
            this.lineTo(e.points[t].x, e.points[t].y)
        }
        this.lineTo(e.points[0].x, e.points[0].y)
    };
    t.Graphics.prototype.drawTriangle = function(e, n) {
        if (typeof n === "undefined") {
            n = false
        }
        var r = new t.Polygon(e);
        if (n) {
            var i = new t.Point(this.game.camera.x - e[0].x, this.game.camera.y - e[0].y);
            var s = new t.Point(e[1].x - e[0].x, e[1].y - e[0].y);
            var o = new t.Point(e[1].x - e[2].x, e[1].y - e[2].y);
            var u = o.cross(s);
            if (i.dot(u) > 0) {
                this.drawPolygon(r)
            }
        } else {
            this.drawPolygon(r)
        }
    };
    t.Graphics.prototype.drawTriangles = function(e, n, r) {
        if (typeof r === "undefined") {
            r = false
        }
        var i = new t.Point;
        var s = new t.Point;
        var o = new t.Point;
        var u = [];
        var a;
        if (!n) {
            if (e[0] instanceof t.Point) {
                for (a = 0; a < e.length / 3; a++) {
                    this.drawTriangle([e[a * 3], e[a * 3 + 1], e[a * 3 + 2]], r)
                }
            } else {
                for (a = 0; a < e.length / 6; a++) {
                    i.x = e[a * 6 + 0];
                    i.y = e[a * 6 + 1];
                    s.x = e[a * 6 + 2];
                    s.y = e[a * 6 + 3];
                    o.x = e[a * 6 + 4];
                    o.y = e[a * 6 + 5];
                    this.drawTriangle([i, s, o], r)
                }
            }
        } else {
            if (e[0] instanceof t.Point) {
                for (a = 0; a < n.length / 3; a++) {
                    u.push(e[n[a * 3]]);
                    u.push(e[n[a * 3 + 1]]);
                    u.push(e[n[a * 3 + 2]]);
                    if (u.length === 3) {
                        this.drawTriangle(u, r);
                        u = []
                    }
                }
            } else {
                for (a = 0; a < n.length; a++) {
                    i.x = e[n[a] * 2];
                    i.y = e[n[a] * 2 + 1];
                    u.push(i.copyTo({}));
                    if (u.length === 3) {
                        this.drawTriangle(u, r);
                        u = []
                    }
                }
            }
        }
    };
    Object.defineProperty(t.Graphics.prototype, "angle", {
        get: function() {
            return t.Math.radToDeg(this.rotation)
        },
        set: function(e) {
            this.rotation = t.Math.degToRad(e)
        }
    });
    Object.defineProperty(t.Graphics.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7]
        },
        set: function(e) {
            if (e) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y)
            } else {
                this._cache[7] = 0
            }
        }
    });
    Object.defineProperty(t.Graphics.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8]
        }
    });
    t.RenderTexture = function(e, n, r, i, s) {
        if (typeof i === "undefined") {
            i = ""
        }
        if (typeof s === "undefined") {
            s = t.scaleModes.DEFAULT
        }
        this.game = e;
        this.key = i;
        this.type = t.RENDERTEXTURE;
        this._temp = new t.Point;
        PIXI.RenderTexture.call(this, n, r, s)
    };
    t.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype);
    t.RenderTexture.prototype.constructor = t.RenderTexture;
    t.RenderTexture.prototype.renderXY = function(e, t, n, r) {
        this._temp.set(t, n);
        this.render(e, this._temp, r)
    };
    t.SpriteBatch = function(e, n, r, i) {
        PIXI.SpriteBatch.call(this);
        t.Group.call(this, e, n, r, i);
        this.type = t.SPRITEBATCH
    };
    t.SpriteBatch.prototype = t.Utils.extend(true, t.SpriteBatch.prototype, t.Group.prototype, PIXI.SpriteBatch.prototype);
    t.SpriteBatch.prototype.constructor = t.SpriteBatch;
    t.RetroFont = function(e, n, r, i, s, o, u, a, f, l) {
        this.characterWidth = r;
        this.characterHeight = i;
        this.characterSpacingX = u || 0;
        this.characterSpacingY = a || 0;
        this.characterPerRow = o;
        this.offsetX = f || 0;
        this.offsetY = l || 0;
        this.align = "left";
        this.multiLine = false;
        this.autoUpperCase = true;
        this.customSpacingX = 0;
        this.customSpacingY = 0;
        this.fixedWidth = 0;
        this.fontSet = e.cache.getImage(n);
        this._text = "";
        this.grabData = [];
        var c = this.offsetX;
        var h = this.offsetY;
        var p = 0;
        var d = new t.FrameData;
        for (var v = 0; v < s.length; v++) {
            var m = e.rnd.uuid();
            var g = d.addFrame(new t.Frame(v, c, h, this.characterWidth, this.characterHeight, "", m));
            this.grabData[s.charCodeAt(v)] = g.index;
            PIXI.TextureCache[m] = new PIXI.Texture(PIXI.BaseTextureCache[n], {
                x: c,
                y: h,
                width: this.characterWidth,
                height: this.characterHeight
            });
            p++;
            if (p == this.characterPerRow) {
                p = 0;
                c = this.offsetX;
                h += this.characterHeight + this.characterSpacingY
            } else {
                c += this.characterWidth + this.characterSpacingX
            }
        }
        e.cache.updateFrameData(n, d);
        this.stamp = new t.Image(e, 0, 0, n, 0);
        t.RenderTexture.call(this, e);
        this.type = t.RETROFONT
    };
    t.RetroFont.prototype = Object.create(t.RenderTexture.prototype);
    t.RetroFont.prototype.constructor = t.RetroFont;
    t.RetroFont.ALIGN_LEFT = "left";
    t.RetroFont.ALIGN_RIGHT = "right";
    t.RetroFont.ALIGN_CENTER = "center";
    t.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
    t.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    t.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";
    t.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789";
    t.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789";
    t.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ";
    t.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39";
    t.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    t.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!";
    t.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    t.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789";
    t.RetroFont.prototype.setFixedWidth = function(e, t) {
        if (typeof t === "undefined") {
            t = "left"
        }
        this.fixedWidth = e;
        this.align = t
    };
    t.RetroFont.prototype.setText = function(e, t, n, r, i, s) {
        this.multiLine = t || false;
        this.customSpacingX = n || 0;
        this.customSpacingY = r || 0;
        this.align = i || "left";
        if (s) {
            this.autoUpperCase = false
        } else {
            this.autoUpperCase = true
        }
        if (e.length > 0) {
            this.text = e
        }
    };
    t.RetroFont.prototype.buildRetroFontText = function() {
        var e = 0;
        var n = 0;
        this.clear();
        if (this.multiLine) {
            var r = this._text.split("\n");
            if (this.fixedWidth > 0) {
                this.resize(this.fixedWidth, r.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, true)
            } else {
                this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), r.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, true)
            }
            for (var i = 0; i < r.length; i++) {
                switch (this.align) {
                    case t.RetroFont.ALIGN_LEFT:
                        e = 0;
                        break;
                    case t.RetroFont.ALIGN_RIGHT:
                        e = this.width - r[i].length * (this.characterWidth + this.customSpacingX);
                        break;
                    case t.RetroFont.ALIGN_CENTER:
                        e = this.width / 2 - r[i].length * (this.characterWidth + this.customSpacingX) / 2;
                        e += this.customSpacingX / 2;
                        break
                }
                if (e < 0) {
                    e = 0
                }
                this.pasteLine(r[i], e, n, this.customSpacingX);
                n += this.characterHeight + this.customSpacingY
            }
        } else {
            if (this.fixedWidth > 0) {
                this.resize(this.fixedWidth, this.characterHeight, true)
            } else {
                this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, true)
            }
            switch (this.align) {
                case t.RetroFont.ALIGN_LEFT:
                    e = 0;
                    break;
                case t.RetroFont.ALIGN_RIGHT:
                    e = this.width - this._text.length * (this.characterWidth + this.customSpacingX);
                    break;
                case t.RetroFont.ALIGN_CENTER:
                    e = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2;
                    e += this.customSpacingX / 2;
                    break
            }
            this.textureBuffer.clear();
            this.pasteLine(this._text, e, 0, this.customSpacingX)
        }
    };
    t.RetroFont.prototype.pasteLine = function(e, n, r, i) {
        var s = new t.Point;
        for (var o = 0; o < e.length; o++) {
            if (e.charAt(o) == " ") {
                n += this.characterWidth + i
            } else {
                if (this.grabData[e.charCodeAt(o)] >= 0) {
                    this.stamp.frame = this.grabData[e.charCodeAt(o)];
                    s.set(n, r);
                    this.render(this.stamp, s, false);
                    n += this.characterWidth + i;
                    if (n > this.width) {
                        break
                    }
                }
            }
        }
    };
    t.RetroFont.prototype.getLongestLine = function() {
        var e = 0;
        if (this._text.length > 0) {
            var t = this._text.split("\n");
            for (var n = 0; n < t.length; n++) {
                if (t[n].length > e) {
                    e = t[n].length
                }
            }
        }
        return e
    };
    t.RetroFont.prototype.removeUnsupportedCharacters = function(e) {
        var t = "";
        for (var n = 0; n < this._text.length; n++) {
            var r = this._text[n];
            var i = r.charCodeAt(0);
            if (this.grabData[i] >= 0 || !e && r === "\n") {
                t = t.concat(r)
            }
        }
        return t
    };
    Object.defineProperty(t.RetroFont.prototype, "text", {
        get: function() {
            return this._text
        },
        set: function(e) {
            var t;
            if (this.autoUpperCase) {
                t = e.toUpperCase()
            } else {
                t = e
            }
            if (t !== this._text) {
                this._text = t;
                this.removeUnsupportedCharacters(this.multiLine);
                this.buildRetroFontText()
            }
        }
    });
    t.Particle = function(e, n, r, i, s) {
        t.Sprite.call(this, e, n, r, i, s);
        this.autoScale = false;
        this.scaleData = null;
        this._s = 0;
        this.autoAlpha = false;
        this.alphaData = null;
        this._a = 0
    };
    t.Particle.prototype = Object.create(t.Sprite.prototype);
    t.Particle.prototype.constructor = t.Particle;
    t.Particle.prototype.update = function() {
        if (this.autoScale) {
            this._s--;
            if (this._s) {
                this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y)
            } else {
                this.autoScale = false
            }
        }
        if (this.autoAlpha) {
            this._a--;
            if (this._a) {
                this.alpha = this.alphaData[this._a].v
            } else {
                this.autoAlpha = false
            }
        }
    };
    t.Particle.prototype.onEmit = function() {};
    t.Particle.prototype.setAlphaData = function(e) {
        this.alphaData = e;
        this._a = e.length - 1;
        this.alpha = this.alphaData[this._a].v;
        this.autoAlpha = true
    };
    t.Particle.prototype.setScaleData = function(e) {
        this.scaleData = e;
        this._s = e.length - 1;
        this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y);
        this.autoScale = true
    };
    t.Particle.prototype.reset = function(e, t, n) {
        if (typeof n === "undefined") {
            n = 1
        }
        this.world.setTo(e, t);
        this.position.x = e;
        this.position.y = t;
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.renderable = true;
        this._outOfBoundsFired = false;
        this.health = n;
        if (this.body) {
            this.body.reset(e, t, false, false)
        }
        this._cache[4] = 1;
        this.alpha = 1;
        this.scale.set(1);
        this.autoScale = false;
        this.autoAlpha = false;
        return this
    };
    t.Canvas = {
        create: function(e, t, n, r) {
            if (typeof r === "undefined") {
                r = false
            }
            e = e || 256;
            t = t || 256;
            if (r) {
                var i = document.createElement("canvas")
            } else {
                var i = document.createElement(navigator.isCocoonJS ? "screencanvas" : "canvas")
            }
            if (typeof n === "string" && n !== "") {
                i.id = n
            }
            i.width = e;
            i.height = t;
            i.style.display = "block";
            return i
        },
        getOffset: function(e, n) {
            n = n || new t.Point;
            var r = e.getBoundingClientRect();
            var i = e.clientTop || document.body.clientTop || 0;
            var s = e.clientLeft || document.body.clientLeft || 0;
            var o = 0;
            var u = 0;
            if (document.compatMode === "CSS1Compat") {
                o = window.pageYOffset || document.documentElement.scrollTop || e.scrollTop || 0;
                u = window.pageXOffset || document.documentElement.scrollLeft || e.scrollLeft || 0
            } else {
                o = window.pageYOffset || document.body.scrollTop || e.scrollTop || 0;
                u = window.pageXOffset || document.body.scrollLeft || e.scrollLeft || 0
            }
            n.x = r.left + u - s;
            n.y = r.top + o - i;
            return n
        },
        getAspectRatio: function(e) {
            return e.width / e.height
        },
        setBackgroundColor: function(e, t) {
            t = t || "rgb(0,0,0)";
            e.style.backgroundColor = t;
            return e
        },
        setTouchAction: function(e, t) {
            t = t || "none";
            e.style.msTouchAction = t;
            e.style["ms-touch-action"] = t;
            e.style["touch-action"] = t;
            return e
        },
        setUserSelect: function(e, t) {
            t = t || "none";
            e.style["-webkit-touch-callout"] = t;
            e.style["-webkit-user-select"] = t;
            e.style["-khtml-user-select"] = t;
            e.style["-moz-user-select"] = t;
            e.style["-ms-user-select"] = t;
            e.style["user-select"] = t;
            e.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)";
            return e
        },
        addToDOM: function(e, t, n) {
            var r;
            if (typeof n === "undefined") {
                n = true
            }
            if (t) {
                if (typeof t === "string") {
                    r = document.getElementById(t)
                } else if (typeof t === "object" && t.nodeType === 1) {
                    r = t
                }
            }
            if (!r) {
                r = document.body
            }
            if (n && r.style) {
                r.style.overflow = "hidden"
            }
            r.appendChild(e);
            return e
        },
        setTransform: function(e, t, n, r, i, s, o) {
            e.setTransform(r, s, o, i, t, n);
            return e
        },
        setSmoothingEnabled: function(e, t) {
            e["imageSmoothingEnabled"] = t;
            e["mozImageSmoothingEnabled"] = t;
            e["oImageSmoothingEnabled"] = t;
            e["webkitImageSmoothingEnabled"] = t;
            e["msImageSmoothingEnabled"] = t;
            return e
        },
        setImageRenderingCrisp: function(e) {
            e.style["image-rendering"] = "optimizeSpeed";
            e.style["image-rendering"] = "crisp-edges";
            e.style["image-rendering"] = "-moz-crisp-edges";
            e.style["image-rendering"] = "-webkit-optimize-contrast";
            e.style["image-rendering"] = "optimize-contrast";
            e.style.msInterpolationMode = "nearest-neighbor";
            return e
        },
        setImageRenderingBicubic: function(e) {
            e.style["image-rendering"] = "auto";
            e.style.msInterpolationMode = "bicubic";
            return e
        }
    };
    t.Device = function(e) {
        this.game = e;
        this.desktop = false;
        this.iOS = false;
        this.cocoonJS = false;
        this.ejecta = false;
        this.crosswalk = false;
        this.android = false;
        this.chromeOS = false;
        this.linux = false;
        this.macOS = false;
        this.windows = false;
        this.windowsPhone = false;
        this.canvas = false;
        this.file = false;
        this.fileSystem = false;
        this.localStorage = false;
        this.webGL = false;
        this.worker = false;
        this.touch = false;
        this.mspointer = false;
        this.css3D = false;
        this.pointerLock = false;
        this.typedArray = false;
        this.vibration = false;
        this.getUserMedia = false;
        this.quirksMode = false;
        this.arora = false;
        this.chrome = false;
        this.epiphany = false;
        this.firefox = false;
        this.ie = false;
        this.ieVersion = 0;
        this.trident = false;
        this.tridentVersion = 0;
        this.mobileSafari = false;
        this.midori = false;
        this.opera = false;
        this.safari = false;
        this.webApp = false;
        this.silk = false;
        this.audioData = false;
        this.webAudio = false;
        this.ogg = false;
        this.opus = false;
        this.mp3 = false;
        this.wav = false;
        this.m4a = false;
        this.webm = false;
        this.iPhone = false;
        this.iPhone4 = false;
        this.iPad = false;
        this.pixelRatio = 0;
        this.littleEndian = false;
        this.support32bit = false;
        this.fullscreen = false;
        this.requestFullscreen = "";
        this.cancelFullscreen = "";
        this.fullscreenKeyboard = false;
        this._checkAudio();
        this._checkBrowser();
        this._checkCSS3D();
        this._checkDevice();
        this._checkFeatures();
        this._checkOS()
    };
    t.Device.LITTLE_ENDIAN = false;
    t.Device.prototype = {
        _checkOS: function() {
            var e = navigator.userAgent;
            if (/Android/.test(e)) {
                this.android = true
            } else if (/CrOS/.test(e)) {
                this.chromeOS = true
            } else if (/iP[ao]d|iPhone/i.test(e)) {
                this.iOS = true
            } else if (/Linux/.test(e)) {
                this.linux = true
            } else if (/Mac OS/.test(e)) {
                this.macOS = true
            } else if (/Windows/.test(e)) {
                this.windows = true;
                if (/Windows Phone/i.test(e)) {
                    this.windowsPhone = true
                }
            }
            if (this.windows || this.macOS || this.linux && this.silk === false) {
                this.desktop = true
            }
            if (this.windowsPhone || /Windows NT/i.test(e) && /Touch/i.test(e)) {
                this.desktop = false
            }
        },
        _checkFeatures: function() {
            this.canvas = !! window["CanvasRenderingContext2D"] || this.cocoonJS;
            try {
                this.localStorage = !! localStorage.getItem
            } catch (e) {
                this.localStorage = false
            }
            this.file = !! window["File"] && !! window["FileReader"] && !! window["FileList"] && !! window["Blob"];
            this.fileSystem = !! window["requestFileSystem"];
            this.webGL = function() {
                try {
                    var e = document.createElement("canvas");
                    return !!window.WebGLRenderingContext && (e.getContext("webgl") || e.getContext("experimental-webgl"))
                } catch (t) {
                    return false
                }
            }();
            if (this.webGL === null || this.webGL === false) {
                this.webGL = false
            } else {
                this.webGL = true
            }
            this.worker = !! window["Worker"];
            if ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints > 1) {
                this.touch = true
            }
            if (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) {
                this.mspointer = true
            }
            this.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
            this.quirksMode = document.compatMode === "CSS1Compat" ? false : true;
            this.getUserMedia = !! (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia)
        },
        checkFullScreenSupport: function() {
            var e = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"];
            for (var t = 0; t < e.length; t++) {
                if (this.game.canvas[e[t]]) {
                    this.fullscreen = true;
                    this.requestFullscreen = e[t]
                }
            }
            var n = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
            if (this.fullscreen) {
                for (var t = 0; t < n.length; t++) {
                    if (this.game.canvas[n[t]]) {
                        this.cancelFullscreen = n[t]
                    }
                }
            }
            if (window["Element"] && Element["ALLOW_KEYBOARD_INPUT"]) {
                this.fullscreenKeyboard = true
            }
        },
        _checkBrowser: function() {
            var e = navigator.userAgent;
            if (/Arora/.test(e)) {
                this.arora = true
            } else if (/Chrome/.test(e)) {
                this.chrome = true
            } else if (/Epiphany/.test(e)) {
                this.epiphany = true
            } else if (/Firefox/.test(e)) {
                this.firefox = true
            } else if (/Mobile Safari/.test(e)) {
                this.mobileSafari = true
            } else if (/MSIE (\d+\.\d+);/.test(e)) {
                this.ie = true;
                this.ieVersion = parseInt(RegExp.$1, 10)
            } else if (/Midori/.test(e)) {
                this.midori = true
            } else if (/Opera/.test(e)) {
                this.opera = true
            } else if (/Safari/.test(e)) {
                this.safari = true
            } else if (/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(e)) {
                this.ie = true;
                this.trident = true;
                this.tridentVersion = parseInt(RegExp.$1, 10);
                this.ieVersion = parseInt(RegExp.$3, 10)
            }
            if (/Silk/.test(e)) {
                this.silk = true
            }
            if (navigator["standalone"]) {
                this.webApp = true
            }
            if (navigator["isCocoonJS"]) {
                this.cocoonJS = true
            }
            if (typeof window.ejecta !== "undefined") {
                this.ejecta = true
            }
            if (/Crosswalk/.test(e)) {
                this.crosswalk = true
            }
        },
        _checkAudio: function() {
            this.audioData = !! window["Audio"];
            this.webAudio = !! (window["webkitAudioContext"] || window["AudioContext"]);
            var e = document.createElement("audio");
            var t = false;
            try {
                if (t = !! e.canPlayType) {
                    if (e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "")) {
                        this.ogg = true
                    }
                    if (e.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "")) {
                        this.opus = true
                    }
                    if (e.canPlayType("audio/mpeg;").replace(/^no$/, "")) {
                        this.mp3 = true
                    }
                    if (e.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "")) {
                        this.wav = true
                    }
                    if (e.canPlayType("audio/x-m4a;") || e.canPlayType("audio/aac;").replace(/^no$/, "")) {
                        this.m4a = true
                    }
                    if (e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")) {
                        this.webm = true
                    }
                }
            } catch (n) {}
        },
        _checkDevice: function() {
            this.pixelRatio = window["devicePixelRatio"] || 1;
            this.iPhone = navigator.userAgent.toLowerCase().indexOf("iphone") != -1;
            this.iPhone4 = this.pixelRatio == 2 && this.iPhone;
            this.iPad = navigator.userAgent.toLowerCase().indexOf("ipad") != -1;
            if (typeof Int8Array !== "undefined") {
                this.typedArray = true
            } else {
                this.typedArray = false
            }
            if (typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint32Array !== "undefined") {
                this.littleEndian = this._checkIsLittleEndian();
                t.Device.LITTLE_ENDIAN = this.littleEndian
            }
            this.support32bit = typeof ArrayBuffer !== "undefined" && typeof Uint8ClampedArray !== "undefined" && typeof Int32Array !== "undefined" && this.littleEndian !== null && this._checkIsUint8ClampedImageData();
            navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;
            if (navigator.vibrate) {
                this.vibration = true
            }
        },
        _checkIsLittleEndian: function() {
            var e = new ArrayBuffer(4);
            var t = new Uint8Array(e);
            var n = new Uint32Array(e);
            t[0] = 161;
            t[1] = 178;
            t[2] = 195;
            t[3] = 212;
            if (n[0] == 3569595041) {
                return true
            }
            if (n[0] == 2712847316) {
                return false
            } else {
                return null
            }
        },
        _checkIsUint8ClampedImageData: function() {
            if (typeof Uint8ClampedArray === "undefined") {
                return false
            }
            var e = document.createElement("canvas");
            var t = e.getContext("2d");
            if (!t) {
                return false
            }
            var n = t.createImageData(1, 1);
            return n.data instanceof Uint8ClampedArray
        },
        _checkCSS3D: function() {
            var e = document.createElement("p");
            var t;
            var n = {
                webkitTransform: "-webkit-transform",
                OTransform: "-o-transform",
                msTransform: "-ms-transform",
                MozTransform: "-moz-transform",
                transform: "transform"
            };
            document.body.insertBefore(e, null);
            for (var r in n) {
                if (e.style[r] !== undefined) {
                    e.style[r] = "translate3d(1px,1px,1px)";
                    t = window.getComputedStyle(e).getPropertyValue(n[r])
                }
            }
            document.body.removeChild(e);
            this.css3D = t !== undefined && t.length > 0 && t !== "none"
        },
        canPlayAudio: function(e) {
            if (e == "mp3" && this.mp3) {
                return true
            } else if (e == "ogg" && (this.ogg || this.opus)) {
                return true
            } else if (e == "m4a" && this.m4a) {
                return true
            } else if (e == "wav" && this.wav) {
                return true
            } else if (e == "webm" && this.webm) {
                return true
            }
            return false
        },
        isConsoleOpen: function() {
            if (window.console && window.console["firebug"]) {
                return true
            }
            if (window.console) {
                console.profile();
                console.profileEnd();
                if (console.clear) {
                    console.clear()
                }
                if (console["profiles"]) {
                    return console["profiles"].length > 0
                }
            }
            return false
        }
    };
    t.Device.prototype.constructor = t.Device;
    t.RequestAnimationFrame = function(e, t) {
        if (typeof t === "undefined") {
            t = false
        }
        this.game = e;
        this.isRunning = false;
        this.forceSetTimeOut = t;
        var n = ["ms", "moz", "webkit", "o"];
        for (var r = 0; r < n.length && !window.requestAnimationFrame; r++) {
            window.requestAnimationFrame = window[n[r] + "RequestAnimationFrame"];
            window.cancelAnimationFrame = window[n[r] + "CancelAnimationFrame"]
        }
        this._isSetTimeOut = false;
        this._onLoop = null;
        this._timeOutID = null
    };
    t.RequestAnimationFrame.prototype = {
        start: function() {
            this.isRunning = true;
            var e = this;
            if (!window.requestAnimationFrame || this.forceSetTimeOut) {
                this._isSetTimeOut = true;
                this._onLoop = function() {
                    return e.updateSetTimeout()
                };
                this._timeOutID = window.setTimeout(this._onLoop, 0)
            } else {
                this._isSetTimeOut = false;
                this._onLoop = function(t) {
                    return e.updateRAF(t)
                };
                this._timeOutID = window.requestAnimationFrame(this._onLoop)
            }
        },
        updateRAF: function() {
            this.game.update(Date.now());
            this._timeOutID = window.requestAnimationFrame(this._onLoop)
        },
        updateSetTimeout: function() {
            this.game.update(Date.now());
            this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall)
        },
        stop: function() {
            if (this._isSetTimeOut) {
                clearTimeout(this._timeOutID)
            } else {
                window.cancelAnimationFrame(this._timeOutID)
            }
            this.isRunning = false
        },
        isSetTimeOut: function() {
            return this._isSetTimeOut
        },
        isRAF: function() {
            return this._isSetTimeOut === false
        }
    };
    t.RequestAnimationFrame.prototype.constructor = t.RequestAnimationFrame;
    t.Math = {
        PI2: Math.PI * 2,
        fuzzyEqual: function(e, t, n) {
            if (typeof n === "undefined") {
                n = 1e-4
            }
            return Math.abs(e - t) < n
        },
        fuzzyLessThan: function(e, t, n) {
            if (typeof n === "undefined") {
                n = 1e-4
            }
            return e < t + n
        },
        fuzzyGreaterThan: function(e, t, n) {
            if (typeof n === "undefined") {
                n = 1e-4
            }
            return e > t - n
        },
        fuzzyCeil: function(e, t) {
            if (typeof t === "undefined") {
                t = 1e-4
            }
            return Math.ceil(e - t)
        },
        fuzzyFloor: function(e, t) {
            if (typeof t === "undefined") {
                t = 1e-4
            }
            return Math.floor(e + t)
        },
        average: function() {
            var e = [];
            for (var t = 0; t < arguments.length - 0; t++) {
                e[t] = arguments[t + 0]
            }
            var n = 0;
            for (var r = 0; r < e.length; r++) {
                n += e[r]
            }
            return n / e.length
        },
        truncate: function(e) {
            return e > 0 ? Math.floor(e) : Math.ceil(e)
        },
        shear: function(e) {
            return e % 1
        },
        snapTo: function(e, t, n) {
            if (typeof n === "undefined") {
                n = 0
            }
            if (t === 0) {
                return e
            }
            e -= n;
            e = t * Math.round(e / t);
            return n + e
        },
        snapToFloor: function(e, t, n) {
            if (typeof n === "undefined") {
                n = 0
            }
            if (t === 0) {
                return e
            }
            e -= n;
            e = t * Math.floor(e / t);
            return n + e
        },
        snapToCeil: function(e, t, n) {
            if (typeof n === "undefined") {
                n = 0
            }
            if (t === 0) {
                return e
            }
            e -= n;
            e = t * Math.ceil(e / t);
            return n + e
        },
        snapToInArray: function(e, t, n) {
            if (typeof n === "undefined") {
                n = true
            }
            if (n) {
                t.sort()
            }
            if (e < t[0]) {
                return t[0]
            }
            var r = 1;
            while (t[r] < e) {
                r++
            }
            var i = t[r - 1];
            var s = r < t.length ? t[r] : Number.POSITIVE_INFINITY;
            return s - e <= e - i ? s : i
        },
        roundTo: function(e, t, n) {
            if (typeof t === "undefined") {
                t = 0
            }
            if (typeof n === "undefined") {
                n = 10
            }
            var r = Math.pow(n, -t);
            return Math.round(e * r) / r
        },
        floorTo: function(e, t, n) {
            if (typeof t === "undefined") {
                t = 0
            }
            if (typeof n === "undefined") {
                n = 10
            }
            var r = Math.pow(n, -t);
            return Math.floor(e * r) / r
        },
        ceilTo: function(e, t, n) {
            if (typeof t === "undefined") {
                t = 0
            }
            if (typeof n === "undefined") {
                n = 10
            }
            var r = Math.pow(n, -t);
            return Math.ceil(e * r) / r
        },
        interpolateFloat: function(e, t, n) {
            return (t - e) * n + e
        },
        angleBetween: function(e, t, n, r) {
            return Math.atan2(r - t, n - e)
        },
        angleBetweenPoints: function(e, t) {
            return Math.atan2(t.y - e.y, t.x - e.x)
        },
        reverseAngle: function(e) {
            return this.normalizeAngle(e + Math.PI, true)
        },
        normalizeAngle: function(e) {
            e = e % (2 * Math.PI);
            return e >= 0 ? e : e + 2 * Math.PI
        },
        normalizeLatitude: function(e) {
            return Math.max(-90, Math.min(90, e))
        },
        normalizeLongitude: function(e) {
            if (e % 360 == 180) {
                return 180
            }
            e = e % 360;
            return e < -180 ? e + 360 : e > 180 ? e - 360 : e
        },
        chanceRoll: function(e) {
            if (typeof e === "undefined") {
                e = 50
            }
            if (e <= 0) {
                return false
            } else if (e >= 100) {
                return true
            } else {
                if (Math.random() * 100 >= e) {
                    return false
                } else {
                    return true
                }
            }
        },
        numberArray: function(e, t) {
            var n = [];
            for (var r = e; r <= t; r++) {
                n.push(r)
            }
            return n
        },
        maxAdd: function(e, t, n) {
            e += t;
            if (e > n) {
                e = n
            }
            return e
        },
        minSub: function(e, t, n) {
            e -= t;
            if (e < n) {
                e = n
            }
            return e
        },
        wrap: function(e, t, n) {
            var r = n - t;
            if (r <= 0) {
                return 0
            }
            var i = (e - t) % r;
            if (i < 0) {
                i += r
            }
            return i + t
        },
        wrapValue: function(e, t, n) {
            var r;
            e = Math.abs(e);
            t = Math.abs(t);
            n = Math.abs(n);
            r = (e + t) % n;
            return r
        },
        limitValue: function(e, t, n) {
            return e < t ? t : e > n ? n : e
        },
        randomSign: function() {
            return Math.random() > .5 ? 1 : -1
        },
        isOdd: function(e) {
            return e & 1
        },
        isEven: function(e) {
            if (e & 1) {
                return false
            } else {
                return true
            }
        },
        min: function() {
            if (arguments.length === 1 && typeof arguments[0] === "object") {
                var e = arguments[0]
            } else {
                var e = arguments
            }
            for (var t = 1, n = 0, r = e.length; t < r; t++) {
                if (e[t] < e[n]) {
                    n = t
                }
            }
            return e[n]
        },
        max: function() {
            if (arguments.length === 1 && typeof arguments[0] === "object") {
                var e = arguments[0]
            } else {
                var e = arguments
            }
            for (var t = 1, n = 0, r = e.length; t < r; t++) {
                if (e[t] > e[n]) {
                    n = t
                }
            }
            return e[n]
        },
        minProperty: function(e) {
            if (arguments.length === 2 && typeof arguments[1] === "object") {
                var t = arguments[1]
            } else {
                var t = arguments.slice(1)
            }
            for (var n = 1, r = 0, i = t.length; n < i; n++) {
                if (t[n][e] < t[r][e]) {
                    r = n
                }
            }
            return t[r][e]
        },
        maxProperty: function(e) {
            if (arguments.length === 2 && typeof arguments[1] === "object") {
                var t = arguments[1]
            } else {
                var t = arguments.slice(1)
            }
            for (var n = 1, r = 0, i = t.length; n < i; n++) {
                if (t[n][e] > t[r][e]) {
                    r = n
                }
            }
            return t[r][e]
        },
        wrapAngle: function(e, t) {
            var n = t ? Math.PI / 180 : 1;
            return this.wrap(e, -180 * n, 180 * n)
        },
        angleLimit: function(e, t, n) {
            var r = e;
            if (e > n) {
                r = n
            } else if (e < t) {
                r = t
            }
            return r
        },
        linearInterpolation: function(e, t) {
            var n = e.length - 1;
            var r = n * t;
            var i = Math.floor(r);
            if (t < 0) {
                return this.linear(e[0], e[1], r)
            }
            if (t > 1) {
                return this.linear(e[n], e[n - 1], n - r)
            }
            return this.linear(e[i], e[i + 1 > n ? n : i + 1], r - i)
        },
        bezierInterpolation: function(e, t) {
            var n = 0;
            var r = e.length - 1;
            for (var i = 0; i <= r; i++) {
                n += Math.pow(1 - t, r - i) * Math.pow(t, i) * e[i] * this.bernstein(r, i)
            }
            return n
        },
        catmullRomInterpolation: function(e, t) {
            var n = e.length - 1;
            var r = n * t;
            var i = Math.floor(r);
            if (e[0] === e[n]) {
                if (t < 0) {
                    i = Math.floor(r = n * (1 + t))
                }
                return this.catmullRom(e[(i - 1 + n) % n], e[i], e[(i + 1) % n], e[(i + 2) % n], r - i)
            } else {
                if (t < 0) {
                    return e[0] - (this.catmullRom(e[0], e[0], e[1], e[1], -r) - e[0])
                }
                if (t > 1) {
                    return e[n] - (this.catmullRom(e[n], e[n], e[n - 1], e[n - 1], r - n) - e[n])
                }
                return this.catmullRom(e[i ? i - 1 : 0], e[i], e[n < i + 1 ? n : i + 1], e[n < i + 2 ? n : i + 2], r - i)
            }
        },
        linear: function(e, t, n) {
            return (t - e) * n + e
        },
        bernstein: function(e, t) {
            return this.factorial(e) / this.factorial(t) / this.factorial(e - t)
        },
        catmullRom: function(e, t, n, r, i) {
            var s = (n - e) * .5,
                o = (r - t) * .5,
                u = i * i,
                a = i * u;
            return (2 * t - 2 * n + s + o) * a + (-3 * t + 3 * n - 2 * s - o) * u + s * i + t
        },
        difference: function(e, t) {
            return Math.abs(e - t)
        },
        getRandom: function(e, t, n) {
            if (typeof t === "undefined") {
                t = 0
            }
            if (typeof n === "undefined") {
                n = 0
            }
            if (e != null) {
                var r = n;
                if (r === 0 || r > e.length - t) {
                    r = e.length - t
                }
                if (r > 0) {
                    return e[t + Math.floor(Math.random() * r)]
                }
            }
            return null
        },
        removeRandom: function(e, t, n) {
            if (typeof t === "undefined") {
                t = 0
            }
            if (typeof n === "undefined") {
                n = 0
            }
            if (e != null) {
                var r = n;
                if (r === 0 || r > e.length - t) {
                    r = e.length - t
                }
                if (r > 0) {
                    var i = t + Math.floor(Math.random() * r);
                    var s = e.splice(i, 1);
                    return s[0]
                }
            }
            return null
        },
        floor: function(e) {
            var t = e | 0;
            return e > 0 ? t : t != e ? t - 1 : t
        },
        ceil: function(e) {
            var t = e | 0;
            return e > 0 ? t != e ? t + 1 : t : t
        },
        sinCosGenerator: function(e, t, n, r) {
            if (typeof t === "undefined") {
                t = 1
            }
            if (typeof n === "undefined") {
                n = 1
            }
            if (typeof r === "undefined") {
                r = 1
            }
            var i = t;
            var s = n;
            var o = r * Math.PI / e;
            var u = [];
            var a = [];
            for (var f = 0; f < e; f++) {
                s -= i * o;
                i += s * o;
                u[f] = s;
                a[f] = i
            }
            return {
                sin: a,
                cos: u,
                length: e
            }
        },
        shift: function(e) {
            var t = e.shift();
            e.push(t);
            return t
        },
        shuffleArray: function(e) {
            for (var t = e.length - 1; t > 0; t--) {
                var n = Math.floor(Math.random() * (t + 1));
                var r = e[t];
                e[t] = e[n];
                e[n] = r
            }
            return e
        },
        distance: function(e, t, n, r) {
            var i = e - n;
            var s = t - r;
            return Math.sqrt(i * i + s * s)
        },
        distancePow: function(e, t, n, r, i) {
            if (typeof i === "undefined") {
                i = 2
            }
            return Math.sqrt(Math.pow(n - e, i) + Math.pow(r - t, i))
        },
        distanceRounded: function(e, n, r, i) {
            return Math.round(t.Math.distance(e, n, r, i))
        },
        clamp: function(e, t, n) {
            return e < t ? t : e > n ? n : e
        },
        clampBottom: function(e, t) {
            return e < t ? t : e
        },
        within: function(e, t, n) {
            return Math.abs(e - t) <= n
        },
        mapLinear: function(e, t, n, r, i) {
            return r + (e - t) * (i - r) / (n - t)
        },
        smoothstep: function(e, t, n) {
            e = Math.max(0, Math.min(1, (e - t) / (n - t)));
            return e * e * (3 - 2 * e)
        },
        smootherstep: function(e, t, n) {
            e = Math.max(0, Math.min(1, (e - t) / (n - t)));
            return e * e * e * (e * (e * 6 - 15) + 10)
        },
        sign: function(e) {
            return e < 0 ? -1 : e > 0 ? 1 : 0
        },
        percent: function(e, t, n) {
            if (typeof n === "undefined") {
                n = 0
            }
            if (e > t || n > t) {
                return 1
            } else if (e < n || n > e) {
                return 0
            } else {
                return (e - n) / t
            }
        },
        degToRad: function() {
            var e = Math.PI / 180;
            return function(t) {
                return t * e
            }
        }(),
        radToDeg: function() {
            var e = 180 / Math.PI;
            return function(t) {
                return t * e
            }
        }()
    };
    t.RandomDataGenerator = function(e) {
        if (typeof e === "undefined") {
            e = []
        }
        this.c = 1;
        this.s0 = 0;
        this.s1 = 0;
        this.s2 = 0;
        this.sow(e)
    };
    t.RandomDataGenerator.prototype = {
        rnd: function() {
            var e = 2091639 * this.s0 + this.c * 2.3283064365386963e-10;
            this.c = e | 0;
            this.s0 = this.s1;
            this.s1 = this.s2;
            this.s2 = e - this.c;
            return this.s2
        },
        sow: function(e) {
            if (typeof e === "undefined") {
                e = []
            }
            this.s0 = this.hash(" ");
            this.s1 = this.hash(this.s0);
            this.s2 = this.hash(this.s1);
            this.c = 1;
            var t;
            for (var n = 0; t = e[n++];) {
                this.s0 -= this.hash(t);
                this.s0 += ~~ (this.s0 < 0);
                this.s1 -= this.hash(t);
                this.s1 += ~~ (this.s1 < 0);
                this.s2 -= this.hash(t);
                this.s2 += ~~ (this.s2 < 0)
            }
        },
        hash: function(e) {
            var t, n, r;
            r = 4022871197;
            e = e.toString();
            for (n = 0; n < e.length; n++) {
                r += e.charCodeAt(n);
                t = .02519603282416938 * r;
                r = t >>> 0;
                t -= r;
                t *= r;
                r = t >>> 0;
                t -= r;
                r += t * 4294967296
            }
            return (r >>> 0) * 2.3283064365386963e-10
        },
        integer: function() {
            return this.rnd.apply(this) * 4294967296
        },
        frac: function() {
            return this.rnd.apply(this) + (this.rnd.apply(this) * 2097152 | 0) * 1.1102230246251565e-16
        },
        real: function() {
            return this.integer() + this.frac()
        },
        integerInRange: function(e, t) {
            return Math.floor(this.realInRange(0, t - e + 1) + e)
        },
        realInRange: function(e, t) {
            return this.frac() * (t - e) + e
        },
        normal: function() {
            return 1 - 2 * this.frac()
        },
        uuid: function() {
            var e = "";
            var t = "";
            for (t = e = ""; e++ < 36; t += ~e % 5 | e * 3 & 4 ? (e ^ 15 ? 8 ^ this.frac() * (e ^ 20 ? 16 : 4) : 4).toString(16) : "-") {}
            return t
        },
        pick: function(e) {
            return e[this.integerInRange(0, e.length - 1)]
        },
        weightedPick: function(e) {
            return e[~~ (Math.pow(this.frac(), 2) * (e.length - 1))]
        },
        timestamp: function(e, t) {
            return this.realInRange(e || 9466848e5, t || 1577862e6)
        },
        angle: function() {
            return this.integerInRange(-180, 180)
        }
    };
    t.RandomDataGenerator.prototype.constructor = t.RandomDataGenerator;
    t.QuadTree = function(e, t, n, r, i, s, o) {
        this.maxObjects = 10;
        this.maxLevels = 4;
        this.level = 0;
        this.bounds = {};
        this.objects = [];
        this.nodes = [];
        this._empty = [];
        this.reset(e, t, n, r, i, s, o)
    };
    t.QuadTree.prototype = {
        reset: function(e, t, n, r, i, s, o) {
            this.maxObjects = i || 10;
            this.maxLevels = s || 4;
            this.level = o || 0;
            this.bounds = {
                x: Math.round(e),
                y: Math.round(t),
                width: n,
                height: r,
                subWidth: Math.floor(n / 2),
                subHeight: Math.floor(r / 2),
                right: Math.round(e) + Math.floor(n / 2),
                bottom: Math.round(t) + Math.floor(r / 2)
            };
            this.objects.length = 0;
            this.nodes.length = 0
        },
        populate: function(e) {
            e.forEach(this.populateHandler, this, true)
        },
        populateHandler: function(e) {
            if (e.body && e.exists) {
                this.insert(e.body)
            }
        },
        split: function() {
            this.level++;
            this.nodes[0] = new t.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level);
            this.nodes[1] = new t.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level);
            this.nodes[2] = new t.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level);
            this.nodes[3] = new t.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level)
        },
        insert: function(e) {
            var t = 0;
            var n;
            if (this.nodes[0] != null) {
                n = this.getIndex(e);
                if (n !== -1) {
                    this.nodes[n].insert(e);
                    return
                }
            }
            this.objects.push(e);
            if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {
                if (this.nodes[0] == null) {
                    this.split()
                }
                while (t < this.objects.length) {
                    n = this.getIndex(this.objects[t]);
                    if (n !== -1) {
                        this.nodes[n].insert(this.objects.splice(t, 1)[0])
                    } else {
                        t++
                    }
                }
            }
        },
        getIndex: function(e) {
            var t = -1;
            if (e.x < this.bounds.right && e.right < this.bounds.right) {
                if (e.y < this.bounds.bottom && e.bottom < this.bounds.bottom) {
                    t = 1
                } else if (e.y > this.bounds.bottom) {
                    t = 2
                }
            } else if (e.x > this.bounds.right) {
                if (e.y < this.bounds.bottom && e.bottom < this.bounds.bottom) {
                    t = 0
                } else if (e.y > this.bounds.bottom) {
                    t = 3
                }
            }
            return t
        },
        retrieve: function(e) {
            if (e instanceof t.Rectangle) {
                var n = this.objects;
                var r = this.getIndex(e)
            } else {
                if (!e.body) {
                    return this._empty
                }
                var n = this.objects;
                var r = this.getIndex(e.body)
            }
            if (this.nodes[0]) {
                if (r !== -1) {
                    n = n.concat(this.nodes[r].retrieve(e))
                } else {
                    n = n.concat(this.nodes[0].retrieve(e));
                    n = n.concat(this.nodes[1].retrieve(e));
                    n = n.concat(this.nodes[2].retrieve(e));
                    n = n.concat(this.nodes[3].retrieve(e))
                }
            }
            return n
        },
        clear: function() {
            this.objects.length = 0;
            var e = this.nodes.length;
            while (e--) {
                this.nodes[e].clear();
                this.nodes.splice(e, 1)
            }
            this.nodes.length = 0
        }
    };
    t.QuadTree.prototype.constructor = t.QuadTree;
    t.Net = function(e) {
        this.game = e
    };
    t.Net.prototype = {
        getHostName: function() {
            if (window.location && window.location.hostname) {
                return window.location.hostname
            }
            return null
        },
        checkDomainName: function(e) {
            return true
        },
        updateQueryString: function(e, t, n, r) {
            if (typeof n === "undefined") {
                n = false
            }
            if (typeof r === "undefined" || r === "") {
                r = window.location.href
            }
            var i = "";
            var s = new RegExp("([?|&])" + e + "=.*?(&|#|$)(.*)", "gi");
            if (s.test(r)) {
                if (typeof t !== "undefined" && t !== null) {
                    i = r.replace(s, "$1" + e + "=" + t + "$2$3")
                } else {
                    i = r.replace(s, "$1$3").replace(/(&|\?)$/, "")
                }
            } else {
                if (typeof t !== "undefined" && t !== null) {
                    var o = r.indexOf("?") !== -1 ? "&" : "?";
                    var u = r.split("#");
                    r = u[0] + o + e + "=" + t;
                    if (u[1]) {
                        r += "#" + u[1]
                    }
                    i = r
                } else {
                    i = r
                }
            }
            if (n) {
                //window.location.href = i
            } else {
                return i
            }
        },
        getQueryString: function(e) {
            if (typeof e === "undefined") {
                e = ""
            }
            var t = {};
            var n = location.search.substring(1).split("&");
            for (var r in n) {
                var i = n[r].split("=");
                if (i.length > 1) {
                    if (e && e == this.decodeURI(i[0])) {
                        return this.decodeURI(i[1])
                    } else {
                        t[this.decodeURI(i[0])] = this.decodeURI(i[1])
                    }
                }
            }
            return t
        },
        decodeURI: function(e) {
            return decodeURIComponent(e.replace(/\+/g, " "))
        }
    };
    t.Net.prototype.constructor = t.Net;
    t.TweenManager = function(e) {
        this.game = e;
        this._tweens = [];
        this._add = [];
        this.game.onPause.add(this._pauseAll, this);
        this.game.onResume.add(this._resumeAll, this)
    };
    t.TweenManager.prototype = {
        getAll: function() {
            return this._tweens
        },
        removeAll: function() {
            for (var e = 0; e < this._tweens.length; e++) {
                this._tweens[e].pendingDelete = true
            }
            this._add = []
        },
        add: function(e) {
            e._manager = this;
            this._add.push(e)
        },
        create: function(e) {
            return new t.Tween(e, this.game, this)
        },
        remove: function(e) {
            var t = this._tweens.indexOf(e);
            if (t !== -1) {
                this._tweens[t].pendingDelete = true
            }
        },
        update: function() {
            if (this._tweens.length === 0 && this._add.length === 0) {
                return false
            }
            var e = 0;
            var t = this._tweens.length;
            while (e < t) {
                if (this._tweens[e].update(this.game.time.now)) {
                    e++
                } else {
                    this._tweens.splice(e, 1);
                    t--
                }
            }
            if (this._add.length > 0) {
                this._tweens = this._tweens.concat(this._add);
                this._add.length = 0
            }
            return true
        },
        isTweening: function(e) {
            return this._tweens.some(function(t) {
                return t._object === e
            })
        },
        _pauseAll: function() {
            for (var e = this._tweens.length - 1; e >= 0; e--) {
                this._tweens[e]._pause()
            }
        },
        _resumeAll: function() {
            for (var e = this._tweens.length - 1; e >= 0; e--) {
                this._tweens[e]._resume()
            }
        },
        pauseAll: function() {
            for (var e = this._tweens.length - 1; e >= 0; e--) {
                this._tweens[e].pause()
            }
        },
        resumeAll: function() {
            for (var e = this._tweens.length - 1; e >= 0; e--) {
                this._tweens[e].resume(true)
            }
        }
    };
    t.TweenManager.prototype.constructor = t.TweenManager;
    t.Tween = function(e, n, r) {
        this._object = e;
        this.game = n;
        this._manager = r;
        this._valuesStart = {};
        this._valuesEnd = {};
        this._valuesStartRepeat = {};
        this._duration = 1e3;
        this._repeat = 0;
        this._yoyo = false;
        this._reversed = false;
        this._delayTime = 0;
        this._startTime = null;
        this._easingFunction = t.Easing.Linear.None;
        this._interpolationFunction = t.Math.linearInterpolation;
        this._chainedTweens = [];
        this._onStartCallbackFired = false;
        this._onUpdateCallback = null;
        this._onUpdateCallbackContext = null;
        this._paused = false;
        this._pausedTime = 0;
        this._codePaused = false;
        this.pendingDelete = false;
        this.onStart = new t.Signal;
        this.onLoop = new t.Signal;
        this.onComplete = new t.Signal;
        this.isRunning = false
    };
    t.Tween.prototype = {
        to: function(e, t, n, r, i, s, o) {
            t = t || 1e3;
            n = n || null;
            r = r || false;
            i = i || 0;
            s = s || 0;
            o = o || false;
            if (o && s === 0) {
                s = 1
            }
            var u;
            if (this._parent) {
                u = this._manager.create(this._object);
                this._lastChild.chain(u);
                this._lastChild = u
            } else {
                u = this;
                this._parent = this;
                this._lastChild = this
            }
            u._repeat = s;
            u._duration = t;
            u._valuesEnd = e;
            if (n !== null) {
                u._easingFunction = n
            }
            if (i > 0) {
                u._delayTime = i
            }
            u._yoyo = o;
            if (r) {
                return this.start()
            } else {
                return this
            }
        },
        from: function(e, t, n, r, i, s, o) {
            var u = {};
            for (var a in e) {
                if (e.hasOwnProperty(a)) {
                    u[a] = this._object[a];
                    this._object[a] = e[a]
                }
            }
            this.to(u, t, n, r, i, s, o)
        },
        start: function() {
            if (this.game === null || this._object === null) {
                return
            }
            this._manager.add(this);
            this.isRunning = true;
            this._onStartCallbackFired = false;
            this._startTime = this.game.time.now + this._delayTime;
            for (var e in this._valuesEnd) {
                if (Array.isArray(this._valuesEnd[e])) {
                    if (this._valuesEnd[e].length === 0) {
                        continue
                    }
                    this._valuesEnd[e] = [this._object[e]].concat(this._valuesEnd[e])
                }
                this._valuesStart[e] = this._object[e];
                if (!Array.isArray(this._valuesStart[e])) {
                    this._valuesStart[e] *= 1
                }
                this._valuesStartRepeat[e] = this._valuesStart[e] || 0
            }
            return this
        },
        generateData: function(e, t) {
            if (this.game === null || this._object === null) {
                return null
            }
            this._startTime = 0;
            for (var n in this._valuesEnd) {
                if (Array.isArray(this._valuesEnd[n])) {
                    if (this._valuesEnd[n].length === 0) {
                        continue
                    }
                    this._valuesEnd[n] = [this._object[n]].concat(this._valuesEnd[n])
                }
                this._valuesStart[n] = this._object[n];
                if (!Array.isArray(this._valuesStart[n])) {
                    this._valuesStart[n] *= 1
                }
                this._valuesStartRepeat[n] = this._valuesStart[n] || 0
            }
            var r = 0;
            var i = Math.floor(e * (this._duration / 1e3));
            var s = this._duration / i;
            var o = [];
            while (i--) {
                var n;
                var u = (r - this._startTime) / this._duration;
                u = u > 1 ? 1 : u;
                var a = this._easingFunction(u);
                var f = {};
                for (n in this._valuesEnd) {
                    var l = this._valuesStart[n] || 0;
                    var c = this._valuesEnd[n];
                    if (c instanceof Array) {
                        f[n] = this._interpolationFunction(c, a)
                    } else {
                        if (typeof c === "string") {
                            c = l + parseFloat(c, 10)
                        }
                        if (typeof c === "number") {
                            f[n] = l + (c - l) * a
                        }
                    }
                }
                o.push(f);
                r += s
            }
            if (this._yoyo) {
                var h = o.slice();
                h.reverse();
                o = o.concat(h)
            }
            if (typeof t !== "undefined") {
                t = t.concat(o);
                return t
            } else {
                return o
            }
        },
        stop: function() {
            this.isRunning = false;
            this._onUpdateCallback = null;
            this._manager.remove(this);
            return this
        },
        delay: function(e) {
            this._delayTime = e;
            return this
        },
        repeat: function(e) {
            this._repeat = e;
            return this
        },
        yoyo: function(e) {
            this._yoyo = e;
            if (e && this._repeat === 0) {
                this._repeat = 1
            }
            return this
        },
        easing: function(e) {
            this._easingFunction = e;
            return this
        },
        interpolation: function(e) {
            this._interpolationFunction = e;
            return this
        },
        chain: function() {
            this._chainedTweens = arguments;
            return this
        },
        loop: function() {
            this._lastChild.chain(this);
            return this
        },
        onUpdateCallback: function(e, t) {
            this._onUpdateCallback = e;
            this._onUpdateCallbackContext = t;
            return this
        },
        pause: function() {
            this._codePaused = true;
            this._paused = true;
            this._pausedTime = this.game.time.now
        },
        _pause: function() {
            if (!this._codePaused) {
                this._paused = true;
                this._pausedTime = this.game.time.now
            }
        },
        resume: function() {
            if (this._paused) {
                this._paused = false;
                this._codePaused = false;
                this._startTime += this.game.time.now - this._pausedTime
            }
        },
        _resume: function() {
            if (this._codePaused) {
                return
            } else {
                this._startTime += this.game.time.pauseDuration;
                this._paused = false
            }
        },
        update: function(e) {
            if (this.pendingDelete) {
                return false
            }
            if (this._paused || e < this._startTime) {
                return true
            }
            var t;
            if (e < this._startTime) {
                return true
            }
            if (this._onStartCallbackFired === false) {
                this.onStart.dispatch(this._object);
                this._onStartCallbackFired = true
            }
            var n = (e - this._startTime) / this._duration;
            n = n > 1 ? 1 : n;
            var r = this._easingFunction(n);
            for (t in this._valuesEnd) {
                var i = this._valuesStart[t] || 0;
                var s = this._valuesEnd[t];
                if (s instanceof Array) {
                    this._object[t] = this._interpolationFunction(s, r)
                } else {
                    if (typeof s === "string") {
                        s = i + parseFloat(s, 10)
                    }
                    if (typeof s === "number") {
                        this._object[t] = i + (s - i) * r
                    }
                }
            }
            if (this._onUpdateCallback !== null) {
                this._onUpdateCallback.call(this._onUpdateCallbackContext, this, r)
            }
            if (n == 1) {
                if (this._repeat > 0) {
                    if (isFinite(this._repeat)) {
                        this._repeat--
                    }
                    for (t in this._valuesStartRepeat) {
                        if (typeof this._valuesEnd[t] === "string") {
                            this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(this._valuesEnd[t], 10)
                        }
                        if (this._yoyo) {
                            var o = this._valuesStartRepeat[t];
                            this._valuesStartRepeat[t] = this._valuesEnd[t];
                            this._valuesEnd[t] = o
                        }
                        this._valuesStart[t] = this._valuesStartRepeat[t]
                    }
                    if (this._yoyo) {
                        this._reversed = !this._reversed
                    }
                    this._startTime = e + this._delayTime;
                    this.onLoop.dispatch(this._object);
                    return true
                } else {
                    this.isRunning = false;
                    this.onComplete.dispatch(this._object);
                    for (var u = 0, a = this._chainedTweens.length; u < a; u++) {
                        this._chainedTweens[u].start(e)
                    }
                    return false
                }
            }
            return true
        }
    };
    t.Tween.prototype.constructor = t.Tween;
    t.Easing = {
        Linear: {
            None: function(e) {
                return e
            }
        },
        Quadratic: {
            In: function(e) {
                return e * e
            },
            Out: function(e) {
                return e * (2 - e)
            },
            InOut: function(e) {
                if ((e *= 2) < 1) return .5 * e * e;
                return -.5 * (--e * (e - 2) - 1)
            }
        },
        Cubic: {
            In: function(e) {
                return e * e * e
            },
            Out: function(e) {
                return --e * e * e + 1
            },
            InOut: function(e) {
                if ((e *= 2) < 1) return .5 * e * e * e;
                return .5 * ((e -= 2) * e * e + 2)
            }
        },
        Quartic: {
            In: function(e) {
                return e * e * e * e
            },
            Out: function(e) {
                return 1 - --e * e * e * e
            },
            InOut: function(e) {
                if ((e *= 2) < 1) return .5 * e * e * e * e;
                return -.5 * ((e -= 2) * e * e * e - 2)
            }
        },
        Quintic: {
            In: function(e) {
                return e * e * e * e * e
            },
            Out: function(e) {
                return --e * e * e * e * e + 1
            },
            InOut: function(e) {
                if ((e *= 2) < 1) return .5 * e * e * e * e * e;
                return .5 * ((e -= 2) * e * e * e * e + 2)
            }
        },
        Sinusoidal: {
            In: function(e) {
                return 1 - Math.cos(e * Math.PI / 2)
            },
            Out: function(e) {
                return Math.sin(e * Math.PI / 2)
            },
            InOut: function(e) {
                return .5 * (1 - Math.cos(Math.PI * e))
            }
        },
        Exponential: {
            In: function(e) {
                return e === 0 ? 0 : Math.pow(1024, e - 1)
            },
            Out: function(e) {
                return e === 1 ? 1 : 1 - Math.pow(2, -10 * e)
            },
            InOut: function(e) {
                if (e === 0) return 0;
                if (e === 1) return 1;
                if ((e *= 2) < 1) return .5 * Math.pow(1024, e - 1);
                return .5 * (-Math.pow(2, -10 * (e - 1)) + 2)
            }
        },
        Circular: {
            In: function(e) {
                return 1 - Math.sqrt(1 - e * e)
            },
            Out: function(e) {
                return Math.sqrt(1 - --e * e)
            },
            InOut: function(e) {
                if ((e *= 2) < 1) return -.5 * (Math.sqrt(1 - e * e) - 1);
                return .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
            }
        },
        Elastic: {
            In: function(e) {
                var t, n = .1,
                    r = .4;
                if (e === 0) return 0;
                if (e === 1) return 1;
                if (!n || n < 1) {
                    n = 1;
                    t = r / 4
                } else t = r * Math.asin(1 / n) / (2 * Math.PI);
                return -(n * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * 2 * Math.PI / r))
            },
            Out: function(e) {
                var t, n = .1,
                    r = .4;
                if (e === 0) return 0;
                if (e === 1) return 1;
                if (!n || n < 1) {
                    n = 1;
                    t = r / 4
                } else t = r * Math.asin(1 / n) / (2 * Math.PI);
                return n * Math.pow(2, -10 * e) * Math.sin((e - t) * 2 * Math.PI / r) + 1
            },
            InOut: function(e) {
                var t, n = .1,
                    r = .4;
                if (e === 0) return 0;
                if (e === 1) return 1;
                if (!n || n < 1) {
                    n = 1;
                    t = r / 4
                } else t = r * Math.asin(1 / n) / (2 * Math.PI);
                if ((e *= 2) < 1) return -.5 * n * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * 2 * Math.PI / r);
                return n * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - t) * 2 * Math.PI / r) * .5 + 1
            }
        },
        Back: {
            In: function(e) {
                var t = 1.70158;
                return e * e * ((t + 1) * e - t)
            },
            Out: function(e) {
                var t = 1.70158;
                return --e * e * ((t + 1) * e + t) + 1
            },
            InOut: function(e) {
                var t = 1.70158 * 1.525;
                if ((e *= 2) < 1) return .5 * e * e * ((t + 1) * e - t);
                return .5 * ((e -= 2) * e * ((t + 1) * e + t) + 2)
            }
        },
        Bounce: {
            In: function(e) {
                return 1 - t.Easing.Bounce.Out(1 - e)
            },
            Out: function(e) {
                if (e < 1 / 2.75) {
                    return 7.5625 * e * e
                } else if (e < 2 / 2.75) {
                    return 7.5625 * (e -= 1.5 / 2.75) * e + .75
                } else if (e < 2.5 / 2.75) {
                    return 7.5625 * (e -= 2.25 / 2.75) * e + .9375
                } else {
                    return 7.5625 * (e -= 2.625 / 2.75) * e + .984375
                }
            },
            InOut: function(e) {
                if (e < .5) return t.Easing.Bounce.In(e * 2) * .5;
                return t.Easing.Bounce.Out(e * 2 - 1) * .5 + .5
            }
        }
    };
    t.Time = function(e) {
        this.game = e;
        this.time = 0;
        this.now = 0;
        this.elapsed = 0;
        this.pausedTime = 0;
        this.advancedTiming = false;
        this.fps = 0;
        this.fpsMin = 1e3;
        this.fpsMax = 0;
        this.msMin = 1e3;
        this.msMax = 0;
        this.physicsElapsed = 0;
        this.deltaCap = 0;
        this.timeCap = 1e3;
        this.frames = 0;
        this.pauseDuration = 0;
        this.timeToCall = 0;
        this.lastTime = 0;
        this.events = new t.Timer(this.game, false);
        this._started = 0;
        this._timeLastSecond = 0;
        this._pauseStarted = 0;
        this._justResumed = false;
        this._timers = [];
        this._len = 0;
        this._i = 0
    };
    t.Time.prototype = {
        boot: function() {
            this._started = Date.now();
            this.events.start()
        },
        create: function(e) {
            if (typeof e === "undefined") {
                e = true
            }
            var n = new t.Timer(this.game, e);
            this._timers.push(n);
            return n
        },
        removeAll: function() {
            for (var e = 0; e < this._timers.length; e++) {
                this._timers[e].destroy()
            }
            this._timers = [];
            this.events.removeAll()
        },
        update: function(e) {
            this.now = e;
            this.timeToCall = this.game.math.max(0, 16 - (e - this.lastTime));
            this.elapsed = this.now - this.time;
            if (this.elapsed > this.timeCap) {
                this.elapsed = 1 / 60
            }
            this.physicsElapsed = this.elapsed / 1e3 || 1 / 60;
            if (this.deltaCap > 0 && this.physicsElapsed > this.deltaCap) {
                this.physicsElapsed = this.deltaCap
            }
            if (this.advancedTiming) {
                this.msMin = this.game.math.min(this.msMin, this.elapsed);
                this.msMax = this.game.math.max(this.msMax, this.elapsed);
                this.frames++;
                if (this.now > this._timeLastSecond + 1e3) {
                    this.fps = Math.round(this.frames * 1e3 / (this.now - this._timeLastSecond));
                    this.fpsMin = this.game.math.min(this.fpsMin, this.fps);
                    this.fpsMax = this.game.math.max(this.fpsMax, this.fps);
                    this._timeLastSecond = this.now;
                    this.frames = 0
                }
            }
            this.time = this.now;
            this.lastTime = e + this.timeToCall;
            if (!this.game.paused) {
                this.events.update(this.now);
                this._i = 0;
                this._len = this._timers.length;
                while (this._i < this._len) {
                    if (this._timers[this._i].update(this.now)) {
                        this._i++
                    } else {
                        this._timers.splice(this._i, 1);
                        this._len--
                    }
                }
            }
        },
        gamePaused: function() {
            this._pauseStarted = this.now;
            this.events.pause();
            var e = this._timers.length;
            while (e--) {
                this._timers[e]._pause()
            }
        },
        gameResumed: function() {
            this.time = this.now = Date.now();
            this.pauseDuration = this.time - this._pauseStarted;
            this.events.resume();
            var e = this._timers.length;
            while (e--) {
                this._timers[e]._resume()
            }
        },
        totalElapsedSeconds: function() {
            return (this.now - this._started) * .001
        },
        elapsedSince: function(e) {
            return this.now - e
        },
        elapsedSecondsSince: function(e) {
            return (this.now - e) * .001
        },
        reset: function() {
            this._started = this.now;
            this.removeAll()
        }
    };
    t.Time.prototype.constructor = t.Time;
    t.Timer = function(e, n) {
        if (typeof n === "undefined") {
            n = true
        }
        this.game = e;
        this.running = false;
        this.autoDestroy = n;
        this.expired = false;
        this.elapsed = 0;
        this.events = [];
        this.onComplete = new t.Signal;
        this.nextTick = 0;
        this.timeCap = 1e3;
        this.paused = false;
        this._codePaused = false;
        this._started = 0;
        this._pauseStarted = 0;
        this._pauseTotal = 0;
        this._now = Date.now();
        this._len = 0;
        this._marked = 0;
        this._i = 0;
        this._diff = 0;
        this._newTick = 0
    };
    t.Timer.MINUTE = 6e4;
    t.Timer.SECOND = 1e3;
    t.Timer.HALF = 500;
    t.Timer.QUARTER = 250;
    t.Timer.prototype = {
        create: function(e, n, r, i, s, o) {
            var u = e;
            if (this._now === 0) {
                u += this.game.time.now
            } else {
                u += this._now
            }
            var a = new t.TimerEvent(this, e, u, r, n, i, s, o);
            this.events.push(a);
            this.order();
            this.expired = false;
            return a
        },
        add: function(e, t, n) {
            return this.create(e, false, 0, t, n, Array.prototype.splice.call(arguments, 3))
        },
        repeat: function(e, t, n, r) {
            return this.create(e, false, t, n, r, Array.prototype.splice.call(arguments, 4))
        },
        loop: function(e, t, n) {
            return this.create(e, true, 0, t, n, Array.prototype.splice.call(arguments, 3))
        },
        start: function(e) {
            if (this.running) {
                return
            }
            this._started = this.game.time.now + (e || 0);
            this.running = true;
            for (var t = 0; t < this.events.length; t++) {
                this.events[t].tick = this.events[t].delay + this._started
            }
        },
        stop: function(e) {
            this.running = false;
            if (typeof e === "undefined") {
                e = true
            }
            if (e) {
                this.events.length = 0
            }
        },
        remove: function(e) {
            for (var t = 0; t < this.events.length; t++) {
                if (this.events[t] === e) {
                    this.events[t].pendingDelete = true;
                    return true
                }
            }
            return false
        },
        order: function() {
            if (this.events.length > 0) {
                this.events.sort(this.sortHandler);
                this.nextTick = this.events[0].tick
            }
        },
        sortHandler: function(e, t) {
            if (e.tick < t.tick) {
                return -1
            } else if (e.tick > t.tick) {
                return 1
            }
            return 0
        },
        clearPendingEvents: function() {
            this._i = this.events.length;
            while (this._i--) {
                if (this.events[this._i].pendingDelete) {
                    this.events.splice(this._i, 1)
                }
            }
            this._len = this.events.length;
            this._i = 0
        },
        update: function(e) {
            if (this.paused) {
                return true
            }
            this.elapsed = e - this._now;
            this._now = e;
            if (this.elapsed > this.timeCap) {
                this.adjustEvents(e - this.elapsed)
            }
            this._marked = 0;
            this.clearPendingEvents();
            if (this.running && this._now >= this.nextTick && this._len > 0) {
                while (this._i < this._len && this.running) {
                    if (this._now >= this.events[this._i].tick) {
                        this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick);
                        if (this._newTick < 0) {
                            this._newTick = this._now + this.events[this._i].delay
                        }
                        if (this.events[this._i].loop === true) {
                            this.events[this._i].tick = this._newTick;
                            this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)
                        } else if (this.events[this._i].repeatCount > 0) {
                            this.events[this._i].repeatCount--;
                            this.events[this._i].tick = this._newTick;
                            this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)
                        } else {
                            this._marked++;
                            this.events[this._i].pendingDelete = true;
                            this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)
                        }
                        this._i++
                    } else {
                        break
                    }
                }
                if (this.events.length > this._marked) {
                    this.order()
                } else {
                    this.expired = true;
                    this.onComplete.dispatch(this)
                }
            }
            if (this.expired && this.autoDestroy) {
                return false
            } else {
                return true
            }
        },
        pause: function() {
            if (!this.running) {
                return
            }
            this._codePaused = true;
            if (this.paused) {
                return
            }
            this._pauseStarted = this.game.time.now;
            this.paused = true
        },
        _pause: function() {
            if (this.paused || !this.running) {
                return
            }
            this._pauseStarted = this.game.time.now;
            this.paused = true
        },
        adjustEvents: function(e) {
            for (var t = 0; t < this.events.length; t++) {
                if (!this.events[t].pendingDelete) {
                    var n = this.events[t].tick - e;
                    if (n < 0) {
                        n = 0
                    }
                    this.events[t].tick = this._now + n
                }
            }
            var r = this.nextTick - e;
            if (r < 0) {
                this.nextTick = this._now
            } else {
                this.nextTick = this._now + r
            }
        },
        resume: function() {
            if (!this.paused) {
                return
            }
            var e = this.game.time.now;
            this._pauseTotal += e - this._now;
            this._now = e;
            this.adjustEvents(this._pauseStarted);
            this.paused = false;
            this._codePaused = false
        },
        _resume: function() {
            if (this._codePaused) {
                return
            } else {
                this.resume()
            }
        },
        removeAll: function() {
            this.onComplete.removeAll();
            this.events.length = 0;
            this._len = 0;
            this._i = 0
        },
        destroy: function() {
            this.onComplete.removeAll();
            this.running = false;
            this.events = [];
            this._len = 0;
            this._i = 0
        }
    };
    Object.defineProperty(t.Timer.prototype, "next", {
        get: function() {
            return this.nextTick
        }
    });
    Object.defineProperty(t.Timer.prototype, "duration", {
        get: function() {
            if (this.running && this.nextTick > this._now) {
                return this.nextTick - this._now
            } else {
                return 0
            }
        }
    });
    Object.defineProperty(t.Timer.prototype, "length", {
        get: function() {
            return this.events.length
        }
    });
    Object.defineProperty(t.Timer.prototype, "ms", {
        get: function() {
            return this._now - this._started - this._pauseTotal
        }
    });
    Object.defineProperty(t.Timer.prototype, "seconds", {
        get: function() {
            return this.ms * .001
        }
    });
    t.Timer.prototype.constructor = t.Timer;
    t.TimerEvent = function(e, t, n, r, i, s, o, u) {
        this.timer = e;
        this.delay = t;
        this.tick = n;
        this.repeatCount = r - 1;
        this.loop = i;
        this.callback = s;
        this.callbackContext = o;
        this.args = u;
        this.pendingDelete = false
    };
    t.TimerEvent.prototype.constructor = t.TimerEvent;
    t.AnimationManager = function(e) {
        this.sprite = e;
        this.game = e.game;
        this.currentFrame = null;
        this.currentAnim = null;
        this.updateIfVisible = true;
        this.isLoaded = false;
        this._frameData = null;
        this._anims = {};
        this._outputFrames = []
    };
    t.AnimationManager.prototype = {
        loadFrameData: function(e) {
            this._frameData = e;
            this.frame = 0;
            this.isLoaded = true
        },
        add: function(e, n, r, i, s) {
            if (this._frameData === null) {
                console.warn("No FrameData available for Phaser.Animation " + e);
                return
            }
            n = n || [];
            r = r || 60;
            if (typeof i === "undefined") {
                i = false
            }
            if (typeof s === "undefined") {
                if (n && typeof n[0] === "number") {
                    s = true
                } else {
                    s = false
                }
            }
            if (this.sprite.events.onAnimationStart === null) {
                this.sprite.events.onAnimationStart = new t.Signal;
                this.sprite.events.onAnimationComplete = new t.Signal;
                this.sprite.events.onAnimationLoop = new t.Signal
            }
            this._outputFrames.length = 0;
            this._frameData.getFrameIndexes(n, s, this._outputFrames);
            this._anims[e] = new t.Animation(this.game, this.sprite, e, this._frameData, this._outputFrames, r, i);
            this.currentAnim = this._anims[e];
            this.currentFrame = this.currentAnim.currentFrame;
            this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);
            if (this.sprite.__tilePattern) {
                this.__tilePattern = false;
                this.tilingTexture = false
            }
            return this._anims[e]
        },
        validateFrames: function(e, t) {
            if (typeof t == "undefined") {
                t = true
            }
            for (var n = 0; n < e.length; n++) {
                if (t === true) {
                    if (e[n] > this._frameData.total) {
                        return false
                    }
                } else {
                    if (this._frameData.checkFrameName(e[n]) === false) {
                        return false
                    }
                }
            }
            return true
        },
        play: function(e, t, n, r) {
            if (this._anims[e]) {
                if (this.currentAnim === this._anims[e]) {
                    if (this.currentAnim.isPlaying === false) {
                        this.currentAnim.paused = false;
                        return this.currentAnim.play(t, n, r)
                    }
                } else {
                    if (this.currentAnim && this.currentAnim.isPlaying) {
                        this.currentAnim.stop()
                    }
                    this.currentAnim = this._anims[e];
                    this.currentAnim.paused = false;
                    return this.currentAnim.play(t, n, r)
                }
            }
        },
        stop: function(e, t) {
            if (typeof t == "undefined") {
                t = false
            }
            if (typeof e == "string") {
                if (this._anims[e]) {
                    this.currentAnim = this._anims[e];
                    this.currentAnim.stop(t)
                }
            } else {
                if (this.currentAnim) {
                    this.currentAnim.stop(t)
                }
            }
        },
        update: function() {
            if (this.updateIfVisible && !this.sprite.visible) {
                return false
            }
            if (this.currentAnim && this.currentAnim.update() === true) {
                this.currentFrame = this.currentAnim.currentFrame;
                return true
            }
            return false
        },
        getAnimation: function(e) {
            if (typeof e === "string") {
                if (this._anims[e]) {
                    return this._anims[e]
                }
            }
            return null
        },
        refreshFrame: function() {
            this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);
            if (this.sprite.__tilePattern) {
                this.__tilePattern = false;
                this.tilingTexture = false
            }
        },
        destroy: function() {
            var e = null;
            for (var e in this._anims) {
                if (this._anims.hasOwnProperty(e)) {
                    this._anims[e].destroy()
                }
            }
            this._anims = {};
            this._frameData = null;
            this._frameIndex = 0;
            this.currentAnim = null;
            this.currentFrame = null
        }
    };
    t.AnimationManager.prototype.constructor = t.AnimationManager;
    Object.defineProperty(t.AnimationManager.prototype, "frameData", {
        get: function() {
            return this._frameData
        }
    });
    Object.defineProperty(t.AnimationManager.prototype, "frameTotal", {
        get: function() {
            if (this._frameData) {
                return this._frameData.total
            } else {
                return -1
            }
        }
    });
    Object.defineProperty(t.AnimationManager.prototype, "paused", {
        get: function() {
            return this.currentAnim.isPaused
        },
        set: function(e) {
            this.currentAnim.paused = e
        }
    });
    Object.defineProperty(t.AnimationManager.prototype, "frame", {
        get: function() {
            if (this.currentFrame) {
                return this._frameIndex
            }
        },
        set: function(e) {
            if (typeof e === "number" && this._frameData && this._frameData.getFrame(e) !== null) {
                this.currentFrame = this._frameData.getFrame(e);
                if (this.currentFrame) {
                    this._frameIndex = e;
                    this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);
                    if (this.sprite.__tilePattern) {
                        this.__tilePattern = false;
                        this.tilingTexture = false
                    }
                }
            }
        }
    });
    Object.defineProperty(t.AnimationManager.prototype, "frameName", {
        get: function() {
            if (this.currentFrame) {
                return this.currentFrame.name
            }
        },
        set: function(e) {
            if (typeof e === "string" && this._frameData && this._frameData.getFrameByName(e) !== null) {
                this.currentFrame = this._frameData.getFrameByName(e);
                if (this.currentFrame) {
                    this._frameIndex = this.currentFrame.index;
                    this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);
                    if (this.sprite.__tilePattern) {
                        this.__tilePattern = false;
                        this.tilingTexture = false
                    }
                }
            } else {
                console.warn("Cannot set frameName: " + e)
            }
        }
    });
    t.Animation = function(e, n, r, i, s, o, u) {
        this.game = e;
        this._parent = n;
        this._frameData = i;
        this.name = r;
        this._frames = [];
        this._frames = this._frames.concat(s);
        this.delay = 1e3 / o;
        this.loop = u;
        this.loopCount = 0;
        this.killOnComplete = false;
        this.isFinished = false;
        this.isPlaying = false;
        this.isPaused = false;
        this._pauseStartTime = 0;
        this._frameIndex = 0;
        this._frameDiff = 0;
        this._frameSkip = 1;
        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
        this.onStart = new t.Signal;
        this.onComplete = new t.Signal;
        this.onLoop = new t.Signal;
        this.game.onPause.add(this.onPause, this);
        this.game.onResume.add(this.onResume, this)
    };
    t.Animation.prototype = {
        play: function(e, t, n) {
            if (typeof e === "number") {
                this.delay = 1e3 / e
            }
            if (typeof t === "boolean") {
                this.loop = t
            }
            if (typeof n !== "undefined") {
                this.killOnComplete = n
            }
            this.isPlaying = true;
            this.isFinished = false;
            this.paused = false;
            this.loopCount = 0;
            this._timeLastFrame = this.game.time.now;
            this._timeNextFrame = this.game.time.now + this.delay;
            this._frameIndex = 0;
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
            this._parent.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);
            if (this._parent.__tilePattern) {
                this._parent.__tilePattern = false;
                this._parent.tilingTexture = false
            }
            this._parent.events.onAnimationStart.dispatch(this._parent, this);
            this.onStart.dispatch(this._parent, this);
            return this
        },
        restart: function() {
            this.isPlaying = true;
            this.isFinished = false;
            this.paused = false;
            this.loopCount = 0;
            this._timeLastFrame = this.game.time.now;
            this._timeNextFrame = this.game.time.now + this.delay;
            this._frameIndex = 0;
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
            this.onStart.dispatch(this._parent, this)
        },
        setFrame: function(e, t) {
            var n;
            if (typeof t === "undefined") {
                t = false
            }
            if (typeof e === "string") {
                for (var r = 0; r < this._frames.length; r++) {
                    if (this._frameData.getFrame(this._frames[r]).name === e) {
                        n = r
                    }
                }
            } else if (typeof e === "number") {
                if (t) {
                    n = e
                } else {
                    for (var r = 0; r < this._frames.length; r++) {
                        if (this.frames[r] === n) {
                            n = r
                        }
                    }
                }
            }
            if (n) {
                this._frameIndex = n - 1;
                this._timeNextFrame = this.game.time.now;
                this.update()
            }
        },
        stop: function(e, t) {
            if (typeof e === "undefined") {
                e = false
            }
            if (typeof t === "undefined") {
                t = false
            }
            this.isPlaying = false;
            this.isFinished = true;
            this.paused = false;
            if (e) {
                this.currentFrame = this._frameData.getFrame(this._frames[0])
            }
            if (t) {
                this._parent.events.onAnimationComplete.dispatch(this._parent, this);
                this.onComplete.dispatch(this._parent, this)
            }
        },
        onPause: function() {
            if (this.isPlaying) {
                this._frameDiff = this._timeNextFrame - this.game.time.now
            }
        },
        onResume: function() {
            if (this.isPlaying) {
                this._timeNextFrame = this.game.time.now + this._frameDiff
            }
        },
        update: function() {
            if (this.isPaused) {
                return false
            }
            if (this.isPlaying === true && this.game.time.now >= this._timeNextFrame) {
                this._frameSkip = 1;
                this._frameDiff = this.game.time.now - this._timeNextFrame;
                this._timeLastFrame = this.game.time.now;
                if (this._frameDiff > this.delay) {
                    this._frameSkip = Math.floor(this._frameDiff / this.delay);
                    this._frameDiff -= this._frameSkip * this.delay
                }
                this._timeNextFrame = this.game.time.now + (this.delay - this._frameDiff);
                this._frameIndex += this._frameSkip;
                if (this._frameIndex >= this._frames.length) {
                    if (this.loop) {
                        this._frameIndex %= this._frames.length;
                        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
                        if (this.currentFrame) {
                            this._parent.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);
                            if (this._parent.__tilePattern) {
                                this._parent.__tilePattern = false;
                                this._parent.tilingTexture = false
                            }
                        }
                        this.loopCount++;
                        this._parent.events.onAnimationLoop.dispatch(this._parent, this);
                        this.onLoop.dispatch(this._parent, this)
                    } else {
                        this.complete()
                    }
                } else {
                    this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
                    if (this.currentFrame) {
                        this._parent.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);
                        if (this._parent.__tilePattern) {
                            this._parent.__tilePattern = false;
                            this._parent.tilingTexture = false
                        }
                    }
                }
                return true
            }
            return false
        },
        destroy: function() {
            this.game.onPause.remove(this.onPause, this);
            this.game.onResume.remove(this.onResume, this);
            this.game = null;
            this._parent = null;
            this._frames = null;
            this._frameData = null;
            this.currentFrame = null;
            this.isPlaying = false;
            this.onStart.dispose();
            this.onLoop.dispose();
            this.onComplete.dispose()
        },
        complete: function() {
            this.isPlaying = false;
            this.isFinished = true;
            this.paused = false;
            this._parent.events.onAnimationComplete.dispatch(this._parent, this);
            this.onComplete.dispatch(this._parent, this);
            if (this.killOnComplete) {
                this._parent.kill()
            }
        }
    };
    t.Animation.prototype.constructor = t.Animation;
    Object.defineProperty(t.Animation.prototype, "paused", {
        get: function() {
            return this.isPaused
        },
        set: function(e) {
            this.isPaused = e;
            if (e) {
                this._pauseStartTime = this.game.time.now
            } else {
                if (this.isPlaying) {
                    this._timeNextFrame = this.game.time.now + this.delay
                }
            }
        }
    });
    Object.defineProperty(t.Animation.prototype, "frameTotal", {
        get: function() {
            return this._frames.length
        }
    });
    Object.defineProperty(t.Animation.prototype, "frame", {
        get: function() {
            if (this.currentFrame !== null) {
                return this.currentFrame.index
            } else {
                return this._frameIndex
            }
        },
        set: function(e) {
            this.currentFrame = this._frameData.getFrame(this._frames[e]);
            if (this.currentFrame !== null) {
                this._frameIndex = e;
                this._parent.setTexture(PIXI.TextureCache[this.currentFrame.uuid])
            }
        }
    });
    Object.defineProperty(t.Animation.prototype, "speed", {
        get: function() {
            return Math.round(1e3 / this.delay)
        },
        set: function(e) {
            if (e >= 1) {
                this.delay = 1e3 / e
            }
        }
    });
    t.Animation.generateFrameNames = function(e, n, r, i, s) {
        if (typeof i == "undefined") {
            i = ""
        }
        var o = [];
        var u = "";
        if (n < r) {
            for (var a = n; a <= r; a++) {
                if (typeof s == "number") {
                    u = t.Utils.pad(a.toString(), s, "0", 1)
                } else {
                    u = a.toString()
                }
                u = e + u + i;
                o.push(u)
            }
        } else {
            for (var a = n; a >= r; a--) {
                if (typeof s == "number") {
                    u = t.Utils.pad(a.toString(), s, "0", 1)
                } else {
                    u = a.toString()
                }
                u = e + u + i;
                o.push(u)
            }
        }
        return o
    };
    t.Frame = function(e, n, r, i, s, o, u) {
        this.index = e;
        this.x = n;
        this.y = r;
        this.width = i;
        this.height = s;
        this.name = o;
        this.uuid = u;
        this.centerX = Math.floor(i / 2);
        this.centerY = Math.floor(s / 2);
        this.distance = t.Math.distance(0, 0, i, s);
        this.rotated = false;
        this.rotationDirection = "cw";
        this.trimmed = false;
        this.sourceSizeW = i;
        this.sourceSizeH = s;
        this.spriteSourceSizeX = 0;
        this.spriteSourceSizeY = 0;
        this.spriteSourceSizeW = 0;
        this.spriteSourceSizeH = 0
    };
    t.Frame.prototype = {
        setTrim: function(e, t, n, r, i, s, o) {
            this.trimmed = e;
            if (e) {
                this.width = t;
                this.height = n;
                this.sourceSizeW = t;
                this.sourceSizeH = n;
                this.centerX = Math.floor(t / 2);
                this.centerY = Math.floor(n / 2);
                this.spriteSourceSizeX = r;
                this.spriteSourceSizeY = i;
                this.spriteSourceSizeW = s;
                this.spriteSourceSizeH = o
            }
        },
        getRect: function(e) {
            if (typeof e === "undefined") {
                e = new t.Rectangle(this.x, this.y, this.width, this.height)
            } else {
                e.setTo(this.x, this.y, this.width, this.height)
            }
            return e
        }
    };
    t.Frame.prototype.constructor = t.Frame;
    t.FrameData = function() {
        this._frames = [];
        this._frameNames = []
    };
    t.FrameData.prototype = {
        addFrame: function(e) {
            e.index = this._frames.length;
            this._frames.push(e);
            if (e.name !== "") {
                this._frameNames[e.name] = e.index
            }
            return e
        },
        getFrame: function(e) {
            if (e > this._frames.length) {
                e = 0
            }
            return this._frames[e]
        },
        getFrameByName: function(e) {
            if (typeof this._frameNames[e] === "number") {
                return this._frames[this._frameNames[e]]
            }
            return null
        },
        checkFrameName: function(e) {
            if (this._frameNames[e] == null) {
                return false
            }
            return true
        },
        getFrameRange: function(e, t, n) {
            if (typeof n === "undefined") {
                n = []
            }
            for (var r = e; r <= t; r++) {
                n.push(this._frames[r])
            }
            return n
        },
        getFrames: function(e, t, n) {
            if (typeof t === "undefined") {
                t = true
            }
            if (typeof n === "undefined") {
                n = []
            }
            if (typeof e === "undefined" || e.length === 0) {
                for (var r = 0; r < this._frames.length; r++) {
                    n.push(this._frames[r])
                }
            } else {
                for (var r = 0, i = e.length; r < i; r++) {
                    if (t) {
                        n.push(this.getFrame(e[r]))
                    } else {
                        n.push(this.getFrameByName(e[r]))
                    }
                }
            }
            return n
        },
        getFrameIndexes: function(e, t, n) {
            if (typeof t === "undefined") {
                t = true
            }
            if (typeof n === "undefined") {
                n = []
            }
            if (typeof e === "undefined" || e.length === 0) {
                for (var r = 0, i = this._frames.length; r < i; r++) {
                    n.push(this._frames[r].index)
                }
            } else {
                for (var r = 0, i = e.length; r < i; r++) {
                    if (t) {
                        n.push(e[r])
                    } else {
                        if (this.getFrameByName(e[r])) {
                            n.push(this.getFrameByName(e[r]).index)
                        }
                    }
                }
            }
            return n
        }
    };
    t.FrameData.prototype.constructor = t.FrameData;
    Object.defineProperty(t.FrameData.prototype, "total", {
        get: function() {
            return this._frames.length
        }
    });
    t.AnimationParser = {
        spriteSheet: function(e, n, r, i, s, o, u) {
            var a = e.cache.getImage(n);
            if (a == null) {
                return null
            }
            var f = a.width;
            var l = a.height;
            if (r <= 0) {
                r = Math.floor(-f / Math.min(-1, r))
            }
            if (i <= 0) {
                i = Math.floor(-l / Math.min(-1, i))
            }
            var c = Math.floor((f - o) / (r + u));
            var h = Math.floor((l - o) / (i + u));
            var p = c * h;
            if (s !== -1) {
                p = s
            }
            if (f === 0 || l === 0 || f < r || l < i || p === 0) {
                console.warn("Phaser.AnimationParser.spriteSheet: width/height zero or width/height < given frameWidth/frameHeight");
                return null
            }
            var d = new t.FrameData;
            var v = o;
            var m = o;
            for (var g = 0; g < p; g++) {
                var y = e.rnd.uuid();
                d.addFrame(new t.Frame(g, v, m, r, i, "", y));
                PIXI.TextureCache[y] = new PIXI.Texture(PIXI.BaseTextureCache[n], {
                    x: v,
                    y: m,
                    width: r,
                    height: i
                });
                v += r + u;
                if (v + r > f) {
                    v = o;
                    m += i + u
                }
            }
            return d
        },
        JSONData: function(e, n, r) {
            if (!n["frames"]) {
                console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array");
                console.log(n);
                return
            }
            var i = new t.FrameData;
            var s = n["frames"];
            var o;
            for (var u = 0; u < s.length; u++) {
                var a = e.rnd.uuid();
                o = i.addFrame(new t.Frame(u, s[u].frame.x, s[u].frame.y, s[u].frame.w, s[u].frame.h, s[u].filename, a));
                PIXI.TextureCache[a] = new PIXI.Texture(PIXI.BaseTextureCache[r], {
                    x: s[u].frame.x,
                    y: s[u].frame.y,
                    width: s[u].frame.w,
                    height: s[u].frame.h
                });
                if (s[u].trimmed) {
                    o.setTrim(s[u].trimmed, s[u].sourceSize.w, s[u].sourceSize.h, s[u].spriteSourceSize.x, s[u].spriteSourceSize.y, s[u].spriteSourceSize.w, s[u].spriteSourceSize.h);
                    PIXI.TextureCache[a].trim = new t.Rectangle(s[u].spriteSourceSize.x, s[u].spriteSourceSize.y, s[u].sourceSize.w, s[u].sourceSize.h)
                }
            }
            return i
        },
        JSONDataHash: function(e, n, r) {
            if (!n["frames"]) {
                console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object");
                console.log(n);
                return
            }
            var i = new t.FrameData;
            var s = n["frames"];
            var o;
            var u = 0;
            for (var a in s) {
                var f = e.rnd.uuid();
                o = i.addFrame(new t.Frame(u, s[a].frame.x, s[a].frame.y, s[a].frame.w, s[a].frame.h, a, f));
                PIXI.TextureCache[f] = new PIXI.Texture(PIXI.BaseTextureCache[r], {
                    x: s[a].frame.x,
                    y: s[a].frame.y,
                    width: s[a].frame.w,
                    height: s[a].frame.h
                });
                if (s[a].trimmed) {
                    o.setTrim(s[a].trimmed, s[a].sourceSize.w, s[a].sourceSize.h, s[a].spriteSourceSize.x, s[a].spriteSourceSize.y, s[a].spriteSourceSize.w, s[a].spriteSourceSize.h);
                    PIXI.TextureCache[f].trim = new t.Rectangle(s[a].spriteSourceSize.x, s[a].spriteSourceSize.y, s[a].sourceSize.w, s[a].sourceSize.h)
                }
                u++
            }
            return i
        },
        XMLData: function(e, n, r) {
            if (!n.getElementsByTagName("TextureAtlas")) {
                console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
                return
            }
            var i = new t.FrameData;
            var s = n.getElementsByTagName("SubTexture");
            var o;
            var u;
            var a;
            var f;
            var l;
            var c;
            var h;
            var p;
            var d;
            var v;
            var m;
            var g;
            for (var y = 0; y < s.length; y++) {
                u = e.rnd.uuid();
                f = s[y].attributes;
                a = f.name.nodeValue;
                l = parseInt(f.x.nodeValue, 10);
                c = parseInt(f.y.nodeValue, 10);
                h = parseInt(f.width.nodeValue, 10);
                p = parseInt(f.height.nodeValue, 10);
                d = null;
                v = null;
                if (f.frameX) {
                    d = Math.abs(parseInt(f.frameX.nodeValue, 10));
                    v = Math.abs(parseInt(f.frameY.nodeValue, 10));
                    m = parseInt(f.frameWidth.nodeValue, 10);
                    g = parseInt(f.frameHeight.nodeValue, 10)
                }
                o = i.addFrame(new t.Frame(y, l, c, h, p, a, u));
                PIXI.TextureCache[u] = new PIXI.Texture(PIXI.BaseTextureCache[r], {
                    x: l,
                    y: c,
                    width: h,
                    height: p
                });
                if (d !== null || v !== null) {
                    o.setTrim(true, h, p, d, v, m, g);
                    PIXI.TextureCache[u].trim = new t.Rectangle(d, v, h, p)
                }
            }
            return i
        }
    };
    t.Cache = function(e) {
        this.game = e;
        this._canvases = {};
        this._images = {};
        this._textures = {};
        this._sounds = {};
        this._text = {};
        this._json = {};
        this._physics = {};
        this._tilemaps = {};
        this._binary = {};
        this._bitmapDatas = {};
        this._bitmapFont = {};
        this.addDefaultImage();
        this.addMissingImage();
        this.onSoundUnlock = new t.Signal;
        this._cacheMap = [];
        this._cacheMap[t.Cache.CANVAS] = this._canvases;
        this._cacheMap[t.Cache.IMAGE] = this._images;
        this._cacheMap[t.Cache.TEXTURE] = this._textures;
        this._cacheMap[t.Cache.SOUND] = this._sounds;
        this._cacheMap[t.Cache.TEXT] = this._text;
        this._cacheMap[t.Cache.PHYSICS] = this._physics;
        this._cacheMap[t.Cache.TILEMAP] = this._tilemaps;
        this._cacheMap[t.Cache.BINARY] = this._binary;
        this._cacheMap[t.Cache.BITMAPDATA] = this._bitmapDatas;
        this._cacheMap[t.Cache.BITMAPFONT] = this._bitmapFont;
        this._cacheMap[t.Cache.JSON] = this._json
    };
    t.Cache.CANVAS = 1;
    t.Cache.IMAGE = 2;
    t.Cache.TEXTURE = 3;
    t.Cache.SOUND = 4;
    t.Cache.TEXT = 5;
    t.Cache.PHYSICS = 6;
    t.Cache.TILEMAP = 7;
    t.Cache.BINARY = 8;
    t.Cache.BITMAPDATA = 9;
    t.Cache.BITMAPFONT = 10;
    t.Cache.JSON = 11;
    t.Cache.prototype = {
        addCanvas: function(e, t, n) {
            this._canvases[e] = {
                canvas: t,
                context: n
            }
        },
        addBinary: function(e, t) {
            this._binary[e] = t
        },
        addBitmapData: function(e, t) {
            this._bitmapDatas[e] = t;
            return t
        },
        addRenderTexture: function(e, n) {
            var r = new t.Frame(0, 0, 0, n.width, n.height, "", "");
            this._textures[e] = {
                texture: n,
                frame: r
            }
        },
        addSpriteSheet: function(e, n, r, i, s, o, u, a) {
            this._images[e] = {
                url: n,
                data: r,
                spriteSheet: true,
                frameWidth: i,
                frameHeight: s,
                margin: u,
                spacing: a
            };
            PIXI.BaseTextureCache[e] = new PIXI.BaseTexture(r);
            PIXI.TextureCache[e] = new PIXI.Texture(PIXI.BaseTextureCache[e]);
            this._images[e].frameData = t.AnimationParser.spriteSheet(this.game, e, i, s, o, u, a)
        },
        addTilemap: function(e, t, n, r) {
            this._tilemaps[e] = {
                url: t,
                data: n,
                format: r
            }
        },
        addTextureAtlas: function(e, n, r, i, s) {
            this._images[e] = {
                url: n,
                data: r,
                spriteSheet: true
            };
            PIXI.BaseTextureCache[e] = new PIXI.BaseTexture(r);
            PIXI.TextureCache[e] = new PIXI.Texture(PIXI.BaseTextureCache[e]);
            if (s == t.Loader.TEXTURE_ATLAS_JSON_ARRAY) {
                this._images[e].frameData = t.AnimationParser.JSONData(this.game, i, e)
            } else if (s == t.Loader.TEXTURE_ATLAS_JSON_HASH) {
                this._images[e].frameData = t.AnimationParser.JSONDataHash(this.game, i, e)
            } else if (s == t.Loader.TEXTURE_ATLAS_XML_STARLING) {
                this._images[e].frameData = t.AnimationParser.XMLData(this.game, i, e)
            }
        },
        addBitmapFont: function(e, n, r, i, s, o) {
            this._images[e] = {
                url: n,
                data: r,
                spriteSheet: true
            };
            PIXI.BaseTextureCache[e] = new PIXI.BaseTexture(r);
            PIXI.TextureCache[e] = new PIXI.Texture(PIXI.BaseTextureCache[e]);
            t.LoaderParser.bitmapFont(this.game, i, e, s, o)
        },
        addPhysicsData: function(e, t, n, r) {
            this._physics[e] = {
                url: t,
                data: n,
                format: r
            }
        },
        addDefaultImage: function() {
            var e = new Image;
            e.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
            this._images["__default"] = {
                url: null,
                data: e,
                spriteSheet: false
            };
            this._images["__default"].frame = new t.Frame(0, 0, 0, 32, 32, "", "");
            PIXI.BaseTextureCache["__default"] = new PIXI.BaseTexture(e);
            PIXI.TextureCache["__default"] = new PIXI.Texture(PIXI.BaseTextureCache["__default"])
        },
        addMissingImage: function() {
            var e = new Image;
            e.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
            this._images["__missing"] = {
                url: null,
                data: e,
                spriteSheet: false
            };
            this._images["__missing"].frame = new t.Frame(0, 0, 0, 32, 32, "", "");
            PIXI.BaseTextureCache["__missing"] = new PIXI.BaseTexture(e);
            PIXI.TextureCache["__missing"] = new PIXI.Texture(PIXI.BaseTextureCache["__missing"])
        },
        addText: function(e, t, n) {
            this._text[e] = {
                url: t,
                data: n
            }
        },
        addJSON: function(e, t, n) {
            this._json[e] = {
                url: t,
                data: n
            }
        },
        addImage: function(e, n, r) {
            this._images[e] = {
                url: n,
                data: r,
                spriteSheet: false
            };
            this._images[e].frame = new t.Frame(0, 0, 0, r.width, r.height, e, this.game.rnd.uuid());
            PIXI.BaseTextureCache[e] = new PIXI.BaseTexture(r);
            PIXI.TextureCache[e] = new PIXI.Texture(PIXI.BaseTextureCache[e])
        },
        addSound: function(e, t, n, r, i) {
            r = r || true;
            i = i || false;
            var s = false;
            if (i) {
                s = true
            }
            this._sounds[e] = {
                url: t,
                data: n,
                isDecoding: false,
                decoded: s,
                webAudio: r,
                audioTag: i
            }
        },
        reloadSound: function(e) {
            var t = this;
            if (this._sounds[e]) {
                this._sounds[e].data.src = this._sounds[e].url;
                this._sounds[e].data.addEventListener("canplaythrough", function() {
                    return t.reloadSoundComplete(e)
                }, false);
                this._sounds[e].data.load()
            }
        },
        reloadSoundComplete: function(e) {
            if (this._sounds[e]) {
                this._sounds[e].locked = false;
                this.onSoundUnlock.dispatch(e)
            }
        },
        updateSound: function(e, t, n) {
            if (this._sounds[e]) {
                this._sounds[e][t] = n
            }
        },
        decodedSound: function(e, t) {
            this._sounds[e].data = t;
            this._sounds[e].decoded = true;
            this._sounds[e].isDecoding = false
        },
        getCanvas: function(e) {
            if (this._canvases[e]) {
                return this._canvases[e].canvas
            } else {
                console.warn('Phaser.Cache.getCanvas: Invalid key: "' + e + '"')
            }
        },
        getBitmapData: function(e) {
            if (this._bitmapDatas[e]) {
                return this._bitmapDatas[e]
            } else {
                console.warn('Phaser.Cache.getBitmapData: Invalid key: "' + e + '"')
            }
        },
        getBitmapFont: function(e) {
            if (this._bitmapFont[e]) {
                return this._bitmapFont[e]
            } else {
                console.warn('Phaser.Cache.getBitmapFont: Invalid key: "' + e + '"')
            }
        },
        getPhysicsData: function(e, t, n) {
            if (typeof t === "undefined" || t === null) {
                if (this._physics[e]) {
                    return this._physics[e].data
                } else {
                    console.warn('Phaser.Cache.getPhysicsData: Invalid key: "' + e + '"')
                }
            } else {
                if (this._physics[e] && this._physics[e].data[t]) {
                    var r = this._physics[e].data[t];
                    if (r && n) {
                        for (var i in r) {
                            i = r[i];
                            if (i.fixtureKey === n) {
                                return i
                            }
                        }
                        console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + n + " in " + e + '"')
                    } else {
                        return r
                    }
                } else {
                    console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + e + " / " + t + '"')
                }
            }
            return null
        },
        checkKey: function(e, t) {
            if (this._cacheMap[e][t]) {
                return true
            }
            return false
        },
        checkCanvasKey: function(e) {
            return this.checkKey(t.Cache.CANVAS, e)
        },
        checkImageKey: function(e) {
            return this.checkKey(t.Cache.IMAGE, e)
        },
        checkTextureKey: function(e) {
            return this.checkKey(t.Cache.TEXTURE, e)
        },
        checkSoundKey: function(e) {
            return this.checkKey(t.Cache.SOUND, e)
        },
        checkTextKey: function(e) {
            return this.checkKey(t.Cache.TEXT, e)
        },
        checkPhysicsKey: function(e) {
            return this.checkKey(t.Cache.PHYSICS, e)
        },
        checkTilemapKey: function(e) {
            return this.checkKey(t.Cache.TILEMAP, e)
        },
        checkBinaryKey: function(e) {
            return this.checkKey(t.Cache.BINARY, e)
        },
        checkBitmapDataKey: function(e) {
            return this.checkKey(t.Cache.BITMAPDATA, e)
        },
        checkBitmapFontKey: function(e) {
            return this.checkKey(t.Cache.BITMAPFONT, e)
        },
        checkJSONKey: function(e) {
            return this.checkKey(t.Cache.JSON, e)
        },
        getImage: function(e) {
            if (this._images[e]) {
                return this._images[e].data
            } else {
                console.warn('Phaser.Cache.getImage: Invalid key: "' + e + '"')
            }
        },
        getTilemapData: function(e) {
            if (this._tilemaps[e]) {
                return this._tilemaps[e]
            } else {
                console.warn('Phaser.Cache.getTilemapData: Invalid key: "' + e + '"')
            }
        },
        getFrameData: function(e) {
            if (this._images[e] && this._images[e].frameData) {
                return this._images[e].frameData
            }
            return null
        },
        updateFrameData: function(e, t) {
            if (this._images[e]) {
                this._images[e].spriteSheet = true;
                this._images[e].frameData = t
            }
        },
        getFrameByIndex: function(e, t) {
            if (this._images[e] && this._images[e].frameData) {
                return this._images[e].frameData.getFrame(t)
            }
            return null
        },
        getFrameByName: function(e, t) {
            if (this._images[e] && this._images[e].frameData) {
                return this._images[e].frameData.getFrameByName(t)
            }
            return null
        },
        getFrame: function(e) {
            if (this._images[e] && this._images[e].spriteSheet === false) {
                return this._images[e].frame
            }
            return null
        },
        getTextureFrame: function(e) {
            if (this._textures[e]) {
                return this._textures[e].frame
            }
            return null
        },
        getTexture: function(e) {
            if (this._textures[e]) {
                return this._textures[e]
            } else {
                console.warn('Phaser.Cache.getTexture: Invalid key: "' + e + '"')
            }
        },
        getSound: function(e) {
            if (this._sounds[e]) {
                return this._sounds[e]
            } else {
                console.warn('Phaser.Cache.getSound: Invalid key: "' + e + '"')
            }
        },
        getSoundData: function(e) {
            if (this._sounds[e]) {
                return this._sounds[e].data
            } else {
                console.warn('Phaser.Cache.getSoundData: Invalid key: "' + e + '"')
            }
        },
        isSoundDecoded: function(e) {
            if (this._sounds[e]) {
                return this._sounds[e].decoded
            }
        },
        isSoundReady: function(e) {
            return this._sounds[e] && this._sounds[e].decoded && this.game.sound.touchLocked === false
        },
        isSpriteSheet: function(e) {
            if (this._images[e]) {
                return this._images[e].spriteSheet
            }
            return false
        },
        getText: function(e) {
            if (this._text[e]) {
                return this._text[e].data
            } else {
                console.warn('Phaser.Cache.getText: Invalid key: "' + e + '"')
            }
        },
        getJSON: function(e) {
            if (this._json[e]) {
                return this._json[e].data
            } else {
                console.warn('Phaser.Cache.getJSON: Invalid key: "' + e + '"')
            }
        },
        getBinary: function(e) {
            if (this._binary[e]) {
                return this._binary[e]
            } else {
                console.warn('Phaser.Cache.getBinary: Invalid key: "' + e + '"')
            }
        },
        getKeys: function(e) {
            var n = null;
            switch (e) {
                case t.Cache.CANVAS:
                    n = this._canvases;
                    break;
                case t.Cache.IMAGE:
                    n = this._images;
                    break;
                case t.Cache.TEXTURE:
                    n = this._textures;
                    break;
                case t.Cache.SOUND:
                    n = this._sounds;
                    break;
                case t.Cache.TEXT:
                    n = this._text;
                    break;
                case t.Cache.PHYSICS:
                    n = this._physics;
                    break;
                case t.Cache.TILEMAP:
                    n = this._tilemaps;
                    break;
                case t.Cache.BINARY:
                    n = this._binary;
                    break;
                case t.Cache.BITMAPDATA:
                    n = this._bitmapDatas;
                    break;
                case t.Cache.BITMAPFONT:
                    n = this._bitmapFont;
                    break;
                case t.Cache.JSON:
                    n = this._json;
                    break
            }
            if (!n) {
                return
            }
            var r = [];
            for (var i in n) {
                if (i !== "__default" && i !== "__missing") {
                    r.push(i)
                }
            }
            return r
        },
        removeCanvas: function(e) {
            delete this._canvases[e]
        },
        removeImage: function(e) {
            delete this._images[e]
        },
        removeSound: function(e) {
            delete this._sounds[e]
        },
        removeText: function(e) {
            delete this._text[e]
        },
        removeJSON: function(e) {
            delete this._json[e]
        },
        removePhysics: function(e) {
            delete this._physics[e]
        },
        removeTilemap: function(e) {
            delete this._tilemaps[e]
        },
        removeBinary: function(e) {
            delete this._binary[e]
        },
        removeBitmapData: function(e) {
            delete this._bitmapDatas[e]
        },
        removeBitmapFont: function(e) {
            delete this._bitmapFont[e]
        },
        destroy: function() {
            for (var e in this._canvases) {
                delete this._canvases[e]
            }
            for (var e in this._images) {
                if (e !== "__default" && e !== "__missing") {
                    delete this._images[e]
                }
            }
            for (var e in this._sounds) {
                delete this._sounds[e]
            }
            for (var e in this._text) {
                delete this._text[e]
            }
            for (var e in this._json) {
                delete this._json[e]
            }
            for (var e in this._textures) {
                delete this._textures[e]
            }
            for (var e in this._physics) {
                delete this._physics[e]
            }
            for (var e in this._tilemaps) {
                delete this._tilemaps[e]
            }
            for (var e in this._binary) {
                delete this._binary[e]
            }
            for (var e in this._bitmapDatas) {
                delete this._bitmapDatas[e]
            }
            for (var e in this._bitmapFont) {
                delete this._bitmapFont[e]
            }
        }
    };
    t.Cache.prototype.constructor = t.Cache;
    t.Loader = function(e) {
        this.game = e;
        this._fileList = [];
        this._fileIndex = 0;
        this._progressChunk = 0;
        this._xhr = new XMLHttpRequest;
        this._ajax = null;
        this.isLoading = false;
        this.hasLoaded = false;
        this.progress = 0;
        this.progressFloat = 0;
        this.preloadSprite = null;
        this.crossOrigin = false;
        this.baseURL = "";
        this.onLoadStart = new t.Signal;
        this.onFileStart = new t.Signal;
        this.onFileComplete = new t.Signal;
        this.onFileError = new t.Signal;
        this.onLoadComplete = new t.Signal
    };
    t.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0;
    t.Loader.TEXTURE_ATLAS_JSON_HASH = 1;
    t.Loader.TEXTURE_ATLAS_XML_STARLING = 2;
    t.Loader.PHYSICS_LIME_CORONA_JSON = 3;
    t.Loader.PHYSICS_PHASER_JSON = 4;
    t.Loader.prototype = {
        setPreloadSprite: function(e, n) {
            n = n || 0;
            this.preloadSprite = {
                sprite: e,
                direction: n,
                width: e.width,
                height: e.height,
                rect: null
            };
            if (n === 0) {
                this.preloadSprite.rect = new t.Rectangle(0, 0, 1, e.height)
            } else {
                this.preloadSprite.rect = new t.Rectangle(0, 0, e.width, 1)
            }
            e.crop(this.preloadSprite.rect);
            e.visible = true
        },
        checkKeyExists: function(e, t) {
            if (this._fileList.length > 0) {
                for (var n = 0; n < this._fileList.length; n++) {
                    if (this._fileList[n].type === e && this._fileList[n].key === t) {
                        return true
                    }
                }
            }
            return false
        },
        getAssetIndex: function(e, t) {
            if (this._fileList.length > 0) {
                for (var n = 0; n < this._fileList.length; n++) {
                    if (this._fileList[n].type === e && this._fileList[n].key === t) {
                        return n
                    }
                }
            }
            return -1
        },
        getAsset: function(e, t) {
            if (this._fileList.length > 0) {
                for (var n = 0; n < this._fileList.length; n++) {
                    if (this._fileList[n].type === e && this._fileList[n].key === t) {
                        return {
                            index: n,
                            file: this._fileList[n]
                        }
                    }
                }
            }
            return false
        },
        reset: function() {
            this.preloadSprite = null;
            this.isLoading = false;
            this._fileList.length = 0;
            this._fileIndex = 0
        },
        addToFileList: function(e, t, n, r) {
            var i = {
                type: e,
                key: t,
                url: n,
                data: null,
                error: false,
                loaded: false
            };
            if (typeof r !== "undefined") {
                for (var s in r) {
                    i[s] = r[s]
                }
            }
            if (this.checkKeyExists(e, t) === false) {
                this._fileList.push(i)
            }
        },
        replaceInFileList: function(e, t, n, r) {
            var i = {
                type: e,
                key: t,
                url: n,
                data: null,
                error: false,
                loaded: false
            };
            if (typeof r !== "undefined") {
                for (var s in r) {
                    i[s] = r[s]
                }
            }
            var o = this.getAssetIndex(e, t);
            if (o === -1) {
                this._fileList.push(i)
            } else {
                this._fileList[o] = i
            }
        },
        image: function(e, t, n) {
            if (typeof n === "undefined") {
                n = false
            }
            if (n) {
                this.replaceInFileList("image", e, t)
            } else {
                this.addToFileList("image", e, t)
            }
            return this
        },
        text: function(e, t, n) {
            if (typeof n === "undefined") {
                n = false
            }
            if (n) {
                this.replaceInFileList("text", e, t)
            } else {
                this.addToFileList("text", e, t)
            }
            return this
        },
        json: function(e, t, n) {
            if (typeof n === "undefined") {
                n = false
            }
            if (n) {
                this.replaceInFileList("json", e, t)
            } else {
                this.addToFileList("json", e, t)
            }
            return this
        },
        script: function(e, t, n, r) {
            if (typeof n === "undefined") {
                n = false
            }
            if (n !== false && typeof r === "undefined") {
                r = n
            }
            this.addToFileList("script", e, t, {
                callback: n,
                callbackContext: r
            });
            return this
        },
        binary: function(e, t, n, r) {
            if (typeof n === "undefined") {
                n = false
            }
            if (n !== false && typeof r === "undefined") {
                r = n
            }
            this.addToFileList("binary", e, t, {
                callback: n,
                callbackContext: r
            });
            return this
        },
        spritesheet: function(e, t, n, r, i, s, o) {
            if (typeof i === "undefined") {
                i = -1
            }
            if (typeof s === "undefined") {
                s = 0
            }
            if (typeof o === "undefined") {
                o = 0
            }
            this.addToFileList("spritesheet", e, t, {
                frameWidth: n,
                frameHeight: r,
                frameMax: i,
                margin: s,
                spacing: o
            });
            return this
        },
        audio: function(e, t, n) {
            if (typeof n === "undefined") {
                n = true
            }
            this.addToFileList("audio", e, t, {
                buffer: null,
                autoDecode: n
            });
            return this
        },
        tilemap: function(e, n, r, i) {
            if (typeof n === "undefined") {
                n = null
            }
            if (typeof r === "undefined") {
                r = null
            }
            if (typeof i === "undefined") {
                i = t.Tilemap.CSV
            }
            if (n == null && r == null) {
                console.warn("Phaser.Loader.tilemap - Both mapDataURL and mapData are null. One must be set.");
                return this
            }
            if (r) {
                switch (i) {
                    case t.Tilemap.CSV:
                        break;
                    case t.Tilemap.TILED_JSON:
                        if (typeof r === "string") {
                            r = JSON.parse(r)
                        }
                        break
                }
                this.game.cache.addTilemap(e, null, r, i)
            } else {
                this.addToFileList("tilemap", e, n, {
                    format: i
                })
            }
            return this
        },
        physics: function(e, n, r, i) {
            if (typeof n === "undefined") {
                n = null
            }
            if (typeof r === "undefined") {
                r = null
            }
            if (typeof i === "undefined") {
                i = t.Physics.LIME_CORONA_JSON
            }
            if (n == null && r == null) {
                console.warn("Phaser.Loader.physics - Both dataURL and jsonData are null. One must be set.");
                return this
            }
            if (r) {
                if (typeof r === "string") {
                    r = JSON.parse(r)
                }
                this.game.cache.addPhysicsData(e, null, r, i)
            } else {
                this.addToFileList("physics", e, n, {
                    format: i
                })
            }
            return this
        },
        bitmapFont: function(e, t, n, r, i, s) {
            if (typeof n === "undefined") {
                n = null
            }
            if (typeof r === "undefined") {
                r = null
            }
            if (typeof i === "undefined") {
                i = 0
            }
            if (typeof s === "undefined") {
                s = 0
            }
            if (n) {
                this.addToFileList("bitmapfont", e, t, {
                    xmlURL: n,
                    xSpacing: i,
                    ySpacing: s
                })
            } else {
                if (typeof r === "string") {
                    var o;
                    try {
                        if (window["DOMParser"]) {
                            var u = new DOMParser;
                            o = u.parseFromString(r, "text/xml")
                        } else {
                            o = new ActiveXObject("Microsoft.XMLDOM");
                            o.async = "false";
                            o.loadXML(r)
                        }
                    } catch (a) {
                        o = undefined
                    }
                    if (!o || !o.documentElement || o.getElementsByTagName("parsererror").length) {
                        throw new Error("Phaser.Loader. Invalid Bitmap Font XML given")
                    } else {
                        this.addToFileList("bitmapfont", e, t, {
                            xmlURL: null,
                            xmlData: o,
                            xSpacing: i,
                            ySpacing: s
                        })
                    }
                }
            }
            return this
        },
        atlasJSONArray: function(e, n, r, i) {
            return this.atlas(e, n, r, i, t.Loader.TEXTURE_ATLAS_JSON_ARRAY)
        },
        atlasJSONHash: function(e, n, r, i) {
            return this.atlas(e, n, r, i, t.Loader.TEXTURE_ATLAS_JSON_HASH)
        },
        atlasXML: function(e, n, r, i) {
            return this.atlas(e, n, r, i, t.Loader.TEXTURE_ATLAS_XML_STARLING)
        },
        atlas: function(e, n, r, i, s) {
            if (typeof r === "undefined") {
                r = null
            }
            if (typeof i === "undefined") {
                i = null
            }
            if (typeof s === "undefined") {
                s = t.Loader.TEXTURE_ATLAS_JSON_ARRAY
            }
            if (r) {
                this.addToFileList("textureatlas", e, n, {
                    atlasURL: r,
                    format: s
                })
            } else {
                switch (s) {
                    case t.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                        if (typeof i === "string") {
                            i = JSON.parse(i)
                        }
                        break;
                    case t.Loader.TEXTURE_ATLAS_XML_STARLING:
                        if (typeof i === "string") {
                            var o;
                            try {
                                if (window["DOMParser"]) {
                                    var u = new DOMParser;
                                    o = u.parseFromString(i, "text/xml")
                                } else {
                                    o = new ActiveXObject("Microsoft.XMLDOM");
                                    o.async = "false";
                                    o.loadXML(i)
                                }
                            } catch (a) {
                                o = undefined
                            }
                            if (!o || !o.documentElement || o.getElementsByTagName("parsererror").length) {
                                throw new Error("Phaser.Loader. Invalid Texture Atlas XML given")
                            } else {
                                i = o
                            }
                        }
                        break
                }
                this.addToFileList("textureatlas", e, n, {
                    atlasURL: null,
                    atlasData: i,
                    format: s
                })
            }
            return this
        },
        removeFile: function(e, t) {
            var n = this.getAsset(e, t);
            if (n !== false) {
                this._fileList.splice(n.index, 1)
            }
        },
        removeAll: function() {
            this._fileList.length = 0
        },
        start: function() {
            if (this.isLoading) {
                return
            }
            this.progress = 0;
            this.progressFloat = 0;
            this.hasLoaded = false;
            this.isLoading = true;
            this.onLoadStart.dispatch(this._fileList.length);
            if (this._fileList.length > 0) {
                this._fileIndex = 0;
                this._progressChunk = 100 / this._fileList.length;
                this.loadFile()
            } else {
                this.progress = 100;
                this.progressFloat = 100;
                this.hasLoaded = true;
                this.onLoadComplete.dispatch()
            }
        },
        loadFile: function() {
            if (!this._fileList[this._fileIndex]) {
                console.warn("Phaser.Loader loadFile invalid index " + this._fileIndex);
                return
            }
            var e = this._fileList[this._fileIndex];
            var n = this;
            this.onFileStart.dispatch(this.progress, e.key);
            switch (e.type) {
                case "image":
                case "spritesheet":
                case "textureatlas":
                case "bitmapfont":
                    e.data = new Image;
                    e.data.name = e.key;
                    e.data.onload = function() {
                        return n.fileComplete(n._fileIndex)
                    };
                    e.data.onerror = function() {
                        return n.fileError(n._fileIndex)
                    };
                    if (this.crossOrigin) {
                        e.data.crossOrigin = this.crossOrigin
                    }
                    e.data.src = this.baseURL + e.url;
                    break;
                case "audio":
                    e.url = this.getAudioURL(e.url);
                    if (e.url !== null) {
                        if (this.game.sound.usingWebAudio) {
                            this._xhr.open("GET", this.baseURL + e.url, true);
                            this._xhr.responseType = "arraybuffer";
                            this._xhr.onload = function() {
                                return n.fileComplete(n._fileIndex)
                            };
                            this._xhr.onerror = function() {
                                return n.fileError(n._fileIndex)
                            };
                            this._xhr.send()
                        } else if (this.game.sound.usingAudioTag) {
                            if (this.game.sound.touchLocked) {
                                e.data = new Audio;
                                e.data.name = e.key;
                                e.data.preload = "auto";
                                e.data.src = this.baseURL + e.url;
                                this.fileComplete(this._fileIndex)
                            } else {
                                e.data = new Audio;
                                e.data.name = e.key;
                                e.data.onerror = function() {
                                    return n.fileError(n._fileIndex)
                                };
                                e.data.preload = "auto";
                                e.data.src = this.baseURL + e.url;
                                e.data.addEventListener("canplaythrough", t.GAMES[this.game.id].load.fileComplete(this._fileIndex), false);
                                e.data.load()
                            }
                        }
                    } else {
                        this.fileError(this._fileIndex)
                    }
                    break;
                case "json":
                    if (window.XDomainRequest) {
                        this._ajax = new window.XDomainRequest;
                        this._ajax.timeout = 3e3;
                        this._ajax.onerror = function() {
                            return n.dataLoadError(n._fileIndex)
                        };
                        this._ajax.ontimeout = function() {
                            return n.dataLoadError(n._fileIndex)
                        };
                        this._ajax.onprogress = function() {};
                        this._ajax.onload = function() {
                            return n.jsonLoadComplete(n._fileIndex)
                        };
                        this._ajax.open("GET", this.baseURL + e.url, true);
                        this._ajax.send()
                    } else {
                        this._xhr.open("GET", this.baseURL + e.url, true);
                        this._xhr.responseType = "text";
                        this._xhr.onload = function() {
                            return n.jsonLoadComplete(n._fileIndex)
                        };
                        this._xhr.onerror = function() {
                            return n.dataLoadError(n._fileIndex)
                        };
                        this._xhr.send()
                    }
                    break;
                case "tilemap":
                    this._xhr.open("GET", this.baseURL + e.url, true);
                    this._xhr.responseType = "text";
                    if (e.format === t.Tilemap.TILED_JSON) {
                        this._xhr.onload = function() {
                            return n.jsonLoadComplete(n._fileIndex)
                        }
                    } else if (e.format === t.Tilemap.CSV) {
                        this._xhr.onload = function() {
                            return n.csvLoadComplete(n._fileIndex)
                        }
                    } else {
                        throw new Error("Phaser.Loader. Invalid Tilemap format: " + e.format)
                    }
                    this._xhr.onerror = function() {
                        return n.dataLoadError(n._fileIndex)
                    };
                    this._xhr.send();
                    break;
                case "text":
                case "script":
                case "physics":
                    this._xhr.open("GET", this.baseURL + e.url, true);
                    this._xhr.responseType = "text";
                    this._xhr.onload = function() {
                        return n.fileComplete(n._fileIndex)
                    };
                    this._xhr.onerror = function() {
                        return n.fileError(n._fileIndex)
                    };
                    this._xhr.send();
                    break;
                case "binary":
                    this._xhr.open("GET", this.baseURL + e.url, true);
                    this._xhr.responseType = "arraybuffer";
                    this._xhr.onload = function() {
                        return n.fileComplete(n._fileIndex)
                    };
                    this._xhr.onerror = function() {
                        return n.fileError(n._fileIndex)
                    };
                    this._xhr.send();
                    break
            }
        },
        getAudioURL: function(e) {
            var t;
            if (typeof e === "string") {
                e = [e]
            }
            for (var n = 0; n < e.length; n++) {
                t = e[n].toLowerCase();
                t = t.substr((Math.max(0, t.lastIndexOf(".")) || Infinity) + 1);
                if (this.game.device.canPlayAudio(t)) {
                    return e[n]
                }
            }
            return null
        },
        fileError: function(e) {
            this._fileList[e].loaded = true;
            this._fileList[e].error = true;
            this.onFileError.dispatch(this._fileList[e].key, this._fileList[e]);
            console.warn("Phaser.Loader error loading file: " + this._fileList[e].key + " from URL " + this._fileList[e].url);
            this.nextFile(e, false)
        },
        fileComplete: function(e) {
            if (!this._fileList[e]) {
                console.warn("Phaser.Loader fileComplete invalid index " + e);
                return
            }
            var n = this._fileList[e];
            n.loaded = true;
            var r = true;
            var i = this;
            switch (n.type) {
                case "image":
                    this.game.cache.addImage(n.key, n.url, n.data);
                    break;
                case "spritesheet":
                    this.game.cache.addSpriteSheet(n.key, n.url, n.data, n.frameWidth, n.frameHeight, n.frameMax, n.margin, n.spacing);
                    break;
                case "textureatlas":
                    if (n.atlasURL == null) {
                        this.game.cache.addTextureAtlas(n.key, n.url, n.data, n.atlasData, n.format)
                    } else {
                        r = false;
                        this._xhr.open("GET", this.baseURL + n.atlasURL, true);
                        this._xhr.responseType = "text";
                        if (n.format == t.Loader.TEXTURE_ATLAS_JSON_ARRAY || n.format == t.Loader.TEXTURE_ATLAS_JSON_HASH) {
                            this._xhr.onload = function() {
                                return i.jsonLoadComplete(e)
                            }
                        } else if (n.format == t.Loader.TEXTURE_ATLAS_XML_STARLING) {
                            this._xhr.onload = function() {
                                return i.xmlLoadComplete(e)
                            }
                        } else {
                            throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + n.format)
                        }
                        this._xhr.onerror = function() {
                            return i.dataLoadError(e)
                        };
                        this._xhr.send()
                    }
                    break;
                case "bitmapfont":
                    if (n.xmlURL == null) {
                        this.game.cache.addBitmapFont(n.key, n.url, n.data, n.xmlData, n.xSpacing, n.ySpacing)
                    } else {
                        r = false;
                        this._xhr.open("GET", this.baseURL + n.xmlURL, true);
                        this._xhr.responseType = "text";
                        this._xhr.onload = function() {
                            return i.xmlLoadComplete(e)
                        };
                        this._xhr.onerror = function() {
                            return i.dataLoadError(e)
                        };
                        this._xhr.send()
                    }
                    break;
                case "audio":
                    if (this.game.sound.usingWebAudio) {
                        n.data = this._xhr.response;
                        this.game.cache.addSound(n.key, n.url, n.data, true, false);
                        if (n.autoDecode) {
                            this.game.cache.updateSound(o, "isDecoding", true);
                            var s = this;
                            var o = n.key;
                            this.game.sound.context.decodeAudioData(n.data, function(e) {
                                if (e) {
                                    s.game.cache.decodedSound(o, e)
                                }
                            })
                        }
                    } else {
                        n.data.removeEventListener("canplaythrough", t.GAMES[this.game.id].load.fileComplete);
                        this.game.cache.addSound(n.key, n.url, n.data, false, true)
                    }
                    break;
                case "text":
                    n.data = this._xhr.responseText;
                    this.game.cache.addText(n.key, n.url, n.data);
                    break;
                case "physics":
                    var u = JSON.parse(this._xhr.responseText);
                    this.game.cache.addPhysicsData(n.key, n.url, u, n.format);
                    break;
                case "script":
                    n.data = document.createElement("script");
                    n.data.language = "javascript";
                    n.data.type = "text/javascript";
                    n.data.defer = false;
                    n.data.text = this._xhr.responseText;
                    document.head.appendChild(n.data);
                    if (n.callback) {
                        n.data = n.callback.call(n.callbackContext, n.key, this._xhr.responseText)
                    }
                    break;
                case "binary":
                    if (n.callback) {
                        n.data = n.callback.call(n.callbackContext, n.key, this._xhr.response)
                    } else {
                        n.data = this._xhr.response
                    }
                    this.game.cache.addBinary(n.key, n.data);
                    break
            }
            if (r) {
                this.nextFile(e, true)
            }
        },
        jsonLoadComplete: function(e) {
            if (!this._fileList[e]) {
                console.warn("Phaser.Loader jsonLoadComplete invalid index " + e);
                return
            }
            var t = this._fileList[e];
            var n = JSON.parse(this._xhr.responseText);
            t.loaded = true;
            if (t.type === "tilemap") {
                this.game.cache.addTilemap(t.key, t.url, n, t.format)
            } else if (t.type === "json") {
                this.game.cache.addJSON(t.key, t.url, n)
            } else {
                this.game.cache.addTextureAtlas(t.key, t.url, t.data, n, t.format)
            }
            this.nextFile(e, true)
        },
        csvLoadComplete: function(e) {
            if (!this._fileList[e]) {
                console.warn("Phaser.Loader csvLoadComplete invalid index " + e);
                return
            }
            var t = this._fileList[e];
            var n = this._xhr.responseText;
            t.loaded = true;
            this.game.cache.addTilemap(t.key, t.url, n, t.format);
            this.nextFile(e, true)
        },
        dataLoadError: function(e) {
            var t = this._fileList[e];
            t.loaded = true;
            t.error = true;
            console.warn("Phaser.Loader dataLoadError: " + t.key);
            this.nextFile(e, true)
        },
        xmlLoadComplete: function(e) {
            var t = this._xhr.responseText;
            var n;
            try {
                if (window["DOMParser"]) {
                    var r = new DOMParser;
                    n = r.parseFromString(t, "text/xml")
                } else {
                    n = new ActiveXObject("Microsoft.XMLDOM");
                    n.async = "false";
                    n.loadXML(t)
                }
            } catch (i) {
                n = undefined
            }
            if (!n || !n.documentElement || n.getElementsByTagName("parsererror").length) {
                throw new Error("Phaser.Loader. Invalid XML given")
            }
            var s = this._fileList[e];
            s.loaded = true;
            if (s.type == "bitmapfont") {
                this.game.cache.addBitmapFont(s.key, s.url, s.data, n, s.xSpacing, s.ySpacing)
            } else if (s.type == "textureatlas") {
                this.game.cache.addTextureAtlas(s.key, s.url, s.data, n, s.format)
            }
            this.nextFile(e, true)
        },
        nextFile: function(e, t) {
            this.progressFloat += this._progressChunk;
            this.progress = Math.round(this.progressFloat);
            if (this.progress > 100) {
                this.progress = 100
            }
            if (this.preloadSprite !== null) {
                if (this.preloadSprite.direction === 0) {
                    this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress);
                    this.preloadSprite.sprite.crop(this.preloadSprite.rect)
                } else {
                    this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress);
                    this.preloadSprite.sprite.crop(this.preloadSprite.rect)
                }
            }
            this.onFileComplete.dispatch(this.progress, this._fileList[e].key, t, this.totalLoadedFiles(), this._fileList.length);
            if (this.totalQueuedFiles() > 0) {
                this._fileIndex++;
                this.loadFile()
            } else {
                this.hasLoaded = true;
                this.isLoading = false;
                this.removeAll();
                this.onLoadComplete.dispatch()
            }
        },
        totalLoadedFiles: function() {
            var e = 0;
            for (var t = 0; t < this._fileList.length; t++) {
                if (this._fileList[t].loaded) {
                    e++
                }
            }
            return e
        },
        totalQueuedFiles: function() {
            var e = 0;
            for (var t = 0; t < this._fileList.length; t++) {
                if (this._fileList[t].loaded === false) {
                    e++
                }
            }
            return e
        }
    };
    t.Loader.prototype.constructor = t.Loader;
    t.LoaderParser = {
        bitmapFont: function(e, t, n, r, i) {
            var s = {};
            var o = t.getElementsByTagName("info")[0];
            var u = t.getElementsByTagName("common")[0];
            s.font = o.getAttribute("face");
            s.size = parseInt(o.getAttribute("size"), 10);
            s.lineHeight = parseInt(u.getAttribute("lineHeight"), 10) + i;
            s.chars = {};
            var a = t.getElementsByTagName("char");
            var f = PIXI.TextureCache[n];
            for (var l = 0; l < a.length; l++) {
                var c = parseInt(a[l].getAttribute("id"), 10);
                var h = new PIXI.Rectangle(parseInt(a[l].getAttribute("x"), 10), parseInt(a[l].getAttribute("y"), 10), parseInt(a[l].getAttribute("width"), 10), parseInt(a[l].getAttribute("height"), 10));
                s.chars[c] = {
                    xOffset: parseInt(a[l].getAttribute("xoffset"), 10),
                    yOffset: parseInt(a[l].getAttribute("yoffset"), 10),
                    xAdvance: parseInt(a[l].getAttribute("xadvance"), 10) + r,
                    kerning: {},
                    texture: PIXI.TextureCache[n] = new PIXI.Texture(f, h)
                }
            }
            var p = t.getElementsByTagName("kerning");
            for (l = 0; l < p.length; l++) {
                var d = parseInt(p[l].getAttribute("first"), 10);
                var v = parseInt(p[l].getAttribute("second"), 10);
                var m = parseInt(p[l].getAttribute("amount"), 10);
                s.chars[v].kerning[d] = m
            }
            PIXI.BitmapText.fonts[n] = s
        }
    };
    t.Sound = function(e, n, r, i, s) {
        if (typeof r == "undefined") {
            r = 1
        }
        if (typeof i == "undefined") {
            i = false
        }
        if (typeof s === "undefined") {
            s = e.sound.connectToMaster
        }
        this.game = e;
        this.name = n;
        this.key = n;
        this.loop = i;
        this._volume = r;
        this.markers = {};
        this.context = null;
        this._buffer = null;
        this._muted = false;
        this.autoplay = false;
        this.totalDuration = 0;
        this.startTime = 0;
        this.currentTime = 0;
        this.duration = 0;
        this.stopTime = 0;
        this.paused = false;
        this.pausedPosition = 0;
        this.pausedTime = 0;
        this.isPlaying = false;
        this.currentMarker = "";
        this.pendingPlayback = false;
        this.override = false;
        this.usingWebAudio = this.game.sound.usingWebAudio;
        this.usingAudioTag = this.game.sound.usingAudioTag;
        this.externalNode = null;
        if (this.usingWebAudio) {
            this.context = this.game.sound.context;
            this.masterGainNode = this.game.sound.masterGain;
            if (typeof this.context.createGain === "undefined") {
                this.gainNode = this.context.createGainNode()
            } else {
                this.gainNode = this.context.createGain()
            }
            this.gainNode.gain.value = r * this.game.sound.volume;
            if (s) {
                this.gainNode.connect(this.masterGainNode)
            }
        } else {
            if (this.game.cache.getSound(n) && this.game.cache.isSoundReady(n)) {
                this._sound = this.game.cache.getSoundData(n);
                this.totalDuration = 0;
                if (this._sound.duration) {
                    this.totalDuration = this._sound.duration
                }
            } else {
                this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)
            }
        }
        this.onDecoded = new t.Signal;
        this.onPlay = new t.Signal;
        this.onPause = new t.Signal;
        this.onResume = new t.Signal;
        this.onLoop = new t.Signal;
        this.onStop = new t.Signal;
        this.onMute = new t.Signal;
        this.onMarkerComplete = new t.Signal
    };
    t.Sound.prototype = {
        soundHasUnlocked: function(e) {
            if (e == this.key) {
                this._sound = this.game.cache.getSoundData(this.key);
                this.totalDuration = this._sound.duration
            }
        },
        addMarker: function(e, t, n, r, i) {
            r = r || 1;
            if (typeof i == "undefined") {
                i = false
            }
            this.markers[e] = {
                name: e,
                start: t,
                stop: t + n,
                volume: r,
                duration: n,
                durationMS: n * 1e3,
                loop: i
            }
        },
        removeMarker: function(e) {
            delete this.markers[e]
        },
        update: function() {
            if (this.pendingPlayback && this.game.cache.isSoundReady(this.key)) {
                this.pendingPlayback = false;
                this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)
            }
            if (this.isPlaying) {
                this.currentTime = this.game.time.now - this.startTime;
                if (this.currentTime >= this.durationMS) {
                    if (this.usingWebAudio) {
                        if (this.loop) {
                            this.onLoop.dispatch(this);
                            if (this.currentMarker === "") {
                                this.currentTime = 0;
                                this.startTime = this.game.time.now
                            } else {
                                this.play(this.currentMarker, 0, this.volume, true, true)
                            }
                        } else {
                            this.stop()
                        }
                    } else {
                        if (this.loop) {
                            this.onLoop.dispatch(this);
                            this.play(this.currentMarker, 0, this.volume, true, true)
                        } else {
                            this.stop()
                        }
                    }
                }
            }
        },
        play: function(e, t, n, r, i) {
            e = e || "";
            t = t || 0;
            if (typeof n === "undefined") {
                n = this._volume
            }
            if (typeof r === "undefined") {
                r = false
            }
            if (typeof i === "undefined") {
                i = true
            }
            if (this.isPlaying === true && i === false && this.override === false) {
                return
            }
            if (this.isPlaying && this.override) {
                if (this.usingWebAudio) {
                    if (typeof this._sound.stop === "undefined") {
                        this._sound.noteOff(0)
                    } else {
                        this._sound.stop(0)
                    }
                } else if (this.usingAudioTag) {
                    this._sound.pause();
                    this._sound.currentTime = 0
                }
            }
            this.currentMarker = e;
            if (e !== "") {
                if (this.markers[e]) {
                    this.position = this.markers[e].start;
                    this.volume = this.markers[e].volume;
                    this.loop = this.markers[e].loop;
                    this.duration = this.markers[e].duration;
                    this.durationMS = this.markers[e].durationMS;
                    this._tempMarker = e;
                    this._tempPosition = this.position;
                    this._tempVolume = this.volume;
                    this._tempLoop = this.loop
                } else {
                    console.warn("Phaser.Sound.play: audio marker " + e + " doesn't exist");
                    return
                }
            } else {
                this.position = t;
                this.volume = n;
                this.loop = r;
                this.duration = 0;
                this.durationMS = 0;
                this._tempMarker = e;
                this._tempPosition = t;
                this._tempVolume = n;
                this._tempLoop = r
            }
            if (this.usingWebAudio) {
                if (this.game.cache.isSoundDecoded(this.key)) {
                    if (this._buffer == null) {
                        this._buffer = this.game.cache.getSoundData(this.key)
                    }
                    this._sound = this.context.createBufferSource();
                    this._sound.buffer = this._buffer;
                    if (this.externalNode) {
                        this._sound.connect(this.externalNode.input)
                    } else {
                        this._sound.connect(this.gainNode)
                    }
                    this.totalDuration = this._sound.buffer.duration;
                    if (this.duration === 0) {
                        this.duration = this.totalDuration;
                        this.durationMS = this.totalDuration * 1e3
                    }
                    if (this.loop && e === "") {
                        this._sound.loop = true
                    }
                    if (typeof this._sound.start === "undefined") {
                        this._sound.noteGrainOn(0, this.position, this.duration)
                    } else {
                        this._sound.start(0, this.position, this.duration)
                    }
                    this.isPlaying = true;
                    this.startTime = this.game.time.now;
                    this.currentTime = 0;
                    this.stopTime = this.startTime + this.durationMS;
                    this.onPlay.dispatch(this)
                } else {
                    this.pendingPlayback = true;
                    if (this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).isDecoding === false) {
                        this.game.sound.decode(this.key, this)
                    }
                }
            } else {
                if (this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked) {
                    this.game.cache.reloadSound(this.key);
                    this.pendingPlayback = true
                } else {
                    if (this._sound && this._sound.readyState == 4) {
                        this._sound.play();
                        this.totalDuration = this._sound.duration;
                        if (this.duration === 0) {
                            this.duration = this.totalDuration;
                            this.durationMS = this.totalDuration * 1e3
                        }
                        this._sound.currentTime = this.position;
                        this._sound.muted = this._muted;
                        if (this._muted) {
                            this._sound.volume = 0
                        } else {
                            this._sound.volume = this._volume
                        }
                        this.isPlaying = true;
                        this.startTime = this.game.time.now;
                        this.currentTime = 0;
                        this.stopTime = this.startTime + this.durationMS;
                        this.onPlay.dispatch(this)
                    } else {
                        this.pendingPlayback = true
                    }
                }
            }
        },
        restart: function(e, t, n, r) {
            e = e || "";
            t = t || 0;
            n = n || 1;
            if (typeof r == "undefined") {
                r = false
            }
            this.play(e, t, n, r, true)
        },
        pause: function() {
            if (this.isPlaying && this._sound) {
                this.stop();
                this.isPlaying = false;
                this.paused = true;
                this.pausedPosition = this.currentTime;
                this.pausedTime = this.game.time.now;
                this.onPause.dispatch(this)
            }
        },
        resume: function() {
            if (this.paused && this._sound) {
                if (this.usingWebAudio) {
                    var e = this.position + this.pausedPosition / 1e3;
                    this._sound = this.context.createBufferSource();
                    this._sound.buffer = this._buffer;
                    this._sound.connect(this.gainNode);
                    if (typeof this._sound.start === "undefined") {
                        this._sound.noteGrainOn(0, e, this.duration)
                    } else {
                        this._sound.start(0, e, this.duration)
                    }
                } else {
                    this._sound.play()
                }
                this.isPlaying = true;
                this.paused = false;
                this.startTime += this.game.time.now - this.pausedTime;
                this.onResume.dispatch(this)
            }
        },
        stop: function() {
            if (this.isPlaying && this._sound) {
                if (this.usingWebAudio) {
                    if (typeof this._sound.stop === "undefined") {
                        this._sound.noteOff(0)
                    } else {
                        this._sound.stop(0)
                    }
                } else if (this.usingAudioTag) {
                    this._sound.pause();
                    this._sound.currentTime = 0
                }
            }
            this.isPlaying = false;
            var e = this.currentMarker;
            this.currentMarker = "";
            this.onStop.dispatch(this, e)
        }
    };
    Object.defineProperty(t.Sound.prototype, "isDecoding", {
        get: function() {
            return this.game.cache.getSound(this.key).isDecoding
        }
    });
    Object.defineProperty(t.Sound.prototype, "isDecoded", {
        get: function() {
            return this.game.cache.isSoundDecoded(this.key)
        }
    });
    Object.defineProperty(t.Sound.prototype, "mute", {
        get: function() {
            return this._muted
        },
        set: function(e) {
            e = e || null;
            if (e) {
                this._muted = true;
                if (this.usingWebAudio) {
                    this._muteVolume = this.gainNode.gain.value;
                    this.gainNode.gain.value = 0
                } else if (this.usingAudioTag && this._sound) {
                    this._muteVolume = this._sound.volume;
                    this._sound.volume = 0
                }
            } else {
                this._muted = false;
                if (this.usingWebAudio) {
                    this.gainNode.gain.value = this._muteVolume
                } else if (this.usingAudioTag && this._sound) {
                    this._sound.volume = this._muteVolume
                }
            }
            this.onMute.dispatch(this)
        }
    });
    Object.defineProperty(t.Sound.prototype, "volume", {
        get: function() {
            return this._volume
        },
        set: function(e) {
            if (this.usingWebAudio) {
                this._volume = e;
                this.gainNode.gain.value = e
            } else if (this.usingAudioTag && this._sound) {
                if (e >= 0 && e <= 1) {
                    this._volume = e;
                    this._sound.volume = e
                }
            }
        }
    });
    t.SoundManager = function(e) {
        this.game = e;
        this.onSoundDecode = new t.Signal;
        this._muted = false;
        this._unlockSource = null;
        this._volume = 1;
        this._sounds = [];
        this.context = null;
        this.usingWebAudio = true;
        this.usingAudioTag = false;
        this.noAudio = false;
        this.connectToMaster = true;
        this.touchLocked = false;
        this.channels = 32
    };
    t.SoundManager.prototype = {
        boot: function() {
            if (this.game.device.iOS && this.game.device.webAudio === false) {
                this.channels = 1
            }
            if (this.game.device.iOS || window["PhaserGlobal"] && window["PhaserGlobal"].fakeiOSTouchLock) {
                this.game.input.touch.callbackContext = this;
                this.game.input.touch.touchStartCallback = this.unlock;
                this.game.input.mouse.callbackContext = this;
                this.game.input.mouse.mouseDownCallback = this.unlock;
                this.touchLocked = true
            } else {
                this.touchLocked = false
            }
            if (this.game.device.android) {
                this.usingWebAudio = false;
                this.usingAudioTag = true;
                this.noAudio = false;
                return
            }
            if ( !! window["AudioContext"]) {
                this.context = new window["AudioContext"]
            } else if ( !! window["webkitAudioContext"]) {
                this.context = new window["webkitAudioContext"]
            } else if ( !! window["Audio"]) {
                this.usingWebAudio = false;
                this.usingAudioTag = true
            } else {
                this.usingWebAudio = false;
                this.noAudio = true
            }
            if (this.context !== null) {
                if (typeof this.context.createGain === "undefined") {
                    this.masterGain = this.context.createGainNode()
                } else {
                    this.masterGain = this.context.createGain()
                }
                this.masterGain.gain.value = 1;
                this.masterGain.connect(this.context.destination)
            }
        },
        unlock: function() {
            if (this.touchLocked === false) {
                return
            }
            if (this.game.device.webAudio === false || window["PhaserGlobal"] && window["PhaserGlobal"].disableWebAudio === true) {
                this.touchLocked = false;
                this._unlockSource = null;
                this.game.input.touch.callbackContext = null;
                this.game.input.touch.touchStartCallback = null;
                this.game.input.mouse.callbackContext = null;
                this.game.input.mouse.mouseDownCallback = null
            } else {
                var e = this.context.createBuffer(1, 1, 22050);
                this._unlockSource = this.context.createBufferSource();
                this._unlockSource.buffer = e;
                this._unlockSource.connect(this.context.destination);
                this._unlockSource.noteOn(0)
            }
        },
        stopAll: function() {
            for (var e = 0; e < this._sounds.length; e++) {
                if (this._sounds[e]) {
                    this._sounds[e].stop()
                }
            }
        },
        pauseAll: function() {
            for (var e = 0; e < this._sounds.length; e++) {
                if (this._sounds[e]) {
                    this._sounds[e].pause()
                }
            }
        },
        resumeAll: function() {
            for (var e = 0; e < this._sounds.length; e++) {
                if (this._sounds[e]) {
                    this._sounds[e].resume()
                }
            }
        },
        decode: function(e, t) {
            t = t || null;
            var n = this.game.cache.getSoundData(e);
            if (n) {
                if (this.game.cache.isSoundDecoded(e) === false) {
                    this.game.cache.updateSound(e, "isDecoding", true);
                    var r = this;
                    this.context.decodeAudioData(n, function(n) {
                        r.game.cache.decodedSound(e, n);
                        if (t) {
                            r.onSoundDecode.dispatch(t)
                        }
                    })
                }
            }
        },
        update: function() {
            if (this.touchLocked) {
                if (this.game.device.webAudio && this._unlockSource !== null) {
                    if (this._unlockSource.playbackState === this._unlockSource.PLAYING_STATE || this._unlockSource.playbackState === this._unlockSource.FINISHED_STATE) {
                        this.touchLocked = false;
                        this._unlockSource = null;
                        this.game.input.touch.callbackContext = null;
                        this.game.input.touch.touchStartCallback = null
                    }
                }
            }
            for (var e = 0; e < this._sounds.length; e++) {
                this._sounds[e].update()
            }
        },
        add: function(e, n, r, i) {
            if (typeof n === "undefined") {
                n = 1
            }
            if (typeof r === "undefined") {
                r = false
            }
            if (typeof i === "undefined") {
                i = this.connectToMaster
            }
            var s = new t.Sound(this.game, e, n, r, i);
            this._sounds.push(s);
            return s
        },
        play: function(e, t, n, r) {
            if (typeof r == "undefined") {
                r = false
            }
            var i = this.add(e, t, n);
            i.play();
            return i
        }
    };
    Object.defineProperty(t.SoundManager.prototype, "mute", {
        get: function() {
            return this._muted
        },
        set: function(e) {
            e = e || null;
            if (e) {
                if (this._muted) {
                    return
                }
                this._muted = true;
                if (this.usingWebAudio) {
                    this._muteVolume = this.masterGain.gain.value;
                    this.masterGain.gain.value = 0
                }
                for (var t = 0; t < this._sounds.length; t++) {
                    if (this._sounds[t].usingAudioTag) {
                        this._sounds[t].mute = true
                    }
                }
            } else {
                if (this._muted === false) {
                    return
                }
                this._muted = false;
                if (this.usingWebAudio) {
                    this.masterGain.gain.value = this._muteVolume
                }
                for (var t = 0; t < this._sounds.length; t++) {
                    if (this._sounds[t].usingAudioTag) {
                        this._sounds[t].mute = false
                    }
                }
            }
        }
    });
    Object.defineProperty(t.SoundManager.prototype, "volume", {
        get: function() {
            if (this.usingWebAudio) {
                return this.masterGain.gain.value
            } else {
                return this._volume
            }
        },
        set: function(e) {
            e = this.game.math.clamp(e, 1, 0);
            this._volume = e;
            if (this.usingWebAudio) {
                this.masterGain.gain.value = e
            }
            for (var t = 0; t < this._sounds.length; t++) {
                if (this._sounds[t].usingAudioTag) {
                    this._sounds[t].volume = this._sounds[t].volume * e
                }
            }
        }
    });
    t.Utils.Debug = function(e) {
        this.game = e;
        this.sprite = null;
        this.canvas = null;
        this.baseTexture = null;
        this.texture = null;
        this.textureFrame = null;
        this.context = null;
        this.font = "14px Courier";
        this.columnWidth = 100;
        this.lineHeight = 16;
        this.renderShadow = true;
        this.currentX = 0;
        this.currentY = 0;
        this.currentAlpha = 1;
        this.dirty = false
    };
    t.Utils.Debug.prototype = {
        boot: function() {
            if (this.game.renderType === t.CANVAS) {
                this.context = this.game.context
            } else {
                this.canvas = t.Canvas.create(this.game.width, this.game.height, "", true);
                this.context = this.canvas.getContext("2d");
                this.baseTexture = new PIXI.BaseTexture(this.canvas);
                this.texture = new PIXI.Texture(this.baseTexture);
                this.textureFrame = new t.Frame(0, 0, 0, this.game.width, this.game.height, "debug", this.game.rnd.uuid());
                this.sprite = this.game.make.image(0, 0, this.texture, this.textureFrame);
                this.game.stage.addChild(this.sprite)
            }
        },
        preUpdate: function() {
            if (this.dirty && this.sprite) {
                this.context.clearRect(0, 0, this.game.width, this.game.height);
                this.dirty = false
            }
        },
        start: function(e, t, n, r) {
            if (typeof e !== "number") {
                e = 0
            }
            if (typeof t !== "number") {
                t = 0
            }
            n = n || "rgb(255,255,255)";
            if (typeof r === "undefined") {
                r = 0
            }
            this.currentX = e;
            this.currentY = t;
            this.currentColor = n;
            this.currentAlpha = this.context.globalAlpha;
            this.columnWidth = r;
            if (this.sprite) {
                this.dirty = true
            }
            this.context.save();
            this.context.setTransform(1, 0, 0, 1, 0, 0);
            this.context.strokeStyle = n;
            this.context.fillStyle = n;
            this.context.font = this.font;
            this.context.globalAlpha = 1
        },
        stop: function() {
            this.context.restore();
            this.context.globalAlpha = this.currentAlpha;
            if (this.sprite) {
                PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl)
            }
        },
        line: function() {
            var e = this.currentX;
            for (var t = 0; t < arguments.length; t++) {
                if (this.renderShadow) {
                    this.context.fillStyle = "rgb(0,0,0)";
                    this.context.fillText(arguments[t], e + 1, this.currentY + 1);
                    this.context.fillStyle = this.currentColor
                }
                this.context.fillText(arguments[t], e, this.currentY);
                e += this.columnWidth
            }
            this.currentY += this.lineHeight
        },
        soundInfo: function(e, t, n, r) {
            this.start(t, n, r);
            this.line("Sound: " + e.key + " Locked: " + e.game.sound.touchLocked);
            this.line("Is Ready?: " + this.game.cache.isSoundReady(e.key) + " Pending Playback: " + e.pendingPlayback);
            this.line("Decoded: " + e.isDecoded + " Decoding: " + e.isDecoding);
            this.line("Total Duration: " + e.totalDuration + " Playing: " + e.isPlaying);
            this.line("Time: " + e.currentTime);
            this.line("Volume: " + e.volume + " Muted: " + e.mute);
            this.line("WebAudio: " + e.usingWebAudio + " Audio: " + e.usingAudioTag);
            if (e.currentMarker !== "") {
                this.line("Marker: " + e.currentMarker + " Duration: " + e.duration + " (ms: " + e.durationMS + ")");
                this.line("Start: " + e.markers[e.currentMarker].start + " Stop: " + e.markers[e.currentMarker].stop);
                this.line("Position: " + e.position)
            }
            this.stop()
        },
        cameraInfo: function(e, t, n, r) {
            this.start(t, n, r);
            this.line("Camera (" + e.width + " x " + e.height + ")");
            this.line("X: " + e.x + " Y: " + e.y);
            this.line("Bounds x: " + e.bounds.x + " Y: " + e.bounds.y + " w: " + e.bounds.width + " h: " + e.bounds.height);
            this.line("View x: " + e.view.x + " Y: " + e.view.y + " w: " + e.view.width + " h: " + e.view.height);
            this.stop()
        },
        timer: function(e, t, n, r) {
            this.start(t, n, r);
            this.line("Timer (running: " + e.running + " expired: " + e.expired + ")");
            this.line("Next Tick: " + e.next + " Duration: " + e.duration);
            this.line("Paused: " + e.paused + " Length: " + e.length);
            this.stop()
        },
        pointer: function(e, t, n, r, i) {
            if (e == null) {
                return
            }
            if (typeof t === "undefined") {
                t = false
            }
            n = n || "rgba(0,255,0,0.5)";
            r = r || "rgba(255,0,0,0.5)";
            if (t === true && e.isUp === true) {
                return
            }
            this.start(e.x, e.y - 100, i);
            this.context.beginPath();
            this.context.arc(e.x, e.y, e.circle.radius, 0, Math.PI * 2);
            if (e.active) {
                this.context.fillStyle = n
            } else {
                this.context.fillStyle = r
            }
            this.context.fill();
            this.context.closePath();
            this.context.beginPath();
            this.context.moveTo(e.positionDown.x, e.positionDown.y);
            this.context.lineTo(e.position.x, e.position.y);
            this.context.lineWidth = 2;
            this.context.stroke();
            this.context.closePath();
            this.line("ID: " + e.id + " Active: " + e.active);
            this.line("World X: " + e.worldX + " World Y: " + e.worldY);
            this.line("Screen X: " + e.x + " Screen Y: " + e.y);
            this.line("Duration: " + e.duration + " ms");
            this.line("is Down: " + e.isDown + " is Up: " + e.isUp);
            this.stop()
        },
        spriteInputInfo: function(e, t, n, r) {
            this.start(t, n, r);
            this.line("Sprite Input: (" + e.width + " x " + e.height + ")");
            this.line("x: " + e.input.pointerX().toFixed(1) + " y: " + e.input.pointerY().toFixed(1));
            this.line("over: " + e.input.pointerOver() + " duration: " + e.input.overDuration().toFixed(0));
            this.line("down: " + e.input.pointerDown() + " duration: " + e.input.downDuration().toFixed(0));
            this.line("just over: " + e.input.justOver() + " just out: " + e.input.justOut());
            this.stop()
        },
        key: function(e, t, n, r) {
            this.start(t, n, r, 150);
            this.line("Key:", e.keyCode, "isDown:", e.isDown);
            this.line("justPressed:", e.justPressed(), "justReleased:", e.justReleased());
            this.line("Time Down:", e.timeDown.toFixed(0), "duration:", e.duration.toFixed(0));
            this.stop()
        },
        inputInfo: function(e, t, n) {
            this.start(e, t, n);
            this.line("Input");
            this.line("X: " + this.game.input.x + " Y: " + this.game.input.y);
            this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY);
            this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1));
            this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY);
            this.stop()
        },
        spriteBounds: function(e, t, n) {
            var r = e.getBounds();
            r.x += this.game.camera.x;
            r.y += this.game.camera.y;
            this.rectangle(r, t, n)
        },
        spriteInfo: function(e, t, n, r) {
            this.start(t, n, r);
            this.line("Sprite: " + " (" + e.width + " x " + e.height + ") anchor: " + e.anchor.x + " x " + e.anchor.y);
            this.line("x: " + e.x.toFixed(1) + " y: " + e.y.toFixed(1));
            this.line("angle: " + e.angle.toFixed(1) + " rotation: " + e.rotation.toFixed(1));
            this.line("visible: " + e.visible + " in camera: " + e.inCamera);
            this.stop()
        },
        spriteCoords: function(e, t, n, r) {
            this.start(t, n, r, 100);
            if (e.name) {
                this.line(e.name)
            }
            this.line("x:", e.x.toFixed(2), "y:", e.y.toFixed(2));
            this.line("pos x:", e.position.x.toFixed(2), "pos y:", e.position.y.toFixed(2));
            this.line("world x:", e.world.x.toFixed(2), "world y:", e.world.y.toFixed(2));
            this.stop()
        },
        lineInfo: function(e, t, n, r) {
            this.start(t, n, r, 80);
            this.line("start.x:", e.start.x.toFixed(2), "start.y:", e.start.y.toFixed(2));
            this.line("end.x:", e.end.x.toFixed(2), "end.y:", e.end.y.toFixed(2));
            this.line("length:", e.length.toFixed(2), "angle:", e.angle);
            this.stop()
        },
        pixel: function(e, t, n, r) {
            r = r || 2;
            this.start();
            this.context.fillStyle = n;
            this.context.fillRect(e, t, r, r);
            this.stop()
        },
        geom: function(e, n, r, i) {
            if (typeof r === "undefined") {
                r = true
            }
            if (typeof i === "undefined") {
                i = 0
            }
            n = n || "rgba(0,255,0,0.4)";
            this.start();
            this.context.fillStyle = n;
            this.context.strokeStyle = n;
            if (e instanceof t.Rectangle || i === 1) {
                if (r) {
                    this.context.fillRect(e.x - this.game.camera.x, e.y - this.game.camera.y, e.width, e.height)
                } else {
                    this.context.strokeRect(e.x - this.game.camera.x, e.y - this.game.camera.y, e.width, e.height)
                }
            } else if (e instanceof t.Circle || i === 2) {
                this.context.beginPath();
                this.context.arc(e.x - this.game.camera.x, e.y - this.game.camera.y, e.radius, 0, Math.PI * 2, false);
                this.context.closePath();
                if (r) {
                    this.context.fill()
                } else {
                    this.context.stroke()
                }
            } else if (e instanceof t.Point || i === 3) {
                this.context.fillRect(e.x - this.game.camera.x, e.y - this.game.camera.y, 4, 4)
            } else if (e instanceof t.Line || i === 4) {
                this.context.lineWidth = 1;
                this.context.beginPath();
                this.context.moveTo(e.start.x + .5 - this.game.camera.x, e.start.y + .5 - this.game.camera.y);
                this.context.lineTo(e.end.x + .5 - this.game.camera.x, e.end.y + .5 - this.game.camera.y);
                this.context.closePath();
                this.context.stroke()
            }
            this.stop()
        },
        rectangle: function(e, t, n) {
            if (typeof n === "undefined") {
                n = true
            }
            t = t || "rgba(0, 255, 0, 0.4)";
            this.start();
            if (n) {
                this.context.fillStyle = t;
                this.context.fillRect(e.x - this.game.camera.x, e.y - this.game.camera.y, e.width, e.height)
            } else {
                this.context.strokeStyle = t;
                this.context.strokeRect(e.x - this.game.camera.x, e.y - this.game.camera.y, e.width, e.height)
            }
            this.stop()
        },
        text: function(e, t, n, r, i) {
            r = r || "rgb(255,255,255)";
            i = i || "16px Courier";
            this.start();
            this.context.font = i;
            if (this.renderShadow) {
                this.context.fillStyle = "rgb(0,0,0)";
                this.context.fillText(e, t + 1, n + 1)
            }
            this.context.fillStyle = r;
            this.context.fillText(e, t, n);
            this.stop()
        },
        quadTree: function(e, t) {
            t = t || "rgba(255,0,0,0.3)";
            this.start();
            var n = e.bounds;
            if (e.nodes.length === 0) {
                this.context.strokeStyle = t;
                this.context.strokeRect(n.x, n.y, n.width, n.height);
                this.text("size: " + e.objects.length, n.x + 4, n.y + 16, "rgb(0,200,0)", "12px Courier");
                this.context.strokeStyle = "rgb(0,255,0)";
                for (var r = 0; r < e.objects.length; r++) {
                    this.context.strokeRect(e.objects[r].x, e.objects[r].y, e.objects[r].width, e.objects[r].height)
                }
            } else {
                for (var r = 0; r < e.nodes.length; r++) {
                    this.quadTree(e.nodes[r])
                }
            }
            this.stop()
        },
        body: function(e, n, r) {
            if (e.body) {
                if (e.body.type === t.Physics.ARCADE) {
                    this.start();
                    t.Physics.Arcade.Body.render(this.context, e.body, n, r);
                    this.stop()
                }
            }
        },
        bodyInfo: function(e, n, r, i) {
            if (e.body) {
                if (e.body.type === t.Physics.ARCADE) {
                    this.start(n, r, i, 210);
                    t.Physics.Arcade.Body.renderBodyInfo(this, e.body);
                    this.stop()
                }
            }
        }
    };
    t.Utils.Debug.prototype.constructor = t.Utils.Debug;
    t.Color = {
        packPixel: function(e, n, r, i) {
            if (t.Device.LITTLE_ENDIAN) {
                return i << 24 | r << 16 | n << 8 | e
            } else {
                return e << 24 | n << 16 | r << 8 | i
            }
        },
        unpackPixel: function(e, n, r, i) {
            if (typeof n === "undefined" || n === null) {
                n = t.Color.createColor()
            }
            if (typeof r === "undefined" || r === null) {
                r = false
            }
            if (typeof i === "undefined" || i === null) {
                i = false
            }
            if (t.Device.LITTLE_ENDIAN) {
                n.a = (e & 4278190080) >>> 24;
                n.b = (e & 16711680) >>> 16;
                n.g = (e & 65280) >>> 8;
                n.r = e & 255
            } else {
                n.r = (e & 4278190080) >>> 24;
                n.g = (e & 16711680) >>> 16;
                n.b = (e & 65280) >>> 8;
                n.a = e & 255
            }
            n.color = e;
            n.rgba = "rgba(" + n.r + "," + n.g + "," + n.b + "," + n.a / 255 + ")";
            if (r) {
                t.Color.RGBtoHSL(n.r, n.g, n.b, n)
            }
            if (i) {
                t.Color.RGBtoHSV(n.r, n.g, n.b, n)
            }
            return n
        },
        fromRGBA: function(e, n) {
            if (!n) {
                n = t.Color.createColor()
            }
            n.r = (e & 4278190080) >>> 24;
            n.g = (e & 16711680) >>> 16;
            n.b = (e & 65280) >>> 8;
            n.a = e & 255;
            n.rgba = "rgba(" + n.r + "," + n.g + "," + n.b + "," + n.a + ")";
            return n
        },
        toRGBA: function(e, t, n, r) {
            return e << 24 | t << 16 | n << 8 | r
        },
        RGBtoHSL: function(e, n, r, i) {
            if (!i) {
                i = t.Color.createColor(e, n, r, 1)
            }
            e /= 255;
            n /= 255;
            r /= 255;
            var s = Math.min(e, n, r);
            var o = Math.max(e, n, r);
            i.h = 0;
            i.s = 0;
            i.l = (o + s) / 2;
            if (o !== s) {
                var u = o - s;
                i.s = i.l > .5 ? u / (2 - o - s) : u / (o + s);
                if (o === e) {
                    i.h = (n - r) / u + (n < r ? 6 : 0)
                } else if (o === n) {
                    i.h = (r - e) / u + 2
                } else if (o === r) {
                    i.h = (e - n) / u + 4
                }
                i.h /= 6
            }
            return i
        },
        HSLtoRGB: function(e, n, r, i) {
            if (!i) {
                i = t.Color.createColor(r, r, r)
            } else {
                i.r = r;
                i.g = r;
                i.b = r
            }
            if (n !== 0) {
                var s = r < .5 ? r * (1 + n) : r + n - r * n;
                var o = 2 * r - s;
                i.r = t.Color.hueToColor(o, s, e + 1 / 3);
                i.g = t.Color.hueToColor(o, s, e);
                i.b = t.Color.hueToColor(o, s, e - 1 / 3)
            }
            i.r = Math.floor(i.r * 255 | 0);
            i.g = Math.floor(i.g * 255 | 0);
            i.b = Math.floor(i.b * 255 | 0);
            t.Color.updateColor(i);
            return i
        },
        RGBtoHSV: function(e, n, r, i) {
            if (!i) {
                i = t.Color.createColor(e, n, r, 255)
            }
            e /= 255;
            n /= 255;
            r /= 255;
            var s = Math.min(e, n, r);
            var o = Math.max(e, n, r);
            var u = o - s;
            i.h = 0;
            i.s = o === 0 ? 0 : u / o;
            i.v = o;
            if (o !== s) {
                if (o === e) {
                    i.h = (n - r) / u + (n < r ? 6 : 0)
                } else if (o === n) {
                    i.h = (r - e) / u + 2
                } else if (o === r) {
                    i.h = (e - n) / u + 4
                }
                i.h /= 6
            }
            return i
        },
        HSVtoRGB: function(e, n, r, i) {
            if (typeof i === "undefined") {
                i = t.Color.createColor(0, 0, 0, 1, e, n, 0, r)
            }
            var s, o, u;
            var a = Math.floor(e * 6);
            var f = e * 6 - a;
            var l = r * (1 - n);
            var c = r * (1 - f * n);
            var h = r * (1 - (1 - f) * n);
            switch (a % 6) {
                case 0:
                    s = r;
                    o = h;
                    u = l;
                    break;
                case 1:
                    s = c;
                    o = r;
                    u = l;
                    break;
                case 2:
                    s = l;
                    o = r;
                    u = h;
                    break;
                case 3:
                    s = l;
                    o = c;
                    u = r;
                    break;
                case 4:
                    s = h;
                    o = l;
                    u = r;
                    break;
                case 5:
                    s = r;
                    o = l;
                    u = c;
                    break
            }
            i.r = Math.floor(s * 255);
            i.g = Math.floor(o * 255);
            i.b = Math.floor(u * 255);
            t.Color.updateColor(i);
            return i
        },
        hueToColor: function(e, t, n) {
            if (n < 0) {
                n += 1
            }
            if (n > 1) {
                n -= 1
            }
            if (n < 1 / 6) {
                return e + (t - e) * 6 * n
            }
            if (n < 1 / 2) {
                return t
            }
            if (n < 2 / 3) {
                return e + (t - e) * (2 / 3 - n) * 6
            }
            return e
        },
        createColor: function(e, t, n, r, i, s, o, u) {
            var a = {
                r: e || 0,
                g: t || 0,
                b: n || 0,
                a: r || 1,
                h: i || 0,
                s: s || 0,
                l: o || 0,
                v: u || 0,
                color: 0
            };
            a.rgba = "rgba(" + a.r + "," + a.g + "," + a.b + "," + a.a + ")";
            return a
        },
        updateColor: function(e) {
            e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a + ")";
            return e
        },
        getColor32: function(e, t, n, r) {
            return e << 24 | t << 16 | n << 8 | r
        },
        getColor: function(e, t, n) {
            return e << 16 | t << 8 | n
        },
        RGBtoString: function(e, n, r, i, s) {
            if (typeof i === "undefined") {
                i = 255
            }
            if (typeof s === "undefined") {
                s = "#"
            }
            if (s === "#") {
                return "#" + ((1 << 24) + (e << 16) + (n << 8) + r).toString(16).slice(1)
            } else {
                return "0x" + t.Color.componentToHex(i) + t.Color.componentToHex(e) + t.Color.componentToHex(n) + t.Color.componentToHex(r)
            }
        },
        hexToRGB: function(e) {
            var n = t.Color.hexToColor(e);
            if (n) {
                return t.Color.getColor32(n.a, n.r, n.g, n.b)
            }
        },
        hexToColor: function(e, n) {
            if (!n) {
                n = t.Color.createColor()
            }
            var r = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            e = e.replace(r, function(e, t, n, r) {
                return t + t + n + n + r + r
            });
            var i = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
            if (i) {
                n.r = parseInt(i[1], 16);
                n.g = parseInt(i[2], 16);
                n.b = parseInt(i[3], 16)
            }
            return n
        },
        componentToHex: function(e) {
            var t = e.toString(16);
            return t.length == 1 ? "0" + t : t
        },
        HSVColorWheel: function(e, n) {
            if (typeof e === "undefined") {
                e = 1
            }
            if (typeof n === "undefined") {
                n = 1
            }
            var r = [];
            for (var i = 0; i <= 359; i++) {
                r.push(t.Color.HSVtoRGB(i / 359, e, n))
            }
            return r
        },
        HSLColorWheel: function(e, n) {
            if (typeof e === "undefined") {
                e = .5
            }
            if (typeof n === "undefined") {
                n = .5
            }
            var r = [];
            for (var i = 0; i <= 359; i++) {
                r.push(t.Color.HSLtoRGB(i / 359, e, n))
            }
            return r
        },
        interpolateColor: function(e, n, r, i, s) {
            if (typeof s === "undefined") {
                s = 255
            }
            var o = t.Color.getRGB(e);
            var u = t.Color.getRGB(n);
            var a = (u.red - o.red) * i / r + o.red;
            var f = (u.green - o.green) * i / r + o.green;
            var l = (u.blue - o.blue) * i / r + o.blue;
            return t.Color.getColor32(s, a, f, l)
        },
        interpolateColorWithRGB: function(e, n, r, i, s, o) {
            var u = t.Color.getRGB(e);
            var a = (n - u.red) * o / s + u.red;
            var f = (r - u.green) * o / s + u.green;
            var l = (i - u.blue) * o / s + u.blue;
            return t.Color.getColor(a, f, l)
        },
        interpolateRGB: function(e, n, r, i, s, o, u, a) {
            var f = (i - e) * a / u + e;
            var l = (s - n) * a / u + n;
            var c = (o - r) * a / u + r;
            return t.Color.getColor(f, l, c)
        },
        getRandomColor: function(e, n, r) {
            if (typeof e === "undefined") {
                e = 0
            }
            if (typeof n === "undefined") {
                n = 255
            }
            if (typeof r === "undefined") {
                r = 255
            }
            if (n > 255 || e > n) {
                return t.Color.getColor(255, 255, 255)
            }
            var i = e + Math.round(Math.random() * (n - e));
            var s = e + Math.round(Math.random() * (n - e));
            var o = e + Math.round(Math.random() * (n - e));
            return t.Color.getColor32(r, i, s, o)
        },
        getRGB: function(e) {
            if (e > 16777215) {
                return {
                    alpha: e >>> 24,
                    red: e >> 16 & 255,
                    green: e >> 8 & 255,
                    blue: e & 255,
                    a: e >>> 24,
                    r: e >> 16 & 255,
                    g: e >> 8 & 255,
                    b: e & 255
                }
            } else {
                return {
                    alpha: 255,
                    red: e >> 16 & 255,
                    green: e >> 8 & 255,
                    blue: e & 255,
                    a: 255,
                    r: e >> 16 & 255,
                    g: e >> 8 & 255,
                    b: e & 255
                }
            }
        },
        getWebRGB: function(e) {
            var n = t.Color.getRGB(e);
            return "rgba(" + n.r.toString() + "," + n.g.toString() + "," + n.b.toString() + "," + n.a.toString() + ")"
        },
        getAlpha: function(e) {
            return e >>> 24
        },
        getAlphaFloat: function(e) {
            return (e >>> 24) / 255
        },
        getRed: function(e) {
            return e >> 16 & 255
        },
        getGreen: function(e) {
            return e >> 8 & 255
        },
        getBlue: function(e) {
            return e & 255
        },
        getColorInfo: function(e) {
            var n = t.Color.getRGB(e);
            var r = t.Color.RGBtoHexstring(e) + "\n";
            r = r.concat("Alpha: " + n.alpha + " Red: " + n.red + " Green: " + n.green + " Blue: " + n.blue) + "\n";
            return r
        },
        RGBtoHexstring: function(e) {
            var n = t.Color.getRGB(e);
            return "0x" + t.Color.colorToHexstring(n.alpha) + t.Color.colorToHexstring(n.red) + t.Color.colorToHexstring(n.green) + t.Color.colorToHexstring(n.blue)
        },
        RGBtoWebstring: function(e) {
            var n = t.Color.getRGB(e);
            return "#" + t.Color.colorToHexstring(n.red) + t.Color.colorToHexstring(n.green) + t.Color.colorToHexstring(n.blue)
        },
        colorToHexstring: function(e) {
            var t = "0123456789ABCDEF";
            var n = e % 16;
            var r = (e - n) / 16;
            var i = t.charAt(r) + t.charAt(n);
            return i
        }
    };
    t.Physics = function(e, t) {
        t = t || {};
        this.game = e;
        this.config = t;
        this.arcade = null;
        this.p2 = null;
        this.ninja = null;
        this.box2d = null;
        this.chipmunk = null;
        this.parseConfig()
    };
    t.Physics.ARCADE = 0;
    t.Physics.P2JS = 1;
    t.Physics.NINJA = 2;
    t.Physics.BOX2D = 3;
    t.Physics.CHIPMUNK = 5;
    t.Physics.prototype = {
        parseConfig: function() {
            if ((!this.config.hasOwnProperty("arcade") || this.config["arcade"] === true) && t.Physics.hasOwnProperty("Arcade")) {
                this.arcade = new t.Physics.Arcade(this.game);
                this.game.time.deltaCap = .2
            }
            if (this.config.hasOwnProperty("ninja") && this.config["ninja"] === true && t.Physics.hasOwnProperty("Ninja")) {
                this.ninja = new t.Physics.Ninja(this.game)
            }
            if (this.config.hasOwnProperty("p2") && this.config["p2"] === true && t.Physics.hasOwnProperty("P2")) {
                this.p2 = new t.Physics.P2(this.game, this.config)
            }
        },
        startSystem: function(e) {
            if (e === t.Physics.ARCADE) {
                this.arcade = new t.Physics.Arcade(this.game)
            } else if (e === t.Physics.P2JS) {
                this.p2 = new t.Physics.P2(this.game, this.config)
            }
            if (e === t.Physics.NINJA) {
                this.ninja = new t.Physics.Ninja(this.game)
            } else if (e === t.Physics.BOX2D && this.box2d === null) {
                throw new Error("The Box2D physics system has not been implemented yet.")
            } else if (e === t.Physics.CHIPMUNK && this.chipmunk === null) {
                throw new Error("The Chipmunk physics system has not been implemented yet.")
            }
        },
        enable: function(e, n, r) {
            if (typeof n === "undefined") {
                n = t.Physics.ARCADE
            }
            if (typeof r === "undefined") {
                r = false
            }
            if (n === t.Physics.ARCADE) {
                this.arcade.enable(e)
            } else if (n === t.Physics.P2JS && this.p2) {
                this.p2.enable(e, r)
            } else if (n === t.Physics.NINJA && this.ninja) {
                this.ninja.enableAABB(e)
            }
        },
        preUpdate: function() {
            if (this.p2) {
                this.p2.preUpdate()
            }
        },
        update: function() {
            if (this.p2) {
                this.p2.update()
            }
        },
        setBoundsToWorld: function() {
            if (this.arcade) {
                this.arcade.setBoundsToWorld()
            }
            if (this.ninja) {
                this.ninja.setBoundsToWorld()
            }
            if (this.p2) {
                this.p2.setBoundsToWorld()
            }
        },
        clear: function() {
            if (this.p2) {
                this.p2.clear()
            }
        },
        destroy: function() {
            if (this.p2) {
                this.p2.destroy()
            }
            this.arcade = null;
            this.ninja = null;
            this.p2 = null
        }
    };
    t.Physics.prototype.constructor = t.Physics;
    t.Physics.Arcade = function(e) {
        this.game = e;
        this.gravity = new t.Point;
        this.bounds = new t.Rectangle(0, 0, e.world.width, e.world.height);
        this.checkCollision = {
            up: true,
            down: true,
            left: true,
            right: true
        };
        this.maxObjects = 10;
        this.maxLevels = 4;
        this.OVERLAP_BIAS = 4;
        this.TILE_BIAS = 16;
        this.forceX = false;
        this.quadTree = new t.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);
        this._overlap = 0;
        this._maxOverlap = 0;
        this._velocity1 = 0;
        this._velocity2 = 0;
        this._newVelocity1 = 0;
        this._newVelocity2 = 0;
        this._average = 0;
        this._mapData = [];
        this._result = false;
        this._total = 0;
        this._angle = 0;
        this._dx = 0;
        this._dy = 0
    };
    t.Physics.Arcade.prototype.constructor = t.Physics.Arcade;
    t.Physics.Arcade.prototype = {
        setBounds: function(e, t, n, r) {
            this.bounds.setTo(e, t, n, r)
        },
        setBoundsToWorld: function() {
            this.bounds.setTo(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height)
        },
        enable: function(e, n) {
            if (typeof n === "undefined") {
                n = true
            }
            var r = 1;
            if (Array.isArray(e)) {
                r = e.length;
                while (r--) {
                    if (e[r] instanceof t.Group) {
                        this.enable(e[r].children, n)
                    } else {
                        this.enableBody(e[r]);
                        if (n && e[r].hasOwnProperty("children") && e[r].children.length > 0) {
                            this.enable(e[r], true)
                        }
                    }
                }
            } else {
                if (e instanceof t.Group) {
                    this.enable(e.children, n)
                } else {
                    this.enableBody(e);
                    if (n && e.hasOwnProperty("children") && e.children.length > 0) {
                        this.enable(e.children, true)
                    }
                }
            }
        },
        enableBody: function(e) {
            if (e.hasOwnProperty("body") && e.body === null) {
                e.body = new t.Physics.Arcade.Body(e)
            }
        },
        updateMotion: function(e) {
            this._velocityDelta = this.computeVelocity(0, e, e.angularVelocity, e.angularAcceleration, e.angularDrag, e.maxAngular) - e.angularVelocity;
            e.angularVelocity += this._velocityDelta;
            e.rotation += e.angularVelocity * this.game.time.physicsElapsed;
            e.velocity.x = this.computeVelocity(1, e, e.velocity.x, e.acceleration.x, e.drag.x, e.maxVelocity.x);
            e.velocity.y = this.computeVelocity(2, e, e.velocity.y, e.acceleration.y, e.drag.y, e.maxVelocity.y)
        },
        computeVelocity: function(e, t, n, r, i, s) {
            s = s || 1e4;
            if (e == 1 && t.allowGravity) {
                n += (this.gravity.x + t.gravity.x) * this.game.time.physicsElapsed
            } else if (e == 2 && t.allowGravity) {
                n += (this.gravity.y + t.gravity.y) * this.game.time.physicsElapsed
            }
            if (r) {
                n += r * this.game.time.physicsElapsed
            } else if (i) {
                this._drag = i * this.game.time.physicsElapsed;
                if (n - this._drag > 0) {
                    n -= this._drag
                } else if (n + this._drag < 0) {
                    n += this._drag
                } else {
                    n = 0
                }
            }
            if (n > s) {
                n = s
            } else if (n < -s) {
                n = -s
            }
            return n
        },
        overlap: function(e, t, n, r, i) {
            n = n || null;
            r = r || null;
            i = i || n;
            this._result = false;
            this._total = 0;
            if (Array.isArray(t)) {
                for (var s = 0, o = t.length; s < o; s++) {
                    this.collideHandler(e, t[s], n, r, i, true)
                }
            } else {
                this.collideHandler(e, t, n, r, i, true)
            }
            return this._total > 0
        },
        collide: function(e, t, n, r, i) {
            n = n || null;
            r = r || null;
            i = i || n;
            this._result = false;
            this._total = 0;
            if (Array.isArray(t)) {
                for (var s = 0, o = t.length; s < o; s++) {
                    this.collideHandler(e, t[s], n, r, i, false)
                }
            } else {
                this.collideHandler(e, t, n, r, i, false)
            }
            return this._total > 0
        },
        collideHandler: function(e, n, r, i, s, o) {
            if (typeof n === "undefined" && (e.type === t.GROUP || e.type === t.EMITTER)) {
                this.collideGroupVsSelf(e, r, i, s, o);
                return
            }
            if (e && n && e.exists && n.exists) {
                if (e.type == t.SPRITE || e.type == t.TILESPRITE) {
                    if (n.type == t.SPRITE || n.type == t.TILESPRITE) {
                        this.collideSpriteVsSprite(e, n, r, i, s, o)
                    } else if (n.type == t.GROUP || n.type == t.EMITTER) {
                        this.collideSpriteVsGroup(e, n, r, i, s, o)
                    } else if (n.type == t.TILEMAPLAYER) {
                        this.collideSpriteVsTilemapLayer(e, n, r, i, s)
                    }
                } else if (e.type == t.GROUP) {
                    if (n.type == t.SPRITE || n.type == t.TILESPRITE) {
                        this.collideSpriteVsGroup(n, e, r, i, s, o)
                    } else if (n.type == t.GROUP || n.type == t.EMITTER) {
                        this.collideGroupVsGroup(e, n, r, i, s, o)
                    } else if (n.type == t.TILEMAPLAYER) {
                        this.collideGroupVsTilemapLayer(e, n, r, i, s)
                    }
                } else if (e.type == t.TILEMAPLAYER) {
                    if (n.type == t.SPRITE || n.type == t.TILESPRITE) {
                        this.collideSpriteVsTilemapLayer(n, e, r, i, s)
                    } else if (n.type == t.GROUP || n.type == t.EMITTER) {
                        this.collideGroupVsTilemapLayer(n, e, r, i, s)
                    }
                } else if (e.type == t.EMITTER) {
                    if (n.type == t.SPRITE || n.type == t.TILESPRITE) {
                        this.collideSpriteVsGroup(n, e, r, i, s, o)
                    } else if (n.type == t.GROUP || n.type == t.EMITTER) {
                        this.collideGroupVsGroup(e, n, r, i, s, o)
                    } else if (n.type == t.TILEMAPLAYER) {
                        this.collideGroupVsTilemapLayer(e, n, r, i, s)
                    }
                }
            }
        },
        collideSpriteVsSprite: function(e, t, n, r, i, s) {
            if (!e.body || !t.body) {
                return false
            }
            if (this.separate(e.body, t.body, r, i, s)) {
                if (n) {
                    n.call(i, e, t)
                }
                this._total++
            }
            return true
        },
        collideSpriteVsGroup: function(e, t, n, r, i, s) {
            if (t.length === 0 || !e.body) {
                return
            }
            this.quadTree.clear();
            this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);
            this.quadTree.populate(t);
            this._potentials = this.quadTree.retrieve(e);
            for (var o = 0, u = this._potentials.length; o < u; o++) {
                if (this.separate(e.body, this._potentials[o], r, i, s)) {
                    if (n) {
                        n.call(i, e, this._potentials[o].sprite)
                    }
                    this._total++
                }
            }
        },
        collideGroupVsSelf: function(e, t, n, r, i) {
            if (e.length === 0) {
                return
            }
            var s = e.children.length;
            for (var o = 0; o < s; o++) {
                for (var u = o + 1; u <= s; u++) {
                    if (e.children[o] && e.children[u] && e.children[o].exists && e.children[u].exists) {
                        this.collideSpriteVsSprite(e.children[o], e.children[u], t, n, r, i)
                    }
                }
            }
        },
        collideGroupVsGroup: function(e, t, n, r, i, s) {
            if (e.length === 0 || t.length === 0) {
                return
            }
            for (var o = 0, u = e.children.length; o < u; o++) {
                if (e.children[o].exists) {
                    this.collideSpriteVsGroup(e.children[o], t, n, r, i, s)
                }
            }
        },
        collideSpriteVsTilemapLayer: function(e, t, n, r, i) {
            if (!e.body) {
                return
            }
            this._mapData = t.getTiles(e.body.position.x - e.body.tilePadding.x, e.body.position.y - e.body.tilePadding.y, e.body.width + e.body.tilePadding.x, e.body.height + e.body.tilePadding.y, false, false);
            if (this._mapData.length === 0) {
                return
            }
            for (var s = 0; s < this._mapData.length; s++) {
                if (this.separateTile(s, e.body, this._mapData[s])) {
                    if (r) {
                        if (r.call(i, e, this._mapData[s])) {
                            this._total++;
                            if (n) {
                                n.call(i, e, this._mapData[s])
                            }
                        }
                    } else {
                        this._total++;
                        if (n) {
                            n.call(i, e, this._mapData[s])
                        }
                    }
                }
            }
        },
        collideGroupVsTilemapLayer: function(e, t, n, r, i) {
            if (e.length === 0) {
                return
            }
            for (var s = 0, o = e.children.length; s < o; s++) {
                if (e.children[s].exists) {
                    this.collideSpriteVsTilemapLayer(e.children[s], t, n, r, i)
                }
            }
        },
        separate: function(e, t, n, r, i) {
            if (!this.intersects(e, t)) {
                return false
            }
            if (n && n.call(r, e.sprite, t.sprite) === false) {
                return false
            }
            if (i) {
                return true
            }
            if (this.forceX || Math.abs(this.gravity.y + e.gravity.y) < Math.abs(this.gravity.x + e.gravity.x)) {
                this._result = this.separateX(e, t, i) || this.separateY(e, t, i)
            } else {
                this._result = this.separateY(e, t, i) || this.separateX(e, t, i)
            }
            return this._result
        },
        intersects: function(e, t) {
            if (e.right <= t.position.x) {
                return false
            }
            if (e.bottom <= t.position.y) {
                return false
            }
            if (e.position.x >= t.right) {
                return false
            }
            if (e.position.y >= t.bottom) {
                return false
            }
            return true
        },
        separateX: function(e, t, n) {
            if (e.immovable && t.immovable) {
                return false
            }
            this._overlap = 0;
            if (this.intersects(e, t)) {
                this._maxOverlap = e.deltaAbsX() + t.deltaAbsX() + this.OVERLAP_BIAS;
                if (e.deltaX() === 0 && t.deltaX() === 0) {
                    e.embedded = true;
                    t.embedded = true
                } else if (e.deltaX() > t.deltaX()) {
                    this._overlap = e.right - t.x;
                    if (this._overlap > this._maxOverlap || e.checkCollision.right === false || t.checkCollision.left === false) {
                        this._overlap = 0
                    } else {
                        e.touching.none = false;
                        e.touching.right = true;
                        t.touching.none = false;
                        t.touching.left = true
                    }
                } else if (e.deltaX() < t.deltaX()) {
                    this._overlap = e.x - t.width - t.x;
                    if (-this._overlap > this._maxOverlap || e.checkCollision.left === false || t.checkCollision.right === false) {
                        this._overlap = 0
                    } else {
                        e.touching.none = false;
                        e.touching.left = true;
                        t.touching.none = false;
                        t.touching.right = true
                    }
                }
                if (this._overlap !== 0) {
                    e.overlapX = this._overlap;
                    t.overlapX = this._overlap;
                    if (n || e.customSeparateX || t.customSeparateX) {
                        return true
                    }
                    this._velocity1 = e.velocity.x;
                    this._velocity2 = t.velocity.x;
                    if (!e.immovable && !t.immovable) {
                        this._overlap *= .5;
                        e.x = e.x - this._overlap;
                        t.x += this._overlap;
                        this._newVelocity1 = Math.sqrt(this._velocity2 * this._velocity2 * t.mass / e.mass) * (this._velocity2 > 0 ? 1 : -1);
                        this._newVelocity2 = Math.sqrt(this._velocity1 * this._velocity1 * e.mass / t.mass) * (this._velocity1 > 0 ? 1 : -1);
                        this._average = (this._newVelocity1 + this._newVelocity2) * .5;
                        this._newVelocity1 -= this._average;
                        this._newVelocity2 -= this._average;
                        e.velocity.x = this._average + this._newVelocity1 * e.bounce.x;
                        t.velocity.x = this._average + this._newVelocity2 * t.bounce.x
                    } else if (!e.immovable) {
                        e.x = e.x - this._overlap;
                        e.velocity.x = this._velocity2 - this._velocity1 * e.bounce.x
                    } else if (!t.immovable) {
                        t.x += this._overlap;
                        t.velocity.x = this._velocity1 - this._velocity2 * t.bounce.x
                    }
                    return true
                }
            }
            return false
        },
        separateY: function(e, t, n) {
            if (e.immovable && t.immovable) {
                return false
            }
            this._overlap = 0;
            if (this.intersects(e, t)) {
                this._maxOverlap = e.deltaAbsY() + t.deltaAbsY() + this.OVERLAP_BIAS;
                if (e.deltaY() === 0 && t.deltaY() === 0) {
                    e.embedded = true;
                    t.embedded = true
                } else if (e.deltaY() > t.deltaY()) {
                    this._overlap = e.bottom - t.y;
                    if (this._overlap > this._maxOverlap || e.checkCollision.down === false || t.checkCollision.up === false) {
                        this._overlap = 0
                    } else {
                        e.touching.none = false;
                        e.touching.down = true;
                        t.touching.none = false;
                        t.touching.up = true
                    }
                } else if (e.deltaY() < t.deltaY()) {
                    this._overlap = e.y - t.bottom;
                    if (-this._overlap > this._maxOverlap || e.checkCollision.up === false || t.checkCollision.down === false) {
                        this._overlap = 0
                    } else {
                        e.touching.none = false;
                        e.touching.up = true;
                        t.touching.none = false;
                        t.touching.down = true
                    }
                }
                if (this._overlap !== 0) {
                    e.overlapY = this._overlap;
                    t.overlapY = this._overlap;
                    if (n || e.customSeparateY || t.customSeparateY) {
                        return true
                    }
                    this._velocity1 = e.velocity.y;
                    this._velocity2 = t.velocity.y;
                    if (!e.immovable && !t.immovable) {
                        this._overlap *= .5;
                        e.y = e.y - this._overlap;
                        t.y += this._overlap;
                        this._newVelocity1 = Math.sqrt(this._velocity2 * this._velocity2 * t.mass / e.mass) * (this._velocity2 > 0 ? 1 : -1);
                        this._newVelocity2 = Math.sqrt(this._velocity1 * this._velocity1 * e.mass / t.mass) * (this._velocity1 > 0 ? 1 : -1);
                        this._average = (this._newVelocity1 + this._newVelocity2) * .5;
                        this._newVelocity1 -= this._average;
                        this._newVelocity2 -= this._average;
                        e.velocity.y = this._average + this._newVelocity1 * e.bounce.y;
                        t.velocity.y = this._average + this._newVelocity2 * t.bounce.y
                    } else if (!e.immovable) {
                        e.y = e.y - this._overlap;
                        e.velocity.y = this._velocity2 - this._velocity1 * e.bounce.y;
                        if (t.moves) {
                            e.x += t.x - t.prev.x
                        }
                    } else if (!t.immovable) {
                        t.y += this._overlap;
                        t.velocity.y = this._velocity1 - this._velocity2 * t.bounce.y;
                        if (e.moves) {
                            t.x += e.x - e.prev.x
                        }
                    }
                    return true
                }
            }
            return false
        },
        separateTile: function(e, t, n) {
            if (!n.intersects(t.position.x, t.position.y, t.right, t.bottom)) {
                return false
            }
            if (n.collisionCallback && !n.collisionCallback.call(n.collisionCallbackContext, t.sprite, n)) {
                return false
            } else if (n.layer.callbacks[n.index] && !n.layer.callbacks[n.index].callback.call(n.layer.callbacks[n.index].callbackContext, t.sprite, n)) {
                return false
            }
            if (!n.faceLeft && !n.faceRight && !n.faceTop && !n.faceBottom) {
                return false
            }
            var r = 0;
            var i = 0;
            var s = 0;
            var o = 1;
            if (t.deltaAbsX() > t.deltaAbsY()) {
                s = -1
            } else if (t.deltaAbsX() < t.deltaAbsY()) {
                o = -1
            }
            if (t.deltaX() !== 0 && t.deltaY() !== 0 && (n.faceLeft || n.faceRight) && (n.faceTop || n.faceBottom)) {
                s = Math.min(Math.abs(t.position.x - n.right), Math.abs(t.right - n.left));
                o = Math.min(Math.abs(t.position.y - n.bottom), Math.abs(t.bottom - n.top))
            }
            if (s < o) {
                if (n.faceLeft || n.faceRight) {
                    r = this.tileCheckX(t, n);
                    if (r !== 0 && !n.intersects(t.position.x, t.position.y, t.right, t.bottom)) {
                        return true
                    }
                }
                if (n.faceTop || n.faceBottom) {
                    i = this.tileCheckY(t, n)
                }
            } else {
                if (n.faceTop || n.faceBottom) {
                    i = this.tileCheckY(t, n);
                    if (i !== 0 && !n.intersects(t.position.x, t.position.y, t.right, t.bottom)) {
                        return true
                    }
                }
                if (n.faceLeft || n.faceRight) {
                    r = this.tileCheckX(t, n)
                }
            }
            return r !== 0 || i !== 0
        },
        tileCheckX: function(e, t) {
            var n = 0;
            if (e.deltaX() < 0 && !e.blocked.left && t.collideRight && e.checkCollision.left) {
                if (t.faceRight && e.x < t.right) {
                    n = e.x - t.right;
                    if (n < -this.TILE_BIAS) {
                        n = 0
                    }
                }
            } else if (e.deltaX() > 0 && !e.blocked.right && t.collideLeft && e.checkCollision.right) {
                if (t.faceLeft && e.right > t.left) {
                    n = e.right - t.left;
                    if (n > this.TILE_BIAS) {
                        n = 0
                    }
                }
            }
            if (n !== 0) {
                this.processTileSeparationX(e, n)
            }
            return n
        },
        tileCheckY: function(e, t) {
            var n = 0;
            if (e.deltaY() < 0 && !e.blocked.up && t.collideDown && e.checkCollision.up) {
                if (t.faceBottom && e.y < t.bottom) {
                    n = e.y - t.bottom;
                    if (n < -this.TILE_BIAS) {
                        n = 0
                    }
                }
            } else if (e.deltaY() > 0 && !e.blocked.down && t.collideUp && e.checkCollision.down) {
                if (t.faceTop && e.bottom > t.top) {
                    n = e.bottom - t.top;
                    if (n > this.TILE_BIAS) {
                        n = 0
                    }
                }
            }
            if (n !== 0) {
                this.processTileSeparationY(e, n)
            }
            return n
        },
        processTileSeparationX: function(e, t) {
            if (t < 0) {
                e.blocked.left = true
            } else if (t > 0) {
                e.blocked.right = true
            }
            e.position.x -= t;
            if (e.bounce.x === 0) {
                e.velocity.x = 0
            } else {
                e.velocity.x = -e.velocity.x * e.bounce.x
            }
        },
        processTileSeparationY: function(e, t) {
            if (t < 0) {
                e.blocked.up = true
            } else if (t > 0) {
                e.blocked.down = true
            }
            e.position.y -= t;
            if (e.bounce.y === 0) {
                e.velocity.y = 0
            } else {
                e.velocity.y = -e.velocity.y * e.bounce.y
            }
        },
        getObjectsUnderPointer: function(e, n, r, i) {
            if (n.length === 0 || !e.exists) {
                return
            }
            this.quadTree.clear();
            this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);
            this.quadTree.populate(n);
            var s = new t.Rectangle(e.x, e.y, 1, 1);
            var o = [];
            this._potentials = this.quadTree.retrieve(s);
            for (var u = 0, a = this._potentials.length; u < a; u++) {
                if (this._potentials[u].hitTest(e.x, e.y)) {
                    if (r) {
                        r.call(i, e, this._potentials[u].sprite)
                    }
                    o.push(this._potentials[u].sprite)
                }
            }
            return o
        },
        moveToObject: function(e, t, n, r) {
            if (typeof n === "undefined") {
                n = 60
            }
            if (typeof r === "undefined") {
                r = 0
            }
            this._angle = Math.atan2(t.y - e.y, t.x - e.x);
            if (r > 0) {
                n = this.distanceBetween(e, t) / (r / 1e3)
            }
            e.body.velocity.x = Math.cos(this._angle) * n;
            e.body.velocity.y = Math.sin(this._angle) * n;
            return this._angle
        },
        moveToPointer: function(e, t, n, r) {
            if (typeof t === "undefined") {
                t = 60
            }
            n = n || this.game.input.activePointer;
            if (typeof r === "undefined") {
                r = 0
            }
            this._angle = this.angleToPointer(e, n);
            if (r > 0) {
                t = this.distanceToPointer(e, n) / (r / 1e3)
            }
            e.body.velocity.x = Math.cos(this._angle) * t;
            e.body.velocity.y = Math.sin(this._angle) * t;
            return this._angle
        },
        moveToXY: function(e, t, n, r, i) {
            if (typeof r === "undefined") {
                r = 60
            }
            if (typeof i === "undefined") {
                i = 0
            }
            this._angle = Math.atan2(n - e.y, t - e.x);
            if (i > 0) {
                r = this.distanceToXY(e, t, n) / (i / 1e3)
            }
            e.body.velocity.x = Math.cos(this._angle) * r;
            e.body.velocity.y = Math.sin(this._angle) * r;
            return this._angle
        },
        velocityFromAngle: function(e, n, r) {
            if (typeof n === "undefined") {
                n = 60
            }
            r = r || new t.Point;
            return r.setTo(Math.cos(this.game.math.degToRad(e)) * n, Math.sin(this.game.math.degToRad(e)) * n)
        },
        velocityFromRotation: function(e, n, r) {
            if (typeof n === "undefined") {
                n = 60
            }
            r = r || new t.Point;
            return r.setTo(Math.cos(e) * n, Math.sin(e) * n)
        },
        accelerationFromRotation: function(e, n, r) {
            if (typeof n === "undefined") {
                n = 60
            }
            r = r || new t.Point;
            return r.setTo(Math.cos(e) * n, Math.sin(e) * n)
        },
        accelerateToObject: function(e, t, n, r, i) {
            if (typeof n === "undefined") {
                n = 60
            }
            if (typeof r === "undefined") {
                r = 1e3
            }
            if (typeof i === "undefined") {
                i = 1e3
            }
            this._angle = this.angleBetween(e, t);
            e.body.acceleration.setTo(Math.cos(this._angle) * n, Math.sin(this._angle) * n);
            e.body.maxVelocity.setTo(r, i);
            return this._angle
        },
        accelerateToPointer: function(e, t, n, r, i) {
            if (typeof n === "undefined") {
                n = 60
            }
            if (typeof t === "undefined") {
                t = this.game.input.activePointer
            }
            if (typeof r === "undefined") {
                r = 1e3
            }
            if (typeof i === "undefined") {
                i = 1e3
            }
            this._angle = this.angleToPointer(e, t);
            e.body.acceleration.setTo(Math.cos(this._angle) * n, Math.sin(this._angle) * n);
            e.body.maxVelocity.setTo(r, i);
            return this._angle
        },
        accelerateToXY: function(e, t, n, r, i, s) {
            if (typeof r === "undefined") {
                r = 60
            }
            if (typeof i === "undefined") {
                i = 1e3
            }
            if (typeof s === "undefined") {
                s = 1e3
            }
            this._angle = this.angleToXY(e, t, n);
            e.body.acceleration.setTo(Math.cos(this._angle) * r, Math.sin(this._angle) * r);
            e.body.maxVelocity.setTo(i, s);
            return this._angle
        },
        distanceBetween: function(e, t) {
            this._dx = e.x - t.x;
            this._dy = e.y - t.y;
            return Math.sqrt(this._dx * this._dx + this._dy * this._dy)
        },
        distanceToXY: function(e, t, n) {
            this._dx = e.x - t;
            this._dy = e.y - n;
            return Math.sqrt(this._dx * this._dx + this._dy * this._dy)
        },
        distanceToPointer: function(e, t) {
            t = t || this.game.input.activePointer;
            this._dx = e.x - t.x;
            this._dy = e.y - t.y;
            return Math.sqrt(this._dx * this._dx + this._dy * this._dy)
        },
        angleBetween: function(e, t) {
            this._dx = t.x - e.x;
            this._dy = t.y - e.y;
            return Math.atan2(this._dy, this._dx)
        },
        angleToXY: function(e, t, n) {
            this._dx = t - e.x;
            this._dy = n - e.y;
            return Math.atan2(this._dy, this._dx)
        },
        angleToPointer: function(e, t) {
            t = t || this.game.input.activePointer;
            this._dx = t.worldX - e.x;
            this._dy = t.worldY - e.y;
            return Math.atan2(this._dy, this._dx)
        }
    };
    t.Physics.Arcade.Body = function(e) {
        this.sprite = e;
        this.game = e.game;
        this.type = t.Physics.ARCADE;
        this.offset = new t.Point;
        this.position = new t.Point(e.x, e.y);
        this.prev = new t.Point(this.position.x, this.position.y);
        this.allowRotation = true;
        this.rotation = e.rotation;
        this.preRotation = e.rotation;
        this.sourceWidth = e.texture.frame.width;
        this.sourceHeight = e.texture.frame.height;
        this.width = e.width;
        this.height = e.height;
        this.halfWidth = Math.abs(e.width / 2);
        this.halfHeight = Math.abs(e.height / 2);
        this.center = new t.Point(e.x + this.halfWidth, e.y + this.halfHeight);
        this.velocity = new t.Point;
        this.newVelocity = new t.Point(0, 0);
        this.deltaMax = new t.Point(0, 0);
        this.acceleration = new t.Point;
        this.drag = new t.Point;
        this.allowGravity = true;
        this.gravity = new t.Point(0, 0);
        this.bounce = new t.Point;
        this.maxVelocity = new t.Point(1e4, 1e4);
        this.angularVelocity = 0;
        this.angularAcceleration = 0;
        this.angularDrag = 0;
        this.maxAngular = 1e3;
        this.mass = 1;
        this.angle = 0;
        this.speed = 0;
        this.facing = t.NONE;
        this.immovable = false;
        this.moves = true;
        this.customSeparateX = false;
        this.customSeparateY = false;
        this.overlapX = 0;
        this.overlapY = 0;
        this.embedded = false;
        this.collideWorldBounds = false;
        this.checkCollision = {
            none: false,
            any: true,
            up: true,
            down: true,
            left: true,
            right: true
        };
        this.touching = {
            none: true,
            up: false,
            down: false,
            left: false,
            right: false
        };
        this.wasTouching = {
            none: true,
            up: false,
            down: false,
            left: false,
            right: false
        };
        this.blocked = {
            up: false,
            down: false,
            left: false,
            right: false
        };
        this.tilePadding = new t.Point;
        this.phase = 0;
        this._reset = true;
        this._sx = e.scale.x;
        this._sy = e.scale.y;
        this._dx = 0;
        this._dy = 0
    };
    t.Physics.Arcade.Body.prototype = {
        updateBounds: function() {
            var e = Math.abs(this.sprite.scale.x);
            var t = Math.abs(this.sprite.scale.y);
            if (e !== this._sx || t !== this._sy) {
                this.width = this.sourceWidth * e;
                this.height = this.sourceHeight * t;
                this.halfWidth = Math.floor(this.width / 2);
                this.halfHeight = Math.floor(this.height / 2);
                this._sx = e;
                this._sy = t;
                this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
                this._reset = true
            }
        },
        preUpdate: function() {
            this.phase = 1;
            this.wasTouching.none = this.touching.none;
            this.wasTouching.up = this.touching.up;
            this.wasTouching.down = this.touching.down;
            this.wasTouching.left = this.touching.left;
            this.wasTouching.right = this.touching.right;
            this.touching.none = true;
            this.touching.up = false;
            this.touching.down = false;
            this.touching.left = false;
            this.touching.right = false;
            this.blocked.up = false;
            this.blocked.down = false;
            this.blocked.left = false;
            this.blocked.right = false;
            this.embedded = false;
            this.updateBounds();
            this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.width + this.offset.x;
            this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.height + this.offset.y;
            this.rotation = this.sprite.angle;
            this.preRotation = this.rotation;
            if (this._reset || this.sprite._cache[4] === 1) {
                this.prev.x = this.position.x;
                this.prev.y = this.position.y
            }
            if (this.moves) {
                this.game.physics.arcade.updateMotion(this);
                this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed);
                this.position.x += this.newVelocity.x;
                this.position.y += this.newVelocity.y;
                if (this.position.x !== this.prev.x || this.position.y !== this.prev.y) {
                    this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
                    this.angle = Math.atan2(this.velocity.y, this.velocity.x)
                }
                if (this.collideWorldBounds) {
                    this.checkWorldBounds()
                }
            }
            this._dx = this.deltaX();
            this._dy = this.deltaY();
            this._reset = false
        },
        postUpdate: function() {
            if (this.phase === 2) {
                return
            }
            this.phase = 2;
            if (this.deltaX() < 0) {
                this.facing = t.LEFT
            } else if (this.deltaX() > 0) {
                this.facing = t.RIGHT
            }
            if (this.deltaY() < 0) {
                this.facing = t.UP
            } else if (this.deltaY() > 0) {
                this.facing = t.DOWN
            }
            if (this.moves) {
                this._dx = this.deltaX();
                this._dy = this.deltaY();
                if (this.deltaMax.x !== 0 && this._dx !== 0) {
                    if (this._dx < 0 && this._dx < -this.deltaMax.x) {
                        this._dx = -this.deltaMax.x
                    } else if (this._dx > 0 && this._dx > this.deltaMax.x) {
                        this._dx = this.deltaMax.x
                    }
                }
                if (this.deltaMax.y !== 0 && this._dy !== 0) {
                    if (this._dy < 0 && this._dy < -this.deltaMax.y) {
                        this._dy = -this.deltaMax.y
                    } else if (this._dy > 0 && this._dy > this.deltaMax.y) {
                        this._dy = this.deltaMax.y
                    }
                }
                this.sprite.x += this._dx;
                this.sprite.y += this._dy
            }
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
            if (this.allowRotation) {
                this.sprite.angle += this.deltaZ()
            }
            this.prev.x = this.position.x;
            this.prev.y = this.position.y
        },
        destroy: function() {
            this.sprite = null
        },
        checkWorldBounds: function() {
            if (this.position.x < this.game.physics.arcade.bounds.x && this.game.physics.arcade.checkCollision.left) {
                this.position.x = this.game.physics.arcade.bounds.x;
                this.velocity.x *= -this.bounce.x;
                this.blocked.left = true
            } else if (this.right > this.game.physics.arcade.bounds.right && this.game.physics.arcade.checkCollision.right) {
                this.position.x = this.game.physics.arcade.bounds.right - this.width;
                this.velocity.x *= -this.bounce.x;
                this.blocked.right = true
            }
            if (this.position.y < this.game.physics.arcade.bounds.y && this.game.physics.arcade.checkCollision.up) {
                this.position.y = this.game.physics.arcade.bounds.y;
                this.velocity.y *= -this.bounce.y;
                this.blocked.up = true
            } else if (this.bottom > this.game.physics.arcade.bounds.bottom && this.game.physics.arcade.checkCollision.down) {
                this.position.y = this.game.physics.arcade.bounds.bottom - this.height;
                this.velocity.y *= -this.bounce.y;
                this.blocked.down = true
            }
        },
        setSize: function(e, t, n, r) {
            n = n || this.offset.x;
            r = r || this.offset.y;
            this.sourceWidth = e;
            this.sourceHeight = t;
            this.width = this.sourceWidth * this._sx;
            this.height = this.sourceHeight * this._sy;
            this.halfWidth = Math.floor(this.width / 2);
            this.halfHeight = Math.floor(this.height / 2);
            this.offset.setTo(n, r);
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
        },
        reset: function(e, t) {
            this.velocity.set(0);
            this.acceleration.set(0);
            this.angularVelocity = 0;
            this.angularAcceleration = 0;
            this.position.x = e - this.sprite.anchor.x * this.width + this.offset.x;
            this.position.y = t - this.sprite.anchor.y * this.height + this.offset.y;
            this.prev.x = this.position.x;
            this.prev.y = this.position.y;
            this.rotation = this.sprite.angle;
            this.preRotation = this.rotation;
            this._sx = this.sprite.scale.x;
            this._sy = this.sprite.scale.y;
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
        },
        hitTest: function(e, n) {
            return t.Rectangle.contains(this, e, n)
        },
        onFloor: function() {
            return this.blocked.down
        },
        onWall: function() {
            return this.blocked.left || this.blocked.right
        },
        deltaAbsX: function() {
            return this.deltaX() > 0 ? this.deltaX() : -this.deltaX()
        },
        deltaAbsY: function() {
            return this.deltaY() > 0 ? this.deltaY() : -this.deltaY()
        },
        deltaX: function() {
            return this.position.x - this.prev.x
        },
        deltaY: function() {
            return this.position.y - this.prev.y
        },
        deltaZ: function() {
            return this.rotation - this.preRotation
        }
    };
    Object.defineProperty(t.Physics.Arcade.Body.prototype, "bottom", {
        get: function() {
            return this.position.y + this.height
        }
    });
    Object.defineProperty(t.Physics.Arcade.Body.prototype, "right", {
        get: function() {
            return this.position.x + this.width
        }
    });
    Object.defineProperty(t.Physics.Arcade.Body.prototype, "x", {
        get: function() {
            return this.position.x
        },
        set: function(e) {
            this.position.x = e
        }
    });
    Object.defineProperty(t.Physics.Arcade.Body.prototype, "y", {
        get: function() {
            return this.position.y
        },
        set: function(e) {
            this.position.y = e
        }
    });
    t.Physics.Arcade.Body.render = function(e, t, n, r) {
        if (typeof n === "undefined") {
            n = true
        }
        r = r || "rgba(0,255,0,0.4)";
        if (n) {
            e.fillStyle = r;
            e.fillRect(t.position.x - t.game.camera.x, t.position.y - t.game.camera.y, t.width, t.height)
        } else {
            e.strokeStyle = r;
            e.strokeRect(t.position.x - t.game.camera.x, t.position.y - t.game.camera.y, t.width, t.height)
        }
    };
    t.Physics.Arcade.Body.renderBodyInfo = function(e, t) {
        e.line("x: " + t.x.toFixed(2), "y: " + t.y.toFixed(2), "width: " + t.width, "height: " + t.height);
        e.line("velocity x: " + t.velocity.x.toFixed(2), "y: " + t.velocity.y.toFixed(2), "deltaX: " + t._dx.toFixed(2), "deltaY: " + t._dy.toFixed(2));
        e.line("acceleration x: " + t.acceleration.x.toFixed(2), "y: " + t.acceleration.y.toFixed(2), "speed: " + t.speed.toFixed(2), "angle: " + t.angle.toFixed(2));
        e.line("gravity x: " + t.gravity.x, "y: " + t.gravity.y, "bounce x: " + t.bounce.x.toFixed(2), "y: " + t.bounce.y.toFixed(2));
        e.line("touching left: " + t.touching.left, "right: " + t.touching.right, "up: " + t.touching.up, "down: " + t.touching.down);
        e.line("blocked left: " + t.blocked.left, "right: " + t.blocked.right, "up: " + t.blocked.up, "down: " + t.blocked.down)
    };
    t.Physics.Arcade.Body.prototype.constructor = t.Physics.Arcade.Body;
    t.Particles = function(e) {
        this.game = e;
        this.emitters = {};
        this.ID = 0
    };
    t.Particles.prototype = {
        add: function(e) {
            this.emitters[e.name] = e;
            return e
        },
        remove: function(e) {
            delete this.emitters[e.name]
        },
        update: function() {
            for (var e in this.emitters) {
                if (this.emitters[e].exists) {
                    this.emitters[e].update()
                }
            }
        }
    };
    t.Particles.prototype.constructor = t.Particles;
    t.Particles.Arcade = {};
    t.Particles.Arcade.Emitter = function(e, n, r, i) {
        this.maxParticles = i || 50;
        t.Group.call(this, e);
        this.name = "emitter" + this.game.particles.ID++;
        this.type = t.EMITTER;
        this.width = 1;
        this.height = 1;
        this.minParticleSpeed = new t.Point(-100, -100);
        this.maxParticleSpeed = new t.Point(100, 100);
        this.minParticleScale = 1;
        this.maxParticleScale = 1;
        this.scaleData = null;
        this.minRotation = -360;
        this.maxRotation = 360;
        this.minParticleAlpha = 1;
        this.maxParticleAlpha = 1;
        this.alphaData = null;
        this.gravity = 100;
        this.particleClass = t.Particle;
        this.particleDrag = new t.Point;
        this.angularDrag = 0;
        this.frequency = 100;
        this.lifespan = 2e3;
        this.bounce = new t.Point;
        this.on = false;
        this.particleAnchor = new t.Point(.5, .5);
        this.blendMode = t.blendModes.NORMAL;
        this.emitX = n;
        this.emitY = r;
        this.autoScale = false;
        this.autoAlpha = false;
        this.particleBringToTop = false;
        this.particleSendToBack = false;
        this._minParticleScale = new t.Point(1, 1);
        this._maxParticleScale = new t.Point(1, 1);
        this._quantity = 0;
        this._timer = 0;
        this._counter = 0;
        this._explode = true;
        this._frames = null
    };
    t.Particles.Arcade.Emitter.prototype = Object.create(t.Group.prototype);
    t.Particles.Arcade.Emitter.prototype.constructor = t.Particles.Arcade.Emitter;
    t.Particles.Arcade.Emitter.prototype.update = function() {
        if (this.on) {
            if (this._explode) {
                this._counter = 0;
                do {
                    this.emitParticle();
                    this._counter++
                } while (this._counter < this._quantity);
                this.on = false
            } else {
                if (this.game.time.now >= this._timer) {
                    this.emitParticle();
                    this._counter++;
                    if (this._quantity > 0) {
                        if (this._counter >= this._quantity) {
                            this.on = false
                        }
                    }
                    this._timer = this.game.time.now + this.frequency
                }
            }
        }
        var e = this.children.length;
        while (e--) {
            if (this.children[e].exists) {
                this.children[e].update()
            }
        }
    };
    t.Particles.Arcade.Emitter.prototype.makeParticles = function(e, t, n, r, i) {
        if (typeof t === "undefined") {
            t = 0
        }
        if (typeof n === "undefined") {
            n = this.maxParticles
        }
        if (typeof r === "undefined") {
            r = false
        }
        if (typeof i === "undefined") {
            i = false
        }
        var s;
        var o = 0;
        var u = e;
        var a = t;
        this._frames = t;
        while (o < n) {
            if (Array.isArray(e)) {
                u = this.game.rnd.pick(e)
            }
            if (Array.isArray(t)) {
                a = this.game.rnd.pick(t)
            }
            s = new this.particleClass(this.game, 0, 0, u, a);
            this.game.physics.arcade.enable(s, false);
            if (r) {
                s.body.checkCollision.any = true;
                s.body.checkCollision.none = false
            } else {
                s.body.checkCollision.none = true
            }
            s.body.collideWorldBounds = i;
            s.exists = false;
            s.visible = false;
            s.anchor.copyFrom(this.particleAnchor);
            this.add(s);
            o++
        }
        return this
    };
    t.Particles.Arcade.Emitter.prototype.kill = function() {
        this.on = false;
        this.alive = false;
        this.exists = false
    };
    t.Particles.Arcade.Emitter.prototype.revive = function() {
        this.alive = true;
        this.exists = true
    };
    t.Particles.Arcade.Emitter.prototype.start = function(e, t, n, r) {
        if (typeof e === "undefined") {
            e = true
        }
        if (typeof t === "undefined") {
            t = 0
        }
        if (typeof n === "undefined" || n === null) {
            n = 250
        }
        if (typeof r === "undefined") {
            r = 0
        }
        this.revive();
        this.visible = true;
        this.on = true;
        this._explode = e;
        this.lifespan = t;
        this.frequency = n;
        if (e) {
            this._quantity = r
        } else {
            this._quantity += r
        }
        this._counter = 0;
        this._timer = this.game.time.now + n
    };
    t.Particles.Arcade.Emitter.prototype.emitParticle = function() {
        var e = this.getFirstExists(false);
        if (e === null) {
            return
        }
        if (this.width > 1 || this.height > 1) {
            e.reset(this.game.rnd.integerInRange(this.left, this.right), this.game.rnd.integerInRange(this.top, this.bottom))
        } else {
            e.reset(this.emitX, this.emitY)
        }
        e.angle = 0;
        e.lifespan = this.lifespan;
        if (this.particleBringToTop) {
            this.bringToTop(e)
        } else if (this.particleSendToBack) {
            this.sendToBack(e)
        }
        if (this.autoScale) {
            e.setScaleData(this.scaleData)
        } else if (this.minParticleScale !== 1 || this.maxParticleScale !== 1) {
            e.scale.set(this.game.rnd.realInRange(this.minParticleScale, this.maxParticleScale))
        } else if (this._minParticleScale.x !== this._maxParticleScale.x || this._minParticleScale.y !== this._maxParticleScale.y) {
            e.scale.set(this.game.rnd.realInRange(this._minParticleScale.x, this._maxParticleScale.x), this.game.rnd.realInRange(this._minParticleScale.y, this._maxParticleScale.y))
        }
        if (Array.isArray(this._frames === "object")) {
            e.frame = this.game.rnd.pick(this._frames)
        } else {
            e.frame = this._frames
        }
        if (this.autoAlpha) {
            e.setAlphaData(this.alphaData)
        } else {
            e.alpha = this.game.rnd.realInRange(this.minParticleAlpha, this.maxParticleAlpha)
        }
        e.blendMode = this.blendMode;
        e.body.updateBounds();
        e.body.bounce.setTo(this.bounce.x, this.bounce.y);
        e.body.velocity.x = this.game.rnd.integerInRange(this.minParticleSpeed.x, this.maxParticleSpeed.x);
        e.body.velocity.y = this.game.rnd.integerInRange(this.minParticleSpeed.y, this.maxParticleSpeed.y);
        e.body.angularVelocity = this.game.rnd.integerInRange(this.minRotation, this.maxRotation);
        e.body.gravity.y = this.gravity;
        e.body.drag.x = this.particleDrag.x;
        e.body.drag.y = this.particleDrag.y;
        e.body.angularDrag = this.angularDrag;
        e.onEmit()
    };
    t.Particles.Arcade.Emitter.prototype.setSize = function(e, t) {
        this.width = e;
        this.height = t
    };
    t.Particles.Arcade.Emitter.prototype.setXSpeed = function(e, t) {
        e = e || 0;
        t = t || 0;
        this.minParticleSpeed.x = e;
        this.maxParticleSpeed.x = t
    };
    t.Particles.Arcade.Emitter.prototype.setYSpeed = function(e, t) {
        e = e || 0;
        t = t || 0;
        this.minParticleSpeed.y = e;
        this.maxParticleSpeed.y = t
    };
    t.Particles.Arcade.Emitter.prototype.setRotation = function(e, t) {
        e = e || 0;
        t = t || 0;
        this.minRotation = e;
        this.maxRotation = t
    };
    t.Particles.Arcade.Emitter.prototype.setAlpha = function(e, n, r, i, s) {
        if (typeof e === "undefined") {
            e = 1
        }
        if (typeof n === "undefined") {
            n = 1
        }
        if (typeof r === "undefined") {
            r = 0
        }
        if (typeof i === "undefined") {
            i = t.Easing.Linear.None
        }
        if (typeof s === "undefined") {
            s = false
        }
        this.minParticleAlpha = e;
        this.maxParticleAlpha = n;
        this.autoAlpha = false;
        if (r > 0 && e !== n) {
            var o = {
                v: e
            };
            var u = this.game.make.tween(o).to({
                v: n
            }, r, i);
            u.yoyo(s);
            this.alphaData = u.generateData(60);
            this.alphaData.reverse();
            this.autoAlpha = true
        }
    };
    t.Particles.Arcade.Emitter.prototype.setScale = function(e, n, r, i, s, o, u) {
        if (typeof e === "undefined") {
            e = 1
        }
        if (typeof n === "undefined") {
            n = 1
        }
        if (typeof r === "undefined") {
            r = 1
        }
        if (typeof i === "undefined") {
            i = 1
        }
        if (typeof s === "undefined") {
            s = 0
        }
        if (typeof o === "undefined") {
            o = t.Easing.Linear.None
        }
        if (typeof u === "undefined") {
            u = false
        }
        this.minParticleScale = 1;
        this.maxParticleScale = 1;
        this._minParticleScale.set(e, r);
        this._maxParticleScale.set(n, i);
        this.autoScale = false;
        if (s > 0 && e !== n || r !== i) {
            var a = {
                x: e,
                y: r
            };
            var f = this.game.make.tween(a).to({
                x: n,
                y: i
            }, s, o);
            f.yoyo(u);
            this.scaleData = f.generateData(60);
            this.scaleData.reverse();
            this.autoScale = true
        }
    };
    t.Particles.Arcade.Emitter.prototype.at = function(e) {
        if (e.center) {
            this.emitX = e.center.x;
            this.emitY = e.center.y
        } else {
            this.emitX = e.world.x + e.anchor.x * e.width;
            this.emitY = e.world.y + e.anchor.y * e.height
        }
    };
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "x", {
        get: function() {
            return this.emitX
        },
        set: function(e) {
            this.emitX = e
        }
    });
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "y", {
        get: function() {
            return this.emitY
        },
        set: function(e) {
            this.emitY = e
        }
    });
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "left", {
        get: function() {
            return Math.floor(this.x - this.width / 2)
        }
    });
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "right", {
        get: function() {
            return Math.floor(this.x + this.width / 2)
        }
    });
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "top", {
        get: function() {
            return Math.floor(this.y - this.height / 2)
        }
    });
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "bottom", {
        get: function() {
            return Math.floor(this.y + this.height / 2)
        }
    });
    t.Tile = function(e, t, n, r, i, s) {
        this.layer = e;
        this.index = t;
        this.x = n;
        this.y = r;
        this.worldX = n * i;
        this.worldY = r * s;
        this.width = i;
        this.height = s;
        this.centerX = Math.abs(i / 2);
        this.centerY = Math.abs(s / 2);
        this.alpha = 1;
        this.properties = {};
        this.scanned = false;
        this.faceTop = false;
        this.faceBottom = false;
        this.faceLeft = false;
        this.faceRight = false;
        this.collideLeft = false;
        this.collideRight = false;
        this.collideUp = false;
        this.collideDown = false;
        this.collisionCallback = null;
        this.collisionCallbackContext = this
    };
    t.Tile.prototype = {
        containsPoint: function(e, t) {
            return !(e < this.worldX || t < this.worldY || e > this.right || t > this.bottom)
        },
        intersects: function(e, t, n, r) {
            if (n <= this.worldX) {
                return false
            }
            if (r <= this.worldY) {
                return false
            }
            if (e >= this.worldX + this.width) {
                return false
            }
            if (t >= this.worldY + this.height) {
                return false
            }
            return true
        },
        setCollisionCallback: function(e, t) {
            this.collisionCallback = e;
            this.collisionCallbackContext = t
        },
        destroy: function() {
            this.collisionCallback = null;
            this.collisionCallbackContext = null;
            this.properties = null
        },
        setCollision: function(e, t, n, r) {
            this.collideLeft = e;
            this.collideRight = t;
            this.collideUp = n;
            this.collideDown = r
        },
        resetCollision: function() {
            this.collideLeft = false;
            this.collideRight = false;
            this.collideUp = false;
            this.collideDown = false;
            this.faceTop = false;
            this.faceBottom = false;
            this.faceLeft = false;
            this.faceRight = false
        },
        isInteresting: function(e, t) {
            if (e && t) {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback
            } else if (e) {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown
            } else if (t) {
                return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight
            }
            return false
        },
        copy: function(e) {
            this.index = e.index;
            this.alpha = e.alpha;
            this.properties = e.properties;
            this.collideUp = e.collideUp;
            this.collideDown = e.collideDown;
            this.collideLeft = e.collideLeft;
            this.collideRight = e.collideRight;
            this.collisionCallback = e.collisionCallback;
            this.collisionCallbackContext = e.collisionCallbackContext
        }
    };
    t.Tile.prototype.constructor = t.Tile;
    Object.defineProperty(t.Tile.prototype, "collides", {
        get: function() {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown
        }
    });
    Object.defineProperty(t.Tile.prototype, "canCollide", {
        get: function() {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback
        }
    });
    Object.defineProperty(t.Tile.prototype, "left", {
        get: function() {
            return this.worldX
        }
    });
    Object.defineProperty(t.Tile.prototype, "right", {
        get: function() {
            return this.worldX + this.width
        }
    });
    Object.defineProperty(t.Tile.prototype, "top", {
        get: function() {
            return this.worldY
        }
    });
    Object.defineProperty(t.Tile.prototype, "bottom", {
        get: function() {
            return this.worldY + this.height
        }
    });
    t.Tilemap = function(e, n, r, i, s, o) {
        this.game = e;
        this.key = n;
        var u = t.TilemapParser.parse(this.game, n, r, i, s, o);
        if (u === null) {
            return
        }
        this.width = u.width;
        this.height = u.height;
        this.tileWidth = u.tileWidth;
        this.tileHeight = u.tileHeight;
        this.orientation = u.orientation;
        this.format = u.format;
        this.version = u.version;
        this.properties = u.properties;
        this.widthInPixels = u.widthInPixels;
        this.heightInPixels = u.heightInPixels;
        this.layers = u.layers;
        this.tilesets = u.tilesets;
        this.tiles = u.tiles;
        this.objects = u.objects;
        this.collideIndexes = [];
        this.collision = u.collision;
        this.images = u.images;
        this.currentLayer = 0;
        this.debugMap = [];
        this._results = [];
        this._tempA = 0;
        this._tempB = 0
    };
    t.Tilemap.CSV = 0;
    t.Tilemap.TILED_JSON = 1;
    t.Tilemap.NORTH = 0;
    t.Tilemap.EAST = 1;
    t.Tilemap.SOUTH = 2;
    t.Tilemap.WEST = 3;
    t.Tilemap.prototype = {
        create: function(e, t, n, r, i, s) {
            if (typeof s === "undefined") {
                s = this.game.world
            }
            this.width = t;
            this.height = n;
            this.setTileSize(r, i);
            this.layers.length = 0;
            return this.createBlankLayer(e, t, n, r, i, s)
        },
        setTileSize: function(e, t) {
            this.tileWidth = e;
            this.tileHeight = t;
            this.widthInPixels = this.width * e;
            this.heightInPixels = this.height * t
        },
        addTilesetImage: function(e, n, r, i, s, o, u) {
            if (typeof r === "undefined") {
                r = this.tileWidth
            }
            if (typeof i === "undefined") {
                i = this.tileHeight
            }
            if (typeof s === "undefined") {
                s = 0
            }
            if (typeof o === "undefined") {
                o = 0
            }
            if (typeof u === "undefined") {
                u = 0
            }
            if (r === 0) {
                r = 32
            }
            if (i === 0) {
                i = 32
            }
            if (typeof n === "undefined") {
                if (typeof e === "string") {
                    n = e;
                    if (!this.game.cache.checkImageKey(n)) {
                        console.warn('Phaser.Tilemap.addTilesetImage: Invalid image key given: "' + n + '"');
                        return null
                    }
                } else {
                    return null
                }
            }
            if (typeof e === "string") {
                e = this.getTilesetIndex(e);
                if (e === null && this.format === t.Tilemap.TILED_JSON) {
                    console.warn('Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: "' + n + '"');
                    return null
                }
            }
            if (this.tilesets[e]) {
                this.tilesets[e].setImage(this.game.cache.getImage(n));
                return this.tilesets[e]
            } else {
                var a = new t.Tileset(n, u, r, i, s, o, {});
                a.setImage(this.game.cache.getImage(n));
                this.tilesets.push(a);
                var f = this.tilesets.length - 1;
                var l = s;
                var c = s;
                var h = 0;
                var p = 0;
                var d = 0;
                for (var v = u; v < u + a.total; v++) {
                    this.tiles[v] = [l, c, f];
                    l += r + o;
                    h++;
                    if (h === a.total) {
                        break
                    }
                    p++;
                    if (p === a.columns) {
                        l = s;
                        c += i + o;
                        p = 0;
                        d++;
                        if (d === a.rows) {
                            break
                        }
                    }
                }
                return a
            }
            return null
        },
        createFromObjects: function(e, n, r, i, s, o, u, a, f) {
            if (typeof s === "undefined") {
                s = true
            }
            if (typeof o === "undefined") {
                o = false
            }
            if (typeof u === "undefined") {
                u = this.game.world
            }
            if (typeof a === "undefined") {
                a = t.Sprite
            }
            if (typeof f === "undefined") {
                f = true
            }
            if (!this.objects[e]) {
                console.warn("Tilemap.createFromObjects: Invalid objectgroup name given: " + e);
                return
            }
            var l;
            for (var c = 0, h = this.objects[e].length; c < h; c++) {
                if (this.objects[e][c].gid === n) {
                    l = new a(this.game, this.objects[e][c].x, this.objects[e][c].y, r, i);
                    l.name = this.objects[e][c].name;
                    l.visible = this.objects[e][c].visible;
                    l.autoCull = o;
                    l.exists = s;
                    if (f) {
                        l.y -= l.height
                    }
                    u.add(l);
                    for (var p in this.objects[e][c].properties) {
                        u.set(l, p, this.objects[e][c].properties[p], false, false, 0, true)
                    }
                }
            }
        },
        createLayer: function(e, n, r, i) {
            if (typeof n === "undefined") {
                n = this.game.width
            }
            if (typeof r === "undefined") {
                r = this.game.height
            }
            if (typeof i === "undefined") {
                i = this.game.world
            }
            var s = e;
            if (typeof e === "string") {
                s = this.getLayerIndex(e)
            }
            if (s === null || s > this.layers.length) {
                console.warn("Tilemap.createLayer: Invalid layer ID given: " + s);
                return
            }
            return i.add(new t.TilemapLayer(this.game, this, s, n, r))
        },
        createBlankLayer: function(e, n, r, i, s, o) {
            if (typeof o === "undefined") {
                o = this.game.world
            }
            if (this.getLayerIndex(e) !== null) {
                console.warn("Tilemap.createBlankLayer: Layer with matching name already exists");
                return
            }
            var u = {
                name: e,
                x: 0,
                y: 0,
                width: n,
                height: r,
                widthInPixels: n * i,
                heightInPixels: r * s,
                alpha: 1,
                visible: true,
                properties: {},
                indexes: [],
                callbacks: [],
                bodies: [],
                data: null
            };
            var a;
            var f = [];
            for (var l = 0; l < r; l++) {
                a = [];
                for (var c = 0; c < n; c++) {
                    a.push(new t.Tile(u, -1, c, l, i, s))
                }
                f.push(a)
            }
            u.data = f;
            this.layers.push(u);
            this.currentLayer = this.layers.length - 1;
            var h = u.widthInPixels;
            var p = u.heightInPixels;
            if (h > this.game.width) {
                h = this.game.width
            }
            if (p > this.game.height) {
                p = this.game.height
            }
            var f = new t.TilemapLayer(this.game, this, this.layers.length - 1, h, p);
            f.name = e;
            return o.add(f)
        },
        getIndex: function(e, t) {
            for (var n = 0; n < e.length; n++) {
                if (e[n].name === t) {
                    return n
                }
            }
            return null
        },
        getLayerIndex: function(e) {
            return this.getIndex(this.layers, e)
        },
        getTilesetIndex: function(e) {
            return this.getIndex(this.tilesets, e)
        },
        getImageIndex: function(e) {
            return this.getIndex(this.images, e)
        },
        getObjectIndex: function(e) {
            return this.getIndex(this.objects, e)
        },
        setTileIndexCallback: function(e, t, n, r) {
            r = this.getLayer(r);
            if (typeof e === "number") {
                this.layers[r].callbacks[e] = {
                    callback: t,
                    callbackContext: n
                }
            } else {
                for (var i = 0, s = e.length; i < s; i++) {
                    this.layers[r].callbacks[e[i]] = {
                        callback: t,
                        callbackContext: n
                    }
                }
            }
        },
        setTileLocationCallback: function(e, t, n, r, i, s, o) {
            o = this.getLayer(o);
            this.copy(e, t, n, r, o);
            if (this._results.length < 2) {
                return
            }
            for (var u = 1; u < this._results.length; u++) {
                this._results[u].setCollisionCallback(i, s)
            }
        },
        setCollision: function(e, t, n, r) {
            if (typeof t === "undefined") {
                t = true
            }
            if (typeof r === "undefined") {
                r = true
            }
            n = this.getLayer(n);
            if (typeof e === "number") {
                return this.setCollisionByIndex(e, t, n, true)
            } else {
                for (var i = 0, s = e.length; i < s; i++) {
                    this.setCollisionByIndex(e[i], t, n, false)
                }
                if (r) {
                    this.calculateFaces(n)
                }
            }
        },
        setCollisionBetween: function(e, t, n, r, i) {
            if (typeof n === "undefined") {
                n = true
            }
            if (typeof i === "undefined") {
                i = true
            }
            r = this.getLayer(r);
            if (e > t) {
                return
            }
            for (var s = e; s <= t; s++) {
                this.setCollisionByIndex(s, n, r, false)
            }
            if (i) {
                this.calculateFaces(r)
            }
        },
        setCollisionByExclusion: function(e, t, n, r) {
            if (typeof t === "undefined") {
                t = true
            }
            if (typeof r === "undefined") {
                r = true
            }
            n = this.getLayer(n);
            for (var i = 0, s = this.tiles.length; i < s; i++) {
                if (e.indexOf(i) === -1) {
                    this.setCollisionByIndex(i, t, n, false)
                }
            }
            if (r) {
                this.calculateFaces(n)
            }
        },
        setCollisionByIndex: function(e, t, n, r) {
            if (typeof t === "undefined") {
                t = true
            }
            if (typeof n === "undefined") {
                n = this.currentLayer
            }
            if (typeof r === "undefined") {
                r = true
            }
            if (t) {
                this.collideIndexes.push(e)
            } else {
                var i = this.collideIndexes.indexOf(e);
                if (i > -1) {
                    this.collideIndexes.splice(i, 1)
                }
            }
            for (var s = 0; s < this.layers[n].height; s++) {
                for (var o = 0; o < this.layers[n].width; o++) {
                    var u = this.layers[n].data[s][o];
                    if (u && u.index === e) {
                        if (t) {
                            u.setCollision(true, true, true, true)
                        } else {
                            u.resetCollision()
                        }
                        u.faceTop = t;
                        u.faceBottom = t;
                        u.faceLeft = t;
                        u.faceRight = t
                    }
                }
            }
            if (r) {
                this.calculateFaces(n)
            }
            return n
        },
        getLayer: function(e) {
            if (typeof e === "undefined") {
                e = this.currentLayer
            } else if (typeof e === "string") {
                e = this.getLayerIndex(e)
            } else if (e instanceof t.TilemapLayer) {
                e = e.index
            }
            return e
        },
        calculateFaces: function(e) {
            var t = null;
            var n = null;
            var r = null;
            var i = null;
            for (var s = 0, o = this.layers[e].height; s < o; s++) {
                for (var u = 0, a = this.layers[e].width; u < a; u++) {
                    var f = this.layers[e].data[s][u];
                    if (f) {
                        t = this.getTileAbove(e, u, s);
                        n = this.getTileBelow(e, u, s);
                        r = this.getTileLeft(e, u, s);
                        i = this.getTileRight(e, u, s);
                        if (f.collides) {
                            f.faceTop = true;
                            f.faceBottom = true;
                            f.faceLeft = true;
                            f.faceRight = true
                        }
                        if (t && t.collides) {
                            f.faceTop = false
                        }
                        if (n && n.collides) {
                            f.faceBottom = false
                        }
                        if (r && r.collides) {
                            f.faceLeft = false
                        }
                        if (i && i.collides) {
                            f.faceRight = false
                        }
                    }
                }
            }
        },
        getTileAbove: function(e, t, n) {
            if (n > 0) {
                return this.layers[e].data[n - 1][t]
            }
            return null
        },
        getTileBelow: function(e, t, n) {
            if (n < this.layers[e].height - 1) {
                return this.layers[e].data[n + 1][t]
            }
            return null
        },
        getTileLeft: function(e, t, n) {
            if (t > 0) {
                return this.layers[e].data[n][t - 1]
            }
            return null
        },
        getTileRight: function(e, t, n) {
            if (t < this.layers[e].width - 1) {
                return this.layers[e].data[n][t + 1]
            }
            return null
        },
        setLayer: function(e) {
            e = this.getLayer(e);
            if (this.layers[e]) {
                this.currentLayer = e
            }
        },
        hasTile: function(e, t, n) {
            n = this.getLayer(n);
            return this.layers[n].data[t] !== null && this.layers[n].data[t][e] !== null
        },
        removeTile: function(e, t, n) {
            n = this.getLayer(n);
            if (e >= 0 && e < this.layers[n].width && t >= 0 && t < this.layers[n].height) {
                if (this.hasTile(e, t, n)) {
                    var r = this.layers[n].data[t][e];
                    this.layers[n].data[t][e] = null;
                    this.layers[n].dirty = true;
                    this.calculateFaces(n);
                    return r
                }
            }
        },
        removeTileWorldXY: function(e, t, n, r, i) {
            i = this.getLayer(i);
            e = this.game.math.snapToFloor(e, n) / n;
            t = this.game.math.snapToFloor(t, r) / r;
            return this.removeTile(e, t, i)
        },
        putTile: function(e, n, r, i) {
            if (e === null) {
                return this.removeTile(n, r, i)
            }
            i = this.getLayer(i);
            if (n >= 0 && n < this.layers[i].width && r >= 0 && r < this.layers[i].height) {
                var s;
                if (e instanceof t.Tile) {
                    s = e.index;
                    if (this.hasTile(n, r, i)) {
                        this.layers[i].data[r][n].copy(e)
                    } else {
                        this.layers[i].data[r][n] = new t.Tile(i, s, n, r, e.width, e.height)
                    }
                } else {
                    s = e;
                    if (this.hasTile(n, r, i)) {
                        this.layers[i].data[r][n].index = s
                    } else {
                        this.layers[i].data[r][n] = new t.Tile(this.layers[i], s, n, r, this.tileWidth, this.tileHeight)
                    }
                }
                if (this.collideIndexes.indexOf(s) > -1) {
                    this.layers[i].data[r][n].setCollision(true, true, true, true)
                } else {
                    this.layers[i].data[r][n].resetCollision()
                }
                this.layers[i].dirty = true;
                this.calculateFaces(i);
                return this.layers[i].data[r][n]
            }
            return null
        },
        putTileWorldXY: function(e, t, n, r, i, s) {
            s = this.getLayer(s);
            t = this.game.math.snapToFloor(t, r) / r;
            n = this.game.math.snapToFloor(n, i) / i;
            return this.putTile(e, t, n, s)
        },
        searchTileIndex: function(e, t, n, r) {
            if (typeof t === "undefined") {
                t = 0
            }
            if (typeof n === "undefined") {
                n = false
            }
            r = this.getLayer(r);
            var i = 0;
            if (n) {
                for (var s = this.layers[r].height - 1; s >= 0; s--) {
                    for (var o = this.layers[r].width - 1; o >= 0; o--) {
                        if (this.layers[r].data[s][o].index === e) {
                            if (i === t) {
                                return this.layers[r].data[s][o]
                            } else {
                                i++
                            }
                        }
                    }
                }
            } else {
                for (var s = 0; s < this.layers[r].height; s++) {
                    for (var o = 0; o < this.layers[r].width; o++) {
                        if (this.layers[r].data[s][o].index === e) {
                            if (i === t) {
                                return this.layers[r].data[s][o]
                            } else {
                                i++
                            }
                        }
                    }
                }
            }
            return null
        },
        getTile: function(e, t, n, r) {
            if (typeof r === "undefined") {
                r = false
            }
            n = this.getLayer(n);
            if (e >= 0 && e < this.layers[n].width && t >= 0 && t < this.layers[n].height) {
                if (this.layers[n].data[t][e].index === -1) {
                    if (r) {
                        return this.layers[n].data[t][e]
                    } else {
                        return null
                    }
                } else {
                    return this.layers[n].data[t][e]
                }
            } else {
                return null
            }
        },
        getTileWorldXY: function(e, t, n, r, i) {
            if (typeof n === "undefined") {
                n = this.tileWidth
            }
            if (typeof r === "undefined") {
                r = this.tileHeight
            }
            i = this.getLayer(i);
            e = this.game.math.snapToFloor(e, n) / n;
            t = this.game.math.snapToFloor(t, r) / r;
            return this.getTile(e, t, i)
        },
        copy: function(e, t, n, r, i) {
            i = this.getLayer(i);
            if (!this.layers[i]) {
                this._results.length = 0;
                return
            }
            if (typeof e === "undefined") {
                e = 0
            }
            if (typeof t === "undefined") {
                t = 0
            }
            if (typeof n === "undefined") {
                n = this.layers[i].width
            }
            if (typeof r === "undefined") {
                r = this.layers[i].height
            }
            if (e < 0) {
                e = 0
            }
            if (t < 0) {
                t = 0
            }
            if (n > this.layers[i].width) {
                n = this.layers[i].width
            }
            if (r > this.layers[i].height) {
                r = this.layers[i].height
            }
            this._results.length = 0;
            this._results.push({
                x: e,
                y: t,
                width: n,
                height: r,
                layer: i
            });
            for (var s = t; s < t + r; s++) {
                for (var o = e; o < e + n; o++) {
                    this._results.push(this.layers[i].data[s][o])
                }
            }
            return this._results
        },
        paste: function(e, t, n, r) {
            if (typeof e === "undefined") {
                e = 0
            }
            if (typeof t === "undefined") {
                t = 0
            }
            r = this.getLayer(r);
            if (!n || n.length < 2) {
                return
            }
            var i = n[1].x - e;
            var s = n[1].y - t;
            for (var o = 1; o < n.length; o++) {
                this.layers[r].data[s + n[o].y][i + n[o].x].copy(n[o])
            }
            this.layers[r].dirty = true;
            this.calculateFaces(r)
        },
        swap: function(e, t, n, r, i, s, o) {
            o = this.getLayer(o);
            this.copy(n, r, i, s, o);
            if (this._results.length < 2) {
                return
            }
            this._tempA = e;
            this._tempB = t;
            this._results.forEach(this.swapHandler, this);
            this.paste(n, r, this._results, o)
        },
        swapHandler: function(e, t) {
            if (e.index === this._tempA) {
                this._results[t].index = this._tempB
            }
            if (e.index === this._tempB) {
                this._results[t].index = this._tempA
            }
        },
        forEach: function(e, t, n, r, i, s, o) {
            o = this.getLayer(o);
            this.copy(n, r, i, s, o);
            if (this._results.length < 2) {
                return
            }
            this._results.forEach(e, t);
            this.paste(n, r, this._results, o)
        },
        replace: function(e, t, n, r, i, s, o) {
            o = this.getLayer(o);
            this.copy(n, r, i, s, o);
            if (this._results.length < 2) {
                return
            }
            for (var u = 1; u < this._results.length; u++) {
                if (this._results[u].index === e) {
                    this._results[u].index = t
                }
            }
            this.paste(n, r, this._results, o)
        },
        random: function(e, t, n, r, i) {
            i = this.getLayer(i);
            this.copy(e, t, n, r, i);
            if (this._results.length < 2) {
                return
            }
            var s = [];
            for (var o = 1; o < this._results.length; o++) {
                if (this._results[o].index) {
                    var u = this._results[o].index;
                    if (s.indexOf(u) === -1) {
                        s.push(u)
                    }
                }
            }
            for (var a = 1; a < this._results.length; a++) {
                this._results[a].index = this.game.rnd.pick(s)
            }
            this.paste(e, t, this._results, i)
        },
        shuffle: function(e, n, r, i, s) {
            s = this.getLayer(s);
            this.copy(e, n, r, i, s);
            if (this._results.length < 2) {
                return
            }
            var o = [];
            for (var u = 1; u < this._results.length; u++) {
                if (this._results[u].index) {
                    o.push(this._results[u].index)
                }
            }
            t.Utils.shuffle(o);
            for (var a = 1; a < this._results.length; a++) {
                this._results[a].index = o[a - 1]
            }
            this.paste(e, n, this._results, s)
        },
        fill: function(e, t, n, r, i, s) {
            s = this.getLayer(s);
            this.copy(t, n, r, i, s);
            if (this._results.length < 2) {
                return
            }
            for (var o = 1; o < this._results.length; o++) {
                this._results[o].index = e
            }
            this.paste(t, n, this._results, s)
        },
        removeAllLayers: function() {
            this.layers.length = 0;
            this.currentLayer = 0
        },
        dump: function() {
            var e = "";
            var t = [""];
            for (var n = 0; n < this.layers[this.currentLayer].height; n++) {
                for (var r = 0; r < this.layers[this.currentLayer].width; r++) {
                    e += "%c  ";
                    if (this.layers[this.currentLayer].data[n][r] > 1) {
                        if (this.debugMap[this.layers[this.currentLayer].data[n][r]]) {
                            t.push("background: " + this.debugMap[this.layers[this.currentLayer].data[n][r]])
                        } else {
                            t.push("background: #ffffff")
                        }
                    } else {
                        t.push("background: rgb(0, 0, 0)")
                    }
                }
                e += "\n"
            }
            t[0] = e;
            console.log.apply(console, t)
        },
        destroy: function() {
            this.removeAllLayers();
            this.data = [];
            this.game = null
        }
    };
    t.Tilemap.prototype.constructor = t.Tilemap;
    Object.defineProperty(t.Tilemap.prototype, "layer", {
        get: function() {
            return this.layers[this.currentLayer]
        },
        set: function(e) {
            if (e !== this.currentLayer) {
                this.setLayer(e)
            }
        }
    });
    t.TilemapLayer = function(e, n, r, i, s) {
        this.game = e;
        this.map = n;
        this.index = r;
        this.layer = n.layers[r];
        this.canvas = t.Canvas.create(i, s, "", true);
        this.context = this.canvas.getContext("2d");
        this.baseTexture = new PIXI.BaseTexture(this.canvas);
        this.texture = new PIXI.Texture(this.baseTexture);
        this.textureFrame = new t.Frame(0, 0, 0, i, s, "tilemapLayer", e.rnd.uuid());
        t.Image.call(this, this.game, 0, 0, this.texture, this.textureFrame);
        this.name = "";
        this.type = t.TILEMAPLAYER;
        this.fixedToCamera = true;
        this.cameraOffset = new t.Point(0, 0);
        this.tileColor = "rgb(255, 255, 255)";
        this.debug = false;
        this.debugAlpha = .5;
        this.debugColor = "rgba(0, 255, 0, 1)";
        this.debugFill = false;
        this.debugFillColor = "rgba(0, 255, 0, 0.2)";
        this.debugCallbackColor = "rgba(255, 0, 0, 1)";
        this.scrollFactorX = 1;
        this.scrollFactorY = 1;
        this.dirty = true;
        this.rayStepRate = 4;
        this._mc = {
            cw: n.tileWidth,
            ch: n.tileHeight,
            ga: 1,
            dx: 0,
            dy: 0,
            dw: 0,
            dh: 0,
            tx: 0,
            ty: 0,
            tw: 0,
            th: 0,
            tl: 0,
            maxX: 0,
            maxY: 0,
            startX: 0,
            startY: 0,
            x: 0,
            y: 0,
            prevX: 0,
            prevY: 0
        };
        this._results = [];
        this.updateMax()
    };
    t.TilemapLayer.prototype = Object.create(t.Image.prototype);
    t.TilemapLayer.prototype.constructor = t.TilemapLayer;
    t.TilemapLayer.prototype.postUpdate = function() {
        t.Image.prototype.postUpdate.call(this);
        this.scrollX = this.game.camera.x * this.scrollFactorX;
        this.scrollY = this.game.camera.y * this.scrollFactorY;
        this.render();
        if (this._cache[7] === 1) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y
        }
    };
    t.TilemapLayer.prototype.resizeWorld = function() {
        this.game.world.setBounds(0, 0, this.layer.widthInPixels, this.layer.heightInPixels)
    };
    t.TilemapLayer.prototype._fixX = function(e) {
        if (e < 0) {
            e = 0
        }
        if (this.scrollFactorX === 1) {
            return e
        }
        return this._mc.x + (e - this._mc.x / this.scrollFactorX)
    };
    t.TilemapLayer.prototype._unfixX = function(e) {
        if (this.scrollFactorX === 1) {
            return e
        }
        return this._mc.x / this.scrollFactorX + (e - this._mc.x)
    };
    t.TilemapLayer.prototype._fixY = function(e) {
        if (e < 0) {
            e = 0
        }
        if (this.scrollFactorY === 1) {
            return e
        }
        return this._mc.y + (e - this._mc.y / this.scrollFactorY)
    };
    t.TilemapLayer.prototype._unfixY = function(e) {
        if (this.scrollFactorY === 1) {
            return e
        }
        return this._mc.y / this.scrollFactorY + (e - this._mc.y)
    };
    t.TilemapLayer.prototype.getTileX = function(e) {
        return this.game.math.snapToFloor(this._fixX(e), this.map.tileWidth) / this.map.tileWidth
    };
    t.TilemapLayer.prototype.getTileY = function(e) {
        return this.game.math.snapToFloor(this._fixY(e), this.map.tileHeight) / this.map.tileHeight
    };
    t.TilemapLayer.prototype.getTileXY = function(e, t, n) {
        n.x = this.getTileX(e);
        n.y = this.getTileY(t);
        return n
    };
    t.TilemapLayer.prototype.getRayCastTiles = function(e, t, n, r) {
        if (typeof t === "undefined" || t === null) {
            t = this.rayStepRate
        }
        if (typeof n === "undefined") {
            n = false
        }
        if (typeof r === "undefined") {
            r = false
        }
        var i = this.getTiles(e.x, e.y, e.width, e.height, n, r);
        if (i.length === 0) {
            return []
        }
        var s = e.coordinatesOnLine(t);
        var o = s.length;
        var u = [];
        for (var a = 0; a < i.length; a++) {
            for (var f = 0; f < o; f++) {
                if (i[a].containsPoint(s[f][0], s[f][1])) {
                    u.push(i[a]);
                    break
                }
            }
        }
        return u
    };
    t.TilemapLayer.prototype.getTiles = function(e, t, n, r, i, s) {
        if (typeof i === "undefined") {
            i = false
        }
        if (typeof s === "undefined") {
            s = false
        }
        e = this._fixX(e);
        t = this._fixY(t);
        if (n > this.layer.widthInPixels) {
            n = this.layer.widthInPixels
        }
        if (r > this.layer.heightInPixels) {
            r = this.layer.heightInPixels
        }
        this._mc.tx = this.game.math.snapToFloor(e, this._mc.cw) / this._mc.cw;
        this._mc.ty = this.game.math.snapToFloor(t, this._mc.ch) / this._mc.ch;
        this._mc.tw = (this.game.math.snapToCeil(n, this._mc.cw) + this._mc.cw) / this._mc.cw;
        this._mc.th = (this.game.math.snapToCeil(r, this._mc.ch) + this._mc.ch) / this._mc.ch;
        this._results.length = 0;
        for (var o = this._mc.ty; o < this._mc.ty + this._mc.th; o++) {
            for (var u = this._mc.tx; u < this._mc.tx + this._mc.tw; u++) {
                if (this.layer.data[o] && this.layer.data[o][u]) {
                    if (!i && !s || this.layer.data[o][u].isInteresting(i, s)) {
                        this._results.push(this.layer.data[o][u])
                    }
                }
            }
        }
        return this._results
    };
    t.TilemapLayer.prototype.updateMax = function() {
        this._mc.maxX = this.game.math.ceil(this.canvas.width / this.map.tileWidth) + 1;
        this._mc.maxY = this.game.math.ceil(this.canvas.height / this.map.tileHeight) + 1;
        if (this.layer) {
            if (this._mc.maxX > this.layer.width) {
                this._mc.maxX = this.layer.width
            }
            if (this._mc.maxY > this.layer.height) {
                this._mc.maxY = this.layer.height
            }
        }
        this.dirty = true
    };
    t.TilemapLayer.prototype.render = function() {
        if (this.layer.dirty) {
            this.dirty = true
        }
        if (!this.dirty || !this.visible) {
            return
        }
        this._mc.prevX = this._mc.dx;
        this._mc.prevY = this._mc.dy;
        this._mc.dx = -(this._mc.x - this._mc.startX * this.map.tileWidth);
        this._mc.dy = -(this._mc.y - this._mc.startY * this.map.tileHeight);
        this._mc.tx = this._mc.dx;
        this._mc.ty = this._mc.dy;
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.context.fillStyle = this.tileColor;
        var e;
        var n;
        if (this.debug) {
            this.context.globalAlpha = this.debugAlpha
        }
        for (var r = this._mc.startY, i = this._mc.startY + this._mc.maxY; r < i; r++) {
            this._column = this.layer.data[r];
            for (var s = this._mc.startX, o = this._mc.startX + this._mc.maxX; s < o; s++) {
                if (this._column[s]) {
                    e = this._column[s];
                    if (e.index > -1) {
                        n = this.map.tilesets[this.map.tiles[e.index][2]];
                        if (this.debug === false && e.alpha !== this.context.globalAlpha) {
                            this.context.globalAlpha = e.alpha
                        }
                        n.draw(this.context, Math.floor(this._mc.tx), Math.floor(this._mc.ty), e.index);
                        if (e.debug) {
                            this.context.fillStyle = "rgba(0, 255, 0, 0.4)";
                            this.context.fillRect(Math.floor(this._mc.tx), Math.floor(this._mc.ty), this.map.tileWidth, this.map.tileHeight)
                        }
                    }
                }
                this._mc.tx += this.map.tileWidth
            }
            this._mc.tx = this._mc.dx;
            this._mc.ty += this.map.tileHeight
        }
        if (this.debug) {
            this.context.globalAlpha = 1;
            this.renderDebug()
        }
        if (this.game.renderType === t.WEBGL) {
            PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl)
        }
        this.dirty = false;
        this.layer.dirty = false;
        return true
    };
    t.TilemapLayer.prototype.renderDebug = function() {
        this._mc.tx = this._mc.dx;
        this._mc.ty = this._mc.dy;
        this.context.strokeStyle = this.debugColor;
        this.context.fillStyle = this.debugFillColor;
        for (var e = this._mc.startY, t = this._mc.startY + this._mc.maxY; e < t; e++) {
            this._column = this.layer.data[e];
            for (var n = this._mc.startX, r = this._mc.startX + this._mc.maxX; n < r; n++) {
                var i = this._column[n];
                if (i && (i.faceTop || i.faceBottom || i.faceLeft || i.faceRight)) {
                    this._mc.tx = Math.floor(this._mc.tx);
                    if (this.debugFill) {
                        this.context.fillRect(this._mc.tx, this._mc.ty, this._mc.cw, this._mc.ch)
                    }
                    this.context.beginPath();
                    if (i.faceTop) {
                        this.context.moveTo(this._mc.tx, this._mc.ty);
                        this.context.lineTo(this._mc.tx + this._mc.cw, this._mc.ty)
                    }
                    if (i.faceBottom) {
                        this.context.moveTo(this._mc.tx, this._mc.ty + this._mc.ch);
                        this.context.lineTo(this._mc.tx + this._mc.cw, this._mc.ty + this._mc.ch)
                    }
                    if (i.faceLeft) {
                        this.context.moveTo(this._mc.tx, this._mc.ty);
                        this.context.lineTo(this._mc.tx, this._mc.ty + this._mc.ch)
                    }
                    if (i.faceRight) {
                        this.context.moveTo(this._mc.tx + this._mc.cw, this._mc.ty);
                        this.context.lineTo(this._mc.tx + this._mc.cw, this._mc.ty + this._mc.ch)
                    }
                    this.context.stroke()
                }
                this._mc.tx += this.map.tileWidth
            }
            this._mc.tx = this._mc.dx;
            this._mc.ty += this.map.tileHeight
        }
    };
    Object.defineProperty(t.TilemapLayer.prototype, "scrollX", {
        get: function() {
            return this._mc.x
        },
        set: function(e) {
            if (e !== this._mc.x && e >= 0 && this.layer.widthInPixels > this.width) {
                this._mc.x = e;
                if (this._mc.x > this.layer.widthInPixels - this.width) {
                    this._mc.x = this.layer.widthInPixels - this.width
                }
                this._mc.startX = this.game.math.floor(this._mc.x / this.map.tileWidth);
                if (this._mc.startX < 0) {
                    this._mc.startX = 0
                }
                if (this._mc.startX + this._mc.maxX > this.layer.width) {
                    this._mc.startX = this.layer.width - this._mc.maxX
                }
                this.dirty = true
            }
        }
    });
    Object.defineProperty(t.TilemapLayer.prototype, "scrollY", {
        get: function() {
            return this._mc.y
        },
        set: function(e) {
            if (e !== this._mc.y && e >= 0 && this.layer.heightInPixels > this.height) {
                this._mc.y = e;
                if (this._mc.y > this.layer.heightInPixels - this.height) {
                    this._mc.y = this.layer.heightInPixels - this.height
                }
                this._mc.startY = this.game.math.floor(this._mc.y / this.map.tileHeight);
                if (this._mc.startY < 0) {
                    this._mc.startY = 0
                }
                if (this._mc.startY + this._mc.maxY > this.layer.height) {
                    this._mc.startY = this.layer.height - this._mc.maxY
                }
                this.dirty = true
            }
        }
    });
    Object.defineProperty(t.TilemapLayer.prototype, "collisionWidth", {
        get: function() {
            return this._mc.cw
        },
        set: function(e) {
            this._mc.cw = e;
            this.dirty = true
        }
    });
    Object.defineProperty(t.TilemapLayer.prototype, "collisionHeight", {
        get: function() {
            return this._mc.ch
        },
        set: function(e) {
            this._mc.ch = e;
            this.dirty = true
        }
    });
    t.TilemapParser = {
        parse: function(e, n, r, i, s, o) {
            if (typeof r === "undefined") {
                r = 32
            }
            if (typeof i === "undefined") {
                i = 32
            }
            if (typeof s === "undefined") {
                s = 10
            }
            if (typeof o === "undefined") {
                o = 10
            }
            if (typeof n === "undefined") {
                return this.getEmptyData()
            }
            if (n === null) {
                return this.getEmptyData(r, i, s, o)
            }
            var u = e.cache.getTilemapData(n);
            if (u) {
                if (u.format === t.Tilemap.CSV) {
                    return this.parseCSV(n, u.data, r, i)
                } else if (!u.format || u.format === t.Tilemap.TILED_JSON) {
                    return this.parseTiledJSON(u.data)
                }
            } else {
                console.warn("Phaser.TilemapParser.parse - No map data found for key " + n)
            }
        },
        parseCSV: function(e, n, r, i) {
            var s = this.getEmptyData();
            n = n.trim();
            var o = [];
            var u = n.split("\n");
            var a = u.length;
            var f = 0;
            for (var l = 0; l < u.length; l++) {
                o[l] = [];
                var c = u[l].split(",");
                for (var h = 0; h < c.length; h++) {
                    o[l][h] = new t.Tile(s.layers[0], parseInt(c[h], 10), h, l, r, i)
                }
                if (f === 0) {
                    f = c.length
                }
            }
            s.format = t.Tilemap.CSV;
            s.name = e;
            s.width = f;
            s.height = a;
            s.tileWidth = r;
            s.tileHeight = i;
            s.widthInPixels = f * r;
            s.heightInPixels = a * i;
            s.layers[0].width = f;
            s.layers[0].height = a;
            s.layers[0].widthInPixels = s.widthInPixels;
            s.layers[0].heightInPixels = s.heightInPixels;
            s.layers[0].data = o;
            return s
        },
        getEmptyData: function(e, t, n, r) {
            var i = {};
            i.width = 0;
            i.height = 0;
            i.tileWidth = 0;
            i.tileHeight = 0;
            if (typeof e !== "undefined" && e !== null) {
                i.tileWidth = e
            }
            if (typeof t !== "undefined" && t !== null) {
                i.tileHeight = t
            }
            if (typeof n !== "undefined" && n !== null) {
                i.width = n
            }
            if (typeof r !== "undefined" && r !== null) {
                i.height = r
            }
            i.orientation = "orthogonal";
            i.version = "1";
            i.properties = {};
            i.widthInPixels = 0;
            i.heightInPixels = 0;
            var s = [];
            var o = {
                name: "layer",
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                widthInPixels: 0,
                heightInPixels: 0,
                alpha: 1,
                visible: true,
                properties: {},
                indexes: [],
                callbacks: [],
                data: []
            };
            s.push(o);
            i.layers = s;
            i.images = [];
            i.objects = {};
            i.collision = {};
            i.tilesets = [];
            i.tiles = [];
            return i
        },
        parseTiledJSON: function(e) {
            function y(e, t) {
                var n = {};
                for (var r in t) {
                    var i = t[r];
                    n[i] = e[i]
                }
                return n
            }
            if (e.orientation !== "orthogonal") {
                console.warn("TilemapParser.parseTiledJSON: Only orthogonal map types are supported in this version of Phaser");
                return null
            }
            var n = {};
            n.width = e.width;
            n.height = e.height;
            n.tileWidth = e.tilewidth;
            n.tileHeight = e.tileheight;
            n.orientation = e.orientation;
            n.format = t.Tilemap.TILED_JSON;
            n.version = e.version;
            n.properties = e.properties;
            n.widthInPixels = n.width * n.tileWidth;
            n.heightInPixels = n.height * n.tileHeight;
            var r = [];
            for (var i = 0; i < e.layers.length; i++) {
                if (e.layers[i].type !== "tilelayer") {
                    continue
                }
                var s = {
                    name: e.layers[i].name,
                    x: e.layers[i].x,
                    y: e.layers[i].y,
                    width: e.layers[i].width,
                    height: e.layers[i].height,
                    widthInPixels: e.layers[i].width * e.tilewidth,
                    heightInPixels: e.layers[i].height * e.tileheight,
                    alpha: e.layers[i].opacity,
                    visible: e.layers[i].visible,
                    properties: {},
                    indexes: [],
                    callbacks: [],
                    bodies: []
                };
                if (e.layers[i].properties) {
                    s.properties = e.layers[i].properties
                }
                var o = 0;
                var u = [];
                var a = [];
                for (var f = 0, l = e.layers[i].data.length; f < l; f++) {
                    if (e.layers[i].data[f] > 0) {
                        u.push(new t.Tile(s, e.layers[i].data[f], o, a.length, e.tilewidth, e.tileheight))
                    } else {
                        u.push(new t.Tile(s, -1, o, a.length, e.tilewidth, e.tileheight))
                    }
                    o++;
                    if (o === e.layers[i].width) {
                        a.push(u);
                        o = 0;
                        u = []
                    }
                }
                s.data = a;
                r.push(s)
            }
            n.layers = r;
            var c = [];
            for (var i = 0; i < e.layers.length; i++) {
                if (e.layers[i].type !== "imagelayer") {
                    continue
                }
                var h = {
                    name: e.layers[i].name,
                    image: e.layers[i].image,
                    x: e.layers[i].x,
                    y: e.layers[i].y,
                    alpha: e.layers[i].opacity,
                    visible: e.layers[i].visible,
                    properties: {}
                };
                if (e.layers[i].properties) {
                    h.properties = e.layers[i].properties
                }
                c.push(h)
            }
            n.images = c;
            var p = [];
            for (var i = 0; i < e.tilesets.length; i++) {
                var d = e.tilesets[i];
                var v = new t.Tileset(d.name, d.firstgid, d.tilewidth, d.tileheight, d.margin, d.spacing, d.properties);
                if (d.tileproperties) {
                    v.tileProperties = d.tileproperties
                }
                v.rows = Math.round((d.imageheight - d.margin) / (d.tileheight + d.spacing));
                v.columns = Math.round((d.imagewidth - d.margin) / (d.tilewidth + d.spacing));
                v.total = v.rows * v.columns;
                if (v.rows % 1 !== 0 || v.columns % 1 !== 0) {
                    console.warn("TileSet image dimensions do not match expected dimensions. Tileset width/height must be evenly divisible by Tilemap tile width/height.")
                } else {
                    p.push(v)
                }
            }
            n.tilesets = p;
            var m = {};
            var g = {};
            for (var i = 0; i < e.layers.length; i++) {
                if (e.layers[i].type !== "objectgroup") {
                    continue
                }
                m[e.layers[i].name] = [];
                g[e.layers[i].name] = [];
                for (var b = 0, l = e.layers[i].objects.length; b < l; b++) {
                    if (e.layers[i].objects[b].gid) {
                        var w = {
                            gid: e.layers[i].objects[b].gid,
                            name: e.layers[i].objects[b].name,
                            x: e.layers[i].objects[b].x,
                            y: e.layers[i].objects[b].y,
                            visible: e.layers[i].objects[b].visible,
                            properties: e.layers[i].objects[b].properties
                        };
                        m[e.layers[i].name].push(w)
                    } else if (e.layers[i].objects[b].polyline) {
                        var w = {
                            name: e.layers[i].objects[b].name,
                            x: e.layers[i].objects[b].x,
                            y: e.layers[i].objects[b].y,
                            width: e.layers[i].objects[b].width,
                            height: e.layers[i].objects[b].height,
                            visible: e.layers[i].objects[b].visible,
                            properties: e.layers[i].objects[b].properties
                        };
                        w.polyline = [];
                        for (var E = 0; E < e.layers[i].objects[b].polyline.length; E++) {
                            w.polyline.push([e.layers[i].objects[b].polyline[E].x, e.layers[i].objects[b].polyline[E].y])
                        }
                        g[e.layers[i].name].push(w)
                    } else if (e.layers[i].objects[b].polygon) {
                        var w = y(e.layers[i].objects[b], ["name", "x", "y", "visible", "properties"]);
                        w.polygon = [];
                        for (var E = 0; E < e.layers[i].objects[b].polygon.length; E++) {
                            w.polygon.push([e.layers[i].objects[b].polygon[E].x, e.layers[i].objects[b].polygon[E].y])
                        }
                        m[e.layers[i].name].push(w)
                    } else if (e.layers[i].objects[b].ellipse) {
                        var w = y(e.layers[i].objects[b], ["name", "ellipse", "x", "y", "width", "height", "visible", "properties"]);
                        m[e.layers[i].name].push(w)
                    } else {
                        var w = y(e.layers[i].objects[b], ["name", "x", "y", "width", "height", "visible", "properties"]);
                        w.rectangle = true;
                        m[e.layers[i].name].push(w)
                    }
                }
            }
            n.objects = m;
            n.collision = g;
            n.tiles = [];
            for (var i = 0; i < n.tilesets.length; i++) {
                var d = n.tilesets[i];
                var o = d.tileMargin;
                var S = d.tileMargin;
                var x = 0;
                var T = 0;
                var N = 0;
                for (var f = d.firstgid; f < d.firstgid + d.total; f++) {
                    n.tiles[f] = [o, S, i];
                    o += d.tileWidth + d.tileSpacing;
                    x++;
                    if (x === d.total) {
                        break
                    }
                    T++;
                    if (T === d.columns) {
                        o = d.tileMargin;
                        S += d.tileHeight + d.tileSpacing;
                        T = 0;
                        N++;
                        if (N === d.rows) {
                            break
                        }
                    }
                }
            }
            return n
        }
    };
    t.Tileset = function(e, t, n, r, i, s, o) {
        if (typeof n === "undefined" || n <= 0) {
            n = 32
        }
        if (typeof r === "undefined" || r <= 0) {
            r = 32
        }
        if (typeof i === "undefined") {
            i = 0
        }
        if (typeof s === "undefined") {
            s = 0
        }
        this.name = e;
        this.firstgid = t;
        this.tileWidth = n;
        this.tileHeight = r;
        this.tileMargin = i;
        this.tileSpacing = s;
        this.properties = o;
        this.image = null;
        this.rows = 0;
        this.columns = 0;
        this.total = 0;
        this.drawCoords = []
    };
    t.Tileset.prototype = {
        draw: function(e, t, n, r) {
            if (!this.image || !this.drawCoords[r]) {
                return
            }
            e.drawImage(this.image, this.drawCoords[r][0], this.drawCoords[r][1], this.tileWidth, this.tileHeight, t, n, this.tileWidth, this.tileHeight)
        },
        setImage: function(e) {
            this.image = e;
            this.rows = Math.round((e.height - this.tileMargin) / (this.tileHeight + this.tileSpacing));
            this.columns = Math.round((e.width - this.tileMargin) / (this.tileWidth + this.tileSpacing));
            this.total = this.rows * this.columns;
            this.drawCoords.length = 0;
            var t = this.tileMargin;
            var n = this.tileMargin;
            var r = this.firstgid;
            for (var i = 0; i < this.rows; i++) {
                for (var s = 0; s < this.columns; s++) {
                    this.drawCoords[r] = [t, n];
                    t += this.tileWidth + this.tileSpacing;
                    r++
                }
                t = this.tileMargin;
                n += this.tileHeight + this.tileSpacing
            }
        },
        setSpacing: function(e, t) {
            this.tileMargin = e;
            this.tileSpacing = t;
            this.setImage(this.image)
        }
    };
    t.Tileset.prototype.constructor = t.Tileset;
    if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
            exports = module.exports = t
        }
        exports.Phaser = t
    } else if (typeof define !== "undefined" && define.amd) {
        define("Phaser", function() {
            return e.Phaser = t
        }())
    } else {
        e.Phaser = t
    }
}).call(this);
Phaser.Physics.Ninja = function(e) {
    this.game = e;
    this.time = this.game.time;
    this.gravity = .2;
    this.bounds = new Phaser.Rectangle(0, 0, e.world.width, e.world.height);
    this.maxObjects = 10;
    this.maxLevels = 4;
    this.quadTree = new Phaser.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels)
};
Phaser.Physics.Ninja.prototype.constructor = Phaser.Physics.Ninja;
Phaser.Physics.Ninja.prototype = {
    enableAABB: function(e, t) {
        this.enable(e, 1, 0, 0, t)
    },
    enableCircle: function(e, t, n) {
        this.enable(e, 2, 0, t, n)
    },
    enableTile: function(e, t, n) {
        this.enable(e, 3, t, 0, n)
    },
    enable: function(e, t, n, r, i) {
        if (typeof t === "undefined") {
            t = 1
        }
        if (typeof n === "undefined") {
            n = 1
        }
        if (typeof r === "undefined") {
            r = 0
        }
        if (typeof i === "undefined") {
            i = true
        }
        if (Array.isArray(e)) {
            var s = e.length;
            while (s--) {
                if (e[s] instanceof Phaser.Group) {
                    this.enable(e[s].children, t, n, r, i)
                } else {
                    this.enableBody(e[s], t, n, r);
                    if (i && e[s].hasOwnProperty("children") && e[s].children.length > 0) {
                        this.enable(e[s], t, n, r, true)
                    }
                }
            }
        } else {
            if (e instanceof Phaser.Group) {
                this.enable(e.children, t, n, r, i)
            } else {
                this.enableBody(e, t, n, r);
                if (i && e.hasOwnProperty("children") && e.children.length > 0) {
                    this.enable(e.children, t, n, r, true)
                }
            }
        }
    },
    enableBody: function(e, t, n, r) {
        if (e.hasOwnProperty("body") && e.body === null) {
            e.body = new Phaser.Physics.Ninja.Body(this, e, t, n, r);
            e.anchor.set(.5)
        }
    },
    setBounds: function(e, t, n, r) {
        this.bounds.setTo(e, t, n, r)
    },
    setBoundsToWorld: function() {
        this.bounds.setTo(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height)
    },
    clearTilemapLayerBodies: function(e, t) {
        t = e.getLayer(t);
        var n = e.layers[t].bodies.length;
        while (n--) {
            e.layers[t].bodies[n].destroy()
        }
        e.layers[t].bodies.length = []
    },
    convertTilemap: function(e, t, n) {
        t = e.getLayer(t);
        this.clearTilemapLayerBodies(e, t);
        for (var r = 0, i = e.layers[t].height; r < i; r++) {
            for (var s = 0, o = e.layers[t].width; s < o; s++) {
                var u = e.layers[t].data[r][s];
                if (u && n.hasOwnProperty(u.index)) {
                    var a = new Phaser.Physics.Ninja.Body(this, null, 3, n[u.index], 0, u.worldX + u.centerX, u.worldY + u.centerY, u.width, u.height);
                    e.layers[t].bodies.push(a)
                }
            }
        }
        return e.layers[t].bodies
    },
    overlap: function(e, t, n, r, i) {
        n = n || null;
        r = r || null;
        i = i || n;
        this._result = false;
        this._total = 0;
        if (Array.isArray(t)) {
            for (var s = 0, o = t.length; s < o; s++) {
                this.collideHandler(e, t[s], n, r, i, true)
            }
        } else {
            this.collideHandler(e, t, n, r, i, true)
        }
        return this._total > 0
    },
    collide: function(e, t, n, r, i) {
        n = n || null;
        r = r || null;
        i = i || n;
        this._result = false;
        this._total = 0;
        if (Array.isArray(t)) {
            for (var s = 0, o = t.length; s < o; s++) {
                this.collideHandler(e, t[s], n, r, i, false)
            }
        } else {
            this.collideHandler(e, t, n, r, i, false)
        }
        return this._total > 0
    },
    collideHandler: function(e, t, n, r, i, s) {
        if (typeof t === "undefined" && (e.type === Phaser.GROUP || e.type === Phaser.EMITTER)) {
            this.collideGroupVsSelf(e, n, r, i, s);
            return
        }
        if (e && t && e.exists && t.exists) {
            if (e.type == Phaser.SPRITE || e.type == Phaser.TILESPRITE) {
                if (t.type == Phaser.SPRITE || t.type == Phaser.TILESPRITE) {
                    this.collideSpriteVsSprite(e, t, n, r, i, s)
                } else if (t.type == Phaser.GROUP || t.type == Phaser.EMITTER) {
                    this.collideSpriteVsGroup(e, t, n, r, i, s)
                } else if (t.type == Phaser.TILEMAPLAYER) {
                    this.collideSpriteVsTilemapLayer(e, t, n, r, i)
                }
            } else if (e.type == Phaser.GROUP) {
                if (t.type == Phaser.SPRITE || t.type == Phaser.TILESPRITE) {
                    this.collideSpriteVsGroup(t, e, n, r, i, s)
                } else if (t.type == Phaser.GROUP || t.type == Phaser.EMITTER) {
                    this.collideGroupVsGroup(e, t, n, r, i, s)
                } else if (t.type == Phaser.TILEMAPLAYER) {
                    this.collideGroupVsTilemapLayer(e, t, n, r, i)
                }
            } else if (e.type == Phaser.TILEMAPLAYER) {
                if (t.type == Phaser.SPRITE || t.type == Phaser.TILESPRITE) {
                    this.collideSpriteVsTilemapLayer(t, e, n, r, i)
                } else if (t.type == Phaser.GROUP || t.type == Phaser.EMITTER) {
                    this.collideGroupVsTilemapLayer(t, e, n, r, i)
                }
            } else if (e.type == Phaser.EMITTER) {
                if (t.type == Phaser.SPRITE || t.type == Phaser.TILESPRITE) {
                    this.collideSpriteVsGroup(t, e, n, r, i, s)
                } else if (t.type == Phaser.GROUP || t.type == Phaser.EMITTER) {
                    this.collideGroupVsGroup(e, t, n, r, i, s)
                } else if (t.type == Phaser.TILEMAPLAYER) {
                    this.collideGroupVsTilemapLayer(e, t, n, r, i)
                }
            }
        }
    },
    collideSpriteVsSprite: function(e, t, n, r, i, s) {
        if (this.separate(e.body, t.body, r, i, s)) {
            if (n) {
                n.call(i, e, t)
            }
            this._total++
        }
    },
    collideSpriteVsGroup: function(e, t, n, r, i, s) {
        if (t.length === 0) {
            return
        }
        for (var o = 0, u = t.children.length; o < u; o++) {
            if (t.children[o].exists && t.children[o].body && this.separate(e.body, t.children[o].body, r, i, s)) {
                if (n) {
                    n.call(i, e, t.children[o])
                }
                this._total++
            }
        }
    },
    collideGroupVsSelf: function(e, t, n, r, i) {
        if (e.length === 0) {
            return
        }
        var s = e.children.length;
        for (var o = 0; o < s; o++) {
            for (var u = o + 1; u <= s; u++) {
                if (e.children[o] && e.children[u] && e.children[o].exists && e.children[u].exists) {
                    this.collideSpriteVsSprite(e.children[o], e.children[u], t, n, r, i)
                }
            }
        }
    },
    collideGroupVsGroup: function(e, t, n, r, i, s) {
        if (e.length === 0 || t.length === 0) {
            return
        }
        for (var o = 0, u = e.children.length; o < u; o++) {
            if (e.children[o].exists) {
                this.collideSpriteVsGroup(e.children[o], t, n, r, i, s)
            }
        }
    },
    separate: function(e, t) {
        if (e.type !== Phaser.Physics.NINJA || t.type !== Phaser.Physics.NINJA) {
            return false
        }
        if (e.aabb && t.aabb) {
            return e.aabb.collideAABBVsAABB(t.aabb)
        }
        if (e.aabb && t.tile) {
            return e.aabb.collideAABBVsTile(t.tile)
        }
        if (e.tile && t.aabb) {
            return t.aabb.collideAABBVsTile(e.tile)
        }
        if (e.circle && t.tile) {
            return e.circle.collideCircleVsTile(t.tile)
        }
        if (e.tile && t.circle) {
            return t.circle.collideCircleVsTile(e.tile)
        }
    }
};
Phaser.Physics.Ninja.Body = function(e, t, n, r, i, s, o, u, a) {
    t = t || null;
    if (typeof n === "undefined") {
        n = 1
    }
    if (typeof r === "undefined") {
        r = 1
    }
    if (typeof i === "undefined") {
        i = 16
    }
    this.sprite = t;
    this.game = e.game;
    this.type = Phaser.Physics.NINJA;
    this.system = e;
    this.aabb = null;
    this.tile = null;
    this.circle = null;
    this.shape = null;
    this.drag = 1;
    this.friction = .05;
    this.gravityScale = 1;
    this.bounce = .3;
    this.velocity = new Phaser.Point;
    this.facing = Phaser.NONE;
    this.immovable = false;
    this.collideWorldBounds = true;
    this.checkCollision = {
        none: false,
        any: true,
        up: true,
        down: true,
        left: true,
        right: true
    };
    this.touching = {
        none: true,
        up: false,
        down: false,
        left: false,
        right: false
    };
    this.wasTouching = {
        none: true,
        up: false,
        down: false,
        left: false,
        right: false
    };
    this.maxSpeed = 8;
    if (t) {
        s = t.x;
        o = t.y;
        u = t.width;
        a = t.height;
        if (t.anchor.x === 0) {
            s += t.width * .5
        }
        if (t.anchor.y === 0) {
            o += t.height * .5
        }
    }
    if (n === 1) {
        this.aabb = new Phaser.Physics.Ninja.AABB(this, s, o, u, a);
        this.shape = this.aabb
    } else if (n === 2) {
        this.circle = new Phaser.Physics.Ninja.Circle(this, s, o, i);
        this.shape = this.circle
    } else if (n === 3) {
        this.tile = new Phaser.Physics.Ninja.Tile(this, s, o, u, a, r);
        this.shape = this.tile
    }
};
Phaser.Physics.Ninja.Body.prototype = {
    preUpdate: function() {
        this.wasTouching.none = this.touching.none;
        this.wasTouching.up = this.touching.up;
        this.wasTouching.down = this.touching.down;
        this.wasTouching.left = this.touching.left;
        this.wasTouching.right = this.touching.right;
        this.touching.none = true;
        this.touching.up = false;
        this.touching.down = false;
        this.touching.left = false;
        this.touching.right = false;
        this.shape.integrate();
        if (this.collideWorldBounds) {
            this.shape.collideWorldBounds()
        }
    },
    postUpdate: function() {
        if (this.sprite) {
            if (this.sprite.type === Phaser.TILESPRITE) {
                this.sprite.x = this.shape.pos.x - this.shape.xw;
                this.sprite.y = this.shape.pos.y - this.shape.yw
            } else {
                this.sprite.x = this.shape.pos.x;
                this.sprite.y = this.shape.pos.y
            }
        }
        if (this.velocity.x < 0) {
            this.facing = Phaser.LEFT
        } else if (this.velocity.x > 0) {
            this.facing = Phaser.RIGHT
        }
        if (this.velocity.y < 0) {
            this.facing = Phaser.UP
        } else if (this.velocity.y > 0) {
            this.facing = Phaser.DOWN
        }
    },
    setZeroVelocity: function() {
        this.shape.oldpos.x = this.shape.pos.x;
        this.shape.oldpos.y = this.shape.pos.y
    },
    moveTo: function(e, t) {
        var n = e * this.game.time.physicsElapsed;
        var t = this.game.math.degToRad(t);
        this.shape.pos.x = this.shape.oldpos.x + n * Math.cos(t);
        this.shape.pos.y = this.shape.oldpos.y + n * Math.sin(t)
    },
    moveFrom: function(e, t) {
        var n = -e * this.game.time.physicsElapsed;
        var t = this.game.math.degToRad(t);
        this.shape.pos.x = this.shape.oldpos.x + n * Math.cos(t);
        this.shape.pos.y = this.shape.oldpos.y + n * Math.sin(t)
    },
    moveLeft: function(e) {
        var t = -e * this.game.time.physicsElapsed;
        this.shape.pos.x = this.shape.oldpos.x + Math.min(this.maxSpeed, Math.max(-this.maxSpeed, this.shape.pos.x - this.shape.oldpos.x + t))
    },
    moveRight: function(e) {
        var t = e * this.game.time.physicsElapsed;
        this.shape.pos.x = this.shape.oldpos.x + Math.min(this.maxSpeed, Math.max(-this.maxSpeed, this.shape.pos.x - this.shape.oldpos.x + t))
    },
    moveUp: function(e) {
        var t = -e * this.game.time.physicsElapsed;
        this.shape.pos.y = this.shape.oldpos.y + Math.min(this.maxSpeed, Math.max(-this.maxSpeed, this.shape.pos.y - this.shape.oldpos.y + t))
    },
    moveDown: function(e) {
        var t = e * this.game.time.physicsElapsed;
        this.shape.pos.y = this.shape.oldpos.y + Math.min(this.maxSpeed, Math.max(-this.maxSpeed, this.shape.pos.y - this.shape.oldpos.y + t))
    },
    reset: function() {
        this.velocity.set(0);
        this.shape.pos.x = this.sprite.x;
        this.shape.pos.y = this.sprite.y;
        this.shape.oldpos.copyFrom(this.shape.pos)
    },
    deltaAbsX: function() {
        return this.deltaX() > 0 ? this.deltaX() : -this.deltaX()
    },
    deltaAbsY: function() {
        return this.deltaY() > 0 ? this.deltaY() : -this.deltaY()
    },
    deltaX: function() {
        return this.shape.pos.x - this.shape.oldpos.x
    },
    deltaY: function() {
        return this.shape.pos.y - this.shape.oldpos.y
    },
    destroy: function() {
        this.sprite = null;
        this.system = null;
        this.aabb = null;
        this.tile = null;
        this.circle = null;
        this.shape.destroy();
        this.shape = null
    }
};
Object.defineProperty(Phaser.Physics.Ninja.Body.prototype, "x", {
    get: function() {
        return this.shape.pos.x
    },
    set: function(e) {
        this.shape.pos.x = e
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Body.prototype, "y", {
    get: function() {
        return this.shape.pos.y
    },
    set: function(e) {
        this.shape.pos.y = e
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Body.prototype, "width", {
    get: function() {
        return this.shape.width
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Body.prototype, "height", {
    get: function() {
        return this.shape.height
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Body.prototype, "bottom", {
    get: function() {
        return this.shape.pos.y + this.shape.yw
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Body.prototype, "right", {
    get: function() {
        return this.shape.pos.x + this.shape.xw
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Body.prototype, "speed", {
    get: function() {
        return Math.sqrt(this.shape.velocity.x * this.shape.velocity.x + this.shape.velocity.y * this.shape.velocity.y)
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Body.prototype, "angle", {
    get: function() {
        return Math.atan2(this.shape.velocity.y, this.shape.velocity.x)
    }
});
Phaser.Physics.Ninja.AABB = function(e, t, n, r, i) {
    this.body = e;
    this.system = e.system;
    this.pos = new Phaser.Point(t, n);
    this.oldpos = new Phaser.Point(t, n);
    this.xw = Math.abs(r / 2);
    this.yw = Math.abs(i / 2);
    this.width = r;
    this.height = i;
    this.oH = 0;
    this.oV = 0;
    this.velocity = new Phaser.Point;
    this.aabbTileProjections = {};
    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_FULL] = this.projAABB_Full;
    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_45DEG] = this.projAABB_45Deg;
    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_CONCAVE] = this.projAABB_Concave;
    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_CONVEX] = this.projAABB_Convex;
    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_22DEGs] = this.projAABB_22DegS;
    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_22DEGb] = this.projAABB_22DegB;
    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_67DEGs] = this.projAABB_67DegS;
    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_67DEGb] = this.projAABB_67DegB;
    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_HALF] = this.projAABB_Half
};
Phaser.Physics.Ninja.AABB.prototype.constructor = Phaser.Physics.Ninja.AABB;
Phaser.Physics.Ninja.AABB.COL_NONE = 0;
Phaser.Physics.Ninja.AABB.COL_AXIS = 1;
Phaser.Physics.Ninja.AABB.COL_OTHER = 2;
Phaser.Physics.Ninja.AABB.prototype = {
    integrate: function() {
        var e = this.pos.x;
        var t = this.pos.y;
        this.pos.x += this.body.drag * this.pos.x - this.body.drag * this.oldpos.x;
        this.pos.y += this.body.drag * this.pos.y - this.body.drag * this.oldpos.y + this.system.gravity * this.body.gravityScale;
        this.velocity.set(this.pos.x - e, this.pos.y - t);
        this.oldpos.set(e, t)
    },
    reportCollisionVsWorld: function(e, t, n, r) {
        var i = this.pos;
        var s = this.oldpos;
        var o = i.x - s.x;
        var u = i.y - s.y;
        var a = o * n + u * r;
        var f = a * n;
        var l = a * r;
        var c = o - f;
        var h = u - l;
        var p, d, v, m, g;
        if (a < 0) {
            m = c * this.body.friction;
            g = h * this.body.friction;
            p = 1 + this.body.bounce;
            d = f * p;
            v = l * p;
            if (n === 1) {
                this.body.touching.left = true
            } else if (n === -1) {
                this.body.touching.right = true
            }
            if (r === 1) {
                this.body.touching.up = true
            } else if (r === -1) {
                this.body.touching.down = true
            }
        } else {
            d = v = m = g = 0
        }
        i.x += e;
        i.y += t;
        s.x += e + d + m;
        s.y += t + v + g
    },
    reverse: function() {
        var e = this.pos.x - this.oldpos.x;
        var t = this.pos.y - this.oldpos.y;
        if (this.oldpos.x < this.pos.x) {
            this.oldpos.x = this.pos.x + e
        } else if (this.oldpos.x > this.pos.x) {
            this.oldpos.x = this.pos.x - e
        }
        if (this.oldpos.y < this.pos.y) {
            this.oldpos.y = this.pos.y + t
        } else if (this.oldpos.y > this.pos.y) {
            this.oldpos.y = this.pos.y - t
        }
    },
    reportCollisionVsBody: function(e, t, n, r, i) {
        var s = this.pos.x - this.oldpos.x;
        var o = this.pos.y - this.oldpos.y;
        var u = s * n + o * r;
        if (this.body.immovable && i.body.immovable) {
            e *= .5;
            t *= .5;
            this.pos.add(e, t);
            this.oldpos.set(this.pos.x, this.pos.y);
            i.pos.subtract(e, t);
            i.oldpos.set(i.pos.x, i.pos.y);
            return
        } else if (!this.body.immovable && !i.body.immovable) {
            e *= .5;
            t *= .5;
            this.pos.add(e, t);
            i.pos.subtract(e, t);
            if (u < 0) {
                this.reverse();
                i.reverse()
            }
        } else if (!this.body.immovable) {
            this.pos.subtract(e, t);
            if (u < 0) {
                this.reverse()
            }
        } else if (!i.body.immovable) {
            i.pos.subtract(e, t);
            if (u < 0) {
                i.reverse()
            }
        }
    },
    collideWorldBounds: function() {
        var e = this.system.bounds.x - (this.pos.x - this.xw);
        if (0 < e) {
            this.reportCollisionVsWorld(e, 0, 1, 0, null)
        } else {
            e = this.pos.x + this.xw - this.system.bounds.right;
            if (0 < e) {
                this.reportCollisionVsWorld(-e, 0, -1, 0, null)
            }
        }
        var t = this.system.bounds.y - (this.pos.y - this.yw);
        if (0 < t) {
            this.reportCollisionVsWorld(0, t, 0, 1, null)
        } else {
            t = this.pos.y + this.yw - this.system.bounds.bottom;
            if (0 < t) {
                this.reportCollisionVsWorld(0, -t, 0, -1, null)
            }
        }
    },
    collideAABBVsAABB: function(e) {
        var t = this.pos;
        var n = e;
        var r = n.pos.x;
        var i = n.pos.y;
        var s = n.xw;
        var o = n.yw;
        var u = t.x - r;
        var a = s + this.xw - Math.abs(u);
        if (0 < a) {
            var f = t.y - i;
            var l = o + this.yw - Math.abs(f);
            if (0 < l) {
                if (a < l) {
                    if (u < 0) {
                        a *= -1;
                        l = 0
                    } else {
                        l = 0
                    }
                } else {
                    if (f < 0) {
                        a = 0;
                        l *= -1
                    } else {
                        a = 0
                    }
                }
                var c = Math.sqrt(a * a + l * l);
                this.reportCollisionVsBody(a, l, a / c, l / c, n);
                return Phaser.Physics.Ninja.AABB.COL_AXIS
            }
        }
        return false
    },
    collideAABBVsTile: function(e) {
        var t = this.pos.x - e.pos.x;
        var n = e.xw + this.xw - Math.abs(t);
        if (0 < n) {
            var r = this.pos.y - e.pos.y;
            var i = e.yw + this.yw - Math.abs(r);
            if (0 < i) {
                if (n < i) {
                    if (t < 0) {
                        n *= -1;
                        i = 0
                    } else {
                        i = 0
                    }
                } else {
                    if (r < 0) {
                        n = 0;
                        i *= -1
                    } else {
                        n = 0
                    }
                }
                return this.resolveTile(n, i, this, e)
            }
        }
        return false
    },
    resolveTile: function(e, t, n, r) {
        if (0 < r.id) {
            return this.aabbTileProjections[r.type](e, t, n, r)
        } else {
            return false
        }
    },
    projAABB_Full: function(e, t, n, r) {
        var i = Math.sqrt(e * e + t * t);
        n.reportCollisionVsWorld(e, t, e / i, t / i, r);
        return Phaser.Physics.Ninja.AABB.COL_AXIS
    },
    projAABB_Half: function(e, t, n, r) {
        var i = r.signx;
        var s = r.signy;
        var o = n.pos.x - i * n.xw - r.pos.x;
        var u = n.pos.y - s * n.yw - r.pos.y;
        var a = o * i + u * s;
        if (a < 0) {
            i *= -a;
            s *= -a;
            var f = Math.sqrt(i * i + s * s);
            var l = Math.sqrt(e * e + t * t);
            if (l < f) {
                n.reportCollisionVsWorld(e, t, e / l, t / l, r);
                return Phaser.Physics.Ninja.AABB.COL_AXIS
            } else {
                n.reportCollisionVsWorld(i, s, r.signx, r.signy, r);
                return Phaser.Physics.Ninja.AABB.COL_OTHER
            }
        }
        return Phaser.Physics.Ninja.AABB.COL_NONE
    },
    projAABB_45Deg: function(e, t, n, r) {
        var i = r.signx;
        var s = r.signy;
        var o = n.pos.x - i * n.xw - r.pos.x;
        var u = n.pos.y - s * n.yw - r.pos.y;
        var a = r.sx;
        var f = r.sy;
        var l = o * a + u * f;
        if (l < 0) {
            a *= -l;
            f *= -l;
            var c = Math.sqrt(a * a + f * f);
            var h = Math.sqrt(e * e + t * t);
            if (h < c) {
                n.reportCollisionVsWorld(e, t, e / h, t / h, r);
                return Phaser.Physics.Ninja.AABB.COL_AXIS
            } else {
                n.reportCollisionVsWorld(a, f, r.sx, r.sy);
                return Phaser.Physics.Ninja.AABB.COL_OTHER
            }
        }
        return Phaser.Physics.Ninja.AABB.COL_NONE
    },
    projAABB_22DegS: function(e, t, n, r) {
        var i = r.signx;
        var s = r.signy;
        var o = n.pos.y - s * n.yw;
        var u = r.pos.y - o;
        if (0 < u * s) {
            var a = n.pos.x - i * n.xw - (r.pos.x + i * r.xw);
            var f = n.pos.y - s * n.yw - (r.pos.y - s * r.yw);
            var l = r.sx;
            var c = r.sy;
            var h = a * l + f * c;
            if (h < 0) {
                l *= -h;
                c *= -h;
                var p = Math.sqrt(l * l + c * c);
                var d = Math.sqrt(e * e + t * t);
                var v = Math.abs(u);
                if (d < p) {
                    if (v < d) {
                        n.reportCollisionVsWorld(0, u, 0, u / v, r);
                        return Phaser.Physics.Ninja.AABB.COL_OTHER
                    } else {
                        n.reportCollisionVsWorld(e, t, e / d, t / d, r);
                        return Phaser.Physics.Ninja.AABB.COL_AXIS
                    }
                } else {
                    if (v < p) {
                        n.reportCollisionVsWorld(0, u, 0, u / v, r);
                        return Phaser.Physics.Ninja.AABB.COL_OTHER
                    } else {
                        n.reportCollisionVsWorld(l, c, r.sx, r.sy, r);
                        return Phaser.Physics.Ninja.AABB.COL_OTHER
                    }
                }
            }
        }
        return Phaser.Physics.Ninja.AABB.COL_NONE
    },
    projAABB_22DegB: function(e, t, n, r) {
        var i = r.signx;
        var s = r.signy;
        var o = n.pos.x - i * n.xw - (r.pos.x - i * r.xw);
        var u = n.pos.y - s * n.yw - (r.pos.y + s * r.yw);
        var a = r.sx;
        var f = r.sy;
        var l = o * a + u * f;
        if (l < 0) {
            a *= -l;
            f *= -l;
            var c = Math.sqrt(a * a + f * f);
            var h = Math.sqrt(e * e + t * t);
            if (h < c) {
                n.reportCollisionVsWorld(e, t, e / h, t / h, r);
                return Phaser.Physics.Ninja.AABB.COL_AXIS
            } else {
                n.reportCollisionVsWorld(a, f, r.sx, r.sy, r);
                return Phaser.Physics.Ninja.AABB.COL_OTHER
            }
        }
        return Phaser.Physics.Ninja.AABB.COL_NONE
    },
    projAABB_67DegS: function(e, t, n, r) {
        var i = r.signx;
        var s = r.signy;
        var o = n.pos.x - i * n.xw;
        var u = r.pos.x - o;
        if (0 < u * i) {
            var a = n.pos.x - i * n.xw - (r.pos.x - i * r.xw);
            var f = n.pos.y - s * n.yw - (r.pos.y + s * r.yw);
            var l = r.sx;
            var c = r.sy;
            var h = a * l + f * c;
            if (h < 0) {
                l *= -h;
                c *= -h;
                var p = Math.sqrt(l * l + c * c);
                var d = Math.sqrt(e * e + t * t);
                var v = Math.abs(u);
                if (d < p) {
                    if (v < d) {
                        n.reportCollisionVsWorld(u, 0, u / v, 0, r);
                        return Phaser.Physics.Ninja.AABB.COL_OTHER
                    } else {
                        n.reportCollisionVsWorld(e, t, e / d, t / d, r);
                        return Phaser.Physics.Ninja.AABB.COL_AXIS
                    }
                } else {
                    if (v < p) {
                        n.reportCollisionVsWorld(u, 0, u / v, 0, r);
                        return Phaser.Physics.Ninja.AABB.COL_OTHER
                    } else {
                        n.reportCollisionVsWorld(l, c, r.sx, r.sy, r);
                        return Phaser.Physics.Ninja.AABB.COL_OTHER
                    }
                }
            }
        }
        return Phaser.Physics.Ninja.AABB.COL_NONE
    },
    projAABB_67DegB: function(e, t, n, r) {
        var i = r.signx;
        var s = r.signy;
        var o = n.pos.x - i * n.xw - (r.pos.x + i * r.xw);
        var u = n.pos.y - s * n.yw - (r.pos.y - s * r.yw);
        var a = r.sx;
        var f = r.sy;
        var l = o * a + u * f;
        if (l < 0) {
            a *= -l;
            f *= -l;
            var c = Math.sqrt(a * a + f * f);
            var h = Math.sqrt(e * e + t * t);
            if (h < c) {
                n.reportCollisionVsWorld(e, t, e / h, t / h, r);
                return Phaser.Physics.Ninja.AABB.COL_AXIS
            } else {
                n.reportCollisionVsWorld(a, f, r.sx, r.sy, r);
                return Phaser.Physics.Ninja.AABB.COL_OTHER
            }
        }
        return Phaser.Physics.Ninja.AABB.COL_NONE
    },
    projAABB_Convex: function(e, t, n, r) {
        var i = r.signx;
        var s = r.signy;
        var o = n.pos.x - i * n.xw - (r.pos.x - i * r.xw);
        var u = n.pos.y - s * n.yw - (r.pos.y - s * r.yw);
        var a = Math.sqrt(o * o + u * u);
        var f = r.xw * 2;
        var l = Math.sqrt(f * f + 0);
        var c = l - a;
        if (i * o < 0 || s * u < 0) {
            var h = Math.sqrt(e * e + t * t);
            n.reportCollisionVsWorld(e, t, e / h, t / h, r);
            return Phaser.Physics.Ninja.AABB.COL_AXIS
        } else if (0 < c) {
            o /= a;
            u /= a;
            n.reportCollisionVsWorld(o * c, u * c, o, u, r);
            return Phaser.Physics.Ninja.AABB.COL_OTHER
        }
        return Phaser.Physics.Ninja.AABB.COL_NONE
    },
    projAABB_Concave: function(e, t, n, r) {
        var i = r.signx;
        var s = r.signy;
        var o = r.pos.x + i * r.xw - (n.pos.x - i * n.xw);
        var u = r.pos.y + s * r.yw - (n.pos.y - s * n.yw);
        var a = r.xw * 2;
        var f = Math.sqrt(a * a + 0);
        var l = Math.sqrt(o * o + u * u);
        var c = l - f;
        if (0 < c) {
            var h = Math.sqrt(e * e + t * t);
            if (h < c) {
                n.reportCollisionVsWorld(e, t, e / h, t / h, r);
                return Phaser.Physics.Ninja.AABB.COL_AXIS
            } else {
                o /= l;
                u /= l;
                n.reportCollisionVsWorld(o * c, u * c, o, u, r);
                return Phaser.Physics.Ninja.AABB.COL_OTHER
            }
        }
        return Phaser.Physics.Ninja.AABB.COL_NONE
    },
    destroy: function() {
        this.body = null;
        this.system = null
    }
};
Phaser.Physics.Ninja.Tile = function(e, t, n, r, i, s) {
    if (typeof s === "undefined") {
        s = Phaser.Physics.Ninja.Tile.EMPTY
    }
    this.body = e;
    this.system = e.system;
    this.id = s;
    this.type = Phaser.Physics.Ninja.Tile.TYPE_EMPTY;
    this.pos = new Phaser.Point(t, n);
    this.oldpos = new Phaser.Point(t, n);
    if (this.id > 1 && this.id < 30) {
        i = r
    }
    this.xw = Math.abs(r / 2);
    this.yw = Math.abs(i / 2);
    this.width = r;
    this.height = i;
    this.velocity = new Phaser.Point;
    this.signx = 0;
    this.signy = 0;
    this.sx = 0;
    this.sy = 0;
    this.body.gravityScale = 0;
    this.body.collideWorldBounds = false;
    if (this.id > 0) {
        this.setType(this.id)
    }
};
Phaser.Physics.Ninja.Tile.prototype.constructor = Phaser.Physics.Ninja.Tile;
Phaser.Physics.Ninja.Tile.prototype = {
    integrate: function() {
        var e = this.pos.x;
        var t = this.pos.y;
        this.pos.x += this.body.drag * this.pos.x - this.body.drag * this.oldpos.x;
        this.pos.y += this.body.drag * this.pos.y - this.body.drag * this.oldpos.y + this.system.gravity * this.body.gravityScale;
        this.velocity.set(this.pos.x - e, this.pos.y - t);
        this.oldpos.set(e, t)
    },
    collideWorldBounds: function() {
        var e = this.system.bounds.x - (this.pos.x - this.xw);
        if (0 < e) {
            this.reportCollisionVsWorld(e, 0, 1, 0, null)
        } else {
            e = this.pos.x + this.xw - this.system.bounds.right;
            if (0 < e) {
                this.reportCollisionVsWorld(-e, 0, -1, 0, null)
            }
        }
        var t = this.system.bounds.y - (this.pos.y - this.yw);
        if (0 < t) {
            this.reportCollisionVsWorld(0, t, 0, 1, null)
        } else {
            t = this.pos.y + this.yw - this.system.bounds.bottom;
            if (0 < t) {
                this.reportCollisionVsWorld(0, -t, 0, -1, null)
            }
        }
    },
    reportCollisionVsWorld: function(e, t, n, r) {
        var i = this.pos;
        var s = this.oldpos;
        var o = i.x - s.x;
        var u = i.y - s.y;
        var a = o * n + u * r;
        var f = a * n;
        var l = a * r;
        var c = o - f;
        var h = u - l;
        var p, d, v, m, g;
        if (a < 0) {
            m = c * this.body.friction;
            g = h * this.body.friction;
            p = 1 + this.body.bounce;
            d = f * p;
            v = l * p;
            if (n === 1) {
                this.body.touching.left = true
            } else if (n === -1) {
                this.body.touching.right = true
            }
            if (r === 1) {
                this.body.touching.up = true
            } else if (r === -1) {
                this.body.touching.down = true
            }
        } else {
            d = v = m = g = 0
        }
        i.x += e;
        i.y += t;
        s.x += e + d + m;
        s.y += t + v + g
    },
    setType: function(e) {
        if (e === Phaser.Physics.Ninja.Tile.EMPTY) {
            this.clear()
        } else {
            this.id = e;
            this.updateType()
        }
        return this
    },
    clear: function() {
        this.id = Phaser.Physics.Ninja.Tile.EMPTY;
        this.updateType()
    },
    destroy: function() {
        this.body = null;
        this.system = null
    },
    updateType: function() {
        if (this.id === 0) {
            this.type = Phaser.Physics.Ninja.Tile.TYPE_EMPTY;
            this.signx = 0;
            this.signy = 0;
            this.sx = 0;
            this.sy = 0;
            return true
        }
        if (this.id < Phaser.Physics.Ninja.Tile.TYPE_45DEG) {
            this.type = Phaser.Physics.Ninja.Tile.TYPE_FULL;
            this.signx = 0;
            this.signy = 0;
            this.sx = 0;
            this.sy = 0
        } else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_CONCAVE) {
            this.type = Phaser.Physics.Ninja.Tile.TYPE_45DEG;
            if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_45DEGpn) {
                this.signx = 1;
                this.signy = -1;
                this.sx = this.signx / Math.SQRT2;
                this.sy = this.signy / Math.SQRT2
            } else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_45DEGnn) {
                this.signx = -1;
                this.signy = -1;
                this.sx = this.signx / Math.SQRT2;
                this.sy = this.signy / Math.SQRT2
            } else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_45DEGnp) {
                this.signx = -1;
                this.signy = 1;
                this.sx = this.signx / Math.SQRT2;
                this.sy = this.signy / Math.SQRT2
            } else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_45DEGpp) {
                this.signx = 1;
                this.signy = 1;
                this.sx = this.signx / Math.SQRT2;
                this.sy = this.signy / Math.SQRT2
            } else {
                return false
            }
        } else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_CONVEX) {
            this.type = Phaser.Physics.Ninja.Tile.TYPE_CONCAVE;
            if (this.id == Phaser.Physics.Ninja.Tile.CONCAVEpn) {
                this.signx = 1;
                this.signy = -1;
                this.sx = 0;
                this.sy = 0
            } else if (this.id == Phaser.Physics.Ninja.Tile.CONCAVEnn) {
                this.signx = -1;
                this.signy = -1;
                this.sx = 0;
                this.sy = 0
            } else if (this.id == Phaser.Physics.Ninja.Tile.CONCAVEnp) {
                this.signx = -1;
                this.signy = 1;
                this.sx = 0;
                this.sy = 0
            } else if (this.id == Phaser.Physics.Ninja.Tile.CONCAVEpp) {
                this.signx = 1;
                this.signy = 1;
                this.sx = 0;
                this.sy = 0
            } else {
                return false
            }
        } else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_22DEGs) {
            this.type = Phaser.Physics.Ninja.Tile.TYPE_CONVEX;
            if (this.id == Phaser.Physics.Ninja.Tile.CONVEXpn) {
                this.signx = 1;
                this.signy = -1;
                this.sx = 0;
                this.sy = 0
            } else if (this.id == Phaser.Physics.Ninja.Tile.CONVEXnn) {
                this.signx = -1;
                this.signy = -1;
                this.sx = 0;
                this.sy = 0
            } else if (this.id == Phaser.Physics.Ninja.Tile.CONVEXnp) {
                this.signx = -1;
                this.signy = 1;
                this.sx = 0;
                this.sy = 0
            } else if (this.id == Phaser.Physics.Ninja.Tile.CONVEXpp) {
                this.signx = 1;
                this.signy = 1;
                this.sx = 0;
                this.sy = 0
            } else {
                return false
            }
        } else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_22DEGb) {
            this.type = Phaser.Physics.Ninja.Tile.TYPE_22DEGs;
            if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGpnS) {
                this.signx = 1;
                this.signy = -1;
                var e = Math.sqrt(2 * 2 + 1 * 1);
                this.sx = this.signx * 1 / e;
                this.sy = this.signy * 2 / e
            } else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGnnS) {
                this.signx = -1;
                this.signy = -1;
                var e = Math.sqrt(2 * 2 + 1 * 1);
                this.sx = this.signx * 1 / e;
                this.sy = this.signy * 2 / e
            } else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGnpS) {
                this.signx = -1;
                this.signy = 1;
                var e = Math.sqrt(2 * 2 + 1 * 1);
                this.sx = this.signx * 1 / e;
                this.sy = this.signy * 2 / e
            } else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGppS) {
                this.signx = 1;
                this.signy = 1;
                var e = Math.sqrt(2 * 2 + 1 * 1);
                this.sx = this.signx * 1 / e;
                this.sy = this.signy * 2 / e
            } else {
                return false
            }
        } else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_67DEGs) {
            this.type = Phaser.Physics.Ninja.Tile.TYPE_22DEGb;
            if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGpnB) {
                this.signx = 1;
                this.signy = -1;
                var e = Math.sqrt(2 * 2 + 1 * 1);
                this.sx = this.signx * 1 / e;
                this.sy = this.signy * 2 / e
            } else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGnnB) {
                this.signx = -1;
                this.signy = -1;
                var e = Math.sqrt(2 * 2 + 1 * 1);
                this.sx = this.signx * 1 / e;
                this.sy = this.signy * 2 / e
            } else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGnpB) {
                this.signx = -1;
                this.signy = 1;
                var e = Math.sqrt(2 * 2 + 1 * 1);
                this.sx = this.signx * 1 / e;
                this.sy = this.signy * 2 / e
            } else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGppB) {
                this.signx = 1;
                this.signy = 1;
                var e = Math.sqrt(2 * 2 + 1 * 1);
                this.sx = this.signx * 1 / e;
                this.sy = this.signy * 2 / e
            } else {
                return false
            }
        } else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_67DEGb) {
            this.type = Phaser.Physics.Ninja.Tile.TYPE_67DEGs;
            if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGpnS) {
                this.signx = 1;
                this.signy = -1;
                var e = Math.sqrt(2 * 2 + 1 * 1);
                this.sx = this.signx * 2 / e;
                this.sy = this.signy * 1 / e
            } else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGnnS) {
                this.signx = -1;
                this.signy = -1;
                var e = Math.sqrt(2 * 2 + 1 * 1);
                this.sx = this.signx * 2 / e;
                this.sy = this.signy * 1 / e
            } else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGnpS) {
                this.signx = -1;
                this.signy = 1;
                var e = Math.sqrt(2 * 2 + 1 * 1);
                this.sx = this.signx * 2 / e;
                this.sy = this.signy * 1 / e
            } else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGppS) {
                this.signx = 1;
                this.signy = 1;
                var e = Math.sqrt(2 * 2 + 1 * 1);
                this.sx = this.signx * 2 / e;
                this.sy = this.signy * 1 / e
            } else {
                return false
            }
        } else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_HALF) {
            this.type = Phaser.Physics.Ninja.Tile.TYPE_67DEGb;
            if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGpnB) {
                this.signx = 1;
                this.signy = -1;
                var e = Math.sqrt(2 * 2 + 1 * 1);
                this.sx = this.signx * 2 / e;
                this.sy = this.signy * 1 / e
            } else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGnnB) {
                this.signx = -1;
                this.signy = -1;
                var e = Math.sqrt(2 * 2 + 1 * 1);
                this.sx = this.signx * 2 / e;
                this.sy = this.signy * 1 / e
            } else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGnpB) {
                this.signx = -1;
                this.signy = 1;
                var e = Math.sqrt(2 * 2 + 1 * 1);
                this.sx = this.signx * 2 / e;
                this.sy = this.signy * 1 / e
            } else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGppB) {
                this.signx = 1;
                this.signy = 1;
                var e = Math.sqrt(2 * 2 + 1 * 1);
                this.sx = this.signx * 2 / e;
                this.sy = this.signy * 1 / e
            } else {
                return false
            }
        } else {
            this.type = Phaser.Physics.Ninja.Tile.TYPE_HALF;
            if (this.id == Phaser.Physics.Ninja.Tile.HALFd) {
                this.signx = 0;
                this.signy = -1;
                this.sx = this.signx;
                this.sy = this.signy
            } else if (this.id == Phaser.Physics.Ninja.Tile.HALFu) {
                this.signx = 0;
                this.signy = 1;
                this.sx = this.signx;
                this.sy = this.signy
            } else if (this.id == Phaser.Physics.Ninja.Tile.HALFl) {
                this.signx = 1;
                this.signy = 0;
                this.sx = this.signx;
                this.sy = this.signy
            } else if (this.id == Phaser.Physics.Ninja.Tile.HALFr) {
                this.signx = -1;
                this.signy = 0;
                this.sx = this.signx;
                this.sy = this.signy
            } else {
                return false
            }
        }
    }
};
Object.defineProperty(Phaser.Physics.Ninja.Tile.prototype, "x", {
    get: function() {
        return this.pos.x - this.xw
    },
    set: function(e) {
        this.pos.x = e
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Tile.prototype, "y", {
    get: function() {
        return this.pos.y - this.yw
    },
    set: function(e) {
        this.pos.y = e
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Tile.prototype, "bottom", {
    get: function() {
        return this.pos.y + this.yw
    }
});
Object.defineProperty(Phaser.Physics.Ninja.Tile.prototype, "right", {
    get: function() {
        return this.pos.x + this.xw
    }
});
Phaser.Physics.Ninja.Tile.EMPTY = 0;
Phaser.Physics.Ninja.Tile.FULL = 1;
Phaser.Physics.Ninja.Tile.SLOPE_45DEGpn = 2;
Phaser.Physics.Ninja.Tile.SLOPE_45DEGnn = 3;
Phaser.Physics.Ninja.Tile.SLOPE_45DEGnp = 4;
Phaser.Physics.Ninja.Tile.SLOPE_45DEGpp = 5;
Phaser.Physics.Ninja.Tile.CONCAVEpn = 6;
Phaser.Physics.Ninja.Tile.CONCAVEnn = 7;
Phaser.Physics.Ninja.Tile.CONCAVEnp = 8;
Phaser.Physics.Ninja.Tile.CONCAVEpp = 9;
Phaser.Physics.Ninja.Tile.CONVEXpn = 10;
Phaser.Physics.Ninja.Tile.CONVEXnn = 11;
Phaser.Physics.Ninja.Tile.CONVEXnp = 12;
Phaser.Physics.Ninja.Tile.CONVEXpp = 13;
Phaser.Physics.Ninja.Tile.SLOPE_22DEGpnS = 14;
Phaser.Physics.Ninja.Tile.SLOPE_22DEGnnS = 15;
Phaser.Physics.Ninja.Tile.SLOPE_22DEGnpS = 16;
Phaser.Physics.Ninja.Tile.SLOPE_22DEGppS = 17;
Phaser.Physics.Ninja.Tile.SLOPE_22DEGpnB = 18;
Phaser.Physics.Ninja.Tile.SLOPE_22DEGnnB = 19;
Phaser.Physics.Ninja.Tile.SLOPE_22DEGnpB = 20;
Phaser.Physics.Ninja.Tile.SLOPE_22DEGppB = 21;
Phaser.Physics.Ninja.Tile.SLOPE_67DEGpnS = 22;
Phaser.Physics.Ninja.Tile.SLOPE_67DEGnnS = 23;
Phaser.Physics.Ninja.Tile.SLOPE_67DEGnpS = 24;
Phaser.Physics.Ninja.Tile.SLOPE_67DEGppS = 25;
Phaser.Physics.Ninja.Tile.SLOPE_67DEGpnB = 26;
Phaser.Physics.Ninja.Tile.SLOPE_67DEGnnB = 27;
Phaser.Physics.Ninja.Tile.SLOPE_67DEGnpB = 28;
Phaser.Physics.Ninja.Tile.SLOPE_67DEGppB = 29;
Phaser.Physics.Ninja.Tile.HALFd = 30;
Phaser.Physics.Ninja.Tile.HALFr = 31;
Phaser.Physics.Ninja.Tile.HALFu = 32;
Phaser.Physics.Ninja.Tile.HALFl = 33;
Phaser.Physics.Ninja.Tile.TYPE_EMPTY = 0;
Phaser.Physics.Ninja.Tile.TYPE_FULL = 1;
Phaser.Physics.Ninja.Tile.TYPE_45DEG = 2;
Phaser.Physics.Ninja.Tile.TYPE_CONCAVE = 6;
Phaser.Physics.Ninja.Tile.TYPE_CONVEX = 10;
Phaser.Physics.Ninja.Tile.TYPE_22DEGs = 14;
Phaser.Physics.Ninja.Tile.TYPE_22DEGb = 18;
Phaser.Physics.Ninja.Tile.TYPE_67DEGs = 22;
Phaser.Physics.Ninja.Tile.TYPE_67DEGb = 26;
Phaser.Physics.Ninja.Tile.TYPE_HALF = 30;
Phaser.Physics.Ninja.Circle = function(e, t, n, r) {
    this.body = e;
    this.system = e.system;
    this.pos = new Phaser.Point(t, n);
    this.oldpos = new Phaser.Point(t, n);
    this.radius = r;
    this.xw = r;
    this.yw = r;
    this.width = r * 2;
    this.height = r * 2;
    this.oH = 0;
    this.oV = 0;
    this.velocity = new Phaser.Point;
    this.circleTileProjections = {};
    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_FULL] = this.projCircle_Full;
    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_45DEG] = this.projCircle_45Deg;
    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_CONCAVE] = this.projCircle_Concave;
    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_CONVEX] = this.projCircle_Convex;
    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_22DEGs] = this.projCircle_22DegS;
    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_22DEGb] = this.projCircle_22DegB;
    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_67DEGs] = this.projCircle_67DegS;
    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_67DEGb] = this.projCircle_67DegB;
    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_HALF] = this.projCircle_Half
};
Phaser.Physics.Ninja.Circle.prototype.constructor = Phaser.Physics.Ninja.Circle;
Phaser.Physics.Ninja.Circle.COL_NONE = 0;
Phaser.Physics.Ninja.Circle.COL_AXIS = 1;
Phaser.Physics.Ninja.Circle.COL_OTHER = 2;
Phaser.Physics.Ninja.Circle.prototype = {
    integrate: function() {
        var e = this.pos.x;
        var t = this.pos.y;
        this.pos.x += this.body.drag * this.pos.x - this.body.drag * this.oldpos.x;
        this.pos.y += this.body.drag * this.pos.y - this.body.drag * this.oldpos.y + this.system.gravity * this.body.gravityScale;
        this.velocity.set(this.pos.x - e, this.pos.y - t);
        this.oldpos.set(e, t)
    },
    reportCollisionVsWorld: function(e, t, n, r) {
        var i = this.pos;
        var s = this.oldpos;
        var o = i.x - s.x;
        var u = i.y - s.y;
        var a = o * n + u * r;
        var f = a * n;
        var l = a * r;
        var c = o - f;
        var h = u - l;
        var p, d, v, m, g;
        if (a < 0) {
            m = c * this.body.friction;
            g = h * this.body.friction;
            p = 1 + this.body.bounce;
            d = f * p;
            v = l * p;
            if (n === 1) {
                this.body.touching.left = true
            } else if (n === -1) {
                this.body.touching.right = true
            }
            if (r === 1) {
                this.body.touching.up = true
            } else if (r === -1) {
                this.body.touching.down = true
            }
        } else {
            d = v = m = g = 0
        }
        i.x += e;
        i.y += t;
        s.x += e + d + m;
        s.y += t + v + g
    },
    collideWorldBounds: function() {
        var e = this.system.bounds.x - (this.pos.x - this.radius);
        if (0 < e) {
            this.reportCollisionVsWorld(e, 0, 1, 0, null)
        } else {
            e = this.pos.x + this.radius - this.system.bounds.right;
            if (0 < e) {
                this.reportCollisionVsWorld(-e, 0, -1, 0, null)
            }
        }
        var t = this.system.bounds.y - (this.pos.y - this.radius);
        if (0 < t) {
            this.reportCollisionVsWorld(0, t, 0, 1, null)
        } else {
            t = this.pos.y + this.radius - this.system.bounds.bottom;
            if (0 < t) {
                this.reportCollisionVsWorld(0, -t, 0, -1, null)
            }
        }
    },
    collideCircleVsTile: function(e) {
        var t = this.pos;
        var n = this.radius;
        var r = e;
        var i = r.pos.x;
        var s = r.pos.y;
        var o = r.xw;
        var u = r.yw;
        var a = t.x - i;
        var f = o + n - Math.abs(a);
        if (0 < f) {
            var l = t.y - s;
            var c = u + n - Math.abs(l);
            if (0 < c) {
                this.oH = 0;
                this.oV = 0;
                if (a < -o) {
                    this.oH = -1
                } else if (o < a) {
                    this.oH = 1
                }
                if (l < -u) {
                    this.oV = -1
                } else if (u < l) {
                    this.oV = 1
                }
                return this.resolveCircleTile(f, c, this.oH, this.oV, this, r)
            }
        }
    },
    resolveCircleTile: function(e, t, n, r, i, s) {
        if (0 < s.id) {
            return this.circleTileProjections[s.type](e, t, n, r, i, s)
        } else {
            return false
        }
    },
    projCircle_Full: function(e, t, n, r, i, s) {
        if (n === 0) {
            if (r === 0) {
                if (e < t) {
                    var o = i.pos.x - s.pos.x;
                    if (o < 0) {
                        i.reportCollisionVsWorld(-e, 0, -1, 0, s);
                        return Phaser.Physics.Ninja.Circle.COL_AXIS
                    } else {
                        i.reportCollisionVsWorld(e, 0, 1, 0, s);
                        return Phaser.Physics.Ninja.Circle.COL_AXIS
                    }
                } else {
                    var u = i.pos.y - s.pos.y;
                    if (u < 0) {
                        i.reportCollisionVsWorld(0, -t, 0, -1, s);
                        return Phaser.Physics.Ninja.Circle.COL_AXIS
                    } else {
                        i.reportCollisionVsWorld(0, t, 0, 1, s);
                        return Phaser.Physics.Ninja.Circle.COL_AXIS
                    }
                }
            } else {
                i.reportCollisionVsWorld(0, t * r, 0, r, s);
                return Phaser.Physics.Ninja.Circle.COL_AXIS
            }
        } else if (r === 0) {
            i.reportCollisionVsWorld(e * n, 0, n, 0, s);
            return Phaser.Physics.Ninja.Circle.COL_AXIS
        } else {
            var a = s.pos.x + n * s.xw;
            var f = s.pos.y + r * s.yw;
            var o = i.pos.x - a;
            var u = i.pos.y - f;
            var l = Math.sqrt(o * o + u * u);
            var c = i.radius - l;
            if (0 < c) {
                if (l === 0) {
                    o = n / Math.SQRT2;
                    u = r / Math.SQRT2
                } else {
                    o /= l;
                    u /= l
                }
                i.reportCollisionVsWorld(o * c, u * c, o, u, s);
                return Phaser.Physics.Ninja.Circle.COL_OTHER
            }
        }
        return Phaser.Physics.Ninja.Circle.COL_NONE
    },
    projCircle_45Deg: function(e, t, n, r, i, s) {
        var o = s.signx;
        var u = s.signy;
        var a;
        if (n === 0) {
            if (r === 0) {
                var f = s.sx;
                var l = s.sy;
                var c = i.pos.x - f * i.radius - s.pos.x;
                var h = i.pos.y - l * i.radius - s.pos.y;
                var p = c * f + h * l;
                if (p < 0) {
                    f *= -p;
                    l *= -p;
                    if (e < t) {
                        a = e;
                        t = 0;
                        if (i.pos.x - s.pos.x < 0) {
                            e *= -1
                        }
                    } else {
                        a = t;
                        e = 0;
                        if (i.pos.y - s.pos.y < 0) {
                            t *= -1
                        }
                    }
                    var d = Math.sqrt(f * f + l * l);
                    if (a < d) {
                        i.reportCollisionVsWorld(e, t, e / a, t / a, s);
                        return Phaser.Physics.Ninja.Circle.COL_AXIS
                    } else {
                        i.reportCollisionVsWorld(f, l, s.sx, s.sy, s);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                }
            } else {
                if (u * r < 0) {
                    i.reportCollisionVsWorld(0, t * r, 0, r, s);
                    return Phaser.Physics.Ninja.Circle.COL_AXIS
                } else {
                    var f = s.sx;
                    var l = s.sy;
                    var c = i.pos.x - (s.pos.x - o * s.xw);
                    var h = i.pos.y - (s.pos.y + r * s.yw);
                    var v = c * -l + h * f;
                    if (0 < v * o * u) {
                        var m = Math.sqrt(c * c + h * h);
                        var g = i.radius - m;
                        if (0 < g) {
                            c /= m;
                            h /= m;
                            i.reportCollisionVsWorld(c * g, h * g, c, h, s);
                            return Phaser.Physics.Ninja.Circle.COL_OTHER
                        }
                    } else {
                        var p = c * f + h * l;
                        var g = i.radius - Math.abs(p);
                        if (0 < g) {
                            i.reportCollisionVsWorld(f * g, l * g, f, l, s);
                            return Phaser.Physics.Ninja.Circle.COL_OTHER
                        }
                    }
                }
            }
        } else if (r === 0) {
            if (o * n < 0) {
                i.reportCollisionVsWorld(e * n, 0, n, 0, s);
                return Phaser.Physics.Ninja.Circle.COL_AXIS
            } else {
                var f = s.sx;
                var l = s.sy;
                var c = i.pos.x - (s.pos.x + n * s.xw);
                var h = i.pos.y - (s.pos.y - u * s.yw);
                var v = c * -l + h * f;
                if (v * o * u < 0) {
                    var m = Math.sqrt(c * c + h * h);
                    var g = i.radius - m;
                    if (0 < g) {
                        c /= m;
                        h /= m;
                        i.reportCollisionVsWorld(c * g, h * g, c, h, s);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                } else {
                    var p = c * f + h * l;
                    var g = i.radius - Math.abs(p);
                    if (0 < g) {
                        i.reportCollisionVsWorld(f * g, l * g, f, l, s);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                }
            }
        } else {
            if (0 < o * n + u * r) {
                return Phaser.Physics.Ninja.Circle.COL_NONE
            } else {
                var y = s.pos.x + n * s.xw;
                var b = s.pos.y + r * s.yw;
                var w = i.pos.x - y;
                var E = i.pos.y - b;
                var m = Math.sqrt(w * w + E * E);
                var g = i.radius - m;
                if (0 < g) {
                    if (m === 0) {
                        w = n / Math.SQRT2;
                        E = r / Math.SQRT2
                    } else {
                        w /= m;
                        E /= m
                    }
                    i.reportCollisionVsWorld(w * g, E * g, w, E, s);
                    return Phaser.Physics.Ninja.Circle.COL_OTHER
                }
            }
        }
        return Phaser.Physics.Ninja.Circle.COL_NONE
    },
    projCircle_Concave: function(e, t, n, r, i, s) {
        var o = s.signx;
        var u = s.signy;
        var a;
        if (n === 0) {
            if (r === 0) {
                var f = s.pos.x + o * s.xw - i.pos.x;
                var l = s.pos.y + u * s.yw - i.pos.y;
                var c = s.xw * 2;
                var h = Math.sqrt(c * c + 0);
                var p = Math.sqrt(f * f + l * l);
                var d = p + i.radius - h;
                if (0 < d) {
                    if (e < t) {
                        a = e;
                        t = 0;
                        if (i.pos.x - s.pos.x < 0) {
                            e *= -1
                        }
                    } else {
                        a = t;
                        e = 0;
                        if (i.pos.y - s.pos.y < 0) {
                            t *= -1
                        }
                    }
                    if (a < d) {
                        i.reportCollisionVsWorld(e, t, e / a, t / a, s);
                        return Phaser.Physics.Ninja.Circle.COL_AXIS
                    } else {
                        f /= p;
                        l /= p;
                        i.reportCollisionVsWorld(f * d, l * d, f, l, s);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                } else {
                    return Phaser.Physics.Ninja.Circle.COL_NONE
                }
            } else {
                if (u * r < 0) {
                    i.reportCollisionVsWorld(0, t * r, 0, r, s);
                    return Phaser.Physics.Ninja.Circle.COL_AXIS
                } else {
                    var v = s.pos.x - o * s.xw;
                    var m = s.pos.y + r * s.yw;
                    var g = i.pos.x - v;
                    var y = i.pos.y - m;
                    var p = Math.sqrt(g * g + y * y);
                    var d = i.radius - p;
                    if (0 < d) {
                        if (p === 0) {
                            g = 0;
                            y = r
                        } else {
                            g /= p;
                            y /= p
                        }
                        i.reportCollisionVsWorld(g * d, y * d, g, y, s);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                }
            }
        } else if (r === 0) {
            if (o * n < 0) {
                i.reportCollisionVsWorld(e * n, 0, n, 0, s);
                return Phaser.Physics.Ninja.Circle.COL_AXIS
            } else {
                var v = s.pos.x + n * s.xw;
                var m = s.pos.y - u * s.yw;
                var g = i.pos.x - v;
                var y = i.pos.y - m;
                var p = Math.sqrt(g * g + y * y);
                var d = i.radius - p;
                if (0 < d) {
                    if (p === 0) {
                        g = n;
                        y = 0
                    } else {
                        g /= p;
                        y /= p
                    }
                    i.reportCollisionVsWorld(g * d, y * d, g, y, s);
                    return Phaser.Physics.Ninja.Circle.COL_OTHER
                }
            }
        } else {
            if (0 < o * n + u * r) {
                return Phaser.Physics.Ninja.Circle.COL_NONE
            } else {
                var v = s.pos.x + n * s.xw;
                var m = s.pos.y + r * s.yw;
                var g = i.pos.x - v;
                var y = i.pos.y - m;
                var p = Math.sqrt(g * g + y * y);
                var d = i.radius - p;
                if (0 < d) {
                    if (p === 0) {
                        g = n / Math.SQRT2;
                        y = r / Math.SQRT2
                    } else {
                        g /= p;
                        y /= p
                    }
                    i.reportCollisionVsWorld(g * d, y * d, g, y, s);
                    return Phaser.Physics.Ninja.Circle.COL_OTHER
                }
            }
        }
        return Phaser.Physics.Ninja.Circle.COL_NONE
    },
    projCircle_Convex: function(e, t, n, r, i, s) {
        var o = s.signx;
        var u = s.signy;
        var a;
        if (n === 0) {
            if (r === 0) {
                var f = i.pos.x - (s.pos.x - o * s.xw);
                var l = i.pos.y - (s.pos.y - u * s.yw);
                var c = s.xw * 2;
                var h = Math.sqrt(c * c + 0);
                var p = Math.sqrt(f * f + l * l);
                var d = h + i.radius - p;
                if (0 < d) {
                    if (e < t) {
                        a = e;
                        t = 0;
                        if (i.pos.x - s.pos.x < 0) {
                            e *= -1
                        }
                    } else {
                        a = t;
                        e = 0;
                        if (i.pos.y - s.pos.y < 0) {
                            t *= -1
                        }
                    }
                    if (a < d) {
                        i.reportCollisionVsWorld(e, t, e / a, t / a, s);
                        return Phaser.Physics.Ninja.Circle.COL_AXIS
                    } else {
                        f /= p;
                        l /= p;
                        i.reportCollisionVsWorld(f * d, l * d, f, l, s);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                }
            } else {
                if (u * r < 0) {
                    i.reportCollisionVsWorld(0, t * r, 0, r, s);
                    return Phaser.Physics.Ninja.Circle.COL_AXIS
                } else {
                    var f = i.pos.x - (s.pos.x - o * s.xw);
                    var l = i.pos.y - (s.pos.y - u * s.yw);
                    var c = s.xw * 2;
                    var h = Math.sqrt(c * c + 0);
                    var p = Math.sqrt(f * f + l * l);
                    var d = h + i.radius - p;
                    if (0 < d) {
                        f /= p;
                        l /= p;
                        i.reportCollisionVsWorld(f * d, l * d, f, l, s);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                }
            }
        } else if (r === 0) {
            if (o * n < 0) {
                i.reportCollisionVsWorld(e * n, 0, n, 0, s);
                return Phaser.Physics.Ninja.Circle.COL_AXIS
            } else {
                var f = i.pos.x - (s.pos.x - o * s.xw);
                var l = i.pos.y - (s.pos.y - u * s.yw);
                var c = s.xw * 2;
                var h = Math.sqrt(c * c + 0);
                var p = Math.sqrt(f * f + l * l);
                var d = h + i.radius - p;
                if (0 < d) {
                    f /= p;
                    l /= p;
                    i.reportCollisionVsWorld(f * d, l * d, f, l, s);
                    return Phaser.Physics.Ninja.Circle.COL_OTHER
                }
            }
        } else {
            if (0 < o * n + u * r) {
                var f = i.pos.x - (s.pos.x - o * s.xw);
                var l = i.pos.y - (s.pos.y - u * s.yw);
                var c = s.xw * 2;
                var h = Math.sqrt(c * c + 0);
                var p = Math.sqrt(f * f + l * l);
                var d = h + i.radius - p;
                if (0 < d) {
                    f /= p;
                    l /= p;
                    i.reportCollisionVsWorld(f * d, l * d, f, l, s);
                    return Phaser.Physics.Ninja.Circle.COL_OTHER
                }
            } else {
                var v = s.pos.x + n * s.xw;
                var m = s.pos.y + r * s.yw;
                var g = i.pos.x - v;
                var y = i.pos.y - m;
                var p = Math.sqrt(g * g + y * y);
                var d = i.radius - p;
                if (0 < d) {
                    if (p === 0) {
                        g = n / Math.SQRT2;
                        y = r / Math.SQRT2
                    } else {
                        g /= p;
                        y /= p
                    }
                    i.reportCollisionVsWorld(g * d, y * d, g, y, s);
                    return Phaser.Physics.Ninja.Circle.COL_OTHER
                }
            }
        }
        return Phaser.Physics.Ninja.Circle.COL_NONE
    },
    projCircle_Half: function(e, t, n, r, i, s) {
        var o = s.signx;
        var u = s.signy;
        var a = n * o + r * u;
        if (0 < a) {
            return Phaser.Physics.Ninja.Circle.COL_NONE
        } else if (n === 0) {
            if (r === 0) {
                var f = i.radius;
                var l = i.pos.x - o * f - s.pos.x;
                var c = i.pos.y - u * f - s.pos.y;
                var h = o;
                var p = u;
                var d = l * h + c * p;
                if (d < 0) {
                    h *= -d;
                    p *= -d;
                    var v = Math.sqrt(h * h + p * p);
                    var m = Math.sqrt(e * e + t * t);
                    if (m < v) {
                        i.reportCollisionVsWorld(e, t, e / m, t / m, s);
                        return Phaser.Physics.Ninja.Circle.COL_AXIS
                    } else {
                        i.reportCollisionVsWorld(h, p, s.signx, s.signy);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                    return true
                }
            } else {
                if (a === 0) {
                    var g = i.pos.x - s.pos.x;
                    if (g * o < 0) {
                        i.reportCollisionVsWorld(0, t * r, 0, r, s);
                        return Phaser.Physics.Ninja.Circle.COL_AXIS
                    } else {
                        var y = i.pos.y - (s.pos.y + r * s.yw);
                        var b = Math.sqrt(g * g + y * y);
                        var w = i.radius - b;
                        if (0 < w) {
                            if (b === 0) {
                                g = o / Math.SQRT2;
                                y = r / Math.SQRT2
                            } else {
                                g /= b;
                                y /= b
                            }
                            i.reportCollisionVsWorld(g * w, y * w, g, y, s);
                            return Phaser.Physics.Ninja.Circle.COL_OTHER
                        }
                    }
                } else {
                    i.reportCollisionVsWorld(0, t * r, 0, r, s);
                    return Phaser.Physics.Ninja.Circle.COL_AXIS
                }
            }
        } else if (r === 0) {
            if (a === 0) {
                var y = i.pos.y - s.pos.y;
                if (y * u < 0) {
                    i.reportCollisionVsWorld(e * n, 0, n, 0, s);
                    return Phaser.Physics.Ninja.Circle.COL_AXIS
                } else {
                    var g = i.pos.x - (s.pos.x + n * s.xw);
                    var b = Math.sqrt(g * g + y * y);
                    var w = i.radius - b;
                    if (0 < w) {
                        if (b === 0) {
                            g = o / Math.SQRT2;
                            y = r / Math.SQRT2
                        } else {
                            g /= b;
                            y /= b
                        }
                        i.reportCollisionVsWorld(g * w, y * w, g, y, s);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                }
            } else {
                i.reportCollisionVsWorld(e * n, 0, n, 0, s);
                return Phaser.Physics.Ninja.Circle.COL_AXIS
            }
        } else {
            var E = s.pos.x + n * s.xw;
            var S = s.pos.y + r * s.yw;
            var g = i.pos.x - E;
            var y = i.pos.y - S;
            var b = Math.sqrt(g * g + y * y);
            var w = i.radius - b;
            if (0 < w) {
                if (b === 0) {
                    g = n / Math.SQRT2;
                    y = r / Math.SQRT2
                } else {
                    g /= b;
                    y /= b
                }
                i.reportCollisionVsWorld(g * w, y * w, g, y, s);
                return Phaser.Physics.Ninja.Circle.COL_OTHER
            }
        }
        return Phaser.Physics.Ninja.Circle.COL_NONE
    },
    projCircle_22DegS: function(e, t, n, r, i, s) {
        var o;
        var u = s.signx;
        var a = s.signy;
        if (0 < a * r) {
            return Phaser.Physics.Ninja.Circle.COL_NONE
        } else if (n === 0) {
            if (r === 0) {
                var f = s.sx;
                var l = s.sy;
                var c = i.radius;
                var h = i.pos.x - (s.pos.x - u * s.xw);
                var p = i.pos.y - s.pos.y;
                var d = h * -l + p * f;
                if (0 < d * u * a) {
                    var v = Math.sqrt(h * h + p * p);
                    var m = c - v;
                    if (0 < m) {
                        h /= v;
                        p /= v;
                        i.reportCollisionVsWorld(h * m, p * m, h, p, s);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                } else {
                    h -= c * f;
                    p -= c * l;
                    var g = h * f + p * l;
                    if (g < 0) {
                        f *= -g;
                        l *= -g;
                        var y = Math.sqrt(f * f + l * l);
                        if (e < t) {
                            o = e;
                            t = 0;
                            if (i.pos.x - s.pos.x < 0) {
                                e *= -1
                            }
                        } else {
                            o = t;
                            e = 0;
                            if (i.pos.y - s.pos.y < 0) {
                                t *= -1
                            }
                        }
                        if (o < y) {
                            i.reportCollisionVsWorld(e, t, e / o, t / o, s);
                            return Phaser.Physics.Ninja.Circle.COL_AXIS
                        } else {
                            i.reportCollisionVsWorld(f, l, s.sx, s.sy, s);
                            return Phaser.Physics.Ninja.Circle.COL_OTHER
                        }
                    }
                }
            } else {
                i.reportCollisionVsWorld(0, t * r, 0, r, s);
                return Phaser.Physics.Ninja.Circle.COL_AXIS
            }
        } else if (r === 0) {
            if (u * n < 0) {
                var b = s.pos.x - u * s.xw;
                var w = s.pos.y;
                var E = i.pos.x - b;
                var S = i.pos.y - w;
                if (S * a < 0) {
                    i.reportCollisionVsWorld(e * n, 0, n, 0, s);
                    return Phaser.Physics.Ninja.Circle.COL_AXIS
                } else {
                    var v = Math.sqrt(E * E + S * S);
                    var m = i.radius - v;
                    if (0 < m) {
                        if (v === 0) {
                            E = n / Math.SQRT2;
                            S = r / Math.SQRT2
                        } else {
                            E /= v;
                            S /= v
                        }
                        i.reportCollisionVsWorld(E * m, S * m, E, S, s);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                }
            } else {
                var f = s.sx;
                var l = s.sy;
                var h = i.pos.x - (s.pos.x + n * s.xw);
                var p = i.pos.y - (s.pos.y - a * s.yw);
                var d = h * -l + p * f;
                if (d * u * a < 0) {
                    var v = Math.sqrt(h * h + p * p);
                    var m = i.radius - v;
                    if (0 < m) {
                        h /= v;
                        p /= v;
                        i.reportCollisionVsWorld(h * m, p * m, h, p, s);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                } else {
                    var g = h * f + p * l;
                    var m = i.radius - Math.abs(g);
                    if (0 < m) {
                        i.reportCollisionVsWorld(f * m, l * m, f, l, s);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                }
            }
        } else {
            var b = s.pos.x + n * s.xw;
            var w = s.pos.y + r * s.yw;
            var E = i.pos.x - b;
            var S = i.pos.y - w;
            var v = Math.sqrt(E * E + S * S);
            var m = i.radius - v;
            if (0 < m) {
                if (v === 0) {
                    E = n / Math.SQRT2;
                    S = r / Math.SQRT2
                } else {
                    E /= v;
                    S /= v
                }
                i.reportCollisionVsWorld(E * m, S * m, E, S, s);
                return Phaser.Physics.Ninja.Circle.COL_OTHER
            }
        }
        return Phaser.Physics.Ninja.Circle.COL_NONE
    },
    projCircle_22DegB: function(e, t, n, r, i, s) {
        var o;
        var u = s.signx;
        var a = s.signy;
        if (n === 0) {
            if (r === 0) {
                var f = s.sx;
                var l = s.sy;
                var c = i.radius;
                var h = i.pos.x - f * c - (s.pos.x - u * s.xw);
                var p = i.pos.y - l * c - (s.pos.y + a * s.yw);
                var d = h * f + p * l;
                if (d < 0) {
                    f *= -d;
                    l *= -d;
                    var v = Math.sqrt(f * f + l * l);
                    if (e < t) {
                        o = e;
                        t = 0;
                        if (i.pos.x - s.pos.x < 0) {
                            e *= -1
                        }
                    } else {
                        o = t;
                        e = 0;
                        if (i.pos.y - s.pos.y < 0) {
                            t *= -1
                        }
                    }
                    if (o < v) {
                        i.reportCollisionVsWorld(e, t, e / o, t / o, s);
                        return Phaser.Physics.Ninja.Circle.COL_AXIS
                    } else {
                        i.reportCollisionVsWorld(f, l, s.sx, s.sy, s);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                }
            } else {
                if (a * r < 0) {
                    i.reportCollisionVsWorld(0, t * r, 0, r, s);
                    return Phaser.Physics.Ninja.Circle.COL_AXIS
                } else {
                    var f = s.sx;
                    var l = s.sy;
                    var h = i.pos.x - (s.pos.x - u * s.xw);
                    var p = i.pos.y - (s.pos.y + a * s.yw);
                    var m = h * -l + p * f;
                    if (0 < m * u * a) {
                        var g = Math.sqrt(h * h + p * p);
                        var y = i.radius - g;
                        if (0 < y) {
                            h /= g;
                            p /= g;
                            i.reportCollisionVsWorld(h * y, p * y, h, p, s);
                            return Phaser.Physics.Ninja.Circle.COL_OTHER
                        }
                    } else {
                        var d = h * f + p * l;
                        var y = i.radius - Math.abs(d);
                        if (0 < y) {
                            i.reportCollisionVsWorld(f * y, l * y, f, l, s);
                            return Phaser.Physics.Ninja.Circle.COL_OTHER
                        }
                    }
                }
            }
        } else if (r === 0) {
            if (u * n < 0) {
                i.reportCollisionVsWorld(e * n, 0, n, 0, s);
                return Phaser.Physics.Ninja.Circle.COL_AXIS
            } else {
                var h = i.pos.x - (s.pos.x + u * s.xw);
                var p = i.pos.y - s.pos.y;
                if (p * a < 0) {
                    i.reportCollisionVsWorld(e * n, 0, n, 0, s);
                    return Phaser.Physics.Ninja.Circle.COL_AXIS
                } else {
                    var f = s.sx;
                    var l = s.sy;
                    var m = h * -l + p * f;
                    if (m * u * a < 0) {
                        var g = Math.sqrt(h * h + p * p);
                        var y = i.radius - g;
                        if (0 < y) {
                            h /= g;
                            p /= g;
                            i.reportCollisionVsWorld(h * y, p * y, h, p, s);
                            return Phaser.Physics.Ninja.Circle.COL_OTHER
                        }
                    } else {
                        var d = h * f + p * l;
                        var y = i.radius - Math.abs(d);
                        if (0 < y) {
                            i.reportCollisionVsWorld(f * y, l * y, s.sx, s.sy, s);
                            return Phaser.Physics.Ninja.Circle.COL_OTHER
                        }
                    }
                }
            }
        } else {
            if (0 < u * n + a * r) {
                var b = Math.sqrt(2 * 2 + 1 * 1);
                var f = u * 1 / b;
                var l = a * 2 / b;
                var c = i.radius;
                var h = i.pos.x - f * c - (s.pos.x - u * s.xw);
                var p = i.pos.y - l * c - (s.pos.y + a * s.yw);
                var d = h * f + p * l;
                if (d < 0) {
                    i.reportCollisionVsWorld(-f * d, -l * d, s.sx, s.sy, s);
                    return Phaser.Physics.Ninja.Circle.COL_OTHER
                }
                return Phaser.Physics.Ninja.Circle.COL_NONE
            } else {
                var w = s.pos.x + n * s.xw;
                var E = s.pos.y + r * s.yw;
                var S = i.pos.x - w;
                var x = i.pos.y - E;
                var g = Math.sqrt(S * S + x * x);
                var y = i.radius - g;
                if (0 < y) {
                    if (g === 0) {
                        S = n / Math.SQRT2;
                        x = r / Math.SQRT2
                    } else {
                        S /= g;
                        x /= g
                    }
                    i.reportCollisionVsWorld(S * y, x * y, S, x, s);
                    return Phaser.Physics.Ninja.Circle.COL_OTHER
                }
            }
        }
        return Phaser.Physics.Ninja.Circle.COL_NONE
    },
    projCircle_67DegS: function(e, t, n, r, i, s) {
        var o = s.signx;
        var u = s.signy;
        if (0 < o * n) {
            return Phaser.Physics.Ninja.Circle.COL_NONE
        } else if (n === 0) {
            if (r === 0) {
                var a;
                var f = s.sx;
                var l = s.sy;
                var c = i.radius;
                var h = i.pos.x - s.pos.x;
                var p = i.pos.y - (s.pos.y - u * s.yw);
                var d = h * -l + p * f;
                if (d * o * u < 0) {
                    var v = Math.sqrt(h * h + p * p);
                    var m = c - v;
                    if (0 < m) {
                        h /= v;
                        p /= v;
                        i.reportCollisionVsWorld(h * m, p * m, h, p, s);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                } else {
                    h -= c * f;
                    p -= c * l;
                    var g = h * f + p * l;
                    if (g < 0) {
                        f *= -g;
                        l *= -g;
                        var y = Math.sqrt(f * f + l * l);
                        if (e < t) {
                            a = e;
                            t = 0;
                            if (i.pos.x - s.pos.x < 0) {
                                e *= -1
                            }
                        } else {
                            a = t;
                            e = 0;
                            if (i.pos.y - s.pos.y < 0) {
                                t *= -1
                            }
                        }
                        if (a < y) {
                            i.reportCollisionVsWorld(e, t, e / a, t / a, s);
                            return Phaser.Physics.Ninja.Circle.COL_AXIS
                        } else {
                            i.reportCollisionVsWorld(f, l, s.sx, s.sy, s);
                            return Phaser.Physics.Ninja.Circle.COL_OTHER
                        }
                    }
                }
            } else {
                if (u * r < 0) {
                    var b = s.pos.x;
                    var w = s.pos.y - u * s.yw;
                    var E = i.pos.x - b;
                    var S = i.pos.y - w;
                    if (E * o < 0) {
                        i.reportCollisionVsWorld(0, t * r, 0, r, s);
                        return Phaser.Physics.Ninja.Circle.COL_AXIS
                    } else {
                        var v = Math.sqrt(E * E + S * S);
                        var m = i.radius - v;
                        if (0 < m) {
                            if (v === 0) {
                                E = n / Math.SQRT2;
                                S = r / Math.SQRT2
                            } else {
                                E /= v;
                                S /= v
                            }
                            i.reportCollisionVsWorld(E * m, S * m, E, S, s);
                            return Phaser.Physics.Ninja.Circle.COL_OTHER
                        }
                    }
                } else {
                    var f = s.sx;
                    var l = s.sy;
                    var h = i.pos.x - (s.pos.x - o * s.xw);
                    var p = i.pos.y - (s.pos.y + r * s.yw);
                    var d = h * -l + p * f;
                    if (0 < d * o * u) {
                        var v = Math.sqrt(h * h + p * p);
                        var m = i.radius - v;
                        if (0 < m) {
                            h /= v;
                            p /= v;
                            i.reportCollisionVsWorld(h * m, p * m, h, p, s);
                            return Phaser.Physics.Ninja.Circle.COL_OTHER
                        }
                    } else {
                        var g = h * f + p * l;
                        var m = i.radius - Math.abs(g);
                        if (0 < m) {
                            i.reportCollisionVsWorld(f * m, l * m, s.sx, s.sy, s);
                            return Phaser.Physics.Ninja.Circle.COL_OTHER
                        }
                    }
                }
            }
        } else if (r === 0) {
            i.reportCollisionVsWorld(e * n, 0, n, 0, s);
            return Phaser.Physics.Ninja.Circle.COL_AXIS
        } else {
            var b = s.pos.x + n * s.xw;
            var w = s.pos.y + r * s.yw;
            var E = i.pos.x - b;
            var S = i.pos.y - w;
            var v = Math.sqrt(E * E + S * S);
            var m = i.radius - v;
            if (0 < m) {
                if (v === 0) {
                    E = n / Math.SQRT2;
                    S = r / Math.SQRT2
                } else {
                    E /= v;
                    S /= v
                }
                i.reportCollisionVsWorld(E * m, S * m, E, S, s);
                return Phaser.Physics.Ninja.Circle.COL_OTHER
            }
        }
        return Phaser.Physics.Ninja.Circle.COL_NONE
    },
    projCircle_67DegB: function(e, t, n, r, i, s) {
        var o = s.signx;
        var u = s.signy;
        if (n === 0) {
            if (r === 0) {
                var a;
                var f = s.sx;
                var l = s.sy;
                var c = i.radius;
                var h = i.pos.x - f * c - (s.pos.x + o * s.xw);
                var p = i.pos.y - l * c - (s.pos.y - u * s.yw);
                var d = h * f + p * l;
                if (d < 0) {
                    f *= -d;
                    l *= -d;
                    var v = Math.sqrt(f * f + l * l);
                    if (e < t) {
                        a = e;
                        t = 0;
                        if (i.pos.x - s.pos.x < 0) {
                            e *= -1
                        }
                    } else {
                        a = t;
                        e = 0;
                        if (i.pos.y - s.pos.y < 0) {
                            t *= -1
                        }
                    }
                    if (a < v) {
                        i.reportCollisionVsWorld(e, t, e / a, t / a, s);
                        return Phaser.Physics.Ninja.Circle.COL_AXIS
                    } else {
                        i.reportCollisionVsWorld(f, l, s.sx, s.sy, s);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                }
            } else {
                if (u * r < 0) {
                    i.reportCollisionVsWorld(0, t * r, 0, r, s);
                    return Phaser.Physics.Ninja.Circle.COL_AXIS
                } else {
                    var h = i.pos.x - s.pos.x;
                    var p = i.pos.y - (s.pos.y + u * s.yw);
                    if (h * o < 0) {
                        i.reportCollisionVsWorld(0, t * r, 0, r, s);
                        return Phaser.Physics.Ninja.Circle.COL_AXIS
                    } else {
                        var f = s.sx;
                        var l = s.sy;
                        var m = h * -l + p * f;
                        if (0 < m * o * u) {
                            var g = Math.sqrt(h * h + p * p);
                            var y = i.radius - g;
                            if (0 < y) {
                                h /= g;
                                p /= g;
                                i.reportCollisionVsWorld(h * y, p * y, h, p, s);
                                return Phaser.Physics.Ninja.Circle.COL_OTHER
                            }
                        } else {
                            var d = h * f + p * l;
                            var y = i.radius - Math.abs(d);
                            if (0 < y) {
                                i.reportCollisionVsWorld(f * y, l * y, f, l, s);
                                return Phaser.Physics.Ninja.Circle.COL_OTHER
                            }
                        }
                    }
                }
            }
        } else if (r === 0) {
            if (o * n < 0) {
                i.reportCollisionVsWorld(e * n, 0, n, 0, s);
                return Phaser.Physics.Ninja.Circle.COL_AXIS
            } else {
                var b = Math.sqrt(2 * 2 + 1 * 1);
                var f = o * 2 / b;
                var l = u * 1 / b;
                var h = i.pos.x - (s.pos.x + o * s.xw);
                var p = i.pos.y - (s.pos.y - u * s.yw);
                var m = h * -l + p * f;
                if (m * o * u < 0) {
                    var g = Math.sqrt(h * h + p * p);
                    var y = i.radius - g;
                    if (0 < y) {
                        h /= g;
                        p /= g;
                        i.reportCollisionVsWorld(h * y, p * y, h, p, s);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                } else {
                    var d = h * f + p * l;
                    var y = i.radius - Math.abs(d);
                    if (0 < y) {
                        i.reportCollisionVsWorld(f * y, l * y, s.sx, s.sy, s);
                        return Phaser.Physics.Ninja.Circle.COL_OTHER
                    }
                }
            }
        } else {
            if (0 < o * n + u * r) {
                var f = s.sx;
                var l = s.sy;
                var c = i.radius;
                var h = i.pos.x - f * c - (s.pos.x + o * s.xw);
                var p = i.pos.y - l * c - (s.pos.y - u * s.yw);
                var d = h * f + p * l;
                if (d < 0) {
                    i.reportCollisionVsWorld(-f * d, -l * d, s.sx, s.sy, s);
                    return Phaser.Physics.Ninja.Circle.COL_OTHER
                }
                return Phaser.Physics.Ninja.Circle.COL_NONE
            } else {
                var w = s.pos.x + n * s.xw;
                var E = s.pos.y + r * s.yw;
                var S = i.pos.x - w;
                var x = i.pos.y - E;
                var g = Math.sqrt(S * S + x * x);
                var y = i.radius - g;
                if (0 < y) {
                    if (g === 0) {
                        S = n / Math.SQRT2;
                        x = r / Math.SQRT2
                    } else {
                        S /= g;
                        x /= g
                    }
                    i.reportCollisionVsWorld(S * y, x * y, S, x, s);
                    return Phaser.Physics.Ninja.Circle.COL_OTHER
                }
            }
        }
        return Phaser.Physics.Ninja.Circle.COL_NONE
    },
    destroy: function() {
        this.body = null;
        this.system = null
    }
};
!
    function(e) {
        "object" == typeof exports ? module.exports = e() : "function" == typeof define && define.amd ? define("p2", function() {
            return this.p2 = e()
        }()) : "undefined" != typeof window ? window.p2 = e() : "undefined" != typeof global ? self.p2 = e() : "undefined" != typeof self && (self.p2 = e())
    }(function() {
        var e, t, n;
        return function r(e, t, n) {
            function i(o, u) {
                if (!t[o]) {
                    if (!e[o]) {
                        var a = typeof require == "function" && require;
                        if (!u && a) return a(o, !0);
                        if (s) return s(o, !0);
                        throw new Error("Cannot find module '" + o + "'")
                    }
                    var f = t[o] = {
                        exports: {}
                    };
                    e[o][0].call(f.exports, function(t) {
                        var n = e[o][1][t];
                        return i(n ? n : t)
                    }, f, f.exports, r, e, t, n)
                }
                return t[o].exports
            }
            var s = typeof require == "function" && require;
            for (var o = 0; o < n.length; o++) i(n[o]);
            return i
        }({
            1: [function(e, t, n) {
                if (!r) {
                    var r = 1e-6
                }
                if (!i) {
                    var i = typeof Float32Array !== "undefined" ? Float32Array : Array
                }
                var s = {};
                s.setMatrixArrayType = function(e) {
                    i = e
                };
                if (typeof n !== "undefined") {
                    n.glMatrix = s
                }
                var o = {};
                o.create = function() {
                    var e = new i(2);
                    e[0] = 0;
                    e[1] = 0;
                    return e
                };
                o.clone = function(e) {
                    var t = new i(2);
                    t[0] = e[0];
                    t[1] = e[1];
                    return t
                };
                o.fromValues = function(e, t) {
                    var n = new i(2);
                    n[0] = e;
                    n[1] = t;
                    return n
                };
                o.copy = function(e, t) {
                    e[0] = t[0];
                    e[1] = t[1];
                    return e
                };
                o.set = function(e, t, n) {
                    e[0] = t;
                    e[1] = n;
                    return e
                };
                o.add = function(e, t, n) {
                    e[0] = t[0] + n[0];
                    e[1] = t[1] + n[1];
                    return e
                };
                o.subtract = function(e, t, n) {
                    e[0] = t[0] - n[0];
                    e[1] = t[1] - n[1];
                    return e
                };
                o.sub = o.subtract;
                o.multiply = function(e, t, n) {
                    e[0] = t[0] * n[0];
                    e[1] = t[1] * n[1];
                    return e
                };
                o.mul = o.multiply;
                o.divide = function(e, t, n) {
                    e[0] = t[0] / n[0];
                    e[1] = t[1] / n[1];
                    return e
                };
                o.div = o.divide;
                o.min = function(e, t, n) {
                    e[0] = Math.min(t[0], n[0]);
                    e[1] = Math.min(t[1], n[1]);
                    return e
                };
                o.max = function(e, t, n) {
                    e[0] = Math.max(t[0], n[0]);
                    e[1] = Math.max(t[1], n[1]);
                    return e
                };
                o.scale = function(e, t, n) {
                    e[0] = t[0] * n;
                    e[1] = t[1] * n;
                    return e
                };
                o.distance = function(e, t) {
                    var n = t[0] - e[0],
                        r = t[1] - e[1];
                    return Math.sqrt(n * n + r * r)
                };
                o.dist = o.distance;
                o.squaredDistance = function(e, t) {
                    var n = t[0] - e[0],
                        r = t[1] - e[1];
                    return n * n + r * r
                };
                o.sqrDist = o.squaredDistance;
                o.length = function(e) {
                    var t = e[0],
                        n = e[1];
                    return Math.sqrt(t * t + n * n)
                };
                o.len = o.length;
                o.squaredLength = function(e) {
                    var t = e[0],
                        n = e[1];
                    return t * t + n * n
                };
                o.sqrLen = o.squaredLength;
                o.negate = function(e, t) {
                    e[0] = -t[0];
                    e[1] = -t[1];
                    return e
                };
                o.normalize = function(e, t) {
                    var n = t[0],
                        r = t[1];
                    var i = n * n + r * r;
                    if (i > 0) {
                        i = 1 / Math.sqrt(i);
                        e[0] = t[0] * i;
                        e[1] = t[1] * i
                    }
                    return e
                };
                o.dot = function(e, t) {
                    return e[0] * t[0] + e[1] * t[1]
                };
                o.cross = function(e, t, n) {
                    var r = t[0] * n[1] - t[1] * n[0];
                    e[0] = e[1] = 0;
                    e[2] = r;
                    return e
                };
                o.lerp = function(e, t, n, r) {
                    var i = t[0],
                        s = t[1];
                    e[0] = i + r * (n[0] - i);
                    e[1] = s + r * (n[1] - s);
                    return e
                };
                o.transformMat2 = function(e, t, n) {
                    var r = t[0],
                        i = t[1];
                    e[0] = n[0] * r + n[2] * i;
                    e[1] = n[1] * r + n[3] * i;
                    return e
                };
                o.transformMat2d = function(e, t, n) {
                    var r = t[0],
                        i = t[1];
                    e[0] = n[0] * r + n[2] * i + n[4];
                    e[1] = n[1] * r + n[3] * i + n[5];
                    return e
                };
                o.transformMat3 = function(e, t, n) {
                    var r = t[0],
                        i = t[1];
                    e[0] = n[0] * r + n[3] * i + n[6];
                    e[1] = n[1] * r + n[4] * i + n[7];
                    return e
                };
                o.transformMat4 = function(e, t, n) {
                    var r = t[0],
                        i = t[1];
                    e[0] = n[0] * r + n[4] * i + n[12];
                    e[1] = n[1] * r + n[5] * i + n[13];
                    return e
                };
                o.forEach = function() {
                    var e = o.create();
                    return function(t, n, r, i, s, o) {
                        var u, a;
                        if (!n) {
                            n = 2
                        }
                        if (!r) {
                            r = 0
                        }
                        if (i) {
                            a = Math.min(i * n + r, t.length)
                        } else {
                            a = t.length
                        }
                        for (u = r; u < a; u += n) {
                            e[0] = t[u];
                            e[1] = t[u + 1];
                            s(e, e, o);
                            t[u] = e[0];
                            t[u + 1] = e[1]
                        }
                        return t
                    }
                }();
                o.str = function(e) {
                    return "vec2(" + e[0] + ", " + e[1] + ")"
                };
                if (typeof n !== "undefined") {
                    n.vec2 = o
                }
            }, {}],
            2: [function(e, t, n) {
                function i() {}
                var r = e("./Scalar");
                t.exports = i;
                i.lineInt = function(e, t, n) {
                    n = n || 0;
                    var i = [0, 0];
                    var s, o, u, a, f, l, c;
                    s = e[1][1] - e[0][1];
                    o = e[0][0] - e[1][0];
                    u = s * e[0][0] + o * e[0][1];
                    a = t[1][1] - t[0][1];
                    f = t[0][0] - t[1][0];
                    l = a * t[0][0] + f * t[0][1];
                    c = s * f - a * o;
                    if (!r.eq(c, 0, n)) {
                        i[0] = (f * u - o * l) / c;
                        i[1] = (s * l - a * u) / c
                    }
                    return i
                };
                i.segmentsIntersect = function(e, t, n, r) {
                    var i = t[0] - e[0];
                    var s = t[1] - e[1];
                    var o = r[0] - n[0];
                    var u = r[1] - n[1];
                    if (o * s - u * i == 0) return false;
                    var a = (i * (n[1] - e[1]) + s * (e[0] - n[0])) / (o * s - u * i);
                    var f = (o * (e[1] - n[1]) + u * (n[0] - e[0])) / (u * i - o * s);
                    return a >= 0 && a <= 1 && f >= 0 && f <= 1
                }
            }, {
                "./Scalar": 5
            }],
            3: [function(e, t, n) {
                function r() {}
                t.exports = r;
                r.area = function(e, t, n) {
                    return (t[0] - e[0]) * (n[1] - e[1]) - (n[0] - e[0]) * (t[1] - e[1])
                };
                r.left = function(e, t, n) {
                    return r.area(e, t, n) > 0
                };
                r.leftOn = function(e, t, n) {
                    return r.area(e, t, n) >= 0
                };
                r.right = function(e, t, n) {
                    return r.area(e, t, n) < 0
                };
                r.rightOn = function(e, t, n) {
                    return r.area(e, t, n) <= 0
                };
                var i = [],
                    s = [];
                r.collinear = function(e, t, n, o) {
                    if (!o) return r.area(e, t, n) == 0;
                    else {
                        var u = i,
                            a = s;
                        u[0] = t[0] - e[0];
                        u[1] = t[1] - e[1];
                        a[0] = n[0] - t[0];
                        a[1] = n[1] - t[1];
                        var f = u[0] * a[0] + u[1] * a[1],
                            l = Math.sqrt(u[0] * u[0] + u[1] * u[1]),
                            c = Math.sqrt(a[0] * a[0] + a[1] * a[1]),
                            h = Math.acos(f / (l * c));
                        return h < o
                    }
                };
                r.sqdist = function(e, t) {
                    var n = t[0] - e[0];
                    var r = t[1] - e[1];
                    return n * n + r * r
                }
            }, {}],
            4: [function(e, t, n) {
                function o() {
                    this.vertices = []
                }
                function f(e, t, n, r, i) {
                    i = i || 0;
                    var o = t[1] - e[1];
                    var u = e[0] - t[0];
                    var a = o * e[0] + u * e[1];
                    var f = r[1] - n[1];
                    var l = n[0] - r[0];
                    var c = f * n[0] + l * n[1];
                    var h = o * l - f * u;
                    if (!s.eq(h, 0, i)) return [(l * a - u * c) / h, (o * c - f * a) / h];
                    else return [0, 0]
                }
                var r = e("./Line"),
                    i = e("./Point"),
                    s = e("./Scalar");
                t.exports = o;
                o.prototype.at = function(e) {
                    var t = this.vertices,
                        n = t.length;
                    return t[e < 0 ? e % n + n : e % n]
                };
                o.prototype.first = function() {
                    return this.vertices[0]
                };
                o.prototype.last = function() {
                    return this.vertices[this.vertices.length - 1]
                };
                o.prototype.clear = function() {
                    this.vertices.length = 0
                };
                o.prototype.append = function(e, t, n) {
                    if (typeof t == "undefined") throw new Error("From is not given!");
                    if (typeof n == "undefined") throw new Error("To is not given!");
                    if (n - 1 < t) throw new Error("lol1");
                    if (n > e.vertices.length) throw new Error("lol2");
                    if (t < 0) throw new Error("lol3");
                    for (var r = t; r < n; r++) {
                        this.vertices.push(e.vertices[r])
                    }
                };
                o.prototype.makeCCW = function() {
                    var e = 0,
                        t = this.vertices;
                    for (var n = 1; n < this.vertices.length; ++n) {
                        if (t[n][1] < t[e][1] || t[n][1] == t[e][1] && t[n][0] > t[e][0]) {
                            e = n
                        }
                    }
                    if (!i.left(this.at(e - 1), this.at(e), this.at(e + 1))) {
                        this.reverse()
                    }
                };
                o.prototype.reverse = function() {
                    var e = [];
                    for (var t = 0, n = this.vertices.length; t !== n; t++) {
                        e.push(this.vertices.pop())
                    }
                    this.vertices = e
                };
                o.prototype.isReflex = function(e) {
                    return i.right(this.at(e - 1), this.at(e), this.at(e + 1))
                };
                var u = [],
                    a = [];
                o.prototype.canSee = function(e, t) {
                    var n, s, o = u,
                        f = a;
                    if (i.leftOn(this.at(e + 1), this.at(e), this.at(t)) && i.rightOn(this.at(e - 1), this.at(e), this.at(t))) {
                        return false
                    }
                    s = i.sqdist(this.at(e), this.at(t));
                    for (var l = 0; l !== this.vertices.length; ++l) {
                        if ((l + 1) % this.vertices.length === e || l === e) continue;
                        if (i.leftOn(this.at(e), this.at(t), this.at(l + 1)) && i.rightOn(this.at(e), this.at(t), this.at(l))) {
                            o[0] = this.at(e);
                            o[1] = this.at(t);
                            f[0] = this.at(l);
                            f[1] = this.at(l + 1);
                            n = r.lineInt(o, f);
                            if (i.sqdist(this.at(e), n) < s) {
                                return false
                            }
                        }
                    }
                    return true
                };
                o.prototype.copy = function(e, t, n) {
                    var r = n || new o;
                    r.clear();
                    if (e < t) {
                        for (var i = e; i <= t; i++) r.vertices.push(this.vertices[i])
                    } else {
                        for (var i = 0; i <= t; i++) r.vertices.push(this.vertices[i]);
                        for (var i = e; i < this.vertices.length; i++) r.vertices.push(this.vertices[i])
                    }
                    return r
                };
                o.prototype.getCutEdges = function() {
                    var e = [],
                        t = [],
                        n = [],
                        r = new o;
                    var i = Number.MAX_VALUE;
                    for (var s = 0; s < this.vertices.length; ++s) {
                        if (this.isReflex(s)) {
                            for (var u = 0; u < this.vertices.length; ++u) {
                                if (this.canSee(s, u)) {
                                    t = this.copy(s, u, r).getCutEdges();
                                    n = this.copy(u, s, r).getCutEdges();
                                    for (var a = 0; a < n.length; a++) t.push(n[a]);
                                    if (t.length < i) {
                                        e = t;
                                        i = t.length;
                                        e.push([this.at(s), this.at(u)])
                                    }
                                }
                            }
                        }
                    }
                    return e
                };
                o.prototype.decomp = function() {
                    var e = this.getCutEdges();
                    if (e.length > 0) return this.slice(e);
                    else return [this]
                };
                o.prototype.slice = function(e) {
                    if (e.length == 0) return [this];
                    if (e instanceof Array && e.length && e[0] instanceof Array && e[0].length == 2 && e[0][0] instanceof Array) {
                        var t = [this];
                        for (var n = 0; n < e.length; n++) {
                            var r = e[n];
                            for (var i = 0; i < t.length; i++) {
                                var s = t[i];
                                var o = s.slice(r);
                                if (o) {
                                    t.splice(i, 1);
                                    t.push(o[0], o[1]);
                                    break
                                }
                            }
                        }
                        return t
                    } else {
                        var r = e;
                        var n = this.vertices.indexOf(r[0]);
                        var i = this.vertices.indexOf(r[1]);
                        if (n != -1 && i != -1) {
                            return [this.copy(n, i), this.copy(i, n)]
                        } else {
                            return false
                        }
                    }
                };
                o.prototype.isSimple = function() {
                    var e = this.vertices;
                    for (var t = 0; t < e.length - 1; t++) {
                        for (var n = 0; n < t - 1; n++) {
                            if (r.segmentsIntersect(e[t], e[t + 1], e[n], e[n + 1])) {
                                return false
                            }
                        }
                    }
                    for (var t = 1; t < e.length - 2; t++) {
                        if (r.segmentsIntersect(e[0], e[e.length - 1], e[t], e[t + 1])) {
                            return false
                        }
                    }
                    return true
                };
                o.prototype.quickDecomp = function(e, t, n, r, s, u) {
                    s = s || 100;
                    u = u || 0;
                    r = r || 25;
                    e = typeof e != "undefined" ? e : [];
                    t = t || [];
                    n = n || [];
                    var a = [0, 0],
                        l = [0, 0],
                        c = [0, 0];
                    var h = 0,
                        p = 0,
                        d = 0,
                        v = 0;
                    var m = 0,
                        g = 0,
                        y = 0;
                    var b = new o,
                        w = new o;
                    var E = this,
                        S = this.vertices;
                    if (S.length < 3) return e;
                    u++;
                    if (u > s) {
                        console.warn("quickDecomp: max level (" + s + ") reached.");
                        return e
                    }
                    for (var x = 0; x < this.vertices.length; ++x) {
                        if (E.isReflex(x)) {
                            t.push(E.vertices[x]);
                            h = p = Number.MAX_VALUE;
                            for (var T = 0; T < this.vertices.length; ++T) {
                                if (i.left(E.at(x - 1), E.at(x), E.at(T)) && i.rightOn(E.at(x - 1), E.at(x), E.at(T - 1))) {
                                    c = f(E.at(x - 1), E.at(x), E.at(T), E.at(T - 1));
                                    if (i.right(E.at(x + 1), E.at(x), c)) {
                                        d = i.sqdist(E.vertices[x], c);
                                        if (d < p) {
                                            p = d;
                                            l = c;
                                            g = T
                                        }
                                    }
                                }
                                if (i.left(E.at(x + 1), E.at(x), E.at(T + 1)) && i.rightOn(E.at(x + 1), E.at(x), E.at(T))) {
                                    c = f(E.at(x + 1), E.at(x), E.at(T), E.at(T + 1));
                                    if (i.left(E.at(x - 1), E.at(x), c)) {
                                        d = i.sqdist(E.vertices[x], c);
                                        if (d < h) {
                                            h = d;
                                            a = c;
                                            m = T
                                        }
                                    }
                                }
                            }
                            if (g == (m + 1) % this.vertices.length) {
                                c[0] = (l[0] + a[0]) / 2;
                                c[1] = (l[1] + a[1]) / 2;
                                n.push(c);
                                if (x < m) {
                                    b.append(E, x, m + 1);
                                    b.vertices.push(c);
                                    w.vertices.push(c);
                                    if (g != 0) {
                                        w.append(E, g, E.vertices.length)
                                    }
                                    w.append(E, 0, x + 1)
                                } else {
                                    if (x != 0) {
                                        b.append(E, x, E.vertices.length)
                                    }
                                    b.append(E, 0, m + 1);
                                    b.vertices.push(c);
                                    w.vertices.push(c);
                                    w.append(E, g, x + 1)
                                }
                            } else {
                                if (g > m) {
                                    m += this.vertices.length
                                }
                                v = Number.MAX_VALUE;
                                if (m < g) {
                                    return e
                                }
                                for (var T = g; T <= m; ++T) {
                                    if (i.leftOn(E.at(x - 1), E.at(x), E.at(T)) && i.rightOn(E.at(x + 1), E.at(x), E.at(T))) {
                                        d = i.sqdist(E.at(x), E.at(T));
                                        if (d < v) {
                                            v = d;
                                            y = T % this.vertices.length
                                        }
                                    }
                                }
                                if (x < y) {
                                    b.append(E, x, y + 1);
                                    if (y != 0) {
                                        w.append(E, y, S.length)
                                    }
                                    w.append(E, 0, x + 1)
                                } else {
                                    if (x != 0) {
                                        b.append(E, x, S.length)
                                    }
                                    b.append(E, 0, y + 1);
                                    w.append(E, y, x + 1)
                                }
                            }
                            if (b.vertices.length < w.vertices.length) {
                                b.quickDecomp(e, t, n, r, s, u);
                                w.quickDecomp(e, t, n, r, s, u)
                            } else {
                                w.quickDecomp(e, t, n, r, s, u);
                                b.quickDecomp(e, t, n, r, s, u)
                            }
                            return e
                        }
                    }
                    e.push(this);
                    return e
                };
                o.prototype.removeCollinearPoints = function(e) {
                    var t = 0;
                    for (var n = this.vertices.length - 1; this.vertices.length > 3 && n >= 0; --n) {
                        if (i.collinear(this.at(n - 1), this.at(n), this.at(n + 1), e)) {
                            this.vertices.splice(n % this.vertices.length, 1);
                            n--;
                            t++
                        }
                    }
                    return t
                }
            }, {
                "./Line": 2,
                "./Point": 3,
                "./Scalar": 5
            }],
            5: [function(e, t, n) {
                function r() {}
                t.exports = r;
                r.eq = function(e, t, n) {
                    n = n || 0;
                    return Math.abs(e - t) < n
                }
            }, {}],
            6: [function(e, t, n) {
                t.exports = {
                    Polygon: e("./Polygon"),
                    Point: e("./Point")
                }
            }, {
                "./Point": 3,
                "./Polygon": 4
            }],
            7: [function(e, t, n) {
                t.exports = {
                    name: "p2",
                    version: "0.5.0",
                    description: "A JavaScript 2D physics engine.",
                    author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                    keywords: ["p2.js", "p2", "physics", "engine", "2d"],
                    main: "./src/p2.js",
                    engines: {
                        node: "*"
                    },
                    repository: {
                        type: "git",
                        url: "https://github.com/schteppe/p2.js.git"
                    },
                    bugs: {
                        url: "https://github.com/schteppe/p2.js/issues"
                    },
                    licenses: [{
                        type: "MIT"
                    }],
                    devDependencies: {
                        grunt: "~0.4.0",
                        "grunt-contrib-jshint": "~0.9.2",
                        "grunt-contrib-nodeunit": "~0.1.2",
                        "grunt-contrib-uglify": "~0.4.0",
                        "grunt-contrib-watch": "~0.5.0",
                        "grunt-browserify": "~2.0.1",
                        "z-schema": "~2.4.6"
                    },
                    dependencies: {
                        "poly-decomp": "0.1.0",
                        "gl-matrix": "2.1.0"
                    }
                }
            }, {}],
            8: [function(e, t, n) {
                function s(e) {
                    this.lowerBound = r.create();
                    if (e && e.lowerBound) {
                        r.copy(this.lowerBound, e.lowerBound)
                    }
                    this.upperBound = r.create();
                    if (e && e.upperBound) {
                        r.copy(this.upperBound, e.upperBound)
                    }
                }
                var r = e("../math/vec2"),
                    i = e("../utils/Utils");
                t.exports = s;
                var o = r.create();
                s.prototype.setFromPoints = function(e, t, n) {
                    var i = this.lowerBound,
                        s = this.upperBound;
                    r.set(i, Number.MAX_VALUE, Number.MAX_VALUE);
                    r.set(s, -Number.MAX_VALUE, -Number.MAX_VALUE);
                    for (var u = 0; u < e.length; u++) {
                        var a = e[u];
                        if (typeof n === "number") {
                            r.rotate(o, a, n);
                            a = o
                        }
                        for (var f = 0; f < 2; f++) {
                            if (a[f] > s[f]) {
                                s[f] = a[f]
                            }
                            if (a[f] < i[f]) {
                                i[f] = a[f]
                            }
                        }
                    }
                    if (t) {
                        r.add(this.lowerBound, this.lowerBound, t);
                        r.add(this.upperBound, this.upperBound, t)
                    }
                };
                s.prototype.copy = function(e) {
                    r.copy(this.lowerBound, e.lowerBound);
                    r.copy(this.upperBound, e.upperBound)
                };
                s.prototype.extend = function(e) {
                    for (var t = 0; t < 2; t++) {
                        if (e.lowerBound[t] < this.lowerBound[t]) {
                            this.lowerBound[t] = e.lowerBound[t]
                        }
                        if (e.upperBound[t] > this.upperBound[t]) {
                            this.upperBound[t] = e.upperBound[t]
                        }
                    }
                };
                s.prototype.overlaps = function(e) {
                    var t = this.lowerBound,
                        n = this.upperBound,
                        r = e.lowerBound,
                        i = e.upperBound;
                    return (r[0] <= n[0] && n[0] <= i[0] || t[0] <= i[0] && i[0] <= n[0]) && (r[1] <= n[1] && n[1] <= i[1] || t[1] <= i[1] && i[1] <= n[1])
                }
            }, {
                "../math/vec2": 30,
                "../utils/Utils": 47
            }],
            9: [function(e, t, n) {
                function s(e) {
                    this.type = e;
                    this.result = [];
                    this.world = null;
                    this.boundingVolumeType = s.AABB
                }
                var r = e("../math/vec2");
                var i = e("../objects/Body");
                t.exports = s;
                s.AABB = 1;
                s.BOUNDING_CIRCLE = 2;
                s.prototype.setWorld = function(e) {
                    this.world = e
                };
                s.prototype.getCollisionPairs = function(e) {
                    throw new Error("getCollisionPairs must be implemented in a subclass!")
                };
                var o = r.create();
                s.boundingRadiusCheck = function(e, t) {
                    r.sub(o, e.position, t.position);
                    var n = r.squaredLength(o),
                        i = e.boundingRadius + t.boundingRadius;
                    return n <= i * i
                };
                s.aabbCheck = function(e, t) {
                    if (e.aabbNeedsUpdate) {
                        e.updateAABB()
                    }
                    if (t.aabbNeedsUpdate) {
                        t.updateAABB()
                    }
                    return e.aabb.overlaps(t.aabb)
                };
                s.prototype.boundingVolumeCheck = function(e, t) {
                    var n;
                    switch (this.boundingVolumeType) {
                        case s.BOUNDING_CIRCLE:
                            n = s.boundingRadiusCheck(e, t);
                            break;
                        case s.AABB:
                            n = s.aabbCheck(e, t);
                            break;
                        default:
                            throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType)
                    }
                    return n
                };
                s.canCollide = function(e, t) {
                    if (e.motionState === i.STATIC && t.motionState === i.STATIC) {
                        return false
                    }
                    if (e.motionState === i.KINEMATIC && t.motionState === i.STATIC || e.motionState === i.STATIC && t.motionState === i.KINEMATIC) {
                        return false
                    }
                    if (e.motionState === i.KINEMATIC && t.motionState === i.KINEMATIC) {
                        return false
                    }
                    if (e.sleepState === i.SLEEPING && t.sleepState === i.SLEEPING) {
                        return false
                    }
                    if (e.sleepState === i.SLEEPING && t.motionState === i.STATIC || t.sleepState === i.SLEEPING && e.motionState === i.STATIC) {
                        return false
                    }
                    return true
                };
                s.NAIVE = 1;
                s.SAP = 2
            }, {
                "../math/vec2": 30,
                "../objects/Body": 31
            }],
            10: [function(e, t, n) {
                function f(e) {
                    o.apply(this);
                    e = a.defaults(e, {
                        xmin: -100,
                        xmax: 100,
                        ymin: -100,
                        ymax: 100,
                        nx: 10,
                        ny: 10
                    });
                    this.xmin = e.xmin;
                    this.ymin = e.ymin;
                    this.xmax = e.xmax;
                    this.ymax = e.ymax;
                    this.nx = e.nx;
                    this.ny = e.ny;
                    this.binsizeX = (this.xmax - this.xmin) / this.nx;
                    this.binsizeY = (this.ymax - this.ymin) / this.ny
                }
                var r = e("../shapes/Circle"),
                    i = e("../shapes/Plane"),
                    s = e("../shapes/Particle"),
                    o = e("../collision/Broadphase"),
                    u = e("../math/vec2"),
                    a = e("../utils/Utils");
                t.exports = f;
                f.prototype = new o;
                f.prototype.getCollisionPairs = function(e) {
                    var t = [],
                        n = e.bodies,
                        r = n.length,
                        i = this.binsizeX,
                        s = this.binsizeY,
                        u = this.nx,
                        a = this.ny,
                        f = this.xmin,
                        l = this.ymin,
                        c = this.xmax,
                        h = this.ymax;
                    var p = [],
                        d = u * a;
                    for (var v = 0; v < d; v++) {
                        p.push([])
                    }
                    var m = u / (c - f);
                    var g = a / (h - l);
                    for (var v = 0; v !== r; v++) {
                        var y = n[v];
                        var b = y.aabb;
                        var w = Math.max(b.lowerBound[0], f);
                        var E = Math.max(b.lowerBound[1], l);
                        var S = Math.min(b.upperBound[0], c);
                        var x = Math.min(b.upperBound[1], h);
                        var T = Math.floor(m * (w - f));
                        var N = Math.floor(g * (E - l));
                        var C = Math.floor(m * (S - f));
                        var k = Math.floor(g * (x - l));
                        for (var L = T; L <= C; L++) {
                            for (var A = N; A <= k; A++) {
                                var O = L;
                                var M = A;
                                var _ = O * (a - 1) + M;
                                if (_ >= 0 && _ < d) {
                                    p[_].push(y)
                                }
                            }
                        }
                    }
                    for (var v = 0; v !== d; v++) {
                        var D = p[v];
                        for (var L = 0, P = D.length; L !== P; L++) {
                            var y = D[L];
                            for (var A = 0; A !== L; A++) {
                                var H = D[A];
                                if (o.canCollide(y, H) && this.boundingVolumeCheck(y, H)) {
                                    t.push(y, H)
                                }
                            }
                        }
                    }
                    return t
                }
            }, {
                "../collision/Broadphase": 9,
                "../math/vec2": 30,
                "../shapes/Circle": 35,
                "../shapes/Particle": 39,
                "../shapes/Plane": 40,
                "../utils/Utils": 47
            }],
            11: [function(e, t, n) {
                function f() {
                    u.call(this, u.NAIVE)
                }
                var r = e("../shapes/Circle"),
                    i = e("../shapes/Plane"),
                    s = e("../shapes/Shape"),
                    o = e("../shapes/Particle"),
                    u = e("../collision/Broadphase"),
                    a = e("../math/vec2");
                t.exports = f;
                f.prototype = new u;
                f.prototype.getCollisionPairs = function(e) {
                    var t = e.bodies,
                        n = this.result;
                    n.length = 0;
                    for (var r = 0, i = t.length; r !== i; r++) {
                        var s = t[r];
                        for (var o = 0; o < r; o++) {
                            var a = t[o];
                            if (u.canCollide(s, a) && this.boundingVolumeCheck(s, a)) {
                                n.push(s, a)
                            }
                        }
                    }
                    return n
                }
            }, {
                "../collision/Broadphase": 9,
                "../math/vec2": 30,
                "../shapes/Circle": 35,
                "../shapes/Particle": 39,
                "../shapes/Plane": 40,
                "../shapes/Shape": 42
            }],
            12: [function(e, t, n) {
                function j() {
                    this.contactEquations = [];
                    this.frictionEquations = [];
                    this.enableFriction = true;
                    this.slipForce = 10;
                    this.frictionCoefficient = .3;
                    this.surfaceVelocity = 0;
                    this.reuseObjects = true;
                    this.reusableContactEquations = [];
                    this.reusableFrictionEquations = [];
                    this.restitution = 0;
                    this.stiffness = f.DEFAULT_STIFFNESS;
                    this.relaxation = f.DEFAULT_RELAXATION;
                    this.frictionStiffness = f.DEFAULT_STIFFNESS;
                    this.frictionRelaxation = f.DEFAULT_RELAXATION;
                    this.collidingBodiesLastStep = new a
                }
                function F(e) {
                    var t = e.keys.length;
                    while (t--) {
                        delete e[e.keys[t]]
                    }
                    e.keys.length = 0
                }
                function I(e, t) {
                    r.set(e.vertices[0], -t.length * .5, -t.radius);
                    r.set(e.vertices[1], t.length * .5, -t.radius);
                    r.set(e.vertices[2], t.length * .5, t.radius);
                    r.set(e.vertices[3], -t.length * .5, t.radius)
                }
                function K(e, t, n, o) {
                    var u = X,
                        a = V,
                        f = $,
                        l = J,
                        c = e,
                        h = t.vertices,
                        p = null;
                    for (var d = 0; d !== h.length + 1; d++) {
                        var v = h[d % h.length],
                            m = h[(d + 1) % h.length];
                        r.rotate(u, v, o);
                        r.rotate(a, m, o);
                        s(u, u, n);
                        s(a, a, n);
                        i(f, u, c);
                        i(l, a, c);
                        var g = r.crossLength(f, l);
                        if (p === null) p = g;
                        if (g * p <= 0) {
                            return false
                        }
                        p = g
                    }
                    return true
                }
                var r = e("../math/vec2"),
                    i = r.sub,
                    s = r.add,
                    o = r.dot,
                    u = e("../utils/Utils"),
                    a = e("../utils/TupleDictionary"),
                    f = e("../equations/Equation"),
                    l = e("../equations/ContactEquation"),
                    c = e("../equations/FrictionEquation"),
                    h = e("../shapes/Circle"),
                    p = e("../shapes/Convex"),
                    d = e("../shapes/Shape"),
                    v = e("../objects/Body"),
                    m = e("../shapes/Rectangle");
                t.exports = j;
                var g = r.fromValues(0, 1);
                var y = r.fromValues(0, 0),
                    b = r.fromValues(0, 0),
                    w = r.fromValues(0, 0),
                    E = r.fromValues(0, 0),
                    S = r.fromValues(0, 0),
                    x = r.fromValues(0, 0),
                    T = r.fromValues(0, 0),
                    N = r.fromValues(0, 0),
                    C = r.fromValues(0, 0),
                    k = r.fromValues(0, 0),
                    L = r.fromValues(0, 0),
                    A = r.fromValues(0, 0),
                    O = r.fromValues(0, 0),
                    M = r.fromValues(0, 0),
                    _ = r.fromValues(0, 0),
                    D = r.fromValues(0, 0),
                    P = r.fromValues(0, 0),
                    H = r.fromValues(0, 0),
                    B = [];
                j.prototype.collidedLastStep = function(e, t) {
                    var n = e.id | 0,
                        r = t.id | 0;
                    return !!this.collidingBodiesLastStep.get(n, r)
                };
                j.prototype.reset = function(e) {
                    this.collidingBodiesLastStep.reset();
                    for (var t = 0; t !== this.contactEquations.length; t++) {
                        var n = this.contactEquations[t],
                            r = n.bodyA.id | 0,
                            i = n.bodyB.id | 0;
                        this.collidingBodiesLastStep.set(r, i, true)
                    }
                    if (this.reuseObjects) {
                        var s = this.contactEquations,
                            o = this.frictionEquations,
                            a = this.reusableFrictionEquations,
                            f = this.reusableContactEquations;
                        u.appendArray(f, s);
                        u.appendArray(a, o)
                    }
                    this.contactEquations.length = this.frictionEquations.length = 0
                };
                j.prototype.createContactEquation = function(e, t, n, r) {
                    var i = this.reusableContactEquations.length ? this.reusableContactEquations.pop() : new l(e, t);
                    i.bodyA = e;
                    i.bodyB = t;
                    i.shapeA = n;
                    i.shapeB = r;
                    i.restitution = this.restitution;
                    i.firstImpact = !this.collidedLastStep(e, t);
                    i.stiffness = this.stiffness;
                    i.relaxation = this.relaxation;
                    i.needsUpdate = true;
                    i.enabled = true;
                    return i
                };
                j.prototype.createFrictionEquation = function(e, t, n, r) {
                    var i = this.reusableFrictionEquations.length ? this.reusableFrictionEquations.pop() : new c(e, t);
                    i.bodyA = e;
                    i.bodyB = t;
                    i.shapeA = n;
                    i.shapeB = r;
                    i.setSlipForce(this.slipForce);
                    i.frictionCoefficient = this.frictionCoefficient;
                    i.relativeVelocity = this.surfaceVelocity;
                    i.enabled = true;
                    i.needsUpdate = true;
                    i.stiffness = this.frictionStiffness;
                    i.relaxation = this.frictionRelaxation;
                    return i
                };
                j.prototype.createFrictionFromContact = function(e) {
                    var t = this.createFrictionEquation(e.bodyA, e.bodyB, e.shapeA, e.shapeB);
                    r.copy(t.contactPointA, e.contactPointA);
                    r.copy(t.contactPointB, e.contactPointB);
                    r.rotate90cw(t.t, e.normalA);
                    t.contactEquation = e;
                    return t
                };
                j.prototype[d.LINE | d.CONVEX] = j.prototype.convexLine = function(e, t, n, r, i, s, o, u, a) {
                    if (a) return false;
                    else return 0
                };
                j.prototype[d.LINE | d.RECTANGLE] = j.prototype.lineRectangle = function(e, t, n, r, i, s, o, u, a) {
                    if (a) return false;
                    else return 0
                };
                var q = new m(1, 1),
                    R = r.create();
                j.prototype[d.CAPSULE | d.CONVEX] = j.prototype[d.CAPSULE | d.RECTANGLE] = j.prototype.convexCapsule = function(e, t, n, i, s, o, u, a, f) {
                    var l = R;
                    r.set(l, o.length / 2, 0);
                    r.rotate(l, l, a);
                    r.add(l, l, u);
                    var c = this.circleConvex(s, o, l, a, e, t, n, i, f, o.radius);
                    r.set(l, -o.length / 2, 0);
                    r.rotate(l, l, a);
                    r.add(l, l, u);
                    var h = this.circleConvex(s, o, l, a, e, t, n, i, f, o.radius);
                    if (f && (c || h)) return true;
                    var p = q;
                    I(p, o);
                    var d = this.convexConvex(e, t, n, i, s, p, u, a, f);
                    return d + c + h
                };
                j.prototype[d.CAPSULE | d.LINE] = j.prototype.lineCapsule = function(e, t, n, r, i, s, o, u, a) {
                    if (a) return false;
                    else return 0
                };
                var U = r.create();
                var z = r.create();
                var W = new m(1, 1);
                j.prototype[d.CAPSULE | d.CAPSULE] = j.prototype.capsuleCapsule = function(e, t, n, i, s, o, u, a, f) {
                    var l = U,
                        c = z;
                    var h = 0;
                    for (var p = 0; p < 2; p++) {
                        r.set(l, (p == 0 ? -1 : 1) * t.length / 2, 0);
                        r.rotate(l, l, i);
                        r.add(l, l, n);
                        for (var d = 0; d < 2; d++) {
                            r.set(c, (d == 0 ? -1 : 1) * o.length / 2, 0);
                            r.rotate(c, c, a);
                            r.add(c, c, u);
                            var v = this.circleCircle(e, t, l, i, s, o, c, a, f, t.radius, o.radius);
                            if (f && v) return true;
                            h += v
                        }
                    }
                    var m = W;
                    I(m, t);
                    var g = this.convexCapsule(e, m, n, i, s, o, u, a, f);
                    if (f && g) return true;
                    h += g;
                    I(m, o);
                    var y = this.convexCapsule(s, m, u, a, e, t, n, i, f);
                    if (f && y) return true;
                    h += y;
                    return h
                };
                j.prototype[d.LINE | d.LINE] = j.prototype.lineLine = function(e, t, n, r, i, s, o, u, a) {
                    if (a) return false;
                    else return 0
                };
                j.prototype[d.PLANE | d.LINE] = j.prototype.planeLine = function(e, t, n, u, a, f, l, c, h) {
                    var p = y,
                        d = b,
                        v = w,
                        m = E,
                        k = S,
                        L = x,
                        A = T,
                        O = N,
                        M = C,
                        _ = B;
                    numContacts = 0;
                    r.set(p, -f.length / 2, 0);
                    r.set(d, f.length / 2, 0);
                    r.rotate(v, p, c);
                    r.rotate(m, d, c);
                    s(v, v, l);
                    s(m, m, l);
                    r.copy(p, v);
                    r.copy(d, m);
                    i(k, d, p);
                    r.normalize(L, k);
                    r.rotate90cw(M, L);
                    r.rotate(O, g, u);
                    _[0] = p;
                    _[1] = d;
                    for (var D = 0; D < _.length; D++) {
                        var P = _[D];
                        i(A, P, n);
                        var H = o(A, O);
                        if (H < 0) {
                            if (h) return true;
                            var j = this.createContactEquation(e, a, t, f);
                            numContacts++;
                            r.copy(j.normalA, O);
                            r.normalize(j.normalA, j.normalA);
                            r.scale(A, O, H);
                            i(j.contactPointA, P, A);
                            i(j.contactPointA, j.contactPointA, e.position);
                            i(j.contactPointB, P, l);
                            s(j.contactPointB, j.contactPointB, l);
                            i(j.contactPointB, j.contactPointB, a.position);
                            this.contactEquations.push(j);
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(j))
                            }
                        }
                    }
                    return numContacts
                };
                j.prototype[d.PARTICLE | d.CAPSULE] = j.prototype.particleCapsule = function(e, t, n, r, i, s, o, u, a) {
                    return this.circleLine(e, t, n, r, i, s, o, u, a, s.radius, 0)
                };
                j.prototype[d.CIRCLE | d.LINE] = j.prototype.circleLine = function(e, t, n, u, a, f, l, c, h, p, d) {
                    var v = f,
                        m = c,
                        g = a,
                        _ = l,
                        D = n,
                        P = e,
                        H = t,
                        p = p || 0,
                        d = typeof d != "undefined" ? d : H.radius,
                        j = y,
                        F = b,
                        I = w,
                        q = E,
                        R = S,
                        U = x,
                        z = T,
                        W = N,
                        X = C,
                        V = k,
                        $ = L,
                        J = A,
                        K = O,
                        Q = M,
                        G = B;
                    r.set(W, -v.length / 2, 0);
                    r.set(X, v.length / 2, 0);
                    r.rotate(V, W, m);
                    r.rotate($, X, m);
                    s(V, V, _);
                    s($, $, _);
                    r.copy(W, V);
                    r.copy(X, $);
                    i(U, X, W);
                    r.normalize(z, U);
                    r.rotate90cw(R, z);
                    i(J, D, W);
                    var Y = o(J, R);
                    i(q, W, _);
                    i(K, D, _);
                    if (Math.abs(Y) < d + p) {
                        r.scale(j, R, Y);
                        i(I, D, j);
                        r.scale(F, R, o(R, K));
                        r.normalize(F, F);
                        r.scale(F, F, p);
                        s(I, I, F);
                        var Z = o(z, I);
                        var et = o(z, W);
                        var tt = o(z, X);
                        if (Z > et && Z < tt) {
                            if (h) return true;
                            var nt = this.createContactEquation(P, g, t, f);
                            r.scale(nt.normalA, j, -1);
                            r.normalize(nt.normalA, nt.normalA);
                            r.scale(nt.contactPointA, nt.normalA, d);
                            s(nt.contactPointA, nt.contactPointA, D);
                            i(nt.contactPointA, nt.contactPointA, P.position);
                            i(nt.contactPointB, I, _);
                            s(nt.contactPointB, nt.contactPointB, _);
                            i(nt.contactPointB, nt.contactPointB, g.position);
                            this.contactEquations.push(nt);
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(nt))
                            }
                            return 1
                        }
                    }
                    G[0] = W;
                    G[1] = X;
                    for (var rt = 0; rt < G.length; rt++) {
                        var it = G[rt];
                        i(J, it, D);
                        if (r.squaredLength(J) < (d + p) * (d + p)) {
                            if (h) return true;
                            var nt = this.createContactEquation(P, g, t, f);
                            r.copy(nt.normalA, J);
                            r.normalize(nt.normalA, nt.normalA);
                            r.scale(nt.contactPointA, nt.normalA, d);
                            s(nt.contactPointA, nt.contactPointA, D);
                            i(nt.contactPointA, nt.contactPointA, P.position);
                            i(nt.contactPointB, it, _);
                            r.scale(Q, nt.normalA, -p);
                            s(nt.contactPointB, nt.contactPointB, Q);
                            s(nt.contactPointB, nt.contactPointB, _);
                            i(nt.contactPointB, nt.contactPointB, g.position);
                            this.contactEquations.push(nt);
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(nt))
                            }
                            return 1
                        }
                    }
                    return 0
                };
                j.prototype[d.CIRCLE | d.CAPSULE] = j.prototype.circleCapsule = function(e, t, n, r, i, s, o, u, a) {
                    return this.circleLine(e, t, n, r, i, s, o, u, a, s.radius)
                };
                j.prototype[d.CIRCLE | d.CONVEX] = j.prototype[d.CIRCLE | d.RECTANGLE] = j.prototype.circleConvex = function(e, t, n, o, u, a, f, l, c, h) {
                    var p = a,
                        d = l,
                        v = u,
                        m = f,
                        g = n,
                        P = e,
                        H = t,
                        h = typeof h == "number" ? h : H.radius;
                    var B = y,
                        j = b,
                        F = w,
                        I = E,
                        q = S,
                        R = x,
                        U = T,
                        z = N,
                        W = C,
                        X = k,
                        V = L,
                        $ = -1,
                        J = null,
                        Q = A,
                        G = O,
                        Y = M,
                        Z = _,
                        et = D,
                        tt = false,
                        nt = Number.MAX_VALUE;
                    var rt = 0;
                    verts = p.vertices;
                    for (var it = 0; it !== verts.length + 1; it++) {
                        var st = verts[it % verts.length],
                            ot = verts[(it + 1) % verts.length];
                        r.rotate(B, st, d);
                        r.rotate(j, ot, d);
                        s(B, B, m);
                        s(j, j, m);
                        i(F, j, B);
                        r.normalize(I, F);
                        r.rotate90cw(q, I);
                        r.scale(Y, q, -H.radius);
                        s(Y, Y, g);
                        if (K(Y, p, m, d)) {
                            r.sub(Z, B, Y);
                            var ut = Math.abs(r.dot(Z, q));
                            if (ut < nt) {
                                r.copy(et, Y);
                                nt = ut;
                                r.scale(G, q, ut);
                                r.add(G, G, Y);
                                tt = true
                            }
                        }
                    }
                    if (tt) {
                        if (c) return true;
                        var at = this.createContactEquation(P, v, t, a);
                        r.sub(at.normalA, et, g);
                        r.normalize(at.normalA, at.normalA);
                        r.scale(at.contactPointA, at.normalA, h);
                        s(at.contactPointA, at.contactPointA, g);
                        i(at.contactPointA, at.contactPointA, P.position);
                        i(at.contactPointB, G, m);
                        s(at.contactPointB, at.contactPointB, m);
                        i(at.contactPointB, at.contactPointB, v.position);
                        this.contactEquations.push(at);
                        if (this.enableFriction) this.frictionEquations.push(this.createFrictionFromContact(at));
                        return 1
                    }
                    if (h > 0) {
                        for (var it = 0; it < verts.length; it++) {
                            var ft = verts[it];
                            r.rotate(V, ft, d);
                            s(V, V, m);
                            i(X, V, g);
                            if (r.squaredLength(X) < h * h) {
                                if (c) return true;
                                var at = this.createContactEquation(P, v, t, a);
                                r.copy(at.normalA, X);
                                r.normalize(at.normalA, at.normalA);
                                r.scale(at.contactPointA, at.normalA, h);
                                s(at.contactPointA, at.contactPointA, g);
                                i(at.contactPointA, at.contactPointA, P.position);
                                i(at.contactPointB, V, m);
                                s(at.contactPointB, at.contactPointB, m);
                                i(at.contactPointB, at.contactPointB, v.position);
                                this.contactEquations.push(at);
                                if (this.enableFriction) {
                                    this.frictionEquations.push(this.createFrictionFromContact(at))
                                }
                                return 1
                            }
                        }
                    }
                    return 0
                };
                var X = r.create(),
                    V = r.create(),
                    $ = r.create(),
                    J = r.create();
                j.prototype[d.PARTICLE | d.CONVEX] = j.prototype[d.PARTICLE | d.RECTANGLE] = j.prototype.particleConvex = function(e, t, n, u, a, f, l, c, h) {
                    var p = f,
                        d = c,
                        v = a,
                        m = l,
                        g = n,
                        B = e,
                        j = t,
                        F = y,
                        I = b,
                        q = w,
                        R = E,
                        U = S,
                        z = x,
                        W = T,
                        X = N,
                        V = C,
                        $ = k,
                        J = L,
                        Q = -1,
                        G = null,
                        Y = A,
                        Z = O,
                        et = M,
                        tt = _,
                        nt = D,
                        rt = P,
                        it = H,
                        st = Number.MAX_VALUE;
                    var ot = 0,
                        ut = false,
                        at = p.vertices;
                    if (!K(g, p, m, d)) {
                        return 0
                    }
                    if (h) return true;
                    var ft = null;
                    for (var lt = 0; lt !== at.length + 1; lt++) {
                        var ct = at[lt % at.length],
                            ht = at[(lt + 1) % at.length];
                        r.rotate(F, ct, d);
                        r.rotate(I, ht, d);
                        s(F, F, m);
                        s(I, I, m);
                        i(q, I, F);
                        r.normalize(R, q);
                        r.rotate90cw(U, R);
                        i($, g, F);
                        var pt = o($, U);
                        i(z, F, m);
                        i(W, g, m);
                        r.sub(rt, F, g);
                        var dt = Math.abs(r.dot(rt, U));
                        if (dt < st) {
                            st = dt;
                            r.scale(Z, U, dt);
                            r.add(Z, Z, g);
                            r.copy(it, U);
                            ut = true
                        }
                    }
                    if (ut) {
                        var vt = this.createContactEquation(B, v, t, f);
                        r.scale(vt.normalA, it, -1);
                        r.normalize(vt.normalA, vt.normalA);
                        r.set(vt.contactPointA, 0, 0);
                        s(vt.contactPointA, vt.contactPointA, g);
                        i(vt.contactPointA, vt.contactPointA, B.position);
                        i(vt.contactPointB, Z, m);
                        s(vt.contactPointB, vt.contactPointB, m);
                        i(vt.contactPointB, vt.contactPointB, v.position);
                        this.contactEquations.push(vt);
                        if (this.enableFriction) this.frictionEquations.push(this.createFrictionFromContact(vt));
                        return 1
                    }
                    return 0
                };
                j.prototype[d.CIRCLE] = j.prototype.circleCircle = function(e, t, n, o, u, a, f, l, c, h, p) {
                    var d = e,
                        v = t,
                        m = n,
                        g = u,
                        b = a,
                        w = f,
                        E = y,
                        h = h || v.radius,
                        p = p || b.radius;
                    i(E, n, f);
                    var S = h + p;
                    if (r.squaredLength(E) > S * S) {
                        return 0
                    }
                    if (c) {
                        return true
                    }
                    var x = this.createContactEquation(d, g, t, a);
                    i(x.normalA, w, m);
                    r.normalize(x.normalA, x.normalA);
                    r.scale(x.contactPointA, x.normalA, h);
                    r.scale(x.contactPointB, x.normalA, -p);
                    s(x.contactPointA, x.contactPointA, m);
                    i(x.contactPointA, x.contactPointA, d.position);
                    s(x.contactPointB, x.contactPointB, w);
                    i(x.contactPointB, x.contactPointB, g.position);
                    this.contactEquations.push(x);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(x))
                    }
                    return 1
                };
                j.prototype[d.PLANE | d.CONVEX] = j.prototype[d.PLANE | d.RECTANGLE] = j.prototype.planeConvex = function(e, t, n, u, a, f, l, c, h) {
                    var p = a,
                        d = l,
                        v = f,
                        m = c,
                        E = e,
                        S = t,
                        x = n,
                        T = u;
                    var N = y,
                        C = b,
                        k = w;
                    var L = 0;
                    r.rotate(C, g, T);
                    for (var A = 0; A < v.vertices.length; A++) {
                        var O = v.vertices[A];
                        r.rotate(N, O, m);
                        s(N, N, d);
                        i(k, N, x);
                        if (o(k, C) <= j.convexPrecision) {
                            if (h) {
                                return true
                            }
                            L++;
                            var M = this.createContactEquation(E, p, S, v);
                            i(k, N, x);
                            r.copy(M.normalA, C);
                            var _ = o(k, M.normalA);
                            r.scale(k, M.normalA, _);
                            i(M.contactPointB, N, p.position);
                            i(M.contactPointA, N, k);
                            i(M.contactPointA, M.contactPointA, E.position);
                            this.contactEquations.push(M);
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(M))
                            }
                        }
                    }
                    return L
                };
                j.prototype.convexPlane = function(e, t, n, r, i, s, o, u, a) {
                    console.warn("Narrowphase.prototype.convexPlane is deprecated. Use planeConvex instead!");
                    return this.planeConvex(i, s, o, u, e, t, n, r, a)
                };
                j.prototype[d.PARTICLE | d.PLANE] = j.prototype.particlePlane = function(e, t, n, s, u, a, f, l, c) {
                    var h = e,
                        p = t,
                        d = n,
                        v = u,
                        m = a,
                        w = f,
                        E = l;
                    var S = y,
                        x = b;
                    E = E || 0;
                    i(S, d, w);
                    r.rotate(x, g, E);
                    var T = o(S, x);
                    if (T > 0) return 0;
                    if (c) return true;
                    var N = this.createContactEquation(v, h, a, t);
                    r.copy(N.normalA, x);
                    r.scale(S, N.normalA, T);
                    i(N.contactPointA, d, S);
                    i(N.contactPointA, N.contactPointA, v.position);
                    i(N.contactPointB, d, h.position);
                    this.contactEquations.push(N);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(N))
                    }
                    return 1
                };
                j.prototype[d.CIRCLE | d.PARTICLE] = j.prototype.circleParticle = function(e, t, n, o, u, a, f, l, c) {
                    var h = e,
                        p = t,
                        d = n,
                        v = u,
                        m = a,
                        g = f,
                        b = y;
                    i(b, g, d);
                    if (r.squaredLength(b) > p.radius * p.radius) return 0;
                    if (c) return true;
                    var w = this.createContactEquation(h, v, t, a);
                    r.copy(w.normalA, b);
                    r.normalize(w.normalA, w.normalA);
                    r.scale(w.contactPointA, w.normalA, p.radius);
                    s(w.contactPointA, w.contactPointA, d);
                    i(w.contactPointA, w.contactPointA, h.position);
                    i(w.contactPointB, g, v.position);
                    this.contactEquations.push(w);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(w))
                    }
                    return 1
                };
                var Q = new h(1),
                    G = r.create(),
                    Y = r.create(),
                    Z = r.create();
                j.prototype[d.PLANE | d.CAPSULE] = j.prototype.planeCapsule = function(e, t, n, i, o, u, a, f, l) {
                    var c = G,
                        h = Y,
                        p = Q,
                        d = Z;
                    r.set(c, -u.length / 2, 0);
                    r.rotate(c, c, f);
                    s(c, c, a);
                    r.set(h, u.length / 2, 0);
                    r.rotate(h, h, f);
                    s(h, h, a);
                    p.radius = u.radius;
                    var v = this.circlePlane(o, p, c, 0, e, t, n, i, l),
                        m = this.circlePlane(o, p, h, 0, e, t, n, i, l);
                    if (l) return v || m;
                    else return v + m
                };
                j.prototype.capsulePlane = function(e, t, n, r, i, s, o, u, a) {
                    console.warn("Narrowphase.prototype.capsulePlane() is deprecated. Use .planeCapsule() instead!");
                    return this.planeCapsule(i, s, o, u, e, t, n, r, a)
                };
                j.prototype[d.CIRCLE | d.PLANE] = j.prototype.circlePlane = function(e, t, n, u, a, f, l, c, h) {
                    var p = e,
                        d = t,
                        v = n,
                        m = a,
                        E = f,
                        S = l,
                        x = c;
                    x = x || 0;
                    var T = y,
                        N = b,
                        C = w;
                    i(T, v, S);
                    r.rotate(N, g, x);
                    var k = o(N, T);
                    if (k > d.radius) {
                        return 0
                    }
                    if (h) {
                        return true
                    }
                    var L = this.createContactEquation(m, p, f, t);
                    r.copy(L.normalA, N);
                    r.scale(L.contactPointB, L.normalA, -d.radius);
                    s(L.contactPointB, L.contactPointB, v);
                    i(L.contactPointB, L.contactPointB, p.position);
                    r.scale(C, L.normalA, k);
                    i(L.contactPointA, T, C);
                    s(L.contactPointA, L.contactPointA, S);
                    i(L.contactPointA, L.contactPointA, m.position);
                    this.contactEquations.push(L);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(L))
                    }
                    return 1
                };
                j.convexPrecision = 1e-7;
                j.prototype[d.CONVEX] = j.prototype[d.CONVEX | d.RECTANGLE] = j.prototype[d.RECTANGLE] = j.prototype.convexConvex = function(e, t, n, u, a, f, l, c, h, p) {
                    var d = y,
                        v = b,
                        m = w,
                        g = E,
                        k = S,
                        L = x,
                        A = T,
                        O = N,
                        M = C,
                        _ = 0,
                        p = p || j.convexPrecision;
                    var D = j.findSeparatingAxis(t, n, u, f, l, c, d);
                    if (!D) {
                        return 0
                    }
                    i(O, l, n);
                    if (o(d, O) > 0) {
                        r.scale(d, d, -1)
                    }
                    var P = j.getClosestEdge(t, u, d, true),
                        H = j.getClosestEdge(f, c, d);
                    if (P === -1 || H === -1) {
                        return 0
                    }
                    for (var B = 0; B < 2; B++) {
                        var F = P,
                            I = H,
                            q = t,
                            R = f,
                            U = n,
                            z = l,
                            W = u,
                            X = c,
                            V = e,
                            $ = a;
                        if (B === 0) {
                            var J;
                            J = F;
                            F = I;
                            I = J;
                            J = q;
                            q = R;
                            R = J;
                            J = U;
                            U = z;
                            z = J;
                            J = W;
                            W = X;
                            X = J;
                            J = V;
                            V = $;
                            $ = J
                        }
                        for (var K = I; K < I + 2; K++) {
                            var Q = R.vertices[(K + R.vertices.length) % R.vertices.length];
                            r.rotate(v, Q, X);
                            s(v, v, z);
                            var G = 0;
                            for (var Y = F - 1; Y < F + 2; Y++) {
                                var Z = q.vertices[(Y + q.vertices.length) % q.vertices.length],
                                    et = q.vertices[(Y + 1 + q.vertices.length) % q.vertices.length];
                                r.rotate(m, Z, W);
                                r.rotate(g, et, W);
                                s(m, m, U);
                                s(g, g, U);
                                i(k, g, m);
                                r.rotate90cw(M, k);
                                r.normalize(M, M);
                                i(O, v, m);
                                var tt = o(M, O);
                                if (tt <= p) {
                                    G++
                                }
                            }
                            if (G >= 3) {
                                if (h) {
                                    return true
                                }
                                var nt = this.createContactEquation(V, $, q, R);
                                _++;
                                var Z = q.vertices[F % q.vertices.length],
                                    et = q.vertices[(F + 1) % q.vertices.length];
                                r.rotate(m, Z, W);
                                r.rotate(g, et, W);
                                s(m, m, U);
                                s(g, g, U);
                                i(k, g, m);
                                r.rotate90cw(nt.normalA, k);
                                r.normalize(nt.normalA, nt.normalA);
                                i(O, v, m);
                                var tt = o(nt.normalA, O);
                                r.scale(A, nt.normalA, tt);
                                i(nt.contactPointA, v, U);
                                i(nt.contactPointA, nt.contactPointA, A);
                                s(nt.contactPointA, nt.contactPointA, U);
                                i(nt.contactPointA, nt.contactPointA, V.position);
                                i(nt.contactPointB, v, z);
                                s(nt.contactPointB, nt.contactPointB, z);
                                i(nt.contactPointB, nt.contactPointB, $.position);
                                this.contactEquations.push(nt);
                                if (this.enableFriction) this.frictionEquations.push(this.createFrictionFromContact(nt))
                            }
                        }
                    }
                    return _
                };
                var et = r.fromValues(0, 0);
                j.projectConvexOntoAxis = function(e, t, n, i, s) {
                    var u = null,
                        a = null,
                        f, l, c = et;
                    r.rotate(c, i, -n);
                    for (var h = 0; h < e.vertices.length; h++) {
                        f = e.vertices[h];
                        l = o(f, c);
                        if (u === null || l > u) u = l;
                        if (a === null || l < a) a = l
                    }
                    if (a > u) {
                        var p = a;
                        a = u;
                        u = p
                    }
                    var d = o(t, i);
                    r.set(s, a + d, u + d)
                };
                var tt = r.fromValues(0, 0),
                    nt = r.fromValues(0, 0),
                    rt = r.fromValues(0, 0),
                    it = r.fromValues(0, 0),
                    st = r.fromValues(0, 0),
                    ot = r.fromValues(0, 0);
                j.findSeparatingAxis = function(e, t, n, s, o, u, a) {
                    var f = null,
                        l = false,
                        c = false,
                        h = tt,
                        p = nt,
                        d = rt,
                        v = it,
                        m = st,
                        g = ot;
                    for (var y = 0; y !== 2; y++) {
                        var b = e,
                            w = n;
                        if (y === 1) {
                            b = s;
                            w = u
                        }
                        for (var E = 0; E !== b.vertices.length; E++) {
                            r.rotate(p, b.vertices[E], w);
                            r.rotate(d, b.vertices[(E + 1) % b.vertices.length], w);
                            i(h, d, p);
                            r.rotate90cw(v, h);
                            r.normalize(v, v);
                            j.projectConvexOntoAxis(e, t, n, v, m);
                            j.projectConvexOntoAxis(s, o, u, v, g);
                            var S = m,
                                x = g,
                                T = false;
                            if (m[0] > g[0]) {
                                x = m;
                                S = g;
                                T = true
                            }
                            var N = x[0] - S[1];
                            l = N <= j.convexPrecision;
                            if (f === null || N > f) {
                                r.copy(a, v);
                                f = N;
                                c = l
                            }
                        }
                    }
                    return c
                };
                var ut = r.fromValues(0, 0),
                    at = r.fromValues(0, 0),
                    ft = r.fromValues(0, 0);
                j.getClosestEdge = function(e, t, n, s) {
                    var u = ut,
                        a = at,
                        f = ft;
                    r.rotate(u, n, -t);
                    if (s) {
                        r.scale(u, u, -1)
                    }
                    var l = -1,
                        c = e.vertices.length;
                    for (var h = 0; h !== c; h++) {
                        i(a, e.vertices[(h + 1) % c], e.vertices[h % c]);
                        r.rotate90cw(f, a);
                        r.normalize(f, f);
                        var p = o(f, u);
                        if (l == -1 || p > maxDot) {
                            l = h % c;
                            maxDot = p
                        }
                    }
                    return l
                };
                var lt = r.create(),
                    ct = r.create(),
                    ht = r.create(),
                    pt = r.create(),
                    dt = r.create(),
                    vt = r.create(),
                    mt = r.create();
                j.prototype[d.CIRCLE | d.HEIGHTFIELD] = j.prototype.circleHeightfield = function(e, t, n, o, u, a, f, l, c, h) {
                    var p = a.data,
                        h = h || t.radius,
                        d = a.elementWidth,
                        v = ct,
                        m = lt,
                        g = dt,
                        y = mt,
                        b = vt,
                        w = ht,
                        E = pt;
                    var S = Math.floor((n[0] - h - f[0]) / d),
                        x = Math.ceil((n[0] + h - f[0]) / d);
                    if (S < 0) S = 0;
                    if (x >= p.length) x = p.length - 1;
                    var T = p[S],
                        N = p[x];
                    for (var C = S; C < x; C++) {
                        if (p[C] < N) N = p[C];
                        if (p[C] > T) T = p[C]
                    }
                    if (n[1] - h > T) return c ? false : 0;
                    if (n[1] + h < N) {}
                    var k = false;
                    for (var C = S; C < x; C++) {
                        r.set(w, C * d, p[C]);
                        r.set(E, (C + 1) * d, p[C + 1]);
                        r.add(w, w, f);
                        r.add(E, E, f);
                        r.sub(b, E, w);
                        r.rotate(b, b, Math.PI / 2);
                        r.normalize(b, b);
                        r.scale(m, b, -h);
                        r.add(m, m, n);
                        r.sub(v, m, w);
                        var L = r.dot(v, b);
                        if (m[0] >= w[0] && m[0] < E[0] && L <= 0) {
                            if (c) {
                                return true
                            }
                            k = true;
                            r.scale(v, b, -L);
                            r.add(g, m, v);
                            r.copy(y, b);
                            var A = this.createContactEquation(u, e, a, t);
                            r.copy(A.normalA, y);
                            r.scale(A.contactPointB, A.normalA, -h);
                            s(A.contactPointB, A.contactPointB, n);
                            i(A.contactPointB, A.contactPointB, e.position);
                            r.copy(A.contactPointA, g);
                            r.sub(A.contactPointA, A.contactPointA, u.position);
                            this.contactEquations.push(A);
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(A))
                            }
                        }
                    }
                    k = false;
                    if (h > 0) {
                        for (var C = S; C <= x; C++) {
                            r.set(w, C * d, p[C]);
                            r.add(w, w, f);
                            r.sub(v, n, w);
                            if (r.squaredLength(v) < h * h) {
                                if (c) return true;
                                k = true;
                                var A = this.createContactEquation(u, e, a, t);
                                r.copy(A.normalA, v);
                                r.normalize(A.normalA, A.normalA);
                                r.scale(A.contactPointB, A.normalA, -h);
                                s(A.contactPointB, A.contactPointB, n);
                                i(A.contactPointB, A.contactPointB, e.position);
                                i(A.contactPointA, w, f);
                                s(A.contactPointA, A.contactPointA, f);
                                i(A.contactPointA, A.contactPointA, u.position);
                                this.contactEquations.push(A);
                                if (this.enableFriction) {
                                    this.frictionEquations.push(this.createFrictionFromContact(A))
                                }
                            }
                        }
                    }
                    if (k) {
                        return 1
                    }
                    return 0
                };
                var gt = r.create(),
                    yt = r.create(),
                    bt = r.create(),
                    wt = new p([r.create(), r.create(), r.create(), r.create()]);
                j.prototype[d.RECTANGLE | d.HEIGHTFIELD] = j.prototype[d.CONVEX | d.HEIGHTFIELD] = j.prototype.convexHeightfield = function(e, t, n, i, s, o, u, a, f) {
                    var l = o.data,
                        c = o.elementWidth,
                        h = gt,
                        p = yt,
                        d = bt,
                        v = wt;
                    var m = Math.floor((e.aabb.lowerBound[0] - u[0]) / c),
                        g = Math.ceil((e.aabb.upperBound[0] - u[0]) / c);
                    if (m < 0) m = 0;
                    if (g >= l.length) g = l.length - 1;
                    var y = l[m],
                        b = l[g];
                    for (var w = m; w < g; w++) {
                        if (l[w] < b) b = l[w];
                        if (l[w] > y) y = l[w]
                    }
                    if (e.aabb.lowerBound[1] > y) {
                        return f ? false : 0
                    }
                    var E = false;
                    var S = 0;
                    for (var w = m; w < g; w++) {
                        r.set(h, w * c, l[w]);
                        r.set(p, (w + 1) * c, l[w + 1]);
                        r.add(h, h, u);
                        r.add(p, p, u);
                        var x = 100;
                        r.set(d, (p[0] + h[0]) * .5, (p[1] + h[1] - x) * .5);
                        r.sub(v.vertices[0], p, d);
                        r.sub(v.vertices[1], h, d);
                        r.copy(v.vertices[2], v.vertices[1]);
                        r.copy(v.vertices[3], v.vertices[0]);
                        v.vertices[2][1] -= x;
                        v.vertices[3][1] -= x;
                        S += this.convexConvex(e, t, n, i, s, v, d, 0, f)
                    }
                    return S
                }
            }, {
                "../equations/ContactEquation": 21,
                "../equations/Equation": 22,
                "../equations/FrictionEquation": 23,
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../shapes/Circle": 35,
                "../shapes/Convex": 36,
                "../shapes/Rectangle": 41,
                "../shapes/Shape": 42,
                "../utils/TupleDictionary": 46,
                "../utils/Utils": 47
            }],
            13: [function(e, t, n) {
                function s() {
                    i.call(this, i.SAP);
                    this.axisList = [];
                    this.world = null;
                    this.axisIndex = 0;
                    var e = this.axisList;
                    this._addBodyHandler = function(t) {
                        e.push(t.body)
                    };
                    this._removeBodyHandler = function(t) {
                        var n = e.indexOf(t.body);
                        if (n !== -1) {
                            e.splice(n, 1)
                        }
                    }
                }
                var r = e("../utils/Utils"),
                    i = e("../collision/Broadphase");
                t.exports = s;
                s.prototype = new i;
                s.prototype.setWorld = function(e) {
                    this.axisList.length = 0;
                    r.appendArray(this.axisList, e.bodies);
                    e.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler);
                    e.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler);
                    this.world = e
                };
                s.sortAxisList = function(e, t) {
                    t = t | 0;
                    for (var n = 1, r = e.length; n < r; n++) {
                        var i = e[n];
                        for (var s = n - 1; s >= 0; s--) {
                            if (e[s].aabb.lowerBound[t] <= i.aabb.lowerBound[t]) {
                                break
                            }
                            e[s + 1] = e[s]
                        }
                        e[s + 1] = i
                    }
                    return e
                };
                s.prototype.getCollisionPairs = function(e) {
                    var t = this.axisList,
                        n = this.result,
                        r = this.axisIndex;
                    n.length = 0;
                    var o = t.length;
                    while (o--) {
                        var u = t[o];
                        if (u.aabbNeedsUpdate) {
                            u.updateAABB()
                        }
                    }
                    s.sortAxisList(t, r);
                    for (var a = 0, f = t.length | 0; a !== f; a++) {
                        var l = t[a];
                        for (var c = a + 1; c < f; c++) {
                            var h = t[c];
                            var p = h.aabb.lowerBound[r] <= l.aabb.upperBound[r];
                            if (!p) {
                                break
                            }
                            if (i.canCollide(l, h) && this.boundingVolumeCheck(l, h)) {
                                n.push(l, h)
                            }
                        }
                    }
                    return n
                }
            }, {
                "../collision/Broadphase": 9,
                "../utils/Utils": 47
            }],
            14: [function(e, t, n) {
                function i(e, t, n, i) {
                    this.type = n;
                    i = r.defaults(i, {
                        collideConnected: true,
                        wakeUpBodies: true
                    });
                    this.equations = [];
                    this.bodyA = e;
                    this.bodyB = t;
                    this.collideConnected = i.collideConnected;
                    if (i.wakeUpBodies) {
                        if (e) {
                            e.wakeUp()
                        }
                        if (t) {
                            t.wakeUp()
                        }
                    }
                }
                t.exports = i;
                var r = e("../utils/Utils");
                i.prototype.update = function() {
                    throw new Error("method update() not implmemented in this Constraint subclass!")
                };
                i.DISTANCE = 1;
                i.GEAR = 2;
                i.LOCK = 3;
                i.PRISMATIC = 4;
                i.REVOLUTE = 5;
                i.prototype.setStiffness = function(e) {
                    var t = this.equations;
                    for (var n = 0; n !== t.length; n++) {
                        var r = t[n];
                        r.stiffness = e;
                        r.needsUpdate = true
                    }
                };
                i.prototype.setRelaxation = function(e) {
                    var t = this.equations;
                    for (var n = 0; n !== t.length; n++) {
                        var r = t[n];
                        r.relaxation = e;
                        r.needsUpdate = true
                    }
                }
            }, {
                "../utils/Utils": 47
            }],
            15: [function(e, t, n) {
                function o(e, t, n, o) {
                    o = o || {};
                    r.call(this, e, t, r.DISTANCE, o);
                    this.distance = n;
                    this.localAnchorA = s.create();
                    this.localAnchorB = s.create();
                    var u = this.localAnchorA;
                    var a = this.localAnchorB;
                    var f;
                    if (typeof o.maxForce === "undefined") {
                        f = Number.MAX_VALUE
                    } else {
                        f = o.maxForce
                    }
                    var l = new i(e, t, -f, f);
                    this.equations = [l];
                    var c = s.create();
                    var h = s.create();
                    var p = s.create();
                    var d = this;
                    l.computeGq = function() {
                        var e = this.bodyA,
                            t = this.bodyB,
                            n = e.position,
                            r = t.position;
                        s.rotate(h, u, e.angle);
                        s.rotate(p, a, t.angle);
                        s.add(c, n, p);
                        s.sub(c, c, h);
                        s.sub(c, c, n);
                        s.sub(c, t.position, e.position);
                        return s.length(c) - d.distance
                    };
                    this.setMaxForce(f)
                }
                var r = e("./Constraint"),
                    i = e("../equations/Equation"),
                    s = e("../math/vec2");
                t.exports = o;
                o.prototype = new r;
                var u = s.create();
                var a = s.create();
                var f = s.create();
                o.prototype.update = function() {
                    var e = this.equations[0],
                        t = this.bodyA,
                        n = this.bodyB,
                        r = this.distance,
                        i = t.position,
                        o = n.position,
                        l = e.G;
                    s.rotate(a, this.localAnchorA, t.angle);
                    s.rotate(f, this.localAnchorB, n.angle);
                    var c = s.crossLength(a, u),
                        h = s.crossLength(f, u);
                    s.sub(u, n.position, t.position);
                    s.normalize(u, u);
                    l[0] = -u[0];
                    l[1] = -u[1];
                    l[3] = u[0];
                    l[4] = u[1]
                };
                o.prototype.setMaxForce = function(e) {
                    var t = this.equations[0];
                    t.minForce = -e;
                    t.maxForce = e
                };
                o.prototype.getMaxForce = function(e) {
                    var t = this.equations[0];
                    return t.maxForce
                }
            }, {
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "./Constraint": 14
            }],
            16: [function(e, t, n) {
                function u(e, t, n) {
                    n = n || {};
                    r.call(this, e, t, r.GEAR, n);
                    this.equations = [new s(e, t, n)];
                    this.angle = typeof n.angle === "number" ? n.angle : 0;
                    this.ratio = typeof n.ratio === "number" ? n.ratio : 1;
                    if (typeof n.maxTorque === "number") {
                        this.setMaxTorque(n.maxTorque)
                    }
                }
                var r = e("./Constraint"),
                    i = e("../equations/Equation"),
                    s = e("../equations/AngleLockEquation"),
                    o = e("../math/vec2");
                t.exports = u;
                u.prototype = new r;
                u.prototype.update = function() {
                    var e = this.equations[0];
                    if (e.ratio !== this.ratio) {
                        e.setRatio(this.ratio)
                    }
                    e.angle = this.angle
                };
                u.prototype.setMaxTorque = function(e) {
                    this.equations[0].setMaxTorque(e)
                };
                u.prototype.getMaxTorque = function(e) {
                    return this.equations[0].maxForce
                }
            }, {
                "../equations/AngleLockEquation": 20,
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "./Constraint": 14
            }],
            17: [function(e, t, n) {
                function o(e, t, n) {
                    n = n || {};
                    r.call(this, e, t, r.LOCK, n);
                    var o = typeof n.maxForce === "undefined" ? Number.MAX_VALUE : n.maxForce;
                    var u = n.localOffsetB || i.fromValues(0, 0);
                    u = i.fromValues(u[0], u[1]);
                    var a = n.localAngleB || 0;
                    var f = new s(e, t, -o, o),
                        l = new s(e, t, -o, o),
                        c = new s(e, t, -o, o);
                    var h = i.create(),
                        p = i.create(),
                        d = this;
                    f.computeGq = function() {
                        i.rotate(h, d.localOffsetB, e.angle);
                        i.sub(p, t.position, e.position);
                        i.sub(p, p, h);
                        return p[0]
                    };
                    l.computeGq = function() {
                        i.rotate(h, d.localOffsetB, e.angle);
                        i.sub(p, t.position, e.position);
                        i.sub(p, p, h);
                        return p[1]
                    };
                    var v = i.create(),
                        m = i.create();
                    c.computeGq = function() {
                        i.rotate(v, d.localOffsetB, t.angle - d.localAngleB);
                        i.scale(v, v, -1);
                        i.sub(p, e.position, t.position);
                        i.add(p, p, v);
                        i.rotate(m, v, -Math.PI / 2);
                        i.normalize(m, m);
                        return i.dot(p, m)
                    };
                    this.localOffsetB = u;
                    this.localAngleB = a;
                    this.equations.push(f, l, c);
                    this.setMaxForce(o)
                }
                var r = e("./Constraint"),
                    i = e("../math/vec2"),
                    s = e("../equations/Equation");
                t.exports = o;
                o.prototype = new r;
                o.prototype.setMaxForce = function(e) {
                    var t = this.equations;
                    for (var n = 0; n < this.equations.length; n++) {
                        t[n].maxForce = e;
                        t[n].minForce = -e
                    }
                };
                o.prototype.getMaxForce = function() {
                    return this.equations[0].maxForce
                };
                var u = i.create();
                var a = i.create();
                var f = i.create();
                var l = i.fromValues(1, 0);
                var c = i.fromValues(0, 1);
                o.prototype.update = function() {
                    var e = this.equations[0],
                        t = this.equations[1],
                        n = this.equations[2],
                        r = this.bodyA,
                        s = this.bodyB;
                    i.rotate(u, this.localOffsetB, r.angle);
                    i.rotate(a, this.localOffsetB, s.angle - this.localAngleB);
                    i.scale(a, a, -1);
                    i.rotate(f, a, Math.PI / 2);
                    i.normalize(f, f);
                    e.G[0] = -1;
                    e.G[1] = 0;
                    e.G[2] = -i.crossLength(u, l);
                    e.G[3] = 1;
                    t.G[0] = 0;
                    t.G[1] = -1;
                    t.G[2] = -i.crossLength(u, c);
                    t.G[4] = 1;
                    n.G[0] = -f[0];
                    n.G[1] = -f[1];
                    n.G[3] = f[0];
                    n.G[4] = f[1];
                    n.G[5] = i.crossLength(a, f)
                }
            }, {
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "./Constraint": 14
            }],
            18: [function(e, t, n) {
                function a(e, t, n) {
                    n = n || {};
                    r.call(this, e, t, r.PRISMATIC, n);
                    var a = o.fromValues(0, 0),
                        f = o.fromValues(1, 0),
                        l = o.fromValues(0, 0);
                    if (n.localAnchorA) o.copy(a, n.localAnchorA);
                    if (n.localAxisA) o.copy(f, n.localAxisA);
                    if (n.localAnchorB) o.copy(l, n.localAnchorB);
                    this.localAnchorA = a;
                    this.localAnchorB = l;
                    this.localAxisA = f;
                    var c = this.maxForce = typeof n.maxForce != "undefined" ? n.maxForce : Number.MAX_VALUE;
                    var h = new s(e, t, -c, c);
                    var p = new o.create,
                        d = new o.create,
                        v = new o.create,
                        m = new o.create;
                    h.computeGq = function() {
                        return o.dot(v, m)
                    };
                    h.updateJacobian = function() {
                        var n = this.G,
                            r = e.position,
                            i = t.position;
                        o.rotate(p, a, e.angle);
                        o.rotate(d, l, t.angle);
                        o.add(v, i, d);
                        o.sub(v, v, r);
                        o.sub(v, v, p);
                        o.rotate(m, f, e.angle + Math.PI / 2);
                        n[0] = -m[0];
                        n[1] = -m[1];
                        n[2] = -o.crossLength(p, m) + o.crossLength(m, v);
                        n[3] = m[0];
                        n[4] = m[1];
                        n[5] = o.crossLength(d, m)
                    };
                    this.equations.push(h);
                    if (!n.disableRotationalLock) {
                        var g = new u(e, t, -c, c);
                        this.equations.push(g)
                    }
                    this.position = 0;
                    this.velocity = 0;
                    this.lowerLimitEnabled = typeof n.lowerLimit !== "undefined" ? true : false;
                    this.upperLimitEnabled = typeof n.upperLimit !== "undefined" ? true : false;
                    this.lowerLimit = typeof n.lowerLimit !== "undefined" ? n.lowerLimit : 0;
                    this.upperLimit = typeof n.upperLimit !== "undefined" ? n.upperLimit : 1;
                    this.upperLimitEquation = new i(e, t);
                    this.lowerLimitEquation = new i(e, t);
                    this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0;
                    this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = c;
                    this.motorEquation = new s(e, t);
                    this.motorEnabled = false;
                    this.motorSpeed = 0;
                    var y = this;
                    var b = this.motorEquation;
                    var w = b.computeGW;
                    b.computeGq = function() {
                        return 0
                    };
                    b.computeGW = function() {
                        var e = this.G,
                            t = this.bodyA,
                            n = this.bodyB,
                            r = t.velocity,
                            i = n.velocity,
                            s = t.angularVelocity,
                            o = n.angularVelocity;
                        return this.transformedGmult(e, r, s, i, o) + y.motorSpeed
                    }
                }
                var r = e("./Constraint"),
                    i = e("../equations/ContactEquation"),
                    s = e("../equations/Equation"),
                    o = e("../math/vec2"),
                    u = e("../equations/RotationalLockEquation");
                t.exports = a;
                a.prototype = new r;
                var f = o.create(),
                    l = o.create(),
                    c = o.create(),
                    h = o.create(),
                    p = o.create(),
                    d = o.create();
                a.prototype.update = function() {
                    var e = this.equations,
                        t = e[0],
                        n = this.upperLimit,
                        r = this.lowerLimit,
                        i = this.upperLimitEquation,
                        s = this.lowerLimitEquation,
                        u = this.bodyA,
                        a = this.bodyB,
                        v = this.localAxisA,
                        m = this.localAnchorA,
                        g = this.localAnchorB;
                    t.updateJacobian();
                    o.rotate(f, v, u.angle);
                    o.rotate(h, m, u.angle);
                    o.add(l, h, u.position);
                    o.rotate(p, g, a.angle);
                    o.add(c, p, a.position);
                    var y = this.position = o.dot(c, f) - o.dot(l, f);
                    if (this.motorEnabled) {
                        var b = this.motorEquation.G;
                        b[0] = f[0];
                        b[1] = f[1];
                        b[2] = o.crossLength(f, p);
                        b[3] = -f[0];
                        b[4] = -f[1];
                        b[5] = -o.crossLength(f, h)
                    }
                    if (this.upperLimitEnabled && y > n) {
                        o.scale(i.normalA, f, -1);
                        o.sub(i.contactPointA, l, u.position);
                        o.sub(i.contactPointB, c, a.position);
                        o.scale(d, f, n);
                        o.add(i.contactPointA, i.contactPointA, d);
                        if (e.indexOf(i) == -1) e.push(i)
                    } else {
                        var w = e.indexOf(i);
                        if (w != -1) e.splice(w, 1)
                    }
                    if (this.lowerLimitEnabled && y < r) {
                        o.scale(s.normalA, f, 1);
                        o.sub(s.contactPointA, l, u.position);
                        o.sub(s.contactPointB, c, a.position);
                        o.scale(d, f, r);
                        o.sub(s.contactPointB, s.contactPointB, d);
                        if (e.indexOf(s) == -1) e.push(s)
                    } else {
                        var w = e.indexOf(s);
                        if (w != -1) e.splice(w, 1)
                    }
                };
                a.prototype.enableMotor = function() {
                    if (this.motorEnabled) return;
                    this.equations.push(this.motorEquation);
                    this.motorEnabled = true
                };
                a.prototype.disableMotor = function() {
                    if (!this.motorEnabled) return;
                    var e = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(e, 1);
                    this.motorEnabled = false
                }
            }, {
                "../equations/ContactEquation": 21,
                "../equations/Equation": 22,
                "../equations/RotationalLockEquation": 24,
                "../math/vec2": 30,
                "./Constraint": 14
            }],
            19: [function(e, t, n) {
                function p(e, t, n, p, d) {
                    d = d || {};
                    r.call(this, e, n, r.REVOLUTE, d);
                    var v = this.maxForce = typeof d.maxForce !== "undefined" ? d.maxForce : Number.MAX_VALUE;
                    this.pivotA = u.fromValues(t[0], t[1]);
                    this.pivotB = u.fromValues(p[0], p[1]);
                    var m = this.equations = [new i(e, n, -v, v), new i(e, n, -v, v)];
                    var y = m[0];
                    var b = m[1];
                    var w = this;
                    y.computeGq = function() {
                        u.rotate(a, w.pivotA, e.angle);
                        u.rotate(f, w.pivotB, n.angle);
                        u.add(h, n.position, f);
                        u.sub(h, h, e.position);
                        u.sub(h, h, a);
                        return u.dot(h, l)
                    };
                    b.computeGq = function() {
                        u.rotate(a, w.pivotA, e.angle);
                        u.rotate(f, w.pivotB, n.angle);
                        u.add(h, n.position, f);
                        u.sub(h, h, e.position);
                        u.sub(h, h, a);
                        return u.dot(h, c)
                    };
                    b.minForce = y.minForce = -v;
                    b.maxForce = y.maxForce = v;
                    this.motorEquation = new s(e, n);
                    this.motorEnabled = false;
                    this.angle = 0;
                    this.lowerLimitEnabled = false;
                    this.upperLimitEnabled = false;
                    this.lowerLimit = 0;
                    this.upperLimit = 0;
                    this.upperLimitEquation = new o(e, n);
                    this.lowerLimitEquation = new o(e, n);
                    this.upperLimitEquation.minForce = 0;
                    this.lowerLimitEquation.maxForce = 0
                }
                var r = e("./Constraint"),
                    i = e("../equations/Equation"),
                    s = e("../equations/RotationalVelocityEquation"),
                    o = e("../equations/RotationalLockEquation"),
                    u = e("../math/vec2");
                t.exports = p;
                var a = u.create(),
                    f = u.create(),
                    l = u.fromValues(1, 0),
                    c = u.fromValues(0, 1),
                    h = u.create();
                p.prototype = new r;
                p.prototype.update = function() {
                    var e = this.bodyA,
                        t = this.bodyB,
                        n = this.pivotA,
                        r = this.pivotB,
                        i = this.equations,
                        s = i[0],
                        o = i[1],
                        h = i[0],
                        p = i[1],
                        d = this.upperLimit,
                        v = this.lowerLimit,
                        m = this.upperLimitEquation,
                        g = this.lowerLimitEquation;
                    var y = this.angle = t.angle - e.angle;
                    if (this.upperLimitEnabled && y > d) {
                        m.angle = d;
                        if (i.indexOf(m) == -1) i.push(m)
                    } else {
                        var b = i.indexOf(m);
                        if (b != -1) i.splice(b, 1)
                    }
                    if (this.lowerLimitEnabled && y < v) {
                        g.angle = v;
                        if (i.indexOf(g) == -1) i.push(g)
                    } else {
                        var b = i.indexOf(g);
                        if (b != -1) i.splice(b, 1)
                    }
                    u.rotate(a, n, e.angle);
                    u.rotate(f, r, t.angle);
                    h.G[0] = -1;
                    h.G[1] = 0;
                    h.G[2] = -u.crossLength(a, l);
                    h.G[3] = 1;
                    h.G[4] = 0;
                    h.G[5] = u.crossLength(f, l);
                    p.G[0] = 0;
                    p.G[1] = -1;
                    p.G[2] = -u.crossLength(a, c);
                    p.G[3] = 0;
                    p.G[4] = 1;
                    p.G[5] = u.crossLength(f, c)
                };
                p.prototype.enableMotor = function() {
                    if (this.motorEnabled) return;
                    this.equations.push(this.motorEquation);
                    this.motorEnabled = true
                };
                p.prototype.disableMotor = function() {
                    if (!this.motorEnabled) return;
                    var e = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(e, 1);
                    this.motorEnabled = false
                };
                p.prototype.motorIsEnabled = function() {
                    return !!this.motorEnabled
                };
                p.prototype.setMotorSpeed = function(e) {
                    if (!this.motorEnabled) {
                        return
                    }
                    var t = this.equations.indexOf(this.motorEquation);
                    this.equations[t].relativeVelocity = e
                };
                p.prototype.getMotorSpeed = function() {
                    if (!this.motorEnabled) return false;
                    return this.motorEquation.relativeVelocity
                }
            }, {
                "../equations/Equation": 22,
                "../equations/RotationalLockEquation": 24,
                "../equations/RotationalVelocityEquation": 25,
                "../math/vec2": 30,
                "./Constraint": 14
            }],
            20: [function(e, t, n) {
                function s(e, t, n) {
                    n = n || {};
                    r.call(this, e, t, -Number.MAX_VALUE, Number.MAX_VALUE);
                    this.angle = n.angle || 0;
                    this.ratio = typeof n.ratio === "number" ? n.ratio : 1;
                    this.setRatio(this.ratio)
                }
                var r = e("./Equation"),
                    i = e("../math/vec2");
                t.exports = s;
                s.prototype = new r;
                s.prototype.constructor = s;
                s.prototype.computeGq = function() {
                    return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle
                };
                s.prototype.setRatio = function(e) {
                    var t = this.G;
                    t[2] = e;
                    t[5] = -1;
                    this.ratio = e
                };
                s.prototype.setMaxTorque = function(e) {
                    this.maxForce = e;
                    this.minForce = -e
                }
            }, {
                "../math/vec2": 30,
                "./Equation": 22
            }],
            21: [function(e, t, n) {
                function s(e, t) {
                    r.call(this, e, t, 0, Number.MAX_VALUE);
                    this.contactPointA = i.create();
                    this.penetrationVec = i.create();
                    this.contactPointB = i.create();
                    this.normalA = i.create();
                    this.restitution = 0;
                    this.firstImpact = false;
                    this.shapeA = null;
                    this.shapeB = null
                }
                var r = e("./Equation"),
                    i = e("../math/vec2");
                t.exports = s;
                s.prototype = new r;
                s.prototype.constructor = s;
                s.prototype.computeB = function(e, t, n) {
                    var r = this.bodyA,
                        s = this.bodyB,
                        o = this.contactPointA,
                        u = this.contactPointB,
                        a = r.position,
                        f = s.position;
                    var l = this.penetrationVec,
                        c = this.normalA,
                        h = this.G;
                    var p = i.crossLength(o, c),
                        d = i.crossLength(u, c);
                    h[0] = -c[0];
                    h[1] = -c[1];
                    h[2] = -p;
                    h[3] = c[0];
                    h[4] = c[1];
                    h[5] = d;
                    i.add(l, f, u);
                    i.sub(l, l, a);
                    i.sub(l, l, o);
                    var v, m;
                    if (this.firstImpact && this.restitution !== 0) {
                        m = 0;
                        v = 1 / t * (1 + this.restitution) * this.computeGW()
                    } else {
                        m = i.dot(c, l);
                        v = this.computeGW()
                    }
                    var g = this.computeGiMf();
                    var y = -m * e - v * t - n * g;
                    return y
                }
            }, {
                "../math/vec2": 30,
                "./Equation": 22
            }],
            22: [function(e, t, n) {
                function o(e, t, n, r) {
                    this.minForce = typeof n === "undefined" ? -Number.MAX_VALUE : n;
                    this.maxForce = typeof r === "undefined" ? Number.MAX_VALUE : r;
                    this.bodyA = e;
                    this.bodyB = t;
                    this.stiffness = o.DEFAULT_STIFFNESS;
                    this.relaxation = o.DEFAULT_RELAXATION;
                    this.G = new i.ARRAY_TYPE(6);
                    for (var s = 0; s < 6; s++) {
                        this.G[s] = 0
                    }
                    this.offset = 0;
                    this.a = 0;
                    this.b = 0;
                    this.epsilon = 0;
                    this.timeStep = 1 / 60;
                    this.needsUpdate = true;
                    this.multiplier = 0;
                    this.relativeVelocity = 0;
                    this.enabled = true
                }
                function u(e, t, n, r, i) {
                    return e[0] * t[0] + e[1] * t[1] + e[2] * n + e[3] * r[0] + e[4] * r[1] + e[5] * i
                }
                function h(e) {
                    if (e.sleepState === s.SLEEPING) {
                        return 0
                    } else {
                        return e.invMass
                    }
                }
                function p(e) {
                    if (e.sleepState === s.SLEEPING) {
                        return 0
                    } else {
                        return e.invInertia
                    }
                }
                t.exports = o;
                var r = e("../math/vec2"),
                    i = e("../utils/Utils"),
                    s = e("../objects/Body");
                o.prototype.constructor = o;
                o.DEFAULT_STIFFNESS = 1e6;
                o.DEFAULT_RELAXATION = 4;
                o.prototype.update = function() {
                    var e = this.stiffness,
                        t = this.relaxation,
                        n = this.timeStep;
                    this.a = 4 / (n * (1 + 4 * t));
                    this.b = 4 * t / (1 + 4 * t);
                    this.epsilon = 4 / (n * n * e * (1 + 4 * t));
                    this.needsUpdate = false
                };
                o.prototype.computeB = function(e, t, n) {
                    var r = this.computeGW();
                    var i = this.computeGq();
                    var s = this.computeGiMf();
                    return -i * e - r * t - s * n
                };
                var a = r.create(),
                    f = r.create();
                o.prototype.computeGq = function() {
                    var e = this.G,
                        t = this.bodyA,
                        n = this.bodyB,
                        r = t.position,
                        i = n.position,
                        s = t.angle,
                        o = n.angle;
                    return u(e, a, s, f, o) + this.offset
                };
                o.prototype.computeGW = function() {
                    var e = this.G,
                        t = this.bodyA,
                        n = this.bodyB,
                        r = t.velocity,
                        i = n.velocity,
                        s = t.angularVelocity,
                        o = n.angularVelocity;
                    return u(e, r, s, i, o) + this.relativeVelocity
                };
                o.prototype.computeGWlambda = function() {
                    var e = this.G,
                        t = this.bodyA,
                        n = this.bodyB,
                        r = t.vlambda,
                        i = n.vlambda,
                        s = t.wlambda,
                        o = n.wlambda;
                    return u(e, r, s, i, o)
                };
                var l = r.create(),
                    c = r.create();
                o.prototype.computeGiMf = function() {
                    var e = this.bodyA,
                        t = this.bodyB,
                        n = e.force,
                        i = e.angularForce,
                        s = t.force,
                        o = t.angularForce,
                        a = h(e),
                        f = h(t),
                        d = p(e),
                        v = p(t),
                        m = this.G;
                    r.scale(l, n, a);
                    r.scale(c, s, f);
                    return u(m, l, i * d, c, o * v)
                };
                o.prototype.computeGiMGt = function() {
                    var e = this.bodyA,
                        t = this.bodyB,
                        n = h(e),
                        r = h(t),
                        i = p(e),
                        s = p(t),
                        o = this.G;
                    return o[0] * o[0] * n + o[1] * o[1] * n + o[2] * o[2] * i + o[3] * o[3] * r + o[4] * o[4] * r + o[5] * o[5] * s
                };
                var d = r.create(),
                    v = r.create(),
                    m = r.create(),
                    g = r.create(),
                    y = r.create(),
                    b = r.create();
                o.prototype.addToWlambda = function(e) {
                    var t = this.bodyA,
                        n = this.bodyB,
                        i = d,
                        s = v,
                        o = m,
                        u = g,
                        a = y,
                        f = h(t),
                        l = h(n),
                        c = p(t),
                        w = p(n),
                        E = b,
                        S = this.G;
                    s[0] = S[0];
                    s[1] = S[1];
                    o[0] = S[3];
                    o[1] = S[4];
                    r.scale(i, s, f * e);
                    r.add(t.vlambda, t.vlambda, i);
                    t.wlambda += c * S[2] * e;
                    r.scale(i, o, l * e);
                    r.add(n.vlambda, n.vlambda, i);
                    n.wlambda += w * S[5] * e
                };
                o.prototype.computeInvC = function(e) {
                    return 1 / (this.computeGiMGt() + e)
                }
            }, {
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../utils/Utils": 47
            }],
            23: [function(e, t, n) {
                function o(e, t, n) {
                    i.call(this, e, t, -n, n);
                    this.contactPointA = r.create();
                    this.contactPointB = r.create();
                    this.t = r.create();
                    this.contactEquation = null;
                    this.shapeA = null;
                    this.shapeB = null;
                    this.frictionCoefficient = .3
                }
                var r = e("../math/vec2"),
                    i = e("./Equation"),
                    s = e("../utils/Utils");
                t.exports = o;
                o.prototype = new i;
                o.prototype.constructor = o;
                o.prototype.setSlipForce = function(e) {
                    this.maxForce = e;
                    this.minForce = -e
                };
                o.prototype.getSlipForce = function() {
                    return this.maxForce
                };
                o.prototype.computeB = function(e, t, n) {
                    var i = this.bodyA,
                        s = this.bodyB,
                        o = this.contactPointA,
                        u = this.contactPointB,
                        a = this.t,
                        f = this.G;
                    f[0] = -a[0];
                    f[1] = -a[1];
                    f[2] = -r.crossLength(o, a);
                    f[3] = a[0];
                    f[4] = a[1];
                    f[5] = r.crossLength(u, a);
                    var l = this.computeGW(),
                        c = this.computeGiMf();
                    var h = -l * t - n * c;
                    return h
                }
            }, {
                "../math/vec2": 30,
                "../utils/Utils": 47,
                "./Equation": 22
            }],
            24: [function(e, t, n) {
                function s(e, t, n) {
                    n = n || {};
                    r.call(this, e, t, -Number.MAX_VALUE, Number.MAX_VALUE);
                    this.angle = n.angle || 0;
                    var i = this.G;
                    i[2] = 1;
                    i[5] = -1
                }
                var r = e("./Equation"),
                    i = e("../math/vec2");
                t.exports = s;
                s.prototype = new r;
                s.prototype.constructor = s;
                var o = i.create(),
                    u = i.create(),
                    a = i.fromValues(1, 0),
                    f = i.fromValues(0, 1);
                s.prototype.computeGq = function() {
                    i.rotate(o, a, this.bodyA.angle + this.angle);
                    i.rotate(u, f, this.bodyB.angle);
                    return i.dot(o, u)
                }
            }, {
                "../math/vec2": 30,
                "./Equation": 22
            }],
            25: [function(e, t, n) {
                function s(e, t) {
                    r.call(this, e, t, -Number.MAX_VALUE, Number.MAX_VALUE);
                    this.relativeVelocity = 1;
                    this.ratio = 1
                }
                var r = e("./Equation"),
                    i = e("../math/vec2");
                t.exports = s;
                s.prototype = new r;
                s.prototype.constructor = s;
                s.prototype.computeB = function(e, t, n) {
                    var r = this.G;
                    r[2] = -1;
                    r[5] = this.ratio;
                    var i = this.computeGiMf();
                    var s = this.computeGW();
                    var o = -s * t - n * i;
                    return o
                }
            }, {
                "../math/vec2": 30,
                "./Equation": 22
            }],
            26: [function(e, t, n) {
                var r = function() {};
                t.exports = r;
                r.prototype = {
                    constructor: r,
                    on: function(e, t, n) {
                        t.context = n || this;
                        if (this._listeners === undefined) this._listeners = {};
                        var r = this._listeners;
                        if (r[e] === undefined) {
                            r[e] = []
                        }
                        if (r[e].indexOf(t) === -1) {
                            r[e].push(t)
                        }
                        return this
                    },
                    has: function(e, t) {
                        if (this._listeners === undefined) return false;
                        var n = this._listeners;
                        if (t) {
                            if (n[e] !== undefined && n[e].indexOf(t) !== -1) {
                                return true
                            }
                        } else {
                            if (n[e] !== undefined) {
                                return true
                            }
                        }
                        return false
                    },
                    off: function(e, t) {
                        if (this._listeners === undefined) return this;
                        var n = this._listeners;
                        var r = n[e].indexOf(t);
                        if (r !== -1) {
                            n[e].splice(r, 1)
                        }
                        return this
                    },
                    emit: function(e) {
                        if (this._listeners === undefined) return this;
                        var t = this._listeners;
                        var n = t[e.type];
                        if (n !== undefined) {
                            e.target = this;
                            for (var r = 0, i = n.length; r < i; r++) {
                                var s = n[r];
                                s.call(s.context, e)
                            }
                        }
                        return this
                    }
                }
            }, {}],
            27: [function(e, t, n) {
                function s(e, t, n) {
                    n = n || {};
                    if (!(e instanceof r) || !(t instanceof r)) throw new Error("First two arguments must be Material instances.");
                    this.id = s.idCounter++;
                    this.materialA = e;
                    this.materialB = t;
                    this.friction = typeof n.friction !== "undefined" ? Number(n.friction) : .3;
                    this.restitution = typeof n.restitution !== "undefined" ? Number(n.restitution) : 0;
                    this.stiffness = typeof n.stiffness !== "undefined" ? Number(n.stiffness) : i.DEFAULT_STIFFNESS;
                    this.relaxation = typeof n.relaxation !== "undefined" ? Number(n.relaxation) : i.DEFAULT_RELAXATION;
                    this.frictionStiffness = typeof n.frictionStiffness !== "undefined" ? Number(n.frictionStiffness) : i.DEFAULT_STIFFNESS;
                    this.frictionRelaxation = typeof n.frictionRelaxation !== "undefined" ? Number(n.frictionRelaxation) : i.DEFAULT_RELAXATION;
                    this.surfaceVelocity = typeof n.surfaceVelocity !== "undefined" ? Number(n.surfaceVelocity) : 0
                }
                var r = e("./Material");
                var i = e("../equations/Equation");
                t.exports = s;
                s.idCounter = 0
            }, {
                "../equations/Equation": 22,
                "./Material": 28
            }],
            28: [function(e, t, n) {
                function r() {
                    this.id = r.idCounter++
                }
                t.exports = r;
                r.idCounter = 0
            }, {}],
            29: [function(e, t, n) {
                var r = {};
                r.GetArea = function(e) {
                    if (e.length < 6) return 0;
                    var t = e.length - 2;
                    var n = 0;
                    for (var r = 0; r < t; r += 2) n += (e[r + 2] - e[r]) * (e[r + 1] + e[r + 3]);
                    n += (e[0] - e[t]) * (e[t + 1] + e[1]);
                    return -n * .5
                };
                r.Triangulate = function(e) {
                    var t = e.length >> 1;
                    if (t < 3) return [];
                    var n = [];
                    var i = [];
                    for (var s = 0; s < t; s++) i.push(s);
                    var s = 0;
                    var o = t;
                    while (o > 3) {
                        var u = i[(s + 0) % o];
                        var a = i[(s + 1) % o];
                        var f = i[(s + 2) % o];
                        var l = e[2 * u],
                            c = e[2 * u + 1];
                        var h = e[2 * a],
                            p = e[2 * a + 1];
                        var d = e[2 * f],
                            v = e[2 * f + 1];
                        var m = false;
                        if (r._convex(l, c, h, p, d, v)) {
                            m = true;
                            for (var g = 0; g < o; g++) {
                                var y = i[g];
                                if (y == u || y == a || y == f) continue;
                                if (r._PointInTriangle(e[2 * y], e[2 * y + 1], l, c, h, p, d, v)) {
                                    m = false;
                                    break
                                }
                            }
                        }
                        if (m) {
                            n.push(u, a, f);
                            i.splice((s + 1) % o, 1);
                            o--;
                            s = 0
                        } else if (s++ > 3 * o) break
                    }
                    n.push(i[0], i[1], i[2]);
                    return n
                };
                r._PointInTriangle = function(e, t, n, r, i, s, o, u) {
                    var a = o - n;
                    var f = u - r;
                    var l = i - n;
                    var c = s - r;
                    var h = e - n;
                    var p = t - r;
                    var d = a * a + f * f;
                    var v = a * l + f * c;
                    var m = a * h + f * p;
                    var g = l * l + c * c;
                    var y = l * h + c * p;
                    var b = 1 / (d * g - v * v);
                    var w = (g * m - v * y) * b;
                    var E = (d * y - v * m) * b;
                    return w >= 0 && E >= 0 && w + E < 1
                };
                r._convex = function(e, t, n, r, i, s) {
                    return (t - r) * (i - n) + (n - e) * (s - r) >= 0
                };
                t.exports = r
            }, {}],
            30: [function(e, t, n) {
                var r = e("../../build/vec2").vec2;
                r.crossLength = function(e, t) {
                    return e[0] * t[1] - e[1] * t[0]
                };
                r.crossVZ = function(e, t, n) {
                    r.rotate(e, t, -Math.PI / 2);
                    r.scale(e, e, n);
                    return e
                };
                r.crossZV = function(e, t, n) {
                    r.rotate(e, n, Math.PI / 2);
                    r.scale(e, e, t);
                    return e
                };
                r.rotate = function(e, t, n) {
                    var r = Math.cos(n),
                        i = Math.sin(n),
                        s = t[0],
                        o = t[1];
                    e[0] = r * s - i * o;
                    e[1] = i * s + r * o
                };
                r.rotate90cw = function(e, t) {
                    e[0] = t[1];
                    e[1] = -t[0]
                };
                r.toLocalFrame = function(e, t, n, i) {
                    r.copy(e, t);
                    r.sub(e, e, n);
                    r.rotate(e, e, -i)
                };
                r.toGlobalFrame = function(e, t, n, i) {
                    r.copy(e, t);
                    r.rotate(e, e, i);
                    r.add(e, e, n)
                };
                r.centroid = function(e, t, n, i) {
                    r.add(e, t, n);
                    r.add(e, e, i);
                    r.scale(e, e, 1 / 3);
                    return e
                };
                t.exports = r
            }, {
                "../../build/vec2": 1
            }],
            31: [function(e, t, n) {
                function a(e) {
                    e = e || {};
                    u.call(this);
                    this.id = ++a._idCounter;
                    this.world = null;
                    this.shapes = [];
                    this.shapeOffsets = [];
                    this.shapeAngles = [];
                    this.mass = e.mass || 0;
                    this.invMass = 0;
                    this.inertia = 0;
                    this.invInertia = 0;
                    this.fixedRotation = !! e.fixedRotation || false;
                    this.position = r.fromValues(0, 0);
                    if (e.position) {
                        r.copy(this.position, e.position)
                    }
                    this.interpolatedPosition = r.fromValues(0, 0);
                    this.interpolatedAngle = 0;
                    this.previousPosition = r.fromValues(0, 0);
                    this.previousAngle = 0;
                    this.velocity = r.fromValues(0, 0);
                    if (e.velocity) {
                        r.copy(this.velocity, e.velocity)
                    }
                    this.vlambda = r.fromValues(0, 0);
                    this.wlambda = 0;
                    this.angle = e.angle || 0;
                    this.angularVelocity = e.angularVelocity || 0;
                    this.force = r.create();
                    if (e.force) r.copy(this.force, e.force);
                    this.angularForce = e.angularForce || 0;
                    this.damping = typeof e.damping == "number" ? e.damping : .1;
                    this.angularDamping = typeof e.angularDamping == "number" ? e.angularDamping : .1;
                    this.motionState = this.mass === 0 ? a.STATIC : a.DYNAMIC;
                    this.boundingRadius = 0;
                    this.aabb = new o;
                    this.aabbNeedsUpdate = true;
                    this.allowSleep = true;
                    this.wantsToSleep = false;
                    this.sleepState = a.AWAKE;
                    this.sleepSpeedLimit = .2;
                    this.sleepTimeLimit = 1;
                    this.gravityScale = 1;
                    this.timeLastSleepy = 0;
                    this.concavePath = null;
                    this.lastDampingScale = 1;
                    this.lastAngularDampingScale = 1;
                    this.lastDampingTimeStep = -1;
                    this._wakeUpAfterNarrowphase = false;
                    this.updateMassProperties()
                }
                var r = e("../math/vec2"),
                    i = e("poly-decomp"),
                    s = e("../shapes/Convex"),
                    o = e("../collision/AABB"),
                    u = e("../events/EventEmitter");
                t.exports = a;
                a.prototype = new u;
                a._idCounter = 0;
                a.prototype.setDensity = function(e) {
                    var t = this.getArea();
                    this.mass = t * e;
                    this.updateMassProperties()
                };
                a.prototype.getArea = function() {
                    var e = 0;
                    for (var t = 0; t < this.shapes.length; t++) {
                        e += this.shapes[t].area
                    }
                    return e
                };
                var f = new o,
                    l = r.create();
                a.prototype.updateAABB = function() {
                    var e = this.shapes,
                        t = this.shapeOffsets,
                        n = this.shapeAngles,
                        i = e.length;
                    for (var s = 0; s !== i; s++) {
                        var o = e[s],
                            u = l,
                            a = n[s] + this.angle;
                        r.rotate(u, t[s], this.angle);
                        r.add(u, u, this.position);
                        o.computeAABB(f, u, a);
                        if (s === 0) this.aabb.copy(f);
                        else this.aabb.extend(f)
                    }
                    this.aabbNeedsUpdate = false
                };
                a.prototype.updateBoundingRadius = function() {
                    var e = this.shapes,
                        t = this.shapeOffsets,
                        n = e.length,
                        i = 0;
                    for (var s = 0; s !== n; s++) {
                        var o = e[s],
                            u = r.length(t[s]),
                            a = o.boundingRadius;
                        if (u + a > i) {
                            i = u + a
                        }
                    }
                    this.boundingRadius = i
                };
                a.prototype.addShape = function(e, t, n) {
                    n = n || 0;
                    if (t) {
                        t = r.fromValues(t[0], t[1])
                    } else {
                        t = r.fromValues(0, 0)
                    }
                    this.shapes.push(e);
                    this.shapeOffsets.push(t);
                    this.shapeAngles.push(n);
                    this.updateMassProperties();
                    this.updateBoundingRadius();
                    this.aabbNeedsUpdate = true
                };
                a.prototype.removeShape = function(e) {
                    var t = this.shapes.indexOf(e);
                    if (t !== -1) {
                        this.shapes.splice(t, 1);
                        this.shapeOffsets.splice(t, 1);
                        this.shapeAngles.splice(t, 1);
                        this.aabbNeedsUpdate = true;
                        return true
                    } else {
                        return false
                    }
                };
                a.prototype.updateMassProperties = function() {
                    if (this.motionState === a.STATIC || this.motionState === a.KINEMATIC) {
                        this.mass = Number.MAX_VALUE;
                        this.invMass = 0;
                        this.inertia = Number.MAX_VALUE;
                        this.invInertia = 0
                    } else {
                        var e = this.shapes,
                            t = e.length,
                            n = this.mass / t,
                            i = 0;
                        if (!this.fixedRotation) {
                            for (var s = 0; s < t; s++) {
                                var o = e[s],
                                    u = r.squaredLength(this.shapeOffsets[s]),
                                    f = o.computeMomentOfInertia(n);
                                i += f + n * u
                            }
                            this.inertia = i;
                            this.invInertia = i > 0 ? 1 / i : 0
                        } else {
                            this.inertia = Number.MAX_VALUE;
                            this.invInertia = 0
                        }
                        this.invMass = 1 / this.mass
                    }
                };
                var c = r.create();
                a.prototype.applyForce = function(e, t) {
                    var n = c;
                    r.sub(n, t, this.position);
                    r.add(this.force, this.force, e);
                    var i = r.crossLength(n, e);
                    this.angularForce += i
                };
                a.prototype.toLocalFrame = function(e, t) {
                    r.toLocalFrame(e, t, this.position, this.angle)
                };
                a.prototype.toWorldFrame = function(e, t) {
                    r.toGlobalFrame(e, t, this.position, this.angle)
                };
                a.prototype.fromPolygon = function(e, t) {
                    t = t || {};
                    for (var n = this.shapes.length; n >= 0; --n) this.removeShape(this.shapes[n]);
                    var o = new i.Polygon;
                    o.vertices = e;
                    o.makeCCW();
                    if (typeof t.removeCollinearPoints == "number") {
                        o.removeCollinearPoints(t.removeCollinearPoints)
                    }
                    if (typeof t.skipSimpleCheck == "undefined") {
                        if (!o.isSimple()) return false
                    }
                    this.concavePath = o.vertices.slice(0);
                    for (var n = 0; n < this.concavePath.length; n++) {
                        var u = [0, 0];
                        r.copy(u, this.concavePath[n]);
                        this.concavePath[n] = u
                    }
                    var a;
                    if (t.optimalDecomp) a = o.decomp();
                    else a = o.quickDecomp();
                    var f = r.create();
                    for (var n = 0; n !== a.length; n++) {
                        var l = new s(a[n].vertices);
                        for (var c = 0; c !== l.vertices.length; c++) {
                            var u = l.vertices[c];
                            r.sub(u, u, l.centerOfMass)
                        }
                        r.scale(f, l.centerOfMass, 1);
                        l.updateTriangles();
                        l.updateCenterOfMass();
                        l.updateBoundingRadius();
                        this.addShape(l, f)
                    }
                    this.adjustCenterOfMass();
                    this.aabbNeedsUpdate = true;
                    return true
                };
                var h = r.fromValues(0, 0),
                    p = r.fromValues(0, 0),
                    d = r.fromValues(0, 0),
                    v = r.fromValues(0, 0);
                a.prototype.adjustCenterOfMass = function() {
                    var e = p,
                        t = d,
                        n = v,
                        i = 0;
                    r.set(t, 0, 0);
                    for (var s = 0; s !== this.shapes.length; s++) {
                        var o = this.shapes[s],
                            u = this.shapeOffsets[s];
                        r.scale(e, u, o.area);
                        r.add(t, t, e);
                        i += o.area
                    }
                    r.scale(n, t, 1 / i);
                    for (var s = 0; s !== this.shapes.length; s++) {
                        var o = this.shapes[s],
                            u = this.shapeOffsets[s];
                        if (!u) {
                            u = this.shapeOffsets[s] = r.create()
                        }
                        r.sub(u, u, n)
                    }
                    r.add(this.position, this.position, n);
                    for (var s = 0; this.concavePath && s < this.concavePath.length; s++) {
                        r.sub(this.concavePath[s], this.concavePath[s], n)
                    }
                    this.updateMassProperties();
                    this.updateBoundingRadius()
                };
                a.prototype.setZeroForce = function() {
                    r.set(this.force, 0, 0);
                    this.angularForce = 0
                };
                a.prototype.resetConstraintVelocity = function() {
                    var e = this,
                        t = e.vlambda;
                    r.set(t, 0, 0);
                    e.wlambda = 0
                };
                a.prototype.addConstraintVelocity = function() {
                    var e = this,
                        t = e.velocity;
                    r.add(t, t, e.vlambda);
                    e.angularVelocity += e.wlambda
                };
                a.prototype.applyDamping = function(e) {
                    if (this.motionState === a.DYNAMIC) {
                        if (e !== this.lastDampingTimeStep) {
                            this.lastDampingScale = Math.pow(1 - this.damping, e);
                            this.lastAngularDampingScale = Math.pow(1 - this.angularDamping, e);
                            this.lastDampingTimeStep = e
                        }
                        var t = this.velocity;
                        r.scale(t, t, this.lastDampingScale);
                        this.angularVelocity *= this.lastAngularDampingScale
                    }
                };
                a.prototype.wakeUp = function() {
                    var e = this.sleepState;
                    this.sleepState = a.AWAKE;
                    this.idleTime = 0;
                    if (e !== a.AWAKE) {
                        this.emit(a.wakeUpEvent)
                    }
                };
                a.prototype.sleep = function() {
                    this.sleepState = a.SLEEPING;
                    this.angularVelocity = 0;
                    this.angularForce = 0;
                    r.set(this.velocity, 0, 0);
                    r.set(this.force, 0, 0);
                    this.emit(a.sleepEvent)
                };
                a.prototype.sleepTick = function(e, t, n) {
                    if (!this.allowSleep || this.motionState === a.SLEEPING) {
                        return
                    }
                    this.wantsToSleep = false;
                    var i = this.sleepState,
                        s = r.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2),
                        o = Math.pow(this.sleepSpeedLimit, 2);
                    if (s >= o) {
                        this.idleTime = 0;
                        this.sleepState = a.AWAKE
                    } else {
                        this.idleTime += n;
                        this.sleepState = a.SLEEPY
                    }
                    if (this.idleTime > this.sleepTimeLimit) {
                        if (!t) {
                            this.sleep()
                        } else {
                            this.wantsToSleep = true
                        }
                    }
                };
                a.prototype.getVelocityFromPosition = function(e, t) {
                    e = e || r.create();
                    r.sub(e, this.position, this.previousPosition);
                    r.scale(e, e, 1 / t);
                    return e
                };
                a.prototype.getAngularVelocityFromPosition = function(e) {
                    return (this.angle - this.previousAngle) / e
                };
                a.sleepyEvent = {
                    type: "sleepy"
                };
                a.sleepEvent = {
                    type: "sleep"
                };
                a.wakeUpEvent = {
                    type: "wakeup"
                };
                a.DYNAMIC = 1;
                a.STATIC = 2;
                a.KINEMATIC = 4;
                a.AWAKE = 0;
                a.SLEEPY = 1;
                a.SLEEPING = 2
            }, {
                "../collision/AABB": 8,
                "../events/EventEmitter": 26,
                "../math/vec2": 30,
                "../shapes/Convex": 36,
                "poly-decomp": 6
            }],
            32: [function(e, t, n) {
                function s(e, t, n) {
                    n = i.defaults(n, {
                        restLength: 1,
                        stiffness: 100,
                        damping: 1,
                        localAnchorA: [0, 0],
                        localAnchorB: [0, 0]
                    });
                    this.restLength = n.restLength;
                    this.stiffness = n.stiffness;
                    this.damping = n.damping;
                    this.bodyA = e;
                    this.bodyB = t;
                    this.localAnchorA = r.create();
                    r.copy(this.localAnchorA, n.localAnchorA);
                    this.localAnchorB = r.create();
                    r.copy(this.localAnchorB, n.localAnchorB);
                    if (n.worldAnchorA) {
                        this.setWorldAnchorA(n.worldAnchorA)
                    }
                    if (n.worldAnchorB) {
                        this.setWorldAnchorB(n.worldAnchorB)
                    }
                }
                var r = e("../math/vec2");
                var i = e("../utils/Utils");
                t.exports = s;
                s.prototype.setWorldAnchorA = function(e) {
                    this.bodyA.toLocalFrame(this.localAnchorA, e)
                };
                s.prototype.setWorldAnchorB = function(e) {
                    this.bodyB.toLocalFrame(this.localAnchorB, e)
                };
                s.prototype.getWorldAnchorA = function(e) {
                    this.bodyA.toWorldFrame(e, this.localAnchorA)
                };
                s.prototype.getWorldAnchorB = function(e) {
                    this.bodyB.toWorldFrame(e, this.localAnchorB)
                };
                var o = r.create(),
                    u = r.create(),
                    a = r.create(),
                    f = r.create(),
                    l = r.create(),
                    c = r.create(),
                    h = r.create(),
                    p = r.create(),
                    d = r.create();
                s.prototype.applyForce = function() {
                    var e = this.stiffness,
                        t = this.damping,
                        n = this.restLength,
                        i = this.bodyA,
                        s = this.bodyB,
                        v = o,
                        m = u,
                        g = a,
                        y = f,
                        b = d;
                    var w = l,
                        E = c,
                        S = h,
                        x = p;
                    this.getWorldAnchorA(w);
                    this.getWorldAnchorB(E);
                    r.sub(S, w, i.position);
                    r.sub(x, E, s.position);
                    r.sub(v, E, w);
                    var T = r.len(v);
                    r.normalize(m, v);
                    r.sub(g, s.velocity, i.velocity);
                    r.crossZV(b, s.angularVelocity, x);
                    r.add(g, g, b);
                    r.crossZV(b, i.angularVelocity, S);
                    r.sub(g, g, b);
                    r.scale(y, m, -e * (T - n) - t * r.dot(g, m));
                    r.sub(i.force, i.force, y);
                    r.add(s.force, s.force, y);
                    var N = r.crossLength(S, y);
                    var C = r.crossLength(x, y);
                    i.angularForce -= N;
                    s.angularForce += C
                }
            }, {
                "../math/vec2": 30,
                "../utils/Utils": 47
            }],
            33: [function(e, t, n) {
                t.exports = {
                    AABB: e("./collision/AABB"),
                    AngleLockEquation: e("./equations/AngleLockEquation"),
                    Body: e("./objects/Body"),
                    Broadphase: e("./collision/Broadphase"),
                    Capsule: e("./shapes/Capsule"),
                    Circle: e("./shapes/Circle"),
                    Constraint: e("./constraints/Constraint"),
                    ContactEquation: e("./equations/ContactEquation"),
                    ContactMaterial: e("./material/ContactMaterial"),
                    Convex: e("./shapes/Convex"),
                    DistanceConstraint: e("./constraints/DistanceConstraint"),
                    Equation: e("./equations/Equation"),
                    EventEmitter: e("./events/EventEmitter"),
                    FrictionEquation: e("./equations/FrictionEquation"),
                    GearConstraint: e("./constraints/GearConstraint"),
                    GridBroadphase: e("./collision/GridBroadphase"),
                    GSSolver: e("./solver/GSSolver"),
                    Heightfield: e("./shapes/Heightfield"),
                    Line: e("./shapes/Line"),
                    LockConstraint: e("./constraints/LockConstraint"),
                    Material: e("./material/Material"),
                    Narrowphase: e("./collision/Narrowphase"),
                    NaiveBroadphase: e("./collision/NaiveBroadphase"),
                    Particle: e("./shapes/Particle"),
                    Plane: e("./shapes/Plane"),
                    RevoluteConstraint: e("./constraints/RevoluteConstraint"),
                    PrismaticConstraint: e("./constraints/PrismaticConstraint"),
                    Rectangle: e("./shapes/Rectangle"),
                    RotationalVelocityEquation: e("./equations/RotationalVelocityEquation"),
                    SAPBroadphase: e("./collision/SAPBroadphase"),
                    Shape: e("./shapes/Shape"),
                    Solver: e("./solver/Solver"),
                    Spring: e("./objects/Spring"),
                    Utils: e("./utils/Utils"),
                    World: e("./world/World"),
                    vec2: e("./math/vec2"),
                    version: e("../package.json").version
                }
            }, {
                "../package.json": 7,
                "./collision/AABB": 8,
                "./collision/Broadphase": 9,
                "./collision/GridBroadphase": 10,
                "./collision/NaiveBroadphase": 11,
                "./collision/Narrowphase": 12,
                "./collision/SAPBroadphase": 13,
                "./constraints/Constraint": 14,
                "./constraints/DistanceConstraint": 15,
                "./constraints/GearConstraint": 16,
                "./constraints/LockConstraint": 17,
                "./constraints/PrismaticConstraint": 18,
                "./constraints/RevoluteConstraint": 19,
                "./equations/AngleLockEquation": 20,
                "./equations/ContactEquation": 21,
                "./equations/Equation": 22,
                "./equations/FrictionEquation": 23,
                "./equations/RotationalVelocityEquation": 25,
                "./events/EventEmitter": 26,
                "./material/ContactMaterial": 27,
                "./material/Material": 28,
                "./math/vec2": 30,
                "./objects/Body": 31,
                "./objects/Spring": 32,
                "./shapes/Capsule": 34,
                "./shapes/Circle": 35,
                "./shapes/Convex": 36,
                "./shapes/Heightfield": 37,
                "./shapes/Line": 38,
                "./shapes/Particle": 39,
                "./shapes/Plane": 40,
                "./shapes/Rectangle": 41,
                "./shapes/Shape": 42,
                "./solver/GSSolver": 43,
                "./solver/Solver": 44,
                "./utils/Utils": 47,
                "./world/World": 51
            }],
            34: [function(e, t, n) {
                function s(e, t) {
                    this.length = e || 1;
                    this.radius = t || 1;
                    r.call(this, r.CAPSULE)
                }
                var r = e("./Shape"),
                    i = e("../math/vec2");
                t.exports = s;
                s.prototype = new r;
                s.prototype.computeMomentOfInertia = function(e) {
                    var t = this.radius,
                        n = this.length + t,
                        r = t * 2;
                    return e * (r * r + n * n) / 12
                };
                s.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = this.radius + this.length / 2
                };
                s.prototype.updateArea = function() {
                    this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length
                };
                var o = i.create();
                s.prototype.computeAABB = function(e, t, n) {
                    var r = this.radius;
                    i.set(o, this.length, 0);
                    i.rotate(o, o, n);
                    i.set(e.upperBound, Math.max(o[0] + r, -o[0] + r), Math.max(o[1] + r, -o[1] + r));
                    i.set(e.lowerBound, Math.min(o[0] - r, -o[0] - r), Math.min(o[1] - r, -o[1] - r));
                    i.add(e.lowerBound, e.lowerBound, t);
                    i.add(e.upperBound, e.upperBound, t)
                }
            }, {
                "../math/vec2": 30,
                "./Shape": 42
            }],
            35: [function(e, t, n) {
                function s(e) {
                    this.radius = e || 1;
                    r.call(this, r.CIRCLE)
                }
                var r = e("./Shape"),
                    i = e("../math/vec2");
                t.exports = s;
                s.prototype = new r;
                s.prototype.computeMomentOfInertia = function(e) {
                    var t = this.radius;
                    return e * t * t / 2
                };
                s.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = this.radius
                };
                s.prototype.updateArea = function() {
                    this.area = Math.PI * this.radius * this.radius
                };
                s.prototype.computeAABB = function(e, t, n) {
                    var r = this.radius;
                    i.set(e.upperBound, r, r);
                    i.set(e.lowerBound, -r, -r);
                    if (t) {
                        i.add(e.lowerBound, e.lowerBound, t);
                        i.add(e.upperBound, e.upperBound, t)
                    }
                }
            }, {
                "../math/vec2": 30,
                "./Shape": 42
            }],
            36: [function(e, t, n) {
                function u(e) {
                    this.vertices = [];
                    for (var t = 0; t < e.length; t++) {
                        var n = i.create();
                        i.copy(n, e[t]);
                        this.vertices.push(n)
                    }
                    this.centerOfMass = i.fromValues(0, 0);
                    this.triangles = [];
                    if (this.vertices.length) {
                        this.updateTriangles();
                        this.updateCenterOfMass()
                    }
                    this.boundingRadius = 0;
                    r.call(this, r.CONVEX);
                    this.updateBoundingRadius();
                    this.updateArea();
                    if (this.area < 0) throw new Error("Convex vertices must be given in conter-clockwise winding.")
                }
                var r = e("./Shape"),
                    i = e("../math/vec2"),
                    s = e("../math/polyk"),
                    o = e("poly-decomp");
                t.exports = u;
                u.prototype = new r;
                u.prototype.updateTriangles = function() {
                    this.triangles.length = 0;
                    var e = [];
                    for (var t = 0; t < this.vertices.length; t++) {
                        var n = this.vertices[t];
                        e.push(n[0], n[1])
                    }
                    var r = s.Triangulate(e);
                    for (var t = 0; t < r.length; t += 3) {
                        var i = r[t],
                            o = r[t + 1],
                            u = r[t + 2];
                        this.triangles.push([i, o, u])
                    }
                };
                var a = i.create(),
                    f = i.create(),
                    l = i.create(),
                    c = i.create(),
                    h = i.create(),
                    p = i.create(),
                    d = i.create(),
                    v = i.create(),
                    m = i.create();
                u.prototype.updateCenterOfMass = function() {
                    var e = this.triangles,
                        t = this.vertices,
                        n = this.centerOfMass,
                        r = a,
                        s = m,
                        o = l,
                        g = c,
                        y = h,
                        b = p,
                        w = d,
                        E = v,
                        S = f;
                    i.set(n, 0, 0);
                    var x = 0;
                    for (var T = 0; T !== e.length; T++) {
                        var N = e[T],
                            o = t[N[0]],
                            g = t[N[1]],
                            y = t[N[2]];
                        i.centroid(r, o, g, y);
                        var C = u.triangleArea(o, g, y);
                        x += C;
                        i.scale(S, r, C);
                        i.add(n, n, S)
                    }
                    i.scale(n, n, 1 / x)
                };
                u.prototype.computeMomentOfInertia = function(e) {
                    var t = 0,
                        n = 0,
                        r = this.vertices.length;
                    for (var s = r - 1, o = 0; o < r; s = o, o++) {
                        var u = this.vertices[s];
                        var a = this.vertices[o];
                        var f = Math.abs(i.crossLength(u, a));
                        var l = i.dot(a, a) + i.dot(a, u) + i.dot(u, u);
                        t += f * l;
                        n += f
                    }
                    return e / 6 * (t / n)
                };
                u.prototype.updateBoundingRadius = function() {
                    var e = this.vertices,
                        t = 0;
                    for (var n = 0; n !== e.length; n++) {
                        var r = i.squaredLength(e[n]);
                        if (r > t) t = r
                    }
                    this.boundingRadius = Math.sqrt(t)
                };
                u.triangleArea = function(e, t, n) {
                    return ((t[0] - e[0]) * (n[1] - e[1]) - (n[0] - e[0]) * (t[1] - e[1])) * .5
                };
                u.prototype.updateArea = function() {
                    this.updateTriangles();
                    this.area = 0;
                    var e = this.triangles,
                        t = this.vertices;
                    for (var n = 0; n !== e.length; n++) {
                        var r = e[n],
                            i = t[r[0]],
                            s = t[r[1]],
                            o = t[r[2]];
                        var a = u.triangleArea(i, s, o);
                        this.area += a
                    }
                };
                u.prototype.computeAABB = function(e, t, n) {
                    e.setFromPoints(this.vertices, t, n)
                }
            }, {
                "../math/polyk": 29,
                "../math/vec2": 30,
                "./Shape": 42,
                "poly-decomp": 6
            }],
            37: [function(e, t, n) {
                function o(e, t) {
                    t = s.defaults(t, {
                        maxValue: null,
                        minValue: null,
                        elementWidth: .1
                    });
                    if (t.minValue === null || t.maxValue === null) {
                        t.maxValue = e[0];
                        t.minValue = e[0];
                        for (var n = 0; n !== e.length; n++) {
                            var i = e[n];
                            if (i > t.maxValue) {
                                t.maxValue = i
                            }
                            if (i < t.minValue) {
                                t.minValue = i
                            }
                        }
                    }
                    this.data = e;
                    this.maxValue = t.maxValue;
                    this.minValue = t.minValue;
                    this.elementWidth = t.elementWidth;
                    r.call(this, r.HEIGHTFIELD)
                }
                var r = e("./Shape"),
                    i = e("../math/vec2"),
                    s = e("../utils/Utils");
                t.exports = o;
                o.prototype = new r;
                o.prototype.computeMomentOfInertia = function(e) {
                    return Number.MAX_VALUE
                };
                o.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = Number.MAX_VALUE
                };
                o.prototype.updateArea = function() {
                    var e = this.data,
                        t = 0;
                    for (var n = 0; n < e.length - 1; n++) {
                        t += (e[n] + e[n + 1]) / 2 * this.elementWidth
                    }
                    this.area = t
                };
                o.prototype.computeAABB = function(e, t, n) {
                    e.upperBound[0] = this.elementWidth * this.data.length + t[0];
                    e.upperBound[1] = this.maxValue + t[1];
                    e.lowerBound[0] = t[0];
                    e.lowerBound[1] = -Number.MAX_VALUE
                }
            }, {
                "../math/vec2": 30,
                "../utils/Utils": 47,
                "./Shape": 42
            }],
            38: [function(e, t, n) {
                function s(e) {
                    this.length = e || 1;
                    r.call(this, r.LINE)
                }
                var r = e("./Shape"),
                    i = e("../math/vec2");
                t.exports = s;
                s.prototype = new r;
                s.prototype.computeMomentOfInertia = function(e) {
                    return e * Math.pow(this.length, 2) / 12
                };
                s.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = this.length / 2
                };
                var o = [i.create(), i.create()];
                s.prototype.computeAABB = function(e, t, n) {
                    var r = this.length;
                    i.set(o[0], -r / 2, 0);
                    i.set(o[1], r / 2, 0);
                    e.setFromPoints(o, t, n)
                }
            }, {
                "../math/vec2": 30,
                "./Shape": 42
            }],
            39: [function(e, t, n) {
                function s() {
                    r.call(this, r.PARTICLE)
                }
                var r = e("./Shape"),
                    i = e("../math/vec2");
                t.exports = s;
                s.prototype = new r;
                s.prototype.computeMomentOfInertia = function(e) {
                    return 0
                };
                s.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = 0
                };
                s.prototype.computeAABB = function(e, t, n) {
                    var r = this.length;
                    i.copy(e.lowerBound, t);
                    i.copy(e.upperBound, t)
                }
            }, {
                "../math/vec2": 30,
                "./Shape": 42
            }],
            40: [function(e, t, n) {
                function o() {
                    r.call(this, r.PLANE)
                }
                var r = e("./Shape"),
                    i = e("../math/vec2"),
                    s = e("../utils/Utils");
                t.exports = o;
                o.prototype = new r;
                o.prototype.computeMomentOfInertia = function(e) {
                    return 0
                };
                o.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = Number.MAX_VALUE
                };
                o.prototype.computeAABB = function(e, t, n) {
                    var r = 0,
                        s = i.set;
                    if (typeof n == "number") r = n % (2 * Math.PI);
                    if (r == 0) {
                        s(e.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
                        s(e.upperBound, Number.MAX_VALUE, 0)
                    } else if (r == Math.PI / 2) {
                        s(e.lowerBound, 0, -Number.MAX_VALUE);
                        s(e.upperBound, Number.MAX_VALUE, Number.MAX_VALUE)
                    } else if (r == Math.PI) {
                        s(e.lowerBound, -Number.MAX_VALUE, 0);
                        s(e.upperBound, Number.MAX_VALUE, Number.MAX_VALUE)
                    } else if (r == 3 * Math.PI / 2) {
                        s(e.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
                        s(e.upperBound, 0, Number.MAX_VALUE)
                    } else {
                        s(e.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
                        s(e.upperBound, Number.MAX_VALUE, Number.MAX_VALUE)
                    }
                    i.add(e.lowerBound, e.lowerBound, t);
                    i.add(e.upperBound, e.upperBound, t)
                };
                o.prototype.updateArea = function() {
                    this.area = Number.MAX_VALUE
                }
            }, {
                "../math/vec2": 30,
                "../utils/Utils": 47,
                "./Shape": 42
            }],
            41: [function(e, t, n) {
                function o(e, t) {
                    e = e || 1;
                    t = t || 1;
                    var n = [r.fromValues(-e / 2, -t / 2), r.fromValues(e / 2, -t / 2), r.fromValues(e / 2, t / 2), r.fromValues(-e / 2, t / 2)];
                    this.width = e;
                    this.height = t;
                    s.call(this, n);
                    this.type = i.RECTANGLE
                }
                var r = e("../math/vec2"),
                    i = e("./Shape"),
                    s = e("./Convex");
                t.exports = o;
                o.prototype = new s([]);
                o.prototype.computeMomentOfInertia = function(e) {
                    var t = this.width,
                        n = this.height;
                    return e * (n * n + t * t) / 12
                };
                o.prototype.updateBoundingRadius = function() {
                    var e = this.width,
                        t = this.height;
                    this.boundingRadius = Math.sqrt(e * e + t * t) / 2
                };
                var u = r.create(),
                    a = r.create(),
                    f = r.create(),
                    l = r.create();
                o.prototype.computeAABB = function(e, t, n) {
                    e.setFromPoints(this.vertices, t, n)
                };
                o.prototype.updateArea = function() {
                    this.area = this.width * this.height
                }
            }, {
                "../math/vec2": 30,
                "./Convex": 36,
                "./Shape": 42
            }],
            42: [function(e, t, n) {
                function r(e) {
                    this.type = e;
                    this.id = r.idCounter++;
                    this.boundingRadius = 0;
                    this.collisionGroup = 1;
                    this.collisionMask = 1;
                    if (e) this.updateBoundingRadius();
                    this.material = null;
                    this.area = 0;
                    this.sensor = false;
                    this.updateArea()
                }
                t.exports = r;
                r.idCounter = 0;
                r.CIRCLE = 1;
                r.PARTICLE = 2;
                r.PLANE = 4;
                r.CONVEX = 8;
                r.LINE = 16;
                r.RECTANGLE = 32;
                r.CAPSULE = 64;
                r.HEIGHTFIELD = 128;
                r.prototype.computeMomentOfInertia = function(e) {
                    throw new Error("Shape.computeMomentOfInertia is not implemented in this Shape...")
                };
                r.prototype.updateBoundingRadius = function() {
                    throw new Error("Shape.updateBoundingRadius is not implemented in this Shape...")
                };
                r.prototype.updateArea = function() {};
                r.prototype.computeAABB = function(e, t, n) {}
            }, {}],
            43: [function(e, t, n) {
                function u(e) {
                    i.call(this, e, i.GS);
                    e = e || {};
                    this.iterations = e.iterations || 10;
                    this.tolerance = e.tolerance || 1e-10;
                    this.arrayStep = 30;
                    this.lambda = new s.ARRAY_TYPE(this.arrayStep);
                    this.Bs = new s.ARRAY_TYPE(this.arrayStep);
                    this.invCs = new s.ARRAY_TYPE(this.arrayStep);
                    this.useZeroRHS = false;
                    this.frictionIterations = 0;
                    this.usedIterations = 0
                }
                function a(e) {
                    var t = e.length;
                    while (t--) {
                        e[t] = +0
                    }
                }
                var r = e("../math/vec2"),
                    i = e("./Solver"),
                    s = e("../utils/Utils"),
                    o = e("../equations/FrictionEquation");
                t.exports = u;
                u.prototype = new i;
                u.prototype.solve = function(e, t) {
                    this.sortEquations();
                    var n = 0,
                        i = this.iterations,
                        f = this.frictionIterations,
                        l = this.equations,
                        c = l.length,
                        h = Math.pow(this.tolerance * c, 2),
                        p = t.bodies,
                        d = t.bodies.length,
                        v = r.add,
                        m = r.set,
                        g = this.useZeroRHS,
                        y = this.lambda;
                    this.usedIterations = 0;
                    if (y.length < c) {
                        y = this.lambda = new s.ARRAY_TYPE(c + this.arrayStep);
                        this.Bs = new s.ARRAY_TYPE(c + this.arrayStep);
                        this.invCs = new s.ARRAY_TYPE(c + this.arrayStep)
                    }
                    a(y);
                    var b = this.invCs,
                        w = this.Bs,
                        y = this.lambda;
                    for (var E = 0; E !== l.length; E++) {
                        var S = l[E];
                        if (S.timeStep !== e || S.needsUpdate) {
                            S.timeStep = e;
                            S.update()
                        }
                        w[E] = S.computeB(S.a, S.b, e);
                        b[E] = S.computeInvC(S.epsilon)
                    }
                    var x, T, S, N, E, C;
                    if (c !== 0) {
                        for (E = 0; E !== d; E++) {
                            p[E].resetConstraintVelocity()
                        }
                        if (f) {
                            for (n = 0; n !== f; n++) {
                                N = 0;
                                for (C = 0; C !== c; C++) {
                                    S = l[C];
                                    if (S instanceof o) {}
                                    var k = u.iterateEquation(C, S, S.epsilon, w, b, y, g, e, n);
                                    N += Math.abs(k)
                                }
                                this.usedIterations++;
                                if (N * N <= h) {
                                    break
                                }
                            }
                            u.updateMultipliers(l, y, 1 / e);
                            for (C = 0; C !== c; C++) {
                                var L = l[C];
                                if (L instanceof o) {
                                    var A = L.contactEquation.multiplier * L.frictionCoefficient;
                                    L.maxForce = A;
                                    L.minForce = -A
                                }
                            }
                        }
                        for (n = 0; n !== i; n++) {
                            N = 0;
                            for (C = 0; C !== c; C++) {
                                S = l[C];
                                var k = u.iterateEquation(C, S, S.epsilon, w, b, y, g, e, n);
                                N += Math.abs(k)
                            }
                            this.usedIterations++;
                            if (N * N <= h) {
                                break
                            }
                        }
                        for (E = 0; E !== d; E++) {
                            p[E].addConstraintVelocity()
                        }
                        u.updateMultipliers(l, y, 1 / e)
                    }
                };
                u.updateMultipliers = function(e, t, n) {
                    var r = e.length;
                    while (r--) {
                        e[r].multiplier = t[r] * n
                    }
                };
                u.iterateEquation = function(e, t, n, r, i, s, o, u, a) {
                    var f = r[e],
                        l = i[e],
                        c = s[e],
                        h = t.computeGWlambda();
                    var p = t.maxForce,
                        d = t.minForce;
                    if (o) {
                        f = 0
                    }
                    var v = l * (f - h - n * c);
                    var m = c + v;
                    if (m < d * u) {
                        v = d * u - c
                    } else if (m > p * u) {
                        v = p * u - c
                    }
                    s[e] += v;
                    t.addToWlambda(v);
                    return v
                }
            }, {
                "../equations/FrictionEquation": 23,
                "../math/vec2": 30,
                "../utils/Utils": 47,
                "./Solver": 44
            }],
            44: [function(e, t, n) {
                function s(e, t) {
                    e = e || {};
                    i.call(this);
                    this.type = t;
                    this.equations = [];
                    this.equationSortFunction = e.equationSortFunction || false
                }
                var r = e("../utils/Utils"),
                    i = e("../events/EventEmitter");
                t.exports = s;
                s.prototype = new i;
                s.prototype.solve = function(e, t) {
                    throw new Error("Solver.solve should be implemented by subclasses!")
                };
                var o = {
                    bodies: []
                };
                s.prototype.solveIsland = function(e, t) {
                    this.removeAllEquations();
                    if (t.equations.length) {
                        this.addEquations(t.equations);
                        o.bodies.length = 0;
                        t.getBodies(o.bodies);
                        if (o.bodies.length) {
                            this.solve(e, o)
                        }
                    }
                };
                s.prototype.sortEquations = function() {
                    if (this.equationSortFunction) {
                        this.equations.sort(this.equationSortFunction)
                    }
                };
                s.prototype.addEquation = function(e) {
                    if (e.enabled) {
                        this.equations.push(e)
                    }
                };
                s.prototype.addEquations = function(e) {
                    for (var t = 0, n = e.length; t !== n; t++) {
                        var r = e[t];
                        if (r.enabled) {
                            this.equations.push(r)
                        }
                    }
                };
                s.prototype.removeEquation = function(e) {
                    var t = this.equations.indexOf(e);
                    if (t !== -1) {
                        this.equations.splice(t, 1)
                    }
                };
                s.prototype.removeAllEquations = function() {
                    this.equations.length = 0
                };
                s.GS = 1;
                s.ISLAND = 2
            }, {
                "../events/EventEmitter": 26,
                "../utils/Utils": 47
            }],
            45: [function(e, t, n) {
                function s() {
                    this.overlappingLastState = new r;
                    this.overlappingCurrentState = new r;
                    this.recordPool = [];
                    this.tmpDict = new r;
                    this.tmpArray1 = []
                }
                function o(e, t, n, r) {
                    this.shapeA = t;
                    this.shapeB = r;
                    this.bodyA = e;
                    this.bodyB = n
                }
                var r = e("./TupleDictionary");
                var i = e("./Utils");
                t.exports = s;
                s.prototype.tick = function() {
                    var e = this.overlappingLastState;
                    var t = this.overlappingCurrentState;
                    var n = t.keys.length;
                    while (n--) {
                        var r = t.keys[n];
                        this.recordPool.push(t.getByKey(r))
                    }
                    e.reset();
                    e.copy(t);
                    t.reset()
                };
                s.prototype.setOverlapping = function(e, t, n, r) {
                    var i = this.overlappingLastState;
                    var s = this.overlappingCurrentState;
                    if (!s.get(t.id, r.id)) {
                        var u;
                        if (this.recordPool.length) {
                            u = this.recordPool.pop()
                        } else {
                            u = new o(e, t, n, r)
                        }
                        s.set(t.id, r.id, u)
                    }
                };
                s.prototype.getNewOverlaps = function(e) {
                    return this.getDiff(this.overlappingLastState, this.overlappingCurrentState, e)
                };
                s.prototype.getEndOverlaps = function(e) {
                    return this.getDiff(this.overlappingCurrentState, this.overlappingLastState, e)
                };
                s.prototype.getDiff = function(e, t, n) {
                    var n = n || [];
                    var r = e;
                    var i = t;
                    n.length = 0;
                    var s = i.keys.length;
                    while (s--) {
                        var o = i.keys[s];
                        var u = i.data[o];
                        if (!u) {
                            throw new Error("Key " + o + " had no data!")
                        }
                        var a = r.data[o];
                        if (!a) {
                            n.push(u)
                        }
                    }
                    return n
                };
                s.prototype.isNewOverlap = function(e, t) {
                    var n = e.id | 0,
                        r = t.id | 0;
                    return !!!this.overlappingLastState.get(n, r) && !! this.overlappingCurrentState.get(n, r)
                };
                s.prototype.getNewBodyOverlaps = function(e) {
                    this.tmpArray1.length = 0;
                    var t = this.getNewOverlaps(this.tmpArray1);
                    return this.getBodyDiff(t, e)
                };
                s.prototype.getEndBodyOverlaps = function(e) {
                    this.tmpArray1.length = 0;
                    var t = this.getEndOverlaps(this.tmpArray1);
                    return this.getBodyDiff(t, e)
                };
                s.prototype.getBodyDiff = function(e, t) {
                    t = t || [];
                    var n = this.tmpDict;
                    var r = e.length;
                    while (r--) {
                        var i = e[r];
                        n.set(i.bodyA.id | 0, i.bodyB.id | 0, i)
                    }
                    r = n.keys.length;
                    while (r--) {
                        var i = n.keys[r];
                        t.push(i.bodyA, i.bodyB)
                    }
                    n.reset();
                    return t
                };
                o.prototype.set = function(e, t, n, r) {
                    o.call(this, e, t, n, r)
                }
            }, {
                "./TupleDictionary": 46,
                "./Utils": 47
            }],
            46: [function(e, t, n) {
                function i() {
                    this.data = [];
                    this.keys = []
                }
                var r = e("./Utils");
                t.exports = i;
                i.prototype.getKey = function(e, t) {
                    e = e | 0;
                    t = t | 0;
                    if ((e | 0) === (t | 0)) {
                        return -1
                    }
                    return ((e | 0) > (t | 0) ? e << 16 | t & 65535 : t << 16 | e & 65535) | 0
                };
                i.prototype.getByKey = function(e) {
                    e = e | 0;
                    return this.data[e]
                };
                i.prototype.get = function(e, t) {
                    e = e | 0;
                    t = t | 0;
                    var n = this.getKey(e, t) | 0;
                    return this.data[n]
                };
                i.prototype.set = function(e, t, n) {
                    if (!n) {
                        throw new Error("No data!")
                    }
                    e = e | 0;
                    t = t | 0;
                    var r = this.getKey(e, t) | 0;
                    if (!this.get(e, t)) {
                        this.keys.push(r)
                    }
                    this.data[r] = n;
                    return r
                };
                i.prototype.reset = function() {
                    var e = this.data,
                        t = this.keys;
                    var n = t.length | 0;
                    while (n--) {
                        var r = t[n] | 0;
                        e[r] = undefined
                    }
                    t.length = 0
                };
                i.prototype.copy = function(e) {
                    this.reset();
                    r.appendArray(this.keys, e.keys);
                    var t = e.keys.length | 0;
                    while (t--) {
                        var n = e.keys[t] | 0;
                        this.data[n] = e.data[n]
                    }
                }
            }, {
                "./Utils": 47
            }],
            47: [function(e, t, n) {
                function r() {}
                t.exports = r;
                r.appendArray = function(e, t) {
                    if (t.length < 15e4) {
                        e.push.apply(e, t)
                    } else {
                        for (var n = 0, r = t.length; n !== r; ++n) {
                            e.push(t[n])
                        }
                    }
                };
                r.splice = function(e, t, n) {
                    n = n || 1;
                    for (var r = t, i = e.length - n; r < i; r++) {
                        e[r] = e[r + n]
                    }
                    e.length = i
                };
                r.ARRAY_TYPE = window.Float32Array || Array;
                r.extend = function(e, t) {
                    for (var n in t) {
                        e[n] = t[n]
                    }
                };
                r.defaults = function(e, t) {
                    e = e || {};
                    for (var n in t) {
                        if (!(n in e)) {
                            e[n] = t[n]
                        }
                    }
                    return e
                }
            }, {}],
            48: [function(e, t, n) {
                function i() {
                    this.equations = [];
                    this.bodies = []
                }
                var r = e("../objects/Body");
                t.exports = i;
                i.prototype.reset = function() {
                    this.equations.length = this.bodies.length = 0
                };
                var s = [];
                i.prototype.getBodies = function(e) {
                    var t = e || [],
                        n = this.equations;
                    s.length = 0;
                    for (var r = 0; r !== n.length; r++) {
                        var i = n[r];
                        if (s.indexOf(i.bodyA.id) === -1) {
                            t.push(i.bodyA);
                            s.push(i.bodyA.id)
                        }
                        if (s.indexOf(i.bodyB.id) === -1) {
                            t.push(i.bodyB);
                            s.push(i.bodyB.id)
                        }
                    }
                    return t
                };
                i.prototype.wantsToSleep = function() {
                    for (var e = 0; e < this.bodies.length; e++) {
                        var t = this.bodies[e];
                        if (t.motionState === r.DYNAMIC && !t.wantsToSleep) {
                            return false
                        }
                    }
                    return true
                };
                i.prototype.sleep = function() {
                    for (var e = 0; e < this.bodies.length; e++) {
                        var t = this.bodies[e];
                        t.sleep()
                    }
                    return true
                }
            }, {
                "../objects/Body": 31
            }],
            49: [function(e, t, n) {
                function u(e) {
                    this._nodePool = [];
                    this._islandPool = [];
                    this.equations = [];
                    this.islands = [];
                    this.nodes = [];
                    this.queue = []
                }
                var r = e("../math/vec2"),
                    i = e("./Island"),
                    s = e("./IslandNode"),
                    o = e("../objects/Body");
                t.exports = u;
                u.getUnvisitedNode = function(e) {
                    var t = e.length;
                    for (var n = 0; n !== t; n++) {
                        var r = e[n];
                        if (!r.visited && r.body.motionState === o.DYNAMIC) {
                            return r
                        }
                    }
                    return false
                };
                u.prototype.visit = function(e, t, n) {
                    t.push(e.body);
                    var r = e.equations.length;
                    for (var i = 0; i !== r; i++) {
                        var s = e.equations[i];
                        if (n.indexOf(s) === -1) {
                            n.push(s)
                        }
                    }
                };
                u.prototype.bfs = function(e, t, n) {
                    var r = this.queue;
                    r.length = 0;
                    r.push(e);
                    e.visited = true;
                    this.visit(e, t, n);
                    while (r.length) {
                        var i = r.pop();
                        var s;
                        while (s = u.getUnvisitedNode(i.neighbors)) {
                            s.visited = true;
                            this.visit(s, t, n);
                            if (s.body.motionState === o.DYNAMIC) {
                                r.push(s)
                            }
                        }
                    }
                };
                u.prototype.split = function(e) {
                    var t = e.bodies,
                        n = this.nodes,
                        r = this.equations;
                    while (n.length) {
                        this._nodePool.push(n.pop())
                    }
                    for (var o = 0; o !== t.length; o++) {
                        if (this._nodePool.length) {
                            var a = this._nodePool.pop();
                            a.reset();
                            a.body = t[o];
                            n.push(a)
                        } else {
                            n.push(new s(t[o]))
                        }
                    }
                    for (var f = 0; f !== r.length; f++) {
                        var l = r[f],
                            o = t.indexOf(l.bodyA),
                            c = t.indexOf(l.bodyB),
                            h = n[o],
                            p = n[c];
                        h.neighbors.push(p);
                        p.neighbors.push(h);
                        h.equations.push(l);
                        p.equations.push(l)
                    }
                    var d = this.islands;
                    while (d.length) {
                        var v = d.pop();
                        v.reset();
                        this._islandPool.push(v)
                    }
                    var m;
                    while (m = u.getUnvisitedNode(n)) {
                        var v = this._islandPool.length ? this._islandPool.pop() : new i;
                        this.bfs(m, v.bodies, v.equations);
                        d.push(v)
                    }
                    return d
                }
            }, {
                "../math/vec2": 30,
                "../objects/Body": 31,
                "./Island": 48,
                "./IslandNode": 50
            }],
            50: [function(e, t, n) {
                function r(e) {
                    this.body = e;
                    this.neighbors = [];
                    this.equations = [];
                    this.visited = false
                }
                t.exports = r;
                r.prototype.reset = function() {
                    this.equations.length = 0;
                    this.neighbors.length = 0;
                    this.visited = false;
                    this.body = null
                }
            }, {}],
            51: [function(e, t, n) {
                function P(e) {
                    d.apply(this);
                    e = e || {};
                    this.springs = [];
                    this.bodies = [];
                    this.disabledBodyCollisionPairs = [];
                    this.solver = e.solver || new r;
                    this.narrowphase = new A(this);
                    this.islandManager = new _;
                    this.gravity = o.fromValues(0, -9.78);
                    if (e.gravity) {
                        o.copy(this.gravity, e.gravity)
                    }
                    this.frictionGravity = o.length(this.gravity) || 10;
                    this.useWorldGravityAsFrictionGravity = true;
                    this.useFrictionGravityOnZeroGravity = true;
                    this.doProfiling = e.doProfiling || false;
                    this.lastStepTime = 0;
                    this.broadphase = e.broadphase || new s;
                    this.broadphase.setWorld(this);
                    this.constraints = [];
                    this.defaultMaterial = new y;
                    this.defaultContactMaterial = new b(this.defaultMaterial, this.defaultMaterial);
                    this.lastTimeStep = 1 / 60;
                    this.applySpringForces = true;
                    this.applyDamping = true;
                    this.applyGravity = true;
                    this.solveConstraints = true;
                    this.contactMaterials = [];
                    this.time = 0;
                    this.stepping = false;
                    this.bodiesToBeRemoved = [];
                    this.fixedStepTime = 0;
                    this.islandSplit = typeof e.islandSplit !== "undefined" ? !! e.islandSplit : false;
                    this.emitImpactEvent = true;
                    this._constraintIdCounter = 0;
                    this._bodyIdCounter = 0;
                    this.postStepEvent = {
                        type: "postStep"
                    };
                    this.addBodyEvent = {
                        type: "addBody",
                        body: null
                    };
                    this.removeBodyEvent = {
                        type: "removeBody",
                        body: null
                    };
                    this.addSpringEvent = {
                        type: "addSpring",
                        spring: null
                    };
                    this.impactEvent = {
                        type: "impact",
                        bodyA: null,
                        bodyB: null,
                        shapeA: null,
                        shapeB: null,
                        contactEquation: null
                    };
                    this.postBroadphaseEvent = {
                        type: "postBroadphase",
                        pairs: null
                    };
                    this.enableBodySleeping = false;
                    this.enableIslandSleeping = false;
                    this.beginContactEvent = {
                        type: "beginContact",
                        shapeA: null,
                        shapeB: null,
                        bodyA: null,
                        bodyB: null,
                        contactEquations: []
                    };
                    this.endContactEvent = {
                        type: "endContact",
                        shapeA: null,
                        shapeB: null,
                        bodyA: null,
                        bodyB: null
                    };
                    this.preSolveEvent = {
                        type: "preSolve",
                        contactEquations: null,
                        frictionEquations: null
                    };
                    this.overlappingShapesLastState = {
                        keys: []
                    };
                    this.overlappingShapesCurrentState = {
                        keys: []
                    };
                    this.overlapKeeper = new M
                }
                function K(e) {
                    if (!e) return e;
                    return [e[0], e[1]]
                }
                function Q(e, t) {
                    for (var n in t) e[n] = t[n]
                }
                function G(e) {
                    return {
                        id: e.id,
                        materialA: e.materialA.id,
                        materialB: e.materialB.id,
                        friction: e.friction,
                        restitution: e.restitution,
                        stiffness: e.stiffness,
                        relaxation: e.relaxation,
                        frictionStiffness: e.frictionStiffness,
                        frictionRelaxation: e.frictionRelaxation
                    }
                }
                var r = e("../solver/GSSolver"),
                    i = e("../solver/Solver"),
                    s = e("../collision/NaiveBroadphase"),
                    o = e("../math/vec2"),
                    u = e("../shapes/Circle"),
                    a = e("../shapes/Rectangle"),
                    f = e("../shapes/Convex"),
                    l = e("../shapes/Line"),
                    c = e("../shapes/Plane"),
                    h = e("../shapes/Capsule"),
                    p = e("../shapes/Particle"),
                    d = e("../events/EventEmitter"),
                    v = e("../objects/Body"),
                    m = e("../shapes/Shape"),
                    g = e("../objects/Spring"),
                    y = e("../material/Material"),
                    b = e("../material/ContactMaterial"),
                    w = e("../constraints/DistanceConstraint"),
                    E = e("../constraints/Constraint"),
                    S = e("../constraints/LockConstraint"),
                    x = e("../constraints/RevoluteConstraint"),
                    T = e("../constraints/PrismaticConstraint"),
                    N = e("../constraints/GearConstraint"),
                    C = e("../../package.json"),
                    k = e("../collision/Broadphase"),
                    L = e("../collision/SAPBroadphase"),
                    A = e("../collision/Narrowphase"),
                    O = e("../utils/Utils"),
                    M = e("../utils/OverlapKeeper"),
                    _ = e("./IslandManager");
                t.exports = P;
                if (typeof performance === "undefined") {
                    performance = {}
                }
                if (!performance.now) {
                    var D = Date.now();
                    if (performance.timing && performance.timing.navigationStart) {
                        D = performance.timing.navigationStart
                    }
                    performance.now = function() {
                        return Date.now() - D
                    }
                }
                P.prototype = new Object(d.prototype);
                P.prototype.addConstraint = function(e) {
                    this.constraints.push(e)
                };
                P.prototype.addContactMaterial = function(e) {
                    this.contactMaterials.push(e)
                };
                P.prototype.removeContactMaterial = function(e) {
                    var t = this.contactMaterials.indexOf(e);
                    if (t !== -1) {
                        O.splice(this.contactMaterials, t, 1)
                    }
                };
                P.prototype.getContactMaterial = function(e, t) {
                    var n = this.contactMaterials;
                    for (var r = 0, i = n.length; r !== i; r++) {
                        var s = n[r];
                        if (s.materialA === e && s.materialB === t || s.materialA === t && s.materialB === e) {
                            return s
                        }
                    }
                    return false
                };
                P.prototype.removeConstraint = function(e) {
                    var t = this.constraints.indexOf(e);
                    if (t !== -1) {
                        O.splice(this.constraints, t, 1)
                    }
                };
                var H = o.create(),
                    B = o.create(),
                    j = o.create(),
                    F = o.create(),
                    I = o.create(),
                    q = o.create(),
                    R = o.create(),
                    U = o.fromValues(0, 0),
                    z = o.fromValues(0, 0),
                    W = o.fromValues(0, 0),
                    X = o.fromValues(0, 0);
                P.prototype.step = function(e, t, n) {
                    n = n || 10;
                    t = t || 0;
                    if (t === 0) {
                        this.internalStep(e);
                        this.time += e
                    } else {
                        var r = Math.floor((this.time + t) / e) - Math.floor(this.time / e);
                        r = Math.min(r, n);
                        for (var i = 0; i !== r; i++) {
                            this.internalStep(e)
                        }
                        this.time += t;
                        var s = this.time % e;
                        var u = s / e;
                        for (var a = 0; a !== this.bodies.length; a++) {
                            var f = this.bodies[a];
                            if (f.motionState !== v.STATIC && f.sleepState !== v.SLEEPING) {
                                o.sub(X, f.position, f.previousPosition);
                                o.scale(X, X, u);
                                o.add(f.interpolatedPosition, f.position, X);
                                f.interpolatedAngle = f.angle + (f.angle - f.previousAngle) * u
                            } else {
                                o.copy(f.interpolatedPosition, f.position);
                                f.interpolatedAngle = f.angle
                            }
                        }
                    }
                };
                var V = [];
                P.prototype.internalStep = function(e) {
                    this.stepping = true;
                    var t = this,
                        n = this.doProfiling,
                        r = this.springs.length,
                        i = this.springs,
                        s = this.bodies,
                        u = this.gravity,
                        a = this.solver,
                        f = this.bodies.length,
                        l = this.broadphase,
                        c = this.narrowphase,
                        h = this.constraints,
                        p, d, m = I,
                        g = q,
                        y = R,
                        b = o.scale,
                        w = o.add,
                        E = o.rotate,
                        S = this.islandManager;
                    this.lastTimeStep = e;
                    if (n) {
                        p = performance.now()
                    }
                    if (this.useWorldGravityAsFrictionGravity) {
                        var x = o.length(this.gravity);
                        if (x === 0 && this.useFrictionGravityOnZeroGravity) {} else {
                            this.frictionGravity = x
                        }
                    }
                    if (this.applyGravity) {
                        for (var T = 0; T !== f; T++) {
                            var N = s[T],
                                C = N.force;
                            if (N.motionState !== v.DYNAMIC || N.sleepState === v.SLEEPING) {
                                continue
                            }
                            o.scale(y, u, N.mass * N.gravityScale);
                            w(C, C, y)
                        }
                    }
                    if (this.applySpringForces) {
                        for (var T = 0; T !== r; T++) {
                            var k = i[T];
                            k.applyForce()
                        }
                    }
                    if (this.applyDamping) {
                        for (var T = 0; T !== f; T++) {
                            var N = s[T];
                            if (N.motionState === v.DYNAMIC) {
                                N.applyDamping(e)
                            }
                        }
                    }
                    var L = l.getCollisionPairs(this);
                    var A = this.disabledBodyCollisionPairs;
                    for (var T = A.length - 2; T >= 0; T -= 2) {
                        for (var M = L.length - 2; M >= 0; M -= 2) {
                            if (A[T] === L[M] && A[T + 1] === L[M + 1] || A[T + 1] === L[M] && A[T] === L[M + 1]) {
                                L.splice(M, 2)
                            }
                        }
                    }
                    var _ = h.length;
                    for (T = 0; T !== _; T++) {
                        var D = h[T];
                        if (!D.collideConnected) {
                            for (var M = L.length - 2; M >= 0; M -= 2) {
                                if (D.bodyA === L[M] && D.bodyB === L[M + 1] || D.bodyB === L[M] && D.bodyA === L[M + 1]) {
                                    L.splice(M, 2)
                                }
                            }
                        }
                    }
                    this.postBroadphaseEvent.pairs = L;
                    this.emit(this.postBroadphaseEvent);
                    c.reset(this);
                    for (var T = 0, H = L.length; T !== H; T += 2) {
                        var B = L[T],
                            j = L[T + 1];
                        for (var F = 0, U = B.shapes.length; F !== U; F++) {
                            var z = B.shapes[F],
                                W = B.shapeOffsets[F],
                                X = B.shapeAngles[F];
                            for (var $ = 0, J = j.shapes.length; $ !== J; $++) {
                                var K = j.shapes[$],
                                    Q = j.shapeOffsets[$],
                                    G = j.shapeAngles[$];
                                var Y = this.defaultContactMaterial;
                                if (z.material && K.material) {
                                    var Z = this.getContactMaterial(z.material, K.material);
                                    if (Z) {
                                        Y = Z
                                    }
                                }
                                this.runNarrowphase(c, B, z, W, X, j, K, Q, G, Y, this.frictionGravity)
                            }
                        }
                    }
                    for (var T = 0; T !== f; T++) {
                        var et = s[T];
                        if (et._wakeUpAfterNarrowphase) {
                            et.wakeUp();
                            et._wakeUpAfterNarrowphase = false
                        }
                    }
                    if (this.has("endContact")) {
                        this.overlapKeeper.getEndOverlaps(V);
                        var tt = this.endContactEvent;
                        var $ = V.length;
                        while ($--) {
                            var nt = V[$];
                            tt.shapeA = nt.shapeA;
                            tt.shapeB = nt.shapeB;
                            tt.bodyA = nt.bodyA;
                            tt.bodyB = nt.bodyA;
                            this.emit(tt)
                        }
                    }
                    this.overlapKeeper.tick();
                    var rt = this.preSolveEvent;
                    rt.contactEquations = c.contactEquations;
                    rt.frictionEquations = c.frictionEquations;
                    this.emit(rt);
                    var _ = h.length;
                    for (T = 0; T !== _; T++) {
                        h[T].update()
                    }
                    if (c.contactEquations.length || c.frictionEquations.length || h.length) {
                        if (this.islandSplit) {
                            S.equations.length = 0;
                            O.appendArray(S.equations, c.contactEquations);
                            O.appendArray(S.equations, c.frictionEquations);
                            for (T = 0; T !== _; T++) {
                                O.appendArray(S.equations, h[T].equations)
                            }
                            S.split(this);
                            for (var T = 0; T !== S.islands.length; T++) {
                                var it = S.islands[T];
                                if (it.equations.length) {
                                    a.solveIsland(e, it)
                                }
                            }
                        } else {
                            a.addEquations(c.contactEquations);
                            a.addEquations(c.frictionEquations);
                            for (T = 0; T !== _; T++) {
                                a.addEquations(h[T].equations)
                            }
                            if (this.solveConstraints) {
                                a.solve(e, this)
                            }
                            a.removeAllEquations()
                        }
                    }
                    for (var T = 0; T !== f; T++) {
                        var et = s[T];
                        if (et.sleepState !== v.SLEEPING && et.motionState !== v.STATIC) {
                            P.integrateBody(et, e)
                        }
                    }
                    for (var T = 0; T !== f; T++) {
                        s[T].setZeroForce()
                    }
                    if (n) {
                        d = performance.now();
                        t.lastStepTime = d - p
                    }
                    if (this.emitImpactEvent && this.has("impact")) {
                        var st = this.impactEvent;
                        for (var T = 0; T !== c.contactEquations.length; T++) {
                            var ot = c.contactEquations[T];
                            if (ot.firstImpact) {
                                st.bodyA = ot.bodyA;
                                st.bodyB = ot.bodyB;
                                st.shapeA = ot.shapeA;
                                st.shapeB = ot.shapeB;
                                st.contactEquation = ot;
                                this.emit(st)
                            }
                        }
                    }
                    if (this.enableBodySleeping) {
                        for (T = 0; T !== f; T++) {
                            s[T].sleepTick(this.time, false, e)
                        }
                    } else if (this.enableIslandSleeping && this.islandSplit) {
                        for (T = 0; T !== f; T++) {
                            s[T].sleepTick(this.time, true, e)
                        }
                        for (var T = 0; T < this.islandManager.islands.length; T++) {
                            var it = this.islandManager.islands[T];
                            if (it.wantsToSleep()) {
                                it.sleep()
                            }
                        }
                    }
                    this.stepping = false;
                    if (this.bodiesToBeRemoved.length) {
                        for (var T = 0; T !== this.bodiesToBeRemoved.length; T++) {
                            this.removeBody(this.bodiesToBeRemoved[T])
                        }
                        this.bodiesToBeRemoved.length = 0
                    }
                    this.emit(this.postStepEvent)
                };
                var $ = o.create();
                var J = o.create();
                P.integrateBody = function(e, t) {
                    var n = e.invMass,
                        r = e.force,
                        i = e.position,
                        s = e.velocity;
                    o.copy(e.previousPosition, e.position);
                    e.previousAngle = e.angle;
                    if (!e.fixedRotation) {
                        e.angularVelocity += e.angularForce * e.invInertia * t;
                        e.angle += e.angularVelocity * t
                    }
                    o.scale($, r, t * n);
                    o.add(s, $, s);
                    o.scale(J, s, t);
                    o.add(i, i, J);
                    e.aabbNeedsUpdate = true
                };
                P.prototype.runNarrowphase = function(e, t, n, r, i, s, u, a, f, l, c) {
                    if (!((n.collisionGroup & u.collisionMask) !== 0 && (u.collisionGroup & n.collisionMask) !== 0)) {
                        return
                    }
                    o.rotate(U, r, t.angle);
                    o.rotate(z, a, s.angle);
                    o.add(U, U, t.position);
                    o.add(z, z, s.position);
                    var h = i + t.angle;
                    var p = f + s.angle;
                    e.enableFriction = l.friction > 0;
                    e.frictionCoefficient = l.friction;
                    var d;
                    if (t.motionState === v.STATIC || t.motionState === v.KINEMATIC) {
                        d = s.mass
                    } else if (s.motionState === v.STATIC || s.motionState === v.KINEMATIC) {
                        d = t.mass
                    } else {
                        d = t.mass * s.mass / (t.mass + s.mass)
                    }
                    e.slipForce = l.friction * c * d;
                    e.restitution = l.restitution;
                    e.surfaceVelocity = l.surfaceVelocity;
                    e.frictionStiffness = l.frictionStiffness;
                    e.frictionRelaxation = l.frictionRelaxation;
                    e.stiffness = l.stiffness;
                    e.relaxation = l.relaxation;
                    var m = e[n.type | u.type],
                        g = 0;
                    if (m) {
                        var y = n.sensor || u.sensor;
                        var b = e.frictionEquations.length;
                        if (n.type < u.type) {
                            g = m.call(e, t, n, U, h, s, u, z, p, y)
                        } else {
                            g = m.call(e, s, u, z, p, t, n, U, h, y)
                        }
                        var w = e.frictionEquations.length - b;
                        if (g) {
                            if (t.allowSleep && t.motionState === v.DYNAMIC && t.sleepState === v.SLEEPING && s.sleepState === v.AWAKE && s.motionState !== v.STATIC) {
                                var E = o.squaredLength(s.velocity) + Math.pow(s.angularVelocity, 2);
                                var S = Math.pow(s.sleepSpeedLimit, 2);
                                if (E >= S * 2) {
                                    t._wakeUpAfterNarrowphase = true
                                }
                            }
                            if (s.allowSleep && s.motionState === v.DYNAMIC && s.sleepState === v.SLEEPING && t.sleepState === v.AWAKE && t.motionState !== v.STATIC) {
                                var x = o.squaredLength(t.velocity) + Math.pow(t.angularVelocity, 2);
                                var T = Math.pow(t.sleepSpeedLimit, 2);
                                if (x >= T * 2) {
                                    s._wakeUpAfterNarrowphase = true
                                }
                            }
                            this.overlapKeeper.setOverlapping(t, n, s, u);
                            if (this.has("beginContact") && this.overlapKeeper.isNewOverlap(n, u)) {
                                var N = this.beginContactEvent;
                                N.shapeA = n;
                                N.shapeB = u;
                                N.bodyA = t;
                                N.bodyB = s;
                                N.contactEquations.length = 0;
                                if (typeof g === "number") {
                                    for (var C = e.contactEquations.length - g; C < e.contactEquations.length; C++) {
                                        N.contactEquations.push(e.contactEquations[C])
                                    }
                                }
                                this.emit(N)
                            }
                            if (typeof g === "number" && w > 1) {
                                for (var C = e.frictionEquations.length - w; C < e.frictionEquations.length; C++) {
                                    var k = e.frictionEquations[C];
                                    k.setSlipForce(k.getSlipForce() / w)
                                }
                            }
                        }
                    }
                };
                P.prototype.addSpring = function(e) {
                    this.springs.push(e);
                    this.addSpringEvent.spring = e;
                    this.emit(this.addSpringEvent)
                };
                P.prototype.removeSpring = function(e) {
                    var t = this.springs.indexOf(e);
                    if (t === -1) {
                        O.splice(this.springs, t, 1)
                    }
                };
                P.prototype.addBody = function(e) {
                    if (this.bodies.indexOf(e) === -1) {
                        this.bodies.push(e);
                        e.world = this;
                        this.addBodyEvent.body = e;
                        this.emit(this.addBodyEvent)
                    }
                };
                P.prototype.removeBody = function(e) {
                    if (this.stepping) {
                        this.bodiesToBeRemoved.push(e)
                    } else {
                        e.world = null;
                        var t = this.bodies.indexOf(e);
                        if (t !== -1) {
                            O.splice(this.bodies, t, 1);
                            this.removeBodyEvent.body = e;
                            e.resetConstraintVelocity();
                            this.emit(this.removeBodyEvent)
                        }
                    }
                };
                P.prototype.getBodyById = function(e) {
                    var t = this.bodies;
                    for (var n = 0; n < t.length; n++) {
                        var r = t[n];
                        if (r.id === e) {
                            return r
                        }
                    }
                    return false
                };
                P.prototype.disableBodyCollision = function(e, t) {
                    this.disabledBodyCollisionPairs.push(e, t)
                };
                P.prototype.enableBodyCollision = function(e, t) {
                    var n = this.disabledBodyCollisionPairs;
                    for (var r = 0; r < n.length; r += 2) {
                        if (n[r] === e && n[r + 1] === t || n[r + 1] === e && n[r] === t) {
                            n.splice(r, 2);
                            return
                        }
                    }
                };
                P.prototype.toJSON = function() {
                    var e = this;
                    var t = {
                        p2: C.version,
                        bodies: [],
                        springs: [],
                        solver: {},
                        gravity: K(e.gravity),
                        broadphase: {},
                        distanceConstraints: [],
                        revoluteConstraints: [],
                        prismaticConstraints: [],
                        lockConstraints: [],
                        gearConstraints: [],
                        contactMaterials: [],
                        materials: [],
                        defaultContactMaterial: G(e.defaultContactMaterial),
                        islandSplit: e.islandSplit,
                        enableIslandSleeping: e.enableIslandSleeping,
                        enableBodySleeping: e.enableBodySleeping
                    };
                    var n = t.solver,
                        r = e.solver;
                    if (r.type === i.GS) {
                        n.type = "GSSolver";
                        n.iterations = r.iterations
                    }
                    var s = t.broadphase,
                        o = e.broadphase;
                    if (o.type === k.NAIVE) {
                        s.type = "NaiveBroadphase"
                    } else if (o.type === k.SAP) {
                        s.type = "SAPBroadphase"
                    } else {
                        console.error("Broadphase not supported: " + o.type)
                    }
                    for (var u = 0; u !== e.springs.length; u++) {
                        var r = e.springs[u];
                        t.springs.push({
                            bodyA: e.bodies.indexOf(r.bodyA),
                            bodyB: e.bodies.indexOf(r.bodyB),
                            stiffness: r.stiffness,
                            damping: r.damping,
                            restLength: r.restLength,
                            localAnchorA: K(r.localAnchorA),
                            localAnchorB: K(r.localAnchorB)
                        })
                    }
                    for (var u = 0; u < e.constraints.length; u++) {
                        var a = e.constraints[u];
                        var f = {
                            bodyA: e.bodies.indexOf(a.bodyA),
                            bodyB: e.bodies.indexOf(a.bodyB),
                            collideConnected: a.collideConnected
                        };
                        switch (a.type) {
                            case E.DISTANCE:
                                Q(f, {
                                    distance: a.distance,
                                    maxForce: a.getMaxForce()
                                });
                                t.distanceConstraints.push(f);
                                break;
                            case E.REVOLUTE:
                                Q(f, {
                                    pivotA: K(a.pivotA),
                                    pivotB: K(a.pivotB),
                                    maxForce: a.maxForce,
                                    motorSpeed: a.getMotorSpeed() || 0,
                                    motorEnabled: !! a.getMotorSpeed(),
                                    lowerLimit: a.lowerLimit,
                                    lowerLimitEnabled: a.lowerLimitEnabled,
                                    upperLimit: a.upperLimit,
                                    upperLimitEnabled: a.upperLimitEnabled
                                });
                                t.revoluteConstraints.push(f);
                                break;
                            case E.PRISMATIC:
                                Q(f, {
                                    localAxisA: K(a.localAxisA),
                                    localAnchorA: K(a.localAnchorA),
                                    localAnchorB: K(a.localAnchorB),
                                    maxForce: a.maxForce,
                                    upperLimitEnabled: a.upperLimitEnabled,
                                    lowerLimitEnabled: a.lowerLimitEnabled,
                                    upperLimit: a.upperLimit,
                                    lowerLimit: a.lowerLimit,
                                    motorEnabled: a.motorEnabled,
                                    motorSpeed: a.motorSpeed
                                });
                                t.prismaticConstraints.push(f);
                                break;
                            case E.LOCK:
                                Q(f, {
                                    localOffsetB: K(a.localOffsetB),
                                    localAngleB: a.localAngleB,
                                    maxForce: a.getMaxForce()
                                });
                                t.lockConstraints.push(f);
                                break;
                            case E.GEAR:
                                Q(f, {
                                    angle: a.angle,
                                    ratio: a.ratio,
                                    maxForce: a.maxForce || 1e6
                                });
                                t.gearConstraints.push(f);
                                break;
                            default:
                                console.error("Constraint not supported yet: ", a.type);
                                break
                        }
                    }
                    for (var u = 0; u !== e.bodies.length; u++) {
                        var l = e.bodies[u],
                            c = l.shapes,
                            h = {
                                id: l.id,
                                mass: l.mass,
                                angle: l.angle,
                                position: K(l.position),
                                velocity: K(l.velocity),
                                angularVelocity: l.angularVelocity,
                                force: K(l.force),
                                motionState: l.motionState,
                                fixedRotation: l.fixedRotation,
                                circleShapes: [],
                                planeShapes: [],
                                particleShapes: [],
                                lineShapes: [],
                                rectangleShapes: [],
                                convexShapes: [],
                                capsuleShapes: []
                            };
                        if (l.concavePath) {
                            h.concavePath = l.concavePath
                        }
                        for (var p = 0; p < c.length; p++) {
                            var r = c[p],
                                d = {};
                            d.offset = K(l.shapeOffsets[p]);
                            d.angle = l.shapeAngles[p];
                            d.collisionGroup = r.collisionGroup;
                            d.collisionMask = r.collisionMask;
                            d.material = r.material ? r.material.id : null;
                            switch (r.type) {
                                case m.CIRCLE:
                                    Q(d, {
                                        radius: r.radius
                                    });
                                    h.circleShapes.push(d);
                                    break;
                                case m.PLANE:
                                    h.planeShapes.push(d);
                                    break;
                                case m.PARTICLE:
                                    h.particleShapes.push(d);
                                    break;
                                case m.LINE:
                                    d.length = r.length;
                                    h.lineShapes.push(d);
                                    break;
                                case m.RECTANGLE:
                                    Q(d, {
                                        width: r.width,
                                        height: r.height
                                    });
                                    h.rectangleShapes.push(d);
                                    break;
                                case m.CONVEX:
                                    var v = [];
                                    for (var g = 0; g < r.vertices.length; g++) {
                                        v.push(K(r.vertices[g]))
                                    }
                                    Q(d, {
                                        vertices: v
                                    });
                                    h.convexShapes.push(d);
                                    break;
                                case m.CAPSULE:
                                    Q(d, {
                                        length: r.length,
                                        radius: r.radius
                                    });
                                    h.capsuleShapes.push(d);
                                    break;
                                default:
                                    console.error("Shape type not supported yet!");
                                    break
                            }
                        }
                        t.bodies.push(h)
                    }
                    for (var u = 0; u < e.contactMaterials.length; u++) {
                        var y = e.contactMaterials[u];
                        t.contactMaterials.push(G(y))
                    }
                    var b = {};
                    for (var u = 0; u < e.contactMaterials.length; u++) {
                        var y = e.contactMaterials[u];
                        b[y.materialA.id + ""] = y.materialA;
                        b[y.materialB.id + ""] = y.materialB
                    }
                    for (var w in b) {
                        var S = b[parseInt(w)];
                        t.materials.push({
                            id: S.id
                        })
                    }
                    return t
                };
                P.prototype.fromJSON = function(e) {
                    this.clear();
                    if (!e.p2) {
                        return false
                    }
                    var t = this;
                    o.copy(t.gravity, e.gravity);
                    t.islandSplit = e.islandSplit;
                    t.enableIslandSleeping = e.enableIslandSleeping;
                    t.enableBodySleeping = e.enableBodySleeping;
                    switch (e.solver.type) {
                        case "GSSolver":
                            var n = e.solver,
                                i = new r;
                            t.solver = i;
                            i.iterations = n.iterations;
                            break;
                        default:
                            throw new Error("Solver type not recognized: " + e.solver.type)
                    }
                    switch (e.broadphase.type) {
                        case "NaiveBroadphase":
                            t.broadphase = new s;
                            break;
                        case "SAPBroadphase":
                            t.broadphase = new L;
                            break
                    }
                    t.broadphase.setWorld(t);
                    var d = t.bodies;
                    var m = {};
                    for (var E = 0; E !== e.materials.length; E++) {
                        var C = e.materials[E];
                        var k = new y;
                        m[C.id + ""] = k;
                        k.id = C.id
                    }
                    t.defaultMaterial.id = e.defaultContactMaterial.materialA;
                    for (var E = 0; E !== e.bodies.length; E++) {
                        var A = e.bodies[E];
                        var O = new v({
                            mass: A.mass,
                            position: A.position,
                            angle: A.angle,
                            velocity: A.velocity,
                            angularVelocity: A.angularVelocity,
                            force: A.force,
                            fixedRotation: A.fixedRotation
                        });
                        O.id = A.id;
                        O.motionState = A.motionState;
                        for (var M = 0; M < A.circleShapes.length; M++) {
                            var i = A.circleShapes[M];
                            _(O, new u(i.radius), i)
                        }
                        for (var M = 0; M < A.planeShapes.length; M++) {
                            var i = A.planeShapes[M];
                            _(O, new c, i)
                        }
                        for (var M = 0; M < A.particleShapes.length; M++) {
                            var i = A.particleShapes[M];
                            _(O, new p, i)
                        }
                        for (var M = 0; M < A.lineShapes.length; M++) {
                            var i = A.lineShapes[M];
                            _(O, new l(i.length), i)
                        }
                        for (var M = 0; M < A.rectangleShapes.length; M++) {
                            var i = A.rectangleShapes[M];
                            _(O, new a(i.width, i.height), i)
                        }
                        for (var M = 0; M < A.convexShapes.length; M++) {
                            var i = A.convexShapes[M];
                            _(O, new f(i.vertices), i)
                        }
                        for (var M = 0; M < A.capsuleShapes.length; M++) {
                            var i = A.capsuleShapes[M];
                            _(O, new h(i.length, i.radius), i)
                        }
                        function _(e, t, n) {
                            t.collisionMask = n.collisionMask;
                            t.collisionGroup = n.collisionGroup;
                            if (n.material) {
                                t.material = m[n.material + ""]
                            }
                            e.addShape(t, n.offset, n.angle)
                        }
                        if (A.concavePath) {
                            O.concavePath = A.concavePath
                        }
                        t.addBody(O)
                    }
                    for (var E = 0; E < e.springs.length; E++) {
                        var n = e.springs[E];
                        var D = d[n.bodyA],
                            P = d[n.bodyB];
                        if (!D) {
                            this.error = "instance.springs[" + E + "] references instance.body[" + n.bodyA + "], which does not exist.";
                            return false
                        }
                        if (!P) {
                            this.error = "instance.springs[" + E + "] references instance.body[" + n.bodyB + "], which does not exist.";
                            return false
                        }
                        var i = new g(D, P, {
                            stiffness: n.stiffness,
                            damping: n.damping,
                            restLength: n.restLength,
                            localAnchorA: n.localAnchorA,
                            localAnchorB: n.localAnchorB
                        });
                        t.addSpring(i)
                    }
                    for (var E = 0; E < e.contactMaterials.length; E++) {
                        var C = e.contactMaterials[E],
                            H = m[C.materialA + ""],
                            B = m[C.materialB + ""];
                        if (!H) {
                            this.error = "Reference to material id " + C.materialA + ": material not found";
                            return false
                        }
                        if (!B) {
                            this.error = "Reference to material id " + C.materialB + ": material not found";
                            return false
                        }
                        var j = new b(H, B, {
                            friction: C.friction,
                            restitution: C.restitution,
                            stiffness: C.stiffness,
                            relaxation: C.relaxation,
                            frictionStiffness: C.frictionStiffness,
                            frictionRelaxation: C.frictionRelaxation
                        });
                        j.id = C.id;
                        t.addContactMaterial(j)
                    }
                    var C = e.defaultContactMaterial,
                        H = t.defaultMaterial,
                        B = t.defaultMaterial;
                    var j = new b(H, B, {
                        friction: C.friction,
                        restitution: C.restitution,
                        stiffness: C.stiffness,
                        relaxation: C.relaxation,
                        frictionStiffness: C.frictionStiffness,
                        frictionRelaxation: C.frictionRelaxation
                    });
                    j.id = C.id;
                    t.defaultContactMaterial = j;
                    for (var E = 0; E < e.distanceConstraints.length; E++) {
                        var F = e.distanceConstraints[E];
                        t.addConstraint(new w(d[F.bodyA], d[F.bodyB], F.distance, {
                            maxForce: F.maxForce,
                            collideConnected: F.collideConnected
                        }))
                    }
                    for (var E = 0; E < e.revoluteConstraints.length; E++) {
                        var F = e.revoluteConstraints[E];
                        var I = new x(d[F.bodyA], F.pivotA, d[F.bodyB], F.pivotB, {
                            maxForce: F.maxForce,
                            collideConnected: F.collideConnected
                        });
                        if (F.motorEnabled) {
                            I.enableMotor()
                        }
                        I.setMotorSpeed(F.motorSpeed);
                        I.lowerLimit = F.lowerLimit;
                        I.upperLimit = F.upperLimit;
                        I.lowerLimitEnabled = F.lowerLimitEnabled;
                        I.upperLimitEnabled = F.upperLimitEnabled;
                        t.addConstraint(I)
                    }
                    for (var E = 0; E < e.prismaticConstraints.length; E++) {
                        var F = e.prismaticConstraints[E],
                            q = new T(d[F.bodyA], d[F.bodyB], {
                                maxForce: F.maxForce,
                                localAxisA: F.localAxisA,
                                localAnchorA: F.localAnchorA,
                                localAnchorB: F.localAnchorB,
                                collideConnected: F.collideConnected
                            });
                        q.motorSpeed = F.motorSpeed;
                        t.addConstraint(q)
                    }
                    for (var E = 0; E < e.lockConstraints.length; E++) {
                        var F = e.lockConstraints[E];
                        t.addConstraint(new S(d[F.bodyA], d[F.bodyB], {
                            maxForce: F.maxForce,
                            localOffsetB: F.localOffsetB,
                            localAngleB: F.localAngleB,
                            collideConnected: F.collideConnected
                        }))
                    }
                    for (var E = 0; E < e.gearConstraints.length; E++) {
                        var F = e.gearConstraints[E];
                        t.addConstraint(new N(d[F.bodyA], d[F.bodyB], {
                            maxForce: F.maxForce,
                            angle: F.angle,
                            ratio: F.ratio,
                            collideConnected: F.collideConnected
                        }))
                    }
                    return true
                };
                P.prototype.clear = function() {
                    this.time = 0;
                    this.fixedStepTime = 0;
                    if (this.solver && this.solver.equations.length) {
                        this.solver.removeAllEquations()
                    }
                    var e = this.constraints;
                    for (var t = e.length - 1; t >= 0; t--) {
                        this.removeConstraint(e[t])
                    }
                    var n = this.bodies;
                    for (var t = n.length - 1; t >= 0; t--) {
                        this.removeBody(n[t])
                    }
                    var r = this.springs;
                    for (var t = r.length - 1; t >= 0; t--) {
                        this.removeSpring(r[t])
                    }
                    var i = this.contactMaterials;
                    for (var t = i.length - 1; t >= 0; t--) {
                        this.removeContactMaterial(i[t])
                    }
                    P.apply(this)
                };
                P.prototype.clone = function() {
                    var e = new P;
                    e.fromJSON(this.toJSON());
                    return e
                };
                var Y = o.create(),
                    Z = o.fromValues(0, 0),
                    et = o.fromValues(0, 0);
                P.prototype.hitTest = function(e, t, n) {
                    n = n || 0;
                    var r = new v({
                            position: e
                        }),
                        i = new p,
                        s = e,
                        a = 0,
                        l = Y,
                        d = Z,
                        m = et;
                    r.addShape(i);
                    var g = this.narrowphase,
                        y = [];
                    for (var b = 0, w = t.length; b !== w; b++) {
                        var E = t[b];
                        for (var S = 0, x = E.shapes.length; S !== x; S++) {
                            var T = E.shapes[S],
                                N = E.shapeOffsets[S] || d,
                                C = E.shapeAngles[S] || 0;
                            o.rotate(l, N, E.angle);
                            o.add(l, l, E.position);
                            var k = C + E.angle;
                            if (T instanceof u && g.circleParticle(E, T, l, k, r, i, s, a, true) || T instanceof f && g.particleConvex(r, i, s, a, E, T, l, k, true) || T instanceof c && g.particlePlane(r, i, s, a, E, T, l, k, true) || T instanceof h && g.particleCapsule(r, i, s, a, E, T, l, k, true) || T instanceof p && o.squaredLength(o.sub(m, l, e)) < n * n) {
                                y.push(E)
                            }
                        }
                    }
                    return y
                };
                P.prototype.setGlobalEquationParameters = function(e) {
                    e = e || {};
                    for (var t = 0; t !== this.constraints.length; t++) {
                        var n = this.constraints[t];
                        for (var r = 0; r !== n.equations.length; r++) {
                            var i = n.equations[r];
                            if (typeof e.stiffness !== "undefined") {
                                i.stiffness = e.stiffness
                            }
                            if (typeof e.relaxation !== "undefined") {
                                i.relaxation = e.relaxation
                            }
                            i.needsUpdate = true
                        }
                    }
                    for (var t = 0; t !== this.contactMaterials.length; t++) {
                        var n = this.contactMaterials[t];
                        if (typeof e.stiffness !== "undefined") {
                            n.stiffness = e.stiffness;
                            n.frictionStiffness = e.stiffness
                        }
                        if (typeof e.relaxation !== "undefined") {
                            n.relaxation = e.relaxation;
                            n.frictionRelaxation = e.relaxation
                        }
                    }
                    var n = this.defaultContactMaterial;
                    if (typeof e.stiffness !== "undefined") {
                        n.stiffness = e.stiffness;
                        n.frictionStiffness = e.stiffness
                    }
                    if (typeof e.relaxation !== "undefined") {
                        n.relaxation = e.relaxation;
                        n.frictionRelaxation = e.relaxation
                    }
                };
                P.prototype.setGlobalStiffness = function(e) {
                    this.setGlobalEquationParameters({
                        stiffness: e
                    })
                };
                P.prototype.setGlobalRelaxation = function(e) {
                    this.setGlobalEquationParameters({
                        relaxation: e
                    })
                }
            }, {
                "../../package.json": 7,
                "../collision/Broadphase": 9,
                "../collision/NaiveBroadphase": 11,
                "../collision/Narrowphase": 12,
                "../collision/SAPBroadphase": 13,
                "../constraints/Constraint": 14,
                "../constraints/DistanceConstraint": 15,
                "../constraints/GearConstraint": 16,
                "../constraints/LockConstraint": 17,
                "../constraints/PrismaticConstraint": 18,
                "../constraints/RevoluteConstraint": 19,
                "../events/EventEmitter": 26,
                "../material/ContactMaterial": 27,
                "../material/Material": 28,
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../objects/Spring": 32,
                "../shapes/Capsule": 34,
                "../shapes/Circle": 35,
                "../shapes/Convex": 36,
                "../shapes/Line": 38,
                "../shapes/Particle": 39,
                "../shapes/Plane": 40,
                "../shapes/Rectangle": 41,
                "../shapes/Shape": 42,
                "../solver/GSSolver": 43,
                "../solver/Solver": 44,
                "../utils/OverlapKeeper": 45,
                "../utils/Utils": 47,
                "./IslandManager": 49
            }]
        }, {}, [33])(33)
    });
p2.Body.prototype.parent = null;
p2.Spring.prototype.parent = null;
Phaser.Physics.P2 = function(e, t) {
    this.game = e;
    if (typeof t === "undefined" || !t.hasOwnProperty("gravity") || !t.hasOwnProperty("broadphase")) {
        t = {
            gravity: [0, 0],
            broadphase: new p2.SAPBroadphase
        }
    }
    this.world = new p2.World(t);
    this.frameRate = 1 / 60;
    this.useElapsedTime = false;
    this.paused = false;
    this.materials = [];
    this.gravity = new Phaser.Physics.P2.InversePointProxy(this, this.world.gravity);
    this.walls = {
        left: null,
        right: null,
        top: null,
        bottom: null
    };
    this.onBodyAdded = new Phaser.Signal;
    this.onBodyRemoved = new Phaser.Signal;
    this.onSpringAdded = new Phaser.Signal;
    this.onSpringRemoved = new Phaser.Signal;
    this.onConstraintAdded = new Phaser.Signal;
    this.onConstraintRemoved = new Phaser.Signal;
    this.onContactMaterialAdded = new Phaser.Signal;
    this.onContactMaterialRemoved = new Phaser.Signal;
    this.postBroadphaseCallback = null;
    this.callbackContext = null;
    this.onBeginContact = new Phaser.Signal;
    this.onEndContact = new Phaser.Signal;
    if (t.hasOwnProperty("mpx") && t.hasOwnProperty("pxm") && t.hasOwnProperty("mpxi") && t.hasOwnProperty("pxmi")) {
        this.mpx = t.mpx;
        this.mpxi = t.mpxi;
        this.pxm = t.pxm;
        this.pxmi = t.pxmi
    }
    this.world.on("beginContact", this.beginContactHandler, this);
    this.world.on("endContact", this.endContactHandler, this);
    this.collisionGroups = [];
    this.nothingCollisionGroup = new Phaser.Physics.P2.CollisionGroup(1);
    this.boundsCollisionGroup = new Phaser.Physics.P2.CollisionGroup(2);
    this.everythingCollisionGroup = new Phaser.Physics.P2.CollisionGroup(2147483648);
    this.boundsCollidesWith = [];
    this._toRemove = [];
    this._collisionGroupID = 2;
    this.setBoundsToWorld(true, true, true, true, false)
};
Phaser.Physics.P2.prototype = {
    removeBodyNextStep: function(e) {
        this._toRemove.push(e)
    },
    preUpdate: function() {
        var e = this._toRemove.length;
        while (e--) {
            this.removeBody(this._toRemove[e])
        }
        this._toRemove.length = 0
    },
    enable: function(e, t, n) {
        if (typeof t === "undefined") {
            t = false
        }
        if (typeof n === "undefined") {
            n = true
        }
        var r = 1;
        if (Array.isArray(e)) {
            r = e.length;
            while (r--) {
                if (e[r] instanceof Phaser.Group) {
                    this.enable(e[r].children, t, n)
                } else {
                    this.enableBody(e[r], t);
                    if (n && e[r].hasOwnProperty("children") && e[r].children.length > 0) {
                        this.enable(e[r], t, true)
                    }
                }
            }
        } else {
            if (e instanceof Phaser.Group) {
                this.enable(e.children, t, n)
            } else {
                this.enableBody(e, t);
                if (n && e.hasOwnProperty("children") && e.children.length > 0) {
                    this.enable(e.children, t, true)
                }
            }
        }
    },
    enableBody: function(e, t) {
        if (e.hasOwnProperty("body") && e.body === null) {
            e.body = new Phaser.Physics.P2.Body(this.game, e, e.x, e.y, 1);
            e.body.debug = t;
            e.anchor.set(.5)
        }
    },
    setImpactEvents: function(e) {
        if (e) {
            this.world.on("impact", this.impactHandler, this)
        } else {
            this.world.off("impact", this.impactHandler, this)
        }
    },
    setPostBroadphaseCallback: function(e, t) {
        this.postBroadphaseCallback = e;
        this.callbackContext = t;
        if (e !== null) {
            this.world.on("postBroadphase", this.postBroadphaseHandler, this)
        } else {
            this.world.off("postBroadphase", this.postBroadphaseHandler, this)
        }
    },
    postBroadphaseHandler: function(e) {
        if (this.postBroadphaseCallback) {
            var t = e.pairs.length;
            while (t -= 2) {
                if (e.pairs[t].parent && e.pairs[t + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, e.pairs[t].parent, e.pairs[t + 1].parent)) {
                    e.pairs.splice(t, 2)
                }
            }
        }
    },
    impactHandler: function(e) {
        if (e.bodyA.parent && e.bodyB.parent) {
            var t = e.bodyA.parent;
            var n = e.bodyB.parent;
            if (t._bodyCallbacks[e.bodyB.id]) {
                t._bodyCallbacks[e.bodyB.id].call(t._bodyCallbackContext[e.bodyB.id], t, n, e.shapeA, e.shapeB)
            }
            if (n._bodyCallbacks[e.bodyA.id]) {
                n._bodyCallbacks[e.bodyA.id].call(n._bodyCallbackContext[e.bodyA.id], n, t, e.shapeB, e.shapeA)
            }
            if (t._groupCallbacks[e.shapeB.collisionGroup]) {
                t._groupCallbacks[e.shapeB.collisionGroup].call(t._groupCallbackContext[e.shapeB.collisionGroup], t, n, e.shapeA, e.shapeB)
            }
            if (n._groupCallbacks[e.shapeA.collisionGroup]) {
                n._groupCallbacks[e.shapeA.collisionGroup].call(n._groupCallbackContext[e.shapeA.collisionGroup], n, t, e.shapeB, e.shapeA)
            }
        }
    },
    beginContactHandler: function(e) {
        this.onBeginContact.dispatch(e.bodyA, e.bodyB, e.shapeA, e.shapeB, e.contactEquations);
        if (e.bodyA.parent) {
            e.bodyA.parent.onBeginContact.dispatch(e.bodyB.parent, e.shapeA, e.shapeB, e.contactEquations)
        }
        if (e.bodyB.parent) {
            e.bodyB.parent.onBeginContact.dispatch(e.bodyA.parent, e.shapeB, e.shapeA, e.contactEquations)
        }
    },
    endContactHandler: function(e) {
        this.onEndContact.dispatch(e.bodyA, e.bodyB, e.shapeA, e.shapeB);
        if (e.bodyA.parent) {
            e.bodyA.parent.onEndContact.dispatch(e.bodyB.parent, e.shapeA, e.shapeB)
        }
        if (e.bodyB.parent) {
            e.bodyB.parent.onEndContact.dispatch(e.bodyA.parent, e.shapeB, e.shapeA)
        }
    },
    setBoundsToWorld: function(e, t, n, r, i) {
        this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, e, t, n, r, i)
    },
    setWorldMaterial: function(e, t, n, r, i) {
        if (typeof t === "undefined") {
            t = true
        }
        if (typeof n === "undefined") {
            n = true
        }
        if (typeof r === "undefined") {
            r = true
        }
        if (typeof i === "undefined") {
            i = true
        }
        if (t && this.walls.left) {
            this.walls.left.shapes[0].material = e
        }
        if (n && this.walls.right) {
            this.walls.right.shapes[0].material = e
        }
        if (r && this.walls.top) {
            this.walls.top.shapes[0].material = e
        }
        if (i && this.walls.bottom) {
            this.walls.bottom.shapes[0].material = e
        }
    },
    updateBoundsCollisionGroup: function(e) {
        var t = this.everythingCollisionGroup.mask;
        if (typeof e === "undefined") {
            t = this.boundsCollisionGroup.mask
        }
        if (this.walls.left) {
            this.walls.left.shapes[0].collisionGroup = t
        }
        if (this.walls.right) {
            this.walls.right.shapes[0].collisionGroup = t
        }
        if (this.walls.top) {
            this.walls.top.shapes[0].collisionGroup = t
        }
        if (this.walls.bottom) {
            this.walls.bottom.shapes[0].collisionGroup = t
        }
    },
    setBounds: function(e, t, n, r, i, s, o, u, a) {
        if (typeof i === "undefined") {
            i = true
        }
        if (typeof s === "undefined") {
            s = true
        }
        if (typeof o === "undefined") {
            o = true
        }
        if (typeof u === "undefined") {
            u = true
        }
        if (typeof a === "undefined") {
            a = true
        }
        if (this.walls.left) {
            this.world.removeBody(this.walls.left)
        }
        if (this.walls.right) {
            this.world.removeBody(this.walls.right)
        }
        if (this.walls.top) {
            this.world.removeBody(this.walls.top)
        }
        if (this.walls.bottom) {
            this.world.removeBody(this.walls.bottom)
        }
        if (i) {
            this.walls.left = new p2.Body({
                mass: 0,
                position: [this.pxmi(e), this.pxmi(t)],
                angle: 1.5707963267948966
            });
            this.walls.left.addShape(new p2.Plane);
            if (a) {
                this.walls.left.shapes[0].collisionGroup = this.boundsCollisionGroup.mask
            }
            this.world.addBody(this.walls.left)
        }
        if (s) {
            this.walls.right = new p2.Body({
                mass: 0,
                position: [this.pxmi(e + n), this.pxmi(t)],
                angle: -1.5707963267948966
            });
            this.walls.right.addShape(new p2.Plane);
            if (a) {
                this.walls.right.shapes[0].collisionGroup = this.boundsCollisionGroup.mask
            }
            this.world.addBody(this.walls.right)
        }
        if (o) {
            this.walls.top = new p2.Body({
                mass: 0,
                position: [this.pxmi(e), this.pxmi(t)],
                angle: -3.141592653589793
            });
            this.walls.top.addShape(new p2.Plane);
            if (a) {
                this.walls.top.shapes[0].collisionGroup = this.boundsCollisionGroup.mask
            }
            this.world.addBody(this.walls.top)
        }
        if (u) {
            this.walls.bottom = new p2.Body({
                mass: 0,
                position: [this.pxmi(e), this.pxmi(r)]
            });
            this.walls.bottom.addShape(new p2.Plane);
            if (a) {
                this.walls.bottom.shapes[0].collisionGroup = this.boundsCollisionGroup.mask
            }
            this.world.addBody(this.walls.bottom)
        }
    },
    pause: function() {
        this.paused = true
    },
    resume: function() {
        this.paused = false
    },
    update: function() {
        if (this.paused) {
            return
        }
        if (this.useElapsedTime) {
            this.world.step(this.game.time.physicsElapsed)
        } else {
            this.world.step(this.frameRate)
        }
    },
    clear: function() {
        this.world.clear();
        this.world.off("beginContact", this.beginContactHandler, this);
        this.world.off("endContact", this.endContactHandler, this);
        this.postBroadphaseCallback = null;
        this.callbackContext = null;
        this.impactCallback = null;
        this.collisionGroups = [];
        this._toRemove = [];
        this._collisionGroupID = 2;
        this.boundsCollidesWith = []
    },
    destroy: function() {
        this.clear();
        this.game = null
    },
    addBody: function(e) {
        if (e.data.world) {
            return false
        } else {
            this.world.addBody(e.data);
            this.onBodyAdded.dispatch(e);
            return true
        }
    },
    removeBody: function(e) {
        if (e.data.world == this.world) {
            this.world.removeBody(e.data);
            this.onBodyRemoved.dispatch(e)
        }
        return e
    },
    addSpring: function(e) {
        this.world.addSpring(e);
        this.onSpringAdded.dispatch(e);
        return e
    },
    removeSpring: function(e) {
        this.world.removeSpring(e);
        this.onSpringRemoved.dispatch(e);
        return e
    },
    createDistanceConstraint: function(e, t, n, r) {
        e = this.getBody(e);
        t = this.getBody(t);
        if (!e || !t) {
            console.warn("Cannot create Constraint, invalid body objects given")
        } else {
            return this.addConstraint(new Phaser.Physics.P2.DistanceConstraint(this, e, t, n, r))
        }
    },
    createGearConstraint: function(e, t, n, r) {
        e = this.getBody(e);
        t = this.getBody(t);
        if (!e || !t) {
            console.warn("Cannot create Constraint, invalid body objects given")
        } else {
            return this.addConstraint(new Phaser.Physics.P2.GearConstraint(this, e, t, n, r))
        }
    },
    createRevoluteConstraint: function(e, t, n, r, i) {
        e = this.getBody(e);
        n = this.getBody(n);
        if (!e || !n) {
            console.warn("Cannot create Constraint, invalid body objects given")
        } else {
            return this.addConstraint(new Phaser.Physics.P2.RevoluteConstraint(this, e, t, n, r, i))
        }
    },
    createLockConstraint: function(e, t, n, r, i) {
        e = this.getBody(e);
        t = this.getBody(t);
        if (!e || !t) {
            console.warn("Cannot create Constraint, invalid body objects given")
        } else {
            return this.addConstraint(new Phaser.Physics.P2.LockConstraint(this, e, t, n, r, i))
        }
    },
    createPrismaticConstraint: function(e, t, n, r, i, s, o) {
        e = this.getBody(e);
        t = this.getBody(t);
        if (!e || !t) {
            console.warn("Cannot create Constraint, invalid body objects given")
        } else {
            return this.addConstraint(new Phaser.Physics.P2.PrismaticConstraint(this, e, t, n, r, i, s, o))
        }
    },
    addConstraint: function(e) {
        this.world.addConstraint(e);
        this.onConstraintAdded.dispatch(e);
        return e
    },
    removeConstraint: function(e) {
        this.world.removeConstraint(e);
        this.onConstraintRemoved.dispatch(e);
        return e
    },
    addContactMaterial: function(e) {
        this.world.addContactMaterial(e);
        this.onContactMaterialAdded.dispatch(e);
        return e
    },
    removeContactMaterial: function(e) {
        this.world.removeContactMaterial(e);
        this.onContactMaterialRemoved.dispatch(e);
        return e
    },
    getContactMaterial: function(e, t) {
        return this.world.getContactMaterial(e, t)
    },
    setMaterial: function(e, t) {
        var n = t.length;
        while (n--) {
            t[n].setMaterial(e)
        }
    },
    createMaterial: function(e, t) {
        e = e || "";
        var n = new Phaser.Physics.P2.Material(e);
        this.materials.push(n);
        if (typeof t !== "undefined") {
            t.setMaterial(n)
        }
        return n
    },
    createContactMaterial: function(e, t, n) {
        if (typeof e === "undefined") {
            e = this.createMaterial()
        }
        if (typeof t === "undefined") {
            t = this.createMaterial()
        }
        var r = new Phaser.Physics.P2.ContactMaterial(e, t, n);
        return this.addContactMaterial(r)
    },
    getBodies: function() {
        var e = [];
        var t = this.world.bodies.length;
        while (t--) {
            e.push(this.world.bodies[t].parent)
        }
        return e
    },
    getBody: function(e) {
        if (e instanceof p2.Body) {
            return e
        } else if (e instanceof Phaser.Physics.P2.Body) {
            return e.data
        } else if (e["body"] && e["body"].type === Phaser.Physics.P2JS) {
            return e.body.data
        }
        return null
    },
    getSprings: function() {
        var e = [];
        var t = this.world.springs.length;
        while (t--) {
            e.push(this.world.springs[t].parent)
        }
        return e
    },
    getConstraints: function() {
        var e = [];
        var t = this.world.constraints.length;
        while (t--) {
            e.push(this.world.constraints[t].parent)
        }
        return e
    },
    hitTest: function(e, t, n, r) {
        if (typeof t === "undefined") {
            t = this.world.bodies
        }
        if (typeof n === "undefined") {
            n = 5
        }
        if (typeof r === "undefined") {
            r = false
        }
        var i = [this.pxmi(e.x), this.pxmi(e.y)];
        var s = [];
        var o = t.length;
        while (o--) {
            if (t[o] instanceof Phaser.Physics.P2.Body && !(r && t[o].data.motionState === p2.Body.STATIC)) {
                s.push(t[o].data)
            } else if (t[o] instanceof p2.Body && t[o].parent && !(r && t[o].motionState === p2.Body.STATIC)) {
                s.push(t[o])
            } else if (t[o] instanceof Phaser.Sprite && t[o].hasOwnProperty("body") && !(r && t[o].body.data.motionState === p2.Body.STATIC)) {
                s.push(t[o].body.data)
            }
        }
        return this.world.hitTest(i, s, n)
    },
    toJSON: function() {
        return this.world.toJSON()
    },
    createCollisionGroup: function(e) {
        var t = Math.pow(2, this._collisionGroupID);
        if (this.walls.left) {
            this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | t
        }
        if (this.walls.right) {
            this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | t
        }
        if (this.walls.top) {
            this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | t
        }
        if (this.walls.bottom) {
            this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | t
        }
        this._collisionGroupID++;
        var n = new Phaser.Physics.P2.CollisionGroup(t);
        this.collisionGroups.push(n);
        if (e) {
            this.setCollisionGroup(e, n)
        }
        return n
    },
    setCollisionGroup: function(e, t) {
        if (e instanceof Phaser.Group) {
            for (var n = 0; n < e.total; n++) {
                if (e.children[n]["body"] && e.children[n]["body"].type === Phaser.Physics.P2JS) {
                    e.children[n].body.setCollisionGroup(t)
                }
            }
        } else {
            e.body.setCollisionGroup(t)
        }
    },
    createSpring: function(e, t, n, r, i, s, o, u, a) {
        e = this.getBody(e);
        t = this.getBody(t);
        if (!e || !t) {
            console.warn("Cannot create Spring, invalid body objects given")
        } else {
            return this.addSpring(new Phaser.Physics.P2.Spring(this, e, t, n, r, i, s, o, u, a))
        }
    },
    createBody: function(e, t, n, r, i, s) {
        if (typeof r === "undefined") {
            r = false
        }
        var o = new Phaser.Physics.P2.Body(this.game, null, e, t, n);
        if (s) {
            var u = o.addPolygon(i, s);
            if (!u) {
                return false
            }
        }
        if (r) {
            this.world.addBody(o.data)
        }
        return o
    },
    createParticle: function(e, t, n, r, i, s) {
        if (typeof r === "undefined") {
            r = false
        }
        var o = new Phaser.Physics.P2.Body(this.game, null, e, t, n);
        if (s) {
            var u = o.addPolygon(i, s);
            if (!u) {
                return false
            }
        }
        if (r) {
            this.world.addBody(o.data)
        }
        return o
    },
    convertCollisionObjects: function(e, t, n) {
        if (typeof n === "undefined") {
            n = true
        }
        var r = [];
        for (var i = 0, s = e.collision[t].length; i < s; i++) {
            var o = e.collision[t][i];
            var u = this.createBody(o.x, o.y, 0, n, {}, o.polyline);
            if (u) {
                r.push(u)
            }
        }
        return r
    },
    clearTilemapLayerBodies: function(e, t) {
        t = e.getLayer(t);
        var n = e.layers[t].bodies.length;
        while (n--) {
            e.layers[t].bodies[n].destroy()
        }
        e.layers[t].bodies.length = 0
    },
    convertTilemap: function(e, t, n, r) {
        t = e.getLayer(t);
        if (typeof n === "undefined") {
            n = true
        }
        if (typeof r === "undefined") {
            r = true
        }
        this.clearTilemapLayerBodies(e, t);
        var i = 0;
        var s = 0;
        var o = 0;
        for (var u = 0, a = e.layers[t].height; u < a; u++) {
            i = 0;
            for (var f = 0, l = e.layers[t].width; f < l; f++) {
                var c = e.layers[t].data[u][f];
                if (c && c.index > -1 && c.collides) {
                    if (r) {
                        var h = e.getTileRight(t, f, u);
                        if (i === 0) {
                            s = c.x * c.width;
                            o = c.y * c.height;
                            i = c.width
                        }
                        if (h && h.collides) {
                            i += c.width
                        } else {
                            var p = this.createBody(s, o, 0, false);
                            p.addRectangle(i, c.height, i / 2, c.height / 2, 0);
                            if (n) {
                                this.addBody(p)
                            }
                            e.layers[t].bodies.push(p);
                            i = 0
                        }
                    } else {
                        var p = this.createBody(c.x * c.width, c.y * c.height, 0, false);
                        p.addRectangle(c.width, c.height, c.width / 2, c.height / 2, 0);
                        if (n) {
                            this.addBody(p)
                        }
                        e.layers[t].bodies.push(p)
                    }
                }
            }
        }
        return e.layers[t].bodies
    },
    mpx: function(e) {
        return e *= 20
    },
    pxm: function(e) {
        return e * .05
    },
    mpxi: function(e) {
        return e *= -20
    },
    pxmi: function(e) {
        return e * -.05
    }
};
Object.defineProperty(Phaser.Physics.P2.prototype, "friction", {
    get: function() {
        return this.world.defaultContactMaterial.friction
    },
    set: function(e) {
        this.world.defaultContactMaterial.friction = e
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "defaultFriction", {
    get: function() {
        return this.world.defaultContactMaterial.friction
    },
    set: function(e) {
        this.world.defaultContactMaterial.friction = e
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "restitution", {
    get: function() {
        return this.world.defaultContactMaterial.restitution
    },
    set: function(e) {
        this.world.defaultContactMaterial.restitution = e
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "defaultRestitution", {
    get: function() {
        return this.world.defaultContactMaterial.restitution
    },
    set: function(e) {
        this.world.defaultContactMaterial.restitution = e
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "contactMaterial", {
    get: function() {
        return this.world.defaultContactMaterial
    },
    set: function(e) {
        this.world.defaultContactMaterial = e
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "applySpringForces", {
    get: function() {
        return this.world.applySpringForces
    },
    set: function(e) {
        this.world.applySpringForces = e
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "applyDamping", {
    get: function() {
        return this.world.applyDamping
    },
    set: function(e) {
        this.world.applyDamping = e
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "applyGravity", {
    get: function() {
        return this.world.applyGravity
    },
    set: function(e) {
        this.world.applyGravity = e
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "solveConstraints", {
    get: function() {
        return this.world.solveConstraints
    },
    set: function(e) {
        this.world.solveConstraints = e
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "time", {
    get: function() {
        return this.world.time
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "emitImpactEvent", {
    get: function() {
        return this.world.emitImpactEvent
    },
    set: function(e) {
        this.world.emitImpactEvent = e
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "enableBodySleeping", {
    get: function() {
        return this.world.enableBodySleeping
    },
    set: function(e) {
        this.world.enableBodySleeping = e
    }
});
Object.defineProperty(Phaser.Physics.P2.prototype, "total", {
    get: function() {
        return this.world.bodies.length
    }
});
Phaser.Physics.P2.FixtureList = function(e) {
    if (!Array.isArray(e)) {
        e = [e]
    }
    this.rawList = e;
    this.init();
    this.parse(this.rawList)
};
Phaser.Physics.P2.FixtureList.prototype = {
    init: function() {
        this.namedFixtures = {};
        this.groupedFixtures = [];
        this.allFixtures = []
    },
    setCategory: function(e, t) {
        var n = function(t) {
            t.collisionGroup = e
        };
        this.getFixtures(t).forEach(n)
    },
    setMask: function(e, t) {
        var n = function(t) {
            t.collisionMask = e
        };
        this.getFixtures(t).forEach(n)
    },
    setSensor: function(e, t) {
        var n = function(t) {
            t.sensor = e
        };
        this.getFixtures(t).forEach(n)
    },
    setMaterial: function(e, t) {
        var n = function(t) {
            t.material = e
        };
        this.getFixtures(t).forEach(n)
    },
    getFixtures: function(e) {
        var t = [];
        if (e) {
            if (!(e instanceof Array)) {
                e = [e]
            }
            var n = this;
            e.forEach(function(e) {
                if (n.namedFixtures[e]) {
                    t.push(n.namedFixtures[e])
                }
            });
            return this.flatten(t)
        } else {
            return this.allFixtures
        }
    },
    getFixtureByKey: function(e) {
        return this.namedFixtures[e]
    },
    getGroup: function(e) {
        return this.groupedFixtures[e]
    },
    parse: function() {
        var e, t, n, r;
        n = this.rawList;
        r = [];
        for (e in n) {
            t = n[e];
            if (!isNaN(e - 0)) {
                this.groupedFixtures[e] = this.groupedFixtures[e] || [];
                this.groupedFixtures[e] = this.groupedFixtures[e].concat(t)
            } else {
                this.namedFixtures[e] = this.flatten(t)
            }
            r.push(this.allFixtures = this.flatten(this.groupedFixtures))
        }
    },
    flatten: function(e) {
        var t, n;
        t = [];
        n = arguments.callee;
        e.forEach(function(e) {
            return Array.prototype.push.apply(t, Array.isArray(e) ? n(e) : [e])
        });
        return t
    }
};
Phaser.Physics.P2.PointProxy = function(e, t) {
    this.world = e;
    this.destination = t
};
Phaser.Physics.P2.PointProxy.prototype.constructor = Phaser.Physics.P2.PointProxy;
Object.defineProperty(Phaser.Physics.P2.PointProxy.prototype, "x", {
    get: function() {
        return this.destination[0]
    },
    set: function(e) {
        this.destination[0] = this.world.pxm(e)
    }
});
Object.defineProperty(Phaser.Physics.P2.PointProxy.prototype, "y", {
    get: function() {
        return this.destination[1]
    },
    set: function(e) {
        this.destination[1] = this.world.pxm(e)
    }
});
Phaser.Physics.P2.InversePointProxy = function(e, t) {
    this.world = e;
    this.destination = t
};
Phaser.Physics.P2.InversePointProxy.prototype.constructor = Phaser.Physics.P2.InversePointProxy;
Object.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, "x", {
    get: function() {
        return this.destination[0]
    },
    set: function(e) {
        this.destination[0] = this.world.pxm(-e)
    }
});
Object.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, "y", {
    get: function() {
        return this.destination[1]
    },
    set: function(e) {
        this.destination[1] = this.world.pxm(-e)
    }
});
Phaser.Physics.P2.Body = function(e, t, n, r, i) {
    t = t || null;
    n = n || 0;
    r = r || 0;
    if (typeof i === "undefined") {
        i = 1
    }
    this.game = e;
    this.world = e.physics.p2;
    this.sprite = t;
    this.type = Phaser.Physics.P2JS;
    this.offset = new Phaser.Point;
    this.data = new p2.Body({
        position: [this.world.pxmi(n), this.world.pxmi(r)],
        mass: i
    });
    this.data.parent = this;
    this.velocity = new Phaser.Physics.P2.InversePointProxy(this.world, this.data.velocity);
    this.force = new Phaser.Physics.P2.InversePointProxy(this.world, this.data.force);
    this.gravity = new Phaser.Point;
    this.onBeginContact = new Phaser.Signal;
    this.onEndContact = new Phaser.Signal;
    this.collidesWith = [];
    this.removeNextStep = false;
    this.debugBody = null;
    this._collideWorldBounds = true;
    this._bodyCallbacks = {};
    this._bodyCallbackContext = {};
    this._groupCallbacks = {};
    this._groupCallbackContext = {};
    if (t) {
        this.setRectangleFromSprite(t);
        if (t.exists) {
            this.game.physics.p2.addBody(this)
        }
    }
};
Phaser.Physics.P2.Body.prototype = {
    createBodyCallback: function(e, t, n) {
        var r = -1;
        if (e["id"]) {
            r = e.id
        } else if (e["body"]) {
            r = e.body.id
        }
        if (r > -1) {
            if (t === null) {
                delete this._bodyCallbacks[r];
                delete this._bodyCallbackContext[r]
            } else {
                this._bodyCallbacks[r] = t;
                this._bodyCallbackContext[r] = n
            }
        }
    },
    createGroupCallback: function(e, t, n) {
        if (t === null) {
            delete this._groupCallbacks[e.mask];
            delete this._groupCallbacksContext[e.mask]
        } else {
            this._groupCallbacks[e.mask] = t;
            this._groupCallbackContext[e.mask] = n
        }
    },
    getCollisionMask: function() {
        var e = 0;
        if (this._collideWorldBounds) {
            e = this.game.physics.p2.boundsCollisionGroup.mask
        }
        for (var t = 0; t < this.collidesWith.length; t++) {
            e = e | this.collidesWith[t].mask
        }
        return e
    },
    updateCollisionMask: function(e) {
        var t = this.getCollisionMask();
        if (typeof e === "undefined") {
            for (var n = this.data.shapes.length - 1; n >= 0; n--) {
                this.data.shapes[n].collisionMask = t
            }
        } else {
            e.collisionMask = t
        }
    },
    setCollisionGroup: function(e, t) {
        var n = this.getCollisionMask();
        if (typeof t === "undefined") {
            for (var r = this.data.shapes.length - 1; r >= 0; r--) {
                this.data.shapes[r].collisionGroup = e.mask;
                this.data.shapes[r].collisionMask = n
            }
        } else {
            t.collisionGroup = e.mask;
            t.collisionMask = n
        }
    },
    clearCollision: function(e, t, n) {
        if (typeof n === "undefined") {
            for (var r = this.data.shapes.length - 1; r >= 0; r--) {
                if (e) {
                    this.data.shapes[r].collisionGroup = null
                }
                if (t) {
                    this.data.shapes[r].collisionMask = null
                }
            }
        } else {
            if (e) {
                n.collisionGroup = null
            }
            if (t) {
                n.collisionMask = null
            }
        }
        if (e) {
            this.collidesWith.length = 0
        }
    },
    collides: function(e, t, n, r) {
        if (Array.isArray(e)) {
            for (var i = 0; i < e.length; i++) {
                if (this.collidesWith.indexOf(e[i]) === -1) {
                    this.collidesWith.push(e[i]);
                    if (t) {
                        this.createGroupCallback(e[i], t, n)
                    }
                }
            }
        } else {
            if (this.collidesWith.indexOf(e) === -1) {
                this.collidesWith.push(e);
                if (t) {
                    this.createGroupCallback(e, t, n)
                }
            }
        }
        var s = this.getCollisionMask();
        if (typeof r === "undefined") {
            for (var i = this.data.shapes.length - 1; i >= 0; i--) {
                this.data.shapes[i].collisionMask = s
            }
        } else {
            r.collisionMask = s
        }
    },
    adjustCenterOfMass: function() {
        this.data.adjustCenterOfMass()
    },
    applyDamping: function(e) {
        this.data.applyDamping(e)
    },
    applyForce: function(e, t, n) {
        this.data.applyForce(e, [this.world.pxmi(t), this.world.pxmi(n)])
    },
    setZeroForce: function() {
        this.data.setZeroForce()
    },
    setZeroRotation: function() {
        this.data.angularVelocity = 0
    },
    setZeroVelocity: function() {
        this.data.velocity[0] = 0;
        this.data.velocity[1] = 0
    },
    setZeroDamping: function() {
        this.data.damping = 0;
        this.data.angularDamping = 0
    },
    toLocalFrame: function(e, t) {
        return this.data.toLocalFrame(e, t)
    },
    toWorldFrame: function(e, t) {
        return this.data.toWorldFrame(e, t)
    },
    rotateLeft: function(e) {
        this.data.angularVelocity = this.world.pxm(-e)
    },
    rotateRight: function(e) {
        this.data.angularVelocity = this.world.pxm(e)
    },
    moveForward: function(e) {
        var t = this.world.pxmi(-e);
        var n = this.data.angle + Math.PI / 2;
        this.data.velocity[0] = t * Math.cos(n);
        this.data.velocity[1] = t * Math.sin(n)
    },
    moveBackward: function(e) {
        var t = this.world.pxmi(-e);
        var n = this.data.angle + Math.PI / 2;
        this.data.velocity[0] = -(t * Math.cos(n));
        this.data.velocity[1] = -(t * Math.sin(n))
    },
    thrust: function(e) {
        var t = this.world.pxmi(-e);
        var n = this.data.angle + Math.PI / 2;
        this.data.force[0] += t * Math.cos(n);
        this.data.force[1] += t * Math.sin(n)
    },
    reverse: function(e) {
        var t = this.world.pxmi(-e);
        var n = this.data.angle + Math.PI / 2;
        this.data.force[0] -= t * Math.cos(n);
        this.data.force[1] -= t * Math.sin(n)
    },
    moveLeft: function(e) {
        this.data.velocity[0] = this.world.pxmi(-e)
    },
    moveRight: function(e) {
        this.data.velocity[0] = this.world.pxmi(e)
    },
    moveUp: function(e) {
        this.data.velocity[1] = this.world.pxmi(-e)
    },
    moveDown: function(e) {
        this.data.velocity[1] = this.world.pxmi(e)
    },
    preUpdate: function() {
        if (this.removeNextStep) {
            this.removeFromWorld();
            this.removeNextStep = false
        }
    },
    postUpdate: function() {
        this.sprite.x = this.world.mpxi(this.data.position[0]);
        this.sprite.y = this.world.mpxi(this.data.position[1]);
        if (!this.fixedRotation) {
            this.sprite.rotation = this.data.angle
        }
    },
    reset: function(e, t, n, r) {
        if (typeof n === "undefined") {
            n = false
        }
        if (typeof r === "undefined") {
            r = false
        }
        this.setZeroForce();
        this.setZeroVelocity();
        this.setZeroRotation();
        if (n) {
            this.setZeroDamping()
        }
        if (r) {
            this.mass = 1
        }
        this.x = e;
        this.y = t
    },
    addToWorld: function() {
        if (this.data.world !== this.game.physics.p2.world) {
            this.game.physics.p2.addBody(this)
        }
    },
    removeFromWorld: function() {
        if (this.data.world === this.game.physics.p2.world) {
            this.game.physics.p2.removeBodyNextStep(this)
        }
    },
    destroy: function() {
        this.removeFromWorld();
        this.clearShapes();
        this._bodyCallbacks = {};
        this._bodyCallbackContext = {};
        this._groupCallbacks = {};
        this._groupCallbackContext = {};
        if (this.debugBody) {
            this.debugBody.destroy()
        }
        this.debugBody = null;
        this.sprite = null
    },
    clearShapes: function() {
        var e = this.data.shapes.length;
        while (e--) {
            this.data.removeShape(this.data.shapes[e])
        }
        this.shapeChanged()
    },
    addShape: function(e, t, n, r) {
        if (typeof t === "undefined") {
            t = 0
        }
        if (typeof n === "undefined") {
            n = 0
        }
        if (typeof r === "undefined") {
            r = 0
        }
        this.data.addShape(e, [this.world.pxmi(t), this.world.pxmi(n)], r);
        this.shapeChanged();
        return e
    },
    addCircle: function(e, t, n, r) {
        var i = new p2.Circle(this.world.pxm(e));
        return this.addShape(i, t, n, r)
    },
    addRectangle: function(e, t, n, r, i) {
        var s = new p2.Rectangle(this.world.pxm(e), this.world.pxm(t));
        return this.addShape(s, n, r, i)
    },
    addPlane: function(e, t, n) {
        var r = new p2.Plane;
        return this.addShape(r, e, t, n)
    },
    addParticle: function(e, t, n) {
        var r = new p2.Particle;
        return this.addShape(r, e, t, n)
    },
    addLine: function(e, t, n, r) {
        var i = new p2.Line(this.world.pxm(e));
        return this.addShape(i, t, n, r)
    },
    addCapsule: function(e, t, n, r, i) {
        var s = new p2.Capsule(this.world.pxm(e), t);
        return this.addShape(s, n, r, i)
    },
    addPolygon: function(e, t) {
        e = e || {};
        t = Array.prototype.slice.call(arguments, 1);
        var n = [];
        if (t.length === 1 && Array.isArray(t[0])) {
            n = t[0].slice(0)
        } else if (Array.isArray(t[0])) {
            n = t[0].slice(0)
        } else if (typeof t[0] === "number") {
            for (var r = 0, i = t.length; r < i; r += 2) {
                n.push([t[r], t[r + 1]])
            }
        }
        var s = n.length - 1;
        if (n[s][0] === n[0][0] && n[s][1] === n[0][1]) {
            n.pop()
        }
        for (var o = 0; o < n.length; o++) {
            n[o][0] = this.world.pxmi(n[o][0]);
            n[o][1] = this.world.pxmi(n[o][1])
        }
        var u = this.data.fromPolygon(n, e);
        this.shapeChanged();
        return u
    },
    removeShape: function(e) {
        return this.data.removeShape(e)
    },
    setCircle: function(e, t, n, r) {
        this.clearShapes();
        return this.addCircle(e, t, n, r)
    },
    setRectangle: function(e, t, n, r, i) {
        if (typeof e === "undefined") {
            e = 16
        }
        if (typeof t === "undefined") {
            t = 16
        }
        this.clearShapes();
        return this.addRectangle(e, t, n, r, i)
    },
    setRectangleFromSprite: function(e) {
        if (typeof e === "undefined") {
            e = this.sprite
        }
        this.clearShapes();
        return this.addRectangle(e.width, e.height, 0, 0, e.rotation)
    },
    setMaterial: function(e, t) {
        if (typeof t === "undefined") {
            for (var n = this.data.shapes.length - 1; n >= 0; n--) {
                this.data.shapes[n].material = e
            }
        } else {
            t.material = e
        }
    },
    shapeChanged: function() {
        if (this.debugBody) {
            this.debugBody.draw()
        }
    },
    addPhaserPolygon: function(e, t) {
        var n = this.game.cache.getPhysicsData(e, t);
        var r = [];
        for (var i = 0; i < n.length; i++) {
            var s = n[i];
            var o = this.addFixture(s);
            r[s.filter.group] = r[s.filter.group] || [];
            r[s.filter.group] = r[s.filter.group].concat(o);
            if (s.fixtureKey) {
                r[s.fixtureKey] = o
            }
        }
        this.data.aabbNeedsUpdate = true;
        this.shapeChanged();
        return r
    },
    addFixture: function(e) {
        var t = [];
        if (e.circle) {
            var n = new p2.Circle(this.world.pxm(e.circle.radius));
            n.collisionGroup = e.filter.categoryBits;
            n.collisionMask = e.filter.maskBits;
            n.sensor = e.isSensor;
            var r = p2.vec2.create();
            r[0] = this.world.pxmi(e.circle.position[0] - this.sprite.width / 2);
            r[1] = this.world.pxmi(e.circle.position[1] - this.sprite.height / 2);
            this.data.addShape(n, r);
            t.push(n)
        } else {
            var i = e.polygons;
            var s = p2.vec2.create();
            for (var o = 0; o < i.length; o++) {
                var u = i[o];
                var a = [];
                for (var f = 0; f < u.length; f += 2) {
                    a.push([this.world.pxmi(u[f]), this.world.pxmi(u[f + 1])])
                }
                var n = new p2.Convex(a);
                for (var l = 0; l !== n.vertices.length; l++) {
                    var c = n.vertices[l];
                    p2.vec2.sub(c, c, n.centerOfMass)
                }
                p2.vec2.scale(s, n.centerOfMass, 1);
                s[0] -= this.world.pxmi(this.sprite.width / 2);
                s[1] -= this.world.pxmi(this.sprite.height / 2);
                n.updateTriangles();
                n.updateCenterOfMass();
                n.updateBoundingRadius();
                n.collisionGroup = e.filter.categoryBits;
                n.collisionMask = e.filter.maskBits;
                n.sensor = e.isSensor;
                this.data.addShape(n, s);
                t.push(n)
            }
        }
        return t
    },
    loadPolygon: function(e, t) {
        var n = this.game.cache.getPhysicsData(e, t);
        var r = p2.vec2.create();
        for (var i = 0; i < n.length; i++) {
            var s = [];
            for (var o = 0; o < n[i].shape.length; o += 2) {
                s.push([this.world.pxmi(n[i].shape[o]), this.world.pxmi(n[i].shape[o + 1])])
            }
            var u = new p2.Convex(s);
            for (var a = 0; a !== u.vertices.length; a++) {
                var f = u.vertices[a];
                p2.vec2.sub(f, f, u.centerOfMass)
            }
            p2.vec2.scale(r, u.centerOfMass, 1);
            r[0] -= this.world.pxmi(this.sprite.width / 2);
            r[1] -= this.world.pxmi(this.sprite.height / 2);
            u.updateTriangles();
            u.updateCenterOfMass();
            u.updateBoundingRadius();
            this.data.addShape(u, r)
        }
        this.data.aabbNeedsUpdate = true;
        this.shapeChanged();
        return true
    },
    loadData: function(e, t) {
        var n = this.game.cache.getPhysicsData(e, t);
        if (n && n.shape) {
            this.mass = n.density;
            return this.loadPolygon(e, t)
        }
    }
};
Phaser.Physics.P2.Body.prototype.constructor = Phaser.Physics.P2.Body;
Phaser.Physics.P2.Body.DYNAMIC = 1;
Phaser.Physics.P2.Body.STATIC = 2;
Phaser.Physics.P2.Body.KINEMATIC = 4;
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "static", {
    get: function() {
        return this.data.motionState === Phaser.Physics.P2.Body.STATIC
    },
    set: function(e) {
        if (e && this.data.motionState !== Phaser.Physics.P2.Body.STATIC) {
            this.data.motionState = Phaser.Physics.P2.Body.STATIC;
            this.mass = 0
        } else if (!e && this.data.motionState === Phaser.Physics.P2.Body.STATIC) {
            this.data.motionState = Phaser.Physics.P2.Body.DYNAMIC;
            if (this.mass === 0) {
                this.mass = 1
            }
        }
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "dynamic", {
    get: function() {
        return this.data.motionState === Phaser.Physics.P2.Body.DYNAMIC
    },
    set: function(e) {
        if (e && this.data.motionState !== Phaser.Physics.P2.Body.DYNAMIC) {
            this.data.motionState = Phaser.Physics.P2.Body.DYNAMIC;
            if (this.mass === 0) {
                this.mass = 1
            }
        } else if (!e && this.data.motionState === Phaser.Physics.P2.Body.DYNAMIC) {
            this.data.motionState = Phaser.Physics.P2.Body.STATIC;
            this.mass = 0
        }
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "kinematic", {
    get: function() {
        return this.data.motionState === Phaser.Physics.P2.Body.KINEMATIC
    },
    set: function(e) {
        if (e && this.data.motionState !== Phaser.Physics.P2.Body.KINEMATIC) {
            this.data.motionState = Phaser.Physics.P2.Body.KINEMATIC;
            this.mass = 4
        } else if (!e && this.data.motionState === Phaser.Physics.P2.Body.KINEMATIC) {
            this.data.motionState = Phaser.Physics.P2.Body.STATIC;
            this.mass = 0
        }
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "allowSleep", {
    get: function() {
        return this.data.allowSleep
    },
    set: function(e) {
        if (e !== this.data.allowSleep) {
            this.data.allowSleep = e
        }
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angle", {
    get: function() {
        return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.data.angle))
    },
    set: function(e) {
        this.data.angle = Phaser.Math.degToRad(Phaser.Math.wrapAngle(e))
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angularDamping", {
    get: function() {
        return this.data.angularDamping
    },
    set: function(e) {
        this.data.angularDamping = e
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angularForce", {
    get: function() {
        return this.data.angularForce
    },
    set: function(e) {
        this.data.angularForce = e
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angularVelocity", {
    get: function() {
        return this.data.angularVelocity
    },
    set: function(e) {
        this.data.angularVelocity = e
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "damping", {
    get: function() {
        return this.data.damping
    },
    set: function(e) {
        this.data.damping = e
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "fixedRotation", {
    get: function() {
        return this.data.fixedRotation
    },
    set: function(e) {
        if (e !== this.data.fixedRotation) {
            this.data.fixedRotation = e
        }
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "inertia", {
    get: function() {
        return this.data.inertia
    },
    set: function(e) {
        this.data.inertia = e
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "mass", {
    get: function() {
        return this.data.mass
    },
    set: function(e) {
        if (e !== this.data.mass) {
            this.data.mass = e;
            this.data.updateMassProperties()
        }
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "motionState", {
    get: function() {
        return this.data.motionState
    },
    set: function(e) {
        if (e !== this.data.motionState) {
            this.data.motionState = e
        }
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "rotation", {
    get: function() {
        return this.data.angle
    },
    set: function(e) {
        this.data.angle = e
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "sleepSpeedLimit", {
    get: function() {
        return this.data.sleepSpeedLimit
    },
    set: function(e) {
        this.data.sleepSpeedLimit = e
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "x", {
    get: function() {
        return this.world.mpxi(this.data.position[0])
    },
    set: function(e) {
        this.data.position[0] = this.world.pxmi(e)
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "y", {
    get: function() {
        return this.world.mpxi(this.data.position[1])
    },
    set: function(e) {
        this.data.position[1] = this.world.pxmi(e)
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "id", {
    get: function() {
        return this.data.id
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "debug", {
    get: function() {
        return !this.debugBody
    },
    set: function(e) {
        if (e && !this.debugBody) {
            this.debugBody = new Phaser.Physics.P2.BodyDebug(this.game, this.data)
        } else if (!e && this.debugBody) {
            this.debugBody.destroy();
            this.debugBody = null
        }
    }
});
Object.defineProperty(Phaser.Physics.P2.Body.prototype, "collideWorldBounds", {
    get: function() {
        return this._collideWorldBounds
    },
    set: function(e) {
        if (e && !this._collideWorldBounds) {
            this._collideWorldBounds = true;
            this.updateCollisionMask()
        } else if (!e && this._collideWorldBounds) {
            this._collideWorldBounds = false;
            this.updateCollisionMask()
        }
    }
});
Phaser.Physics.P2.BodyDebug = function(e, t, n) {
    Phaser.Group.call(this, e);
    var r = {
        pixelsPerLengthUnit: 20,
        debugPolygons: false,
        lineWidth: 1,
        alpha: .5
    };
    this.settings = Phaser.Utils.extend(r, n);
    this.ppu = this.settings.pixelsPerLengthUnit;
    this.ppu = -1 * this.ppu;
    this.body = t;
    this.canvas = new Phaser.Graphics(e);
    this.canvas.alpha = this.settings.alpha;
    this.add(this.canvas);
    this.draw()
};
Phaser.Physics.P2.BodyDebug.prototype = Object.create(Phaser.Group.prototype);
Phaser.Physics.P2.BodyDebug.prototype.constructor = Phaser.Physics.P2.BodyDebug;
Phaser.Utils.extend(Phaser.Physics.P2.BodyDebug.prototype, {
    update: function() {
        this.updateSpriteTransform()
    },
    updateSpriteTransform: function() {
        this.position.x = this.body.position[0] * this.ppu;
        this.position.y = this.body.position[1] * this.ppu;
        return this.rotation = this.body.angle
    },
    draw: function() {
        var e, t, n, r, i, s, o, u, a, f, l, c, h, p, d;
        u = this.body;
        f = this.canvas;
        f.clear();
        n = parseInt(this.randomPastelHex(), 16);
        s = 16711680;
        o = this.lineWidth;
        if (u instanceof p2.Body && u.shapes.length) {
            var v = u.shapes.length;
            r = 0;
            while (r !== v) {
                t = u.shapes[r];
                a = u.shapeOffsets[r];
                e = u.shapeAngles[r];
                a = a || 0;
                e = e || 0;
                if (t instanceof p2.Circle) {
                    this.drawCircle(f, a[0] * this.ppu, a[1] * this.ppu, e, t.radius * this.ppu, n, o)
                } else if (t instanceof p2.Convex) {
                    c = [];
                    h = p2.vec2.create();
                    for (i = p = 0, d = t.vertices.length; 0 <= d ? p < d : p > d; i = 0 <= d ? ++p : --p) {
                        l = t.vertices[i];
                        p2.vec2.rotate(h, l, e);
                        c.push([(h[0] + a[0]) * this.ppu, -(h[1] + a[1]) * this.ppu])
                    }
                    this.drawConvex(f, c, t.triangles, s, n, o, this.settings.debugPolygons, [a[0] * this.ppu, -a[1] * this.ppu])
                } else if (t instanceof p2.Plane) {
                    this.drawPlane(f, a[0] * this.ppu, -a[1] * this.ppu, n, s, o * 5, o * 10, o * 10, this.ppu * 100, e)
                } else if (t instanceof p2.Line) {
                    this.drawLine(f, t.length * this.ppu, s, o)
                } else if (t instanceof p2.Rectangle) {
                    this.drawRectangle(f, a[0] * this.ppu, -a[1] * this.ppu, e, t.width * this.ppu, t.height * this.ppu, s, n, o)
                }
                r++
            }
        }
    },
    drawRectangle: function(e, t, n, r, i, s, o, u, a) {
        if (typeof a === "undefined") {
            a = 1
        }
        if (typeof o === "undefined") {
            o = 0
        }
        e.lineStyle(a, o, 1);
        e.beginFill(u);
        e.drawRect(t - i / 2, n - s / 2, i, s)
    },
    drawCircle: function(e, t, n, r, i, s, o) {
        if (typeof o === "undefined") {
            o = 1
        }
        if (typeof s === "undefined") {
            s = 16777215
        }
        e.lineStyle(o, 0, 1);
        e.beginFill(s, 1);
        e.drawCircle(t, n, -i);
        e.endFill();
        e.moveTo(t, n);
        e.lineTo(t + i * Math.cos(-r), n + i * Math.sin(-r))
    },
    drawLine: function(e, t, n, r) {
        if (typeof r === "undefined") {
            r = 1
        }
        if (typeof n === "undefined") {
            n = 0
        }
        e.lineStyle(r * 5, n, 1);
        e.moveTo(-t / 2, 0);
        e.lineTo(t / 2, 0)
    },
    drawConvex: function(e, t, n, r, i, s, o, u) {
        var a, f, l, c, h, p, d, v, m, g, y;
        if (typeof s === "undefined") {
            s = 1
        }
        if (typeof r === "undefined") {
            r = 0
        }
        if (!o) {
            e.lineStyle(s, r, 1);
            e.beginFill(i);
            f = 0;
            while (f !== t.length) {
                l = t[f];
                p = l[0];
                m = l[1];
                if (f === 0) {
                    e.moveTo(p, -m)
                } else {
                    e.lineTo(p, -m)
                }
                f++
            }
            e.endFill();
            if (t.length > 2) {
                e.moveTo(t[t.length - 1][0], -t[t.length - 1][1]);
                return e.lineTo(t[0][0], -t[0][1])
            }
        } else {
            a = [16711680, 65280, 255];
            f = 0;
            while (f !== t.length + 1) {
                c = t[f % t.length];
                h = t[(f + 1) % t.length];
                d = c[0];
                g = c[1];
                v = h[0];
                y = h[1];
                e.lineStyle(s, a[f % a.length], 1);
                e.moveTo(d, -g);
                e.lineTo(v, -y);
                e.drawCircle(d, -g, s * 2);
                f++
            }
            e.lineStyle(s, 0, 1);
            return e.drawCircle(u[0], u[1], s * 2)
        }
    },
    drawPath: function(e, t, n, r, i) {
        var s, o, u, a, f, l, c, h, p, d, v, m, g;
        if (typeof i === "undefined") {
            i = 1
        }
        if (typeof n === "undefined") {
            n = 0
        }
        e.lineStyle(i, n, 1);
        if (typeof r === "number") {
            e.beginFill(r)
        }
        u = null;
        a = null;
        o = 0;
        while (o < t.length) {
            v = t[o];
            m = v[0];
            g = v[1];
            if (m !== u || g !== a) {
                if (o === 0) {
                    e.moveTo(m, g)
                } else {
                    f = u;
                    l = a;
                    c = m;
                    h = g;
                    p = t[(o + 1) % t.length][0];
                    d = t[(o + 1) % t.length][1];
                    s = (c - f) * (d - l) - (p - f) * (h - l);
                    if (s !== 0) {
                        e.lineTo(m, g)
                    }
                }
                u = m;
                a = g
            }
            o++
        }
        if (typeof r === "number") {
            e.endFill()
        }
        if (t.length > 2 && typeof r === "number") {
            e.moveTo(t[t.length - 1][0], t[t.length - 1][1]);
            e.lineTo(t[0][0], t[0][1])
        }
    },
    drawPlane: function(e, t, n, r, i, s, o, u, a, f) {
        var l, c, h;
        if (typeof s === "undefined") {
            s = 1
        }
        if (typeof r === "undefined") {
            r = 16777215
        }
        e.lineStyle(s, i, 11);
        e.beginFill(r);
        l = a;
        e.moveTo(t, -n);
        c = t + Math.cos(f) * this.game.width;
        h = n + Math.sin(f) * this.game.height;
        e.lineTo(c, -h);
        e.moveTo(t, -n);
        c = t + Math.cos(f) * -this.game.width;
        h = n + Math.sin(f) * -this.game.height;
        e.lineTo(c, -h)
    },
    randomPastelHex: function() {
        var e, t, n, r;
        n = [255, 255, 255];
        r = Math.floor(Math.random() * 256);
        t = Math.floor(Math.random() * 256);
        e = Math.floor(Math.random() * 256);
        r = Math.floor((r + 3 * n[0]) / 4);
        t = Math.floor((t + 3 * n[1]) / 4);
        e = Math.floor((e + 3 * n[2]) / 4);
        return this.rgbToHex(r, t, e)
    },
    rgbToHex: function(e, t, n) {
        return this.componentToHex(e) + this.componentToHex(t) + this.componentToHex(n)
    },
    componentToHex: function(e) {
        var t;
        t = e.toString(16);
        if (t.len === 2) {
            return t
        } else {
            return t + "0"
        }
    }
});
Phaser.Physics.P2.Spring = function(e, t, n, r, i, s, o, u, a, f) {
    this.game = e.game;
    this.world = e;
    if (typeof r === "undefined") {
        r = 1
    }
    if (typeof i === "undefined") {
        i = 100
    }
    if (typeof s === "undefined") {
        s = 1
    }
    r = e.pxm(r);
    var l = {
        restLength: r,
        stiffness: i,
        damping: s
    };
    if (typeof o !== "undefined" && o !== null) {
        l.worldAnchorA = [e.pxm(o[0]), e.pxm(o[1])]
    }
    if (typeof u !== "undefined" && u !== null) {
        l.worldAnchorB = [e.pxm(u[0]), e.pxm(u[1])]
    }
    if (typeof a !== "undefined" && a !== null) {
        l.localAnchorA = [e.pxm(a[0]), e.pxm(a[1])]
    }
    if (typeof f !== "undefined" && f !== null) {
        l.localAnchorB = [e.pxm(f[0]), e.pxm(f[1])]
    }
    p2.Spring.call(this, t, n, l)
};
Phaser.Physics.P2.Spring.prototype = Object.create(p2.Spring.prototype);
Phaser.Physics.P2.Spring.prototype.constructor = Phaser.Physics.P2.Spring;
Phaser.Physics.P2.Material = function(e) {
    this.name = e;
    p2.Material.call(this)
};
Phaser.Physics.P2.Material.prototype = Object.create(p2.Material.prototype);
Phaser.Physics.P2.Material.prototype.constructor = Phaser.Physics.P2.Material;
Phaser.Physics.P2.ContactMaterial = function(e, t, n) {
    p2.ContactMaterial.call(this, e, t, n)
};
Phaser.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype);
Phaser.Physics.P2.ContactMaterial.prototype.constructor = Phaser.Physics.P2.ContactMaterial;
Phaser.Physics.P2.CollisionGroup = function(e) {
    this.mask = e
};
Phaser.Physics.P2.DistanceConstraint = function(e, t, n, r, i) {
    if (typeof r === "undefined") {
        r = 100
    }
    this.game = e.game;
    this.world = e;
    r = e.pxm(r);
    p2.DistanceConstraint.call(this, t, n, r, {
        maxForce: i
    })
};
Phaser.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype);
Phaser.Physics.P2.DistanceConstraint.prototype.constructor = Phaser.Physics.P2.DistanceConstraint;
Phaser.Physics.P2.GearConstraint = function(e, t, n, r, i) {
    if (typeof r === "undefined") {
        r = 0
    }
    if (typeof i === "undefined") {
        i = 1
    }
    this.game = e.game;
    this.world = e;
    var s = {
        angle: r,
        ratio: i
    };
    p2.GearConstraint.call(this, t, n, s)
};
Phaser.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype);
Phaser.Physics.P2.GearConstraint.prototype.constructor = Phaser.Physics.P2.GearConstraint;
Phaser.Physics.P2.LockConstraint = function(e, t, n, r, i, s) {
    if (typeof r === "undefined") {
        r = [0, 0]
    }
    if (typeof i === "undefined") {
        i = 0
    }
    if (typeof s === "undefined") {
        s = Number.MAX_VALUE
    }
    this.game = e.game;
    this.world = e;
    r = [e.pxm(r[0]), e.pxm(r[1])];
    var o = {
        localOffsetB: r,
        localAngleB: i,
        maxForce: s
    };
    p2.LockConstraint.call(this, t, n, o)
};
Phaser.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype);
Phaser.Physics.P2.LockConstraint.prototype.constructor = Phaser.Physics.P2.LockConstraint;
Phaser.Physics.P2.PrismaticConstraint = function(e, t, n, r, i, s, o, u) {
    if (typeof r === "undefined") {
        r = true
    }
    if (typeof i === "undefined") {
        i = [0, 0]
    }
    if (typeof s === "undefined") {
        s = [0, 0]
    }
    if (typeof o === "undefined") {
        o = [0, 0]
    }
    if (typeof u === "undefined") {
        u = Number.MAX_VALUE
    }
    this.game = e.game;
    this.world = e;
    i = [e.pxmi(i[0]), e.pxmi(i[1])];
    s = [e.pxmi(s[0]), e.pxmi(s[1])];
    var a = {
        localAnchorA: i,
        localAnchorB: s,
        localAxisA: o,
        maxForce: u,
        disableRotationalLock: !r
    };
    p2.PrismaticConstraint.call(this, t, n, a)
};
Phaser.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype);
Phaser.Physics.P2.PrismaticConstraint.prototype.constructor = Phaser.Physics.P2.PrismaticConstraint;
Phaser.Physics.P2.RevoluteConstraint = function(e, t, n, r, i, s) {
    if (typeof s === "undefined") {
        s = Number.MAX_VALUE
    }
    this.game = e.game;
    this.world = e;
    n = [e.pxmi(n[0]), e.pxmi(n[1])];
    i = [e.pxmi(i[0]), e.pxmi(i[1])];
    p2.RevoluteConstraint.call(this, t, n, r, i, {
        maxForce: s
    })
};
Phaser.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype);
Phaser.Physics.P2.RevoluteConstraint.prototype.constructor = Phaser.Physics.P2.RevoluteConstraint