var cc = cc || {};
_p = window;
_p = Object.prototype;
delete window._p;
cc._isNodeJs = "undefined" !== typeof require && require("fs");
cc.each = function (a, b, c) {
    if (a)
        if (a instanceof Array)
            for (var d = 0, e = a.length; d < e && !1 !== b.call(c, a[d], d); d++);
        else
            for (d in a)
                if (!1 === b.call(c, a[d], d)) break
};
cc.async = {
    _counterFunc: function (a) {
        var b = this.counter;
        if (!b.err) {
            var c = b.length,
                d = b.results,
                e = b.option,
                f = e.cb,
                g = e.cbTarget,
                h = e.trigger,
                e = e.triggerTarget;
            if (a) {
                if (b.err = a, f) return f.call(g, a)
            } else {
                var k = Array.apply(null, arguments).slice(1),
                    m = k.length;
                0 == m ? k = null : 1 == m && (k = k[0]);
                d[this.index] = k;
                b.count--;
                h && h.call(e, k, c - b.count, c);
                0 == b.count && f && f.apply(g, [null, d])
            }
        }
    },
    _emptyFunc: function () {},
    parallel: function (a, b, c) {
        var d = cc.async,
            e = arguments.length;
        if (3 == e) "function" == typeof b && (b = {
                trigger: b
            }), b.cb =
            c || b.cb;
        else if (2 == e) "function" == typeof b && (b = {
            cb: b
        });
        else if (1 == e) b = {};
        else throw "arguments error!";
        var f = (e = a instanceof Array) ? a.length : Object.keys(a).length;
        if (0 == f) b.cb && b.cb.call(b.cbTarget, null);
        else {
            var g = {
                length: f,
                count: f,
                option: b,
                results: e ? [] : {}
            };
            cc.each(a, function (a, c) {
                if (g.err) return !1;
                var e = b.cb || b.trigger ? d._counterFunc.bind({
                    counter: g,
                    index: c
                }) : d._emptyFunc;
                a(e, c)
            })
        }
    },
    map: function (a, b, c) {
        var d = this,
            e = arguments.length;
        "function" == typeof b && (b = {
            iterator: b
        });
        if (3 == e) b.cb = c || b.cb;
        else if (2 !=
            e) throw "arguments error!";
        var f = (e = a instanceof Array) ? a.length : Object.keys(a).length;
        if (0 == f) b.cb && b.cb.call(b.cbTarget, null);
        else {
            var g = {
                length: f,
                count: f,
                option: b,
                results: e ? [] : {}
            };
            cc.each(a, function (a, c) {
                if (g.err) return !1;
                var e = b.cb ? d._counterFunc.bind({
                    counter: g,
                    index: c
                }) : d._emptyFunc;
                b.iterator.call(b.iteratorTarget, a, c, e)
            })
        }
    }
};
cc.path = {
    join: function () {
        for (var a = arguments.length, b = "", c = 0; c < a; c++) b = (b + ("" == b ? "" : "/") + arguments[c]).replace(/(\/|\\\\)$/, "");
        return b
    },
    extname: function (a) {
        return (a = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(a)) ? a[1] : null
    },
    basename: function (a, b) {
        var c = a.indexOf("?");
        0 < c && (a = a.substring(0, c));
        c = /(\/|\\\\)([^(\/|\\\\)]+)$/g.exec(a.replace(/(\/|\\\\)$/, ""));
        if (!c) return null;
        c = c[2];
        return b && a.substring(a.length - b.length).toLowerCase() == b.toLowerCase() ? c.substring(0, c.length - b.length) : c
    },
    dirname: function (a) {
        return a.replace(/(\/|\\\\)$/,
            "").replace(/(\/|\\\\)[^(\/|\\\\)]+$/, "")
    },
    changeExtname: function (a, b) {
        b = b || "";
        var c = a.indexOf("?"),
            d = "";
        0 < c && (d = a.substring(c), a = a.substring(0, c));
        c = a.lastIndexOf(".");
        return 0 > c ? a + b + d : a.substring(0, c) + b + d
    },
    changeBasename: function (a, b, c) {
        if (0 == b.indexOf(".")) return this.changeExtname(a, b);
        var d = a.indexOf("?"),
            e = "";
        c = c ? this.extname(a) : "";
        0 < d && (e = a.substring(d), a = a.substring(0, d));
        d = a.lastIndexOf("/");
        return a.substring(0, 0 >= d ? 0 : d + 1) + b + c + e
    }
};
var Uint8Array = Uint8Array || Array;
if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
    var IEBinaryToArray_ByteStr_Script = '\x3c!-- IEBinaryToArray_ByteStr --\x3e\r\nFunction IEBinaryToArray_ByteStr(Binary)\r\n   IEBinaryToArray_ByteStr \x3d CStr(Binary)\r\nEnd Function\r\nFunction IEBinaryToArray_ByteStr_Last(Binary)\r\n   Dim lastIndex\r\n   lastIndex \x3d LenB(Binary)\r\n   if lastIndex mod 2 Then\r\n       IEBinaryToArray_ByteStr_Last \x3d Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n   Else\r\n       IEBinaryToArray_ByteStr_Last \x3d ""\r\n   End If\r\nEnd Function\r\n',
        myVBScript = document.createElement("script");
    myVBScript.type = "text/vbscript";
    myVBScript.textContent = IEBinaryToArray_ByteStr_Script;
    document.body.appendChild(myVBScript);
    cc._convertResponseBodyToText = function (a) {
        for (var b = {}, c = 0; 256 > c; c++)
            for (var d = 0; 256 > d; d++) b[String.fromCharCode(c + 256 * d)] = String.fromCharCode(c) + String.fromCharCode(d);
        c = IEBinaryToArray_ByteStr(a);
        a = IEBinaryToArray_ByteStr_Last(a);
        return c.replace(/[\s\S]/g, function (a) {
            return b[a]
        }) + a
    }
}
cc.loader = {
    _jsCache: {},
    _register: {},
    _langPathCache: {},
    _aliases: {},
    resPath: "",
    audioPath: "",
    cache: {},
    getXMLHttpRequest: function () {
        return window.XMLHttpRequest ? new window.XMLHttpRequest : new ActiveXObject("MSXML2.XMLHTTP")
    },
    _getArgs4Js: function (a) {
        var b = a[0],
            c = a[1],
            d = a[2],
            e = ["", null, null];
        if (1 == a.length) e[1] = b instanceof Array ? b : [b];
        else if (2 == a.length) "function" == typeof c ? (e[1] = b instanceof Array ? b : [b], e[2] = c) : (e[0] = b || "", e[1] = c instanceof Array ? c : [c]);
        else if (3 == a.length) e[0] = b || "", e[1] = c instanceof
        Array ? c : [c], e[2] = d;
        else throw "arguments error to load js!";
        return e
    },
    loadJs: function (a, b, c) {
        var d = this,
            e = d._jsCache,
            f = d._getArgs4Js(arguments); - 1 < navigator.userAgent.indexOf("Trident/5") ? d._loadJs4Dependency(f[0], f[1], 0, f[2]) : cc.async.map(f[1], function (a, b, c) {
            a = cc.path.join(f[0], a);
            if (e[a]) return c(null);
            d._createScript(a, !1, c)
        }, f[2])
    },
    loadJsWithImg: function (a, b, c) {
        var d = this._loadJsImg(),
            e = this._getArgs4Js(arguments);
        this.loadJs(e[0], e[1], function (a) {
            if (a) throw a;
            d.parentNode.removeChild(d);
            if (e[2]) e[2]()
        })
    },
    _createScript: function (a, b, c) {
        var d = document,
            e = d.createElement("script");
        e.async = b;
        e.src = a;
        this._jsCache[a] = !0;
        e.addEventListener("load", function () {
            this.removeEventListener("load", arguments.callee, !1);
            c()
        }, !1);
        e.addEventListener("error", function () {
            c("Load " + a + " failed!")
        }, !1);
        d.body.appendChild(e)
    },
    _loadJs4Dependency: function (a, b, c, d) {
        if (c >= b.length) d && d();
        else {
            var e = this;
            e._createScript(cc.path.join(a, b[c]), !1, function (f) {
                if (f) return d(f);
                e._loadJs4Dependency(a, b, c + 1, d)
            })
        }
    },
    _loadJsImg: function () {
        var a =
            document,
            b = a.getElementById("cocos2d_loadJsImg");
        if (!b) {
            b = a.createElement("img");
            b.src = "data:image/gif;base64,R0lGODlhEAAQALMNAD8/P7+/vyoqKlVVVX9/fxUVFUBAQGBgYMDAwC8vL5CQkP///wAAAP///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFAAANACwAAAAAEAAQAAAEO5DJSau9OOvNex0IMnDIsiCkiW6g6BmKYlBFkhSUEgQKlQCARG6nEBwOgl+QApMdCIRD7YZ5RjlGpCUCACH5BAUAAA0ALAAAAgAOAA4AAAQ6kLGB0JA4M7QW0hrngRllkYyhKAYqKUGguAws0ypLS8JxCLQDgXAIDg+FRKIA6v0SAECCBpXSkstMBAAh+QQFAAANACwAAAAACgAQAAAEOJDJORAac6K1kDSKYmydpASBUl0mqmRfaGTCcQgwcxDEke+9XO2WkxQSiUIuAQAkls0n7JgsWq8RACH5BAUAAA0ALAAAAAAOAA4AAAQ6kMlplDIzTxWC0oxwHALnDQgySAdBHNWFLAvCukc215JIZihVIZEogDIJACBxnCSXTcmwGK1ar1hrBAAh+QQFAAANACwAAAAAEAAKAAAEN5DJKc4RM+tDyNFTkSQF5xmKYmQJACTVpQSBwrpJNteZSGYoFWjIGCAQA2IGsVgglBOmEyoxIiMAIfkEBQAADQAsAgAAAA4ADgAABDmQSVZSKjPPBEDSGucJxyGA1XUQxAFma/tOpDlnhqIYN6MEAUXvF+zldrMBAjHoIRYLhBMqvSmZkggAIfkEBQAADQAsBgAAAAoAEAAABDeQyUmrnSWlYhMASfeFVbZdjHAcgnUQxOHCcqWylKEohqUEAYVkgEAMfkEJYrFA6HhKJsJCNFoiACH5BAUAAA0ALAIAAgAOAA4AAAQ3kMlJq704611SKloCAEk4lln3DQgyUMJxCBKyLAh1EMRR3wiDQmHY9SQslyIQUMRmlmVTIyRaIgA7";
            a = a.getElementById(cc.game.config.id);
            a.style.backgroundColor = "black";
            a.parentNode.appendChild(b);
            var c = getComputedStyle ? getComputedStyle(a) : a.currentStyle;
            b.style.left = a.offsetLeft + (parseFloat(c.width) - b.width) / 2 + "px";
            b.style.top = a.offsetTop + (parseFloat(c.height) - b.height) / 2 + "px";
            b.style.position = "absolute"
        }
        return b
    },
    loadTxt: function (a, b) {
        if (cc._isNodeJs) require("fs").readFile(a, function (a, c) {
            a ? b(a) : b(null, c.toString())
        });
        else {
            var c = this.getXMLHttpRequest(),
                d = "load " + a + " failed!";
            c.open("GET", a, !0);
            /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (c.setRequestHeader("Accept-Charset", "utf-8"), c.onreadystatechange = function () {
                4 == c.readyState && 200 == c.status ? b(null, c.responseText) : b(d)
            }) : (c.overrideMimeType && c.overrideMimeType("text/plain; charset\x3dutf-8"), c.onload = function () {
                4 == c.readyState && 200 == c.status ? b(null, c.responseText) : b(d)
            });
            c.send(null)
        }
    },
    _loadTxtSync: function (a) {
        if (cc._isNodeJs) return require("fs").readFileSync(a).toString();
        var b = this.getXMLHttpRequest();
        b.open("GET", a, !1);
        /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? b.setRequestHeader("Accept-Charset", "utf-8") : b.overrideMimeType && b.overrideMimeType("text/plain; charset\x3dutf-8");
        b.send(null);
        return 4 == !b.readyState || 200 != b.status ? null : b.responseText
    },
    loadJson: function (a, b) {
        this.loadTxt(a, function (a, d) {
            try {
                a ? b(a) : b(null, JSON.parse(d))
            } catch (e) {
                throw e;
            }
        })
    },
    loadImg: function (a, b, c) {
        var d = arguments.length,
            e = !0;
        3 == d ? e = null == b.isCrossOrigin ? e : b.isCrossOrigin : 2 == d && (c = b);
        var f =
            new Image;
        e && (f.crossOrigin = "Anonymous");
        f.addEventListener("load", function () {
            this.removeEventListener("load", arguments.callee, !1);
            this.removeEventListener("error", arguments.callee, !1);
            c && c(null, f)
        });
        f.addEventListener("error", function () {
            this.removeEventListener("error", arguments.callee, !1);
            c && c("load image failed")
        });
        f.src = a;
        return f
    },
    _str2Uint8Array: function (a) {
        if (!a) return null;
        for (var b = new Uint8Array(a.length), c = 0; c < a.length; c++) b[c] = a.charCodeAt(c) & 255;
        return b
    },
    loadBinary: function (a, b) {
        var c =
            this,
            d = this.getXMLHttpRequest(),
            e = "load " + a + " failed!";
        d.open("GET", a, !0);
        /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (d.setRequestHeader("Accept-Charset", "x-user-defined"), d.onreadystatechange = function () {
            if (4 == d.readyState && 200 == d.status) {
                var a = cc._convertResponseBodyToText(d.responseBody);
                b(null, c._str2Uint8Array(a))
            } else b(e)
        }) : (d.overrideMimeType && d.overrideMimeType("text/plain; charset\x3dx-user-defined"), d.onload = function () {
            4 == d.readyState && 200 == d.status ? b(null, c._str2Uint8Array(d.responseText)) :
                b(e)
        });
        d.send(null)
    },
    loadBinarySync: function (a) {
        var b = this.getXMLHttpRequest(),
            c = "load " + a + " failed!";
        b.open("GET", a, !1);
        a = null;
        if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
            b.setRequestHeader("Accept-Charset", "x-user-defined");
            b.send(null);
            if (200 != b.status) return cc.log(c), null;
            (b = cc._convertResponseBodyToText(b.responseBody)) && (a = this._str2Uint8Array(b))
        } else {
            b.overrideMimeType && b.overrideMimeType("text/plain; charset\x3dx-user-defined");
            b.send(null);
            if (200 != b.status) return cc.log(c),
                null;
            a = this._str2Uint8Array(b.responseText)
        }
        return a
    },
    _loadResIterator: function (a, b, c) {
        var d = this,
            e = null,
            f = a.type;
        f ? (f = "." + f.toLowerCase(), e = a.name + f) : (e = a, f = cc.path.extname(e));
        if (b = d.cache[e]) return c(null, b);
        b = d._register[f.toLowerCase()];
        if (!b) return c("loader for [" + f + "] not exists!");
        f = b.getBasePath ? b.getBasePath() : d.resPath;
        f = d.getUrl(f, e);
        b.load(f, e, a, function (a, b) {
            a ? (cc.log(a), d.cache[e] = null, c()) : (d.cache[e] = b, c(null, b))
        })
    },
    getUrl: function (a, b) {
        var c = this._langPathCache,
            d = cc.path;
        if (1 ==
            arguments.length) {
            b = a;
            var e = d.extname(b),
                e = e ? e.toLowerCase() : "";
            a = (e = this._register[e]) ? e.getBasePath ? e.getBasePath() : this.resPath : this.resPath
        }
        b = cc.path.join(a || "", b);
        if (b.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
            if (c[b]) return c[b];
            d = d.extname(b) || "";
            b = c[b] = b.substring(0, b.length - d.length) + "_" + cc.sys.language + d
        }
        return b
    },
    load: function (a, b, c) {
        var d = arguments.length;
        if (3 == d) "function" == typeof b && (b = {
            trigger: b
        });
        else if (2 == d) "function" == typeof b && (c = b, b = {});
        else if (1 == d) b = {};
        else throw "arguments error!";
        b.cb = function (a, b) {
            a && cc.log(a);
            c && c(b)
        };
        a instanceof Array || (a = [a]);
        b.iterator = this._loadResIterator;
        b.iteratorTarget = this;
        cc.async.map(a, b)
    },
    _handleAliases: function (a, b) {
        var c = this._aliases,
            d = [],
            e;
        for (e in a) {
            var f = a[e];
            c[e] = f;
            d.push(f)
        }
        this.load(d, b)
    },
    loadAliases: function (a, b) {
        var c = this,
            d = c.getRes(a);
        d ? c._handleAliases(d.filenames, b) : c.load(a, function (a) {
            c._handleAliases(a[0].filenames, b)
        })
    },
    register: function (a, b) {
        if (a && b) {
            if ("string" == typeof a) return this._register[a.trim().toLowerCase()] = b;
            for (var c = 0, d = a.length; c < d; c++) this._register["." + a[c].trim().toLowerCase()] = b
        }
    },
    getRes: function (a) {
        return this.cache[a] || this.cache[this._aliases[a]]
    },
    release: function (a) {
        var b = this.cache,
            c = this._aliases;
        delete b[a];
        delete b[c[a]];
        delete c[a]
    },
    releaseAll: function () {
        var a = this.cache,
            b = this._aliases,
            c;
        for (c in a) delete a[c];
        for (c in b) delete b[c]
    }
};
(function () {
    var a = window,
        b, c;
    "undefined" !== typeof document.hidden ? (b = "hidden", c = "visibilitychange") : "undefined" !== typeof document.mozHidden ? (b = "mozHidden", c = "mozvisibilitychange") : "undefined" !== typeof document.msHidden ? (b = "msHidden", c = "msvisibilitychange") : "undefined" !== typeof document.webkitHidden && (b = "webkitHidden", c = "webkitvisibilitychange");
    var d = function () {
            cc.eventManager && cc.eventManager.dispatchEvent(cc.game._eventHide)
        },
        e = function () {
            cc.eventManager && cc.eventManager.dispatchEvent(cc.game._eventShow)
        };
    "undefined" !== typeof document.addEventListener && b ? document.addEventListener(c, function () {
        document[b] ? d() : e()
    }, !1) : (a.addEventListener("blur", d, !1), a.addEventListener("focus", e, !1));
    c = a = null
})();
cc._logToWebPage = function (a) {
    if (cc._canvas) {
        var b = cc._logList,
            c = document;
        if (!b) {
            var d = c.createElement("Div"),
                b = d.style;
            d.setAttribute("id", "logInfoDiv");
            cc._canvas.parentNode.appendChild(d);
            d.setAttribute("width", "200");
            d.setAttribute("height", cc._canvas.height);
            b.zIndex = "99999";
            b.position = "absolute";
            b.top = "0";
            b.left = "0";
            b = cc._logList = c.createElement("textarea");
            c = b.style;
            b.setAttribute("rows", "20");
            b.setAttribute("cols", "30");
            b.setAttribute("disabled", !0);
            d.appendChild(b);
            c.backgroundColor = "transparent";
            c.borderBottom = "1px solid #cccccc";
            c.borderRightWidth = "0px";
            c.borderLeftWidth = "0px";
            c.borderTopWidth = "0px";
            c.borderTopStyle = "none";
            c.borderRightStyle = "none";
            c.borderLeftStyle = "none";
            c.padding = "0px";
            c.margin = 0
        }
        a = "string" == typeof a ? a : JSON.stringify(a);
        b.value = b.value + a + "\r\n";
        b.scrollTop = b.scrollHeight
    }
};
console.log ? (cc.log = console.log.bind(console), cc.warn = console.warn.bind(console), cc.error = console.error.bind(console), cc.assert = console.assert.bind(console)) : cc.log = cc.warn = cc.error = cc.assert = function () {};
cc._initDebugSetting = function (a) {
    var b = cc.game;
    a == b.DEBUG_MODE_INFO && console.log || (cc.log = a == b.DEBUG_MODE_INFO && !console.log || a == b.DEBUG_MODE_INFO_FOR_WEB_PAGE ? cc._logToWebPage.bind(cc) : function () {});
    a && a != b.DEBUG_MODE_NONE && a != b.DEBUG_MODE_ERROR && a != b.DEBUG_MODE_ERROR_FOR_WEB_PAGE ? a != b.DEBUG_MODE_INFO_FOR_WEB_PAGE && a != b.DEBUG_MODE_WARN_FOR_WEB_PAGE && console.warn || (cc.warn = cc._logToWebPage.bind(cc)) : cc.warn = function () {};
    a && a != b.DEBUG_MODE_NONE ? a != b.DEBUG_MODE_INFO_FOR_WEB_PAGE && a != b.DEBUG_MODE_WARN_FOR_WEB_PAGE &&
        a != b.DEBUG_MODE_ERROR_FOR_WEB_PAGE && console.error || (cc.error = cc._logToWebPage.bind(cc), cc.assert = function (a, b) {
            !a && b && cc._logToWebPage(b)
        }) : (cc.error = function () {}, cc.assert = function () {})
};
cc.create3DContext = function (a, b) {
    for (var c = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"], d = null, e = 0; e < c.length; ++e) {
        try {
            d = a.getContext(c[e], b)
        } catch (f) {}
        if (d) break
    }
    return d
};
cc._initSys = function (a, b) {
    cc._RENDER_TYPE_CANVAS = 0;
    cc._RENDER_TYPE_WEBGL = 1;
    var c = cc.sys = {};
    c.LANGUAGE_ENGLISH = "en";
    c.LANGUAGE_CHINESE = "zh";
    c.LANGUAGE_FRENCH = "fr";
    c.LANGUAGE_ITALIAN = "it";
    c.LANGUAGE_GERMAN = "de";
    c.LANGUAGE_SPANISH = "es";
    c.LANGUAGE_RUSSIAN = "ru";
    c.LANGUAGE_KOREAN = "ko";
    c.LANGUAGE_JAPANESE = "ja";
    c.LANGUAGE_HUNGARIAN = "hu";
    c.LANGUAGE_PORTUGUESE = "pt";
    c.LANGUAGE_ARABIC = "ar";
    c.LANGUAGE_NORWEGIAN = "no";
    c.LANGUAGE_POLISH = "pl";
    c.OS_WINDOWS = "Windows";
    c.OS_IOS = "iOS";
    c.OS_OSX = "OS X";
    c.OS_UNIX = "UNIX";
    c.OS_LINUX = "Linux";
    c.OS_ANDROID = "Android";
    c.OS_UNKNOWN = "Unknown";
    c.BROWSER_TYPE_WECHAT = "wechat";
    c.BROWSER_TYPE_ANDROID = "androidbrowser";
    c.BROWSER_TYPE_IE = "ie";
    c.BROWSER_TYPE_QQ = "qqbrowser";
    c.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser";
    c.BROWSER_TYPE_UC = "ucbrowser";
    c.BROWSER_TYPE_360 = "360browser";
    c.BROWSER_TYPE_BAIDU_APP = "baiduboxapp";
    c.BROWSER_TYPE_BAIDU = "baidubrowser";
    c.BROWSER_TYPE_MAXTHON = "maxthon";
    c.BROWSER_TYPE_OPERA = "opera";
    c.BROWSER_TYPE_MIUI = "miuibrowser";
    c.BROWSER_TYPE_FIREFOX = "firefox";
    c.BROWSER_TYPE_SAFARI =
        "safari";
    c.BROWSER_TYPE_CHROME = "chrome";
    c.BROWSER_TYPE_UNKNOWN = "unknown";
    c.isNative = !1;
    var d = [c.BROWSER_TYPE_BAIDU, c.BROWSER_TYPE_OPERA, c.BROWSER_TYPE_FIREFOX, c.BROWSER_TYPE_CHROME, c.BROWSER_TYPE_SAFARI],
        e = [c.BROWSER_TYPE_BAIDU, c.BROWSER_TYPE_OPERA, c.BROWSER_TYPE_FIREFOX, c.BROWSER_TYPE_CHROME, c.BROWSER_TYPE_SAFARI, c.BROWSER_TYPE_UC, c.BROWSER_TYPE_QQ, c.BROWSER_TYPE_MOBILE_QQ, c.BROWSER_TYPE_IE],
        f = window,
        g = f.navigator,
        h = document.documentElement,
        k = g.userAgent.toLowerCase();
    c.isMobile = -1 != k.indexOf("mobile") ||
        -1 != k.indexOf("android");
    var m = g.language,
        m = (m = m ? m : g.browserLanguage) ? m.split("-")[0] : c.LANGUAGE_ENGLISH;
    c.language = m;
    var m = c.BROWSER_TYPE_UNKNOWN,
        n = k.match(/micromessenger|qqbrowser|mqqbrowser|ucbrowser|360browser|baiduboxapp|baidubrowser|maxthon|trident|opera|miuibrowser|firefox/i) || k.match(/chrome|safari/i);
    n && 0 < n.length && (m = n[0].toLowerCase(), "micromessenger" == m ? m = c.BROWSER_TYPE_WECHAT : "safari" === m && k.match(/android.*applewebkit/) ? m = c.BROWSER_TYPE_ANDROID : "trident" == m && (m = c.BROWSER_TYPE_IE));
    c.browserType = m;
    c._supportMultipleAudio = -1 < e.indexOf(c.browserType);
    e = parseInt(a[b.renderMode]);
    m = cc._RENDER_TYPE_WEBGL;
    n = document.createElement("Canvas");
    cc._supportRender = !0;
    d = -1 == d.indexOf(c.browserType);
    if (1 === e || 0 === e && (c.isMobile || d)) m = cc._RENDER_TYPE_CANVAS;
    m != cc._RENDER_TYPE_WEBGL || f.WebGLRenderingContext && cc.create3DContext(n, {
        stencil: !0,
        preserveDrawingBuffer: !0
    }) || (0 == e ? m = cc._RENDER_TYPE_CANVAS : cc._supportRender = !1);
    if (m == cc._RENDER_TYPE_CANVAS) try {
        n.getContext("2d")
    } catch (p) {
        cc._supportRender = !1
    }
    cc._renderType = m;
    try {
        c._supportWebAudio = !!new(f.AudioContext || f.webkitAudioContext || f.mozAudioContext)
    } catch (r) {
        c._supportWebAudio = !1
    }
    try {
        var q = c.localStorage = f.localStorage;
        q.setItem("storage", "");
        q.removeItem("storage");
        q = null
    } catch (s) {
        "SECURITY_ERR" !== s.name && "QuotaExceededError" !== s.name || cc.warn("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option"), c.localStorage = function () {}
    }
    q = c.capabilities = {
        canvas: !0
    };
    cc._renderType == cc._RENDER_TYPE_WEBGL && (q.opengl = !0);
    void 0 !== h.ontouchstart || g.msPointerEnabled ? q.touches = !0 : void 0 !== h.onmouseup && (q.mouse = !0);
    void 0 !== h.onkeyup && (q.keyboard = !0);
    if (f.DeviceMotionEvent || f.DeviceOrientationEvent) q.accelerometer = !0;
    f = k.match(/(iPad|iPhone|iPod)/i) ? !0 : !1;
    k = k.match(/android/i) || g.platform.match(/android/i) ? !0 : !1;
    h = c.OS_UNKNOWN; - 1 != g.appVersion.indexOf("Win") ? h = c.OS_WINDOWS : f ? h = c.OS_IOS : -1 != g.appVersion.indexOf("Mac") ? h = c.OS_OSX : -1 != g.appVersion.indexOf("X11") ? h = c.OS_UNIX : -1 != g.appVersion.indexOf("Linux") ? h = c.OS_LINUX :
        k && (h = c.OS_ANDROID);
    c.os = h;
    c.garbageCollect = function () {};
    c.dumpRoot = function () {};
    c.restartVM = function () {};
    c.dump = function () {
        var a;
        a = "" + ("isMobile : " + this.isMobile + "\r\n");
        a += "language : " + this.language + "\r\n";
        a += "browserType : " + this.browserType + "\r\n";
        a += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n";
        a += "os : " + this.os + "\r\n";
        cc.log(a)
    }
};
cc.ORIENTATION_PORTRAIT = 0;
cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1;
cc.ORIENTATION_LANDSCAPE_LEFT = 2;
cc.ORIENTATION_LANDSCAPE_RIGHT = 3;
cc._drawingUtil = null;
cc._renderContext = null;
cc._canvas = null;
cc._gameDiv = null;
cc._rendererInitialized = !1;
cc._setup = function (a, b, c) {
    var d = window;
    d.requestAnimFrame = d.requestAnimationFrame || d.webkitRequestAnimationFrame || d.mozRequestAnimationFrame || d.oRequestAnimationFrame || d.msRequestAnimationFrame;
    var e = cc.$(a) || cc.$("#" + a),
        f;
    "CANVAS" == e.tagName ? (b = b || e.width, c = c || e.height, f = cc.container = cc.$new("DIV"), a = cc._canvas = e, a.parentNode.insertBefore(f, a), a.appendTo(f), f.setAttribute("id", "Cocos2dGameContainer")) : ("DIV" != e.tagName && cc.log("Warning: target element is not a DIV or CANVAS"), b = b || e.clientWidth,
        c = c || e.clientHeight, f = cc.container = e, a = cc._canvas = cc.$new("CANVAS"), e.appendChild(a));
    a.addClass("gameCanvas");
    a.setAttribute("width", b || 480);
    a.setAttribute("height", c || 320);
    e = f.style;
    e.width = (b || 480) + "px";
    e.height = (c || 320) + "px";
    e.margin = "0 auto";
    e.position = "relative";
    e.overflow = "hidden";
    f.top = "100%";
    cc._renderType == cc._RENDER_TYPE_WEBGL && (cc._renderContext = cc.webglContext = cc.create3DContext(a, {
        stencil: !0,
        preserveDrawingBuffer: !0,
        antialias: !cc.sys.isMobile,
        alpha: !1
    }));
    cc._renderContext ? (d.gl = cc._renderContext,
        cc._drawingUtil = new cc.DrawingPrimitiveWebGL(cc._renderContext), cc._rendererInitialized = !0, cc.textureCache._initializingRenderer(), cc.shaderCache._init()) : (cc._renderContext = a.getContext("2d"), cc._mainRenderContextBackup = cc._renderContext, cc._renderContext.translate(0, a.height), cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(cc._renderContext) : null);
    cc._gameDiv = f;
    cc.log(cc.ENGINE_VERSION);
    cc._setContextMenuEnable(!1);
    cc.sys.isMobile && (b = document.createElement("style"), b.type =
        "text/css", document.body.appendChild(b), b.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}");
    cc.view = cc.EGLView._getInstance();
    cc.inputManager.registerSystemEvent(cc._canvas);
    cc.director = cc.Director._getInstance();
    cc.director.setOpenGLView(cc.view);
    cc.winSize = cc.director.getWinSize();
    cc.saxParser = new cc.SAXParser;
    cc.plistParser = new cc.PlistParser
};
cc._isContextMenuEnable = !1;
cc._setContextMenuEnable = function (a) {
    cc._isContextMenuEnable = a;
    cc._canvas.oncontextmenu = function () {
        if (!cc._isContextMenuEnable) return !1
    }
};
cc.game = {
    DEBUG_MODE_NONE: 0,
    DEBUG_MODE_INFO: 1,
    DEBUG_MODE_WARN: 2,
    DEBUG_MODE_ERROR: 3,
    DEBUG_MODE_INFO_FOR_WEB_PAGE: 4,
    DEBUG_MODE_WARN_FOR_WEB_PAGE: 5,
    DEBUG_MODE_ERROR_FOR_WEB_PAGE: 6,
    EVENT_HIDE: "game_on_hide",
    EVENT_SHOW: "game_on_show",
    _eventHide: null,
    _eventShow: null,
    _onBeforeStartArr: [],
    CONFIG_KEY: {
        engineDir: "engineDir",
        dependencies: "dependencies",
        debugMode: "debugMode",
        showFPS: "showFPS",
        frameRate: "frameRate",
        id: "id",
        renderMode: "renderMode",
        jsList: "jsList",
        classReleaseMode: "classReleaseMode"
    },
    _prepareCalled: !1,
    _prepared: !1,
    _paused: !0,
    _intervalId: null,
    config: null,
    onStart: null,
    onStop: null,
    setFrameRate: function (a) {
        this.config[this.CONFIG_KEY.frameRate] = a;
        this._intervalId && clearInterval(this._intervalId);
        this._paused = !0;
        this._runMainLoop()
    },
    _runMainLoop: function () {
        var a = this,
            b, c = a.config,
            d = a.CONFIG_KEY,
            e = window,
            f = c[d.frameRate],
            g = cc.director;
        g.setDisplayStats(c[d.showFPS]);
        e.requestAnimFrame && 60 == f ? (b = function () {
            a._paused || (g.mainLoop(), e.requestAnimFrame(b))
        }, e.requestAnimFrame(b)) : (b = function () {
                g.mainLoop()
            },
            a._intervalId = setInterval(b, 1E3 / f));
        a._paused = !1
    },
    run: function () {
        var a = this;
        a._prepareCalled ? cc._supportRender && (a._checkPrepare = setInterval(function () {
            a._prepared && (cc._setup(a.config[a.CONFIG_KEY.id]), a._runMainLoop(), a._eventHide = a._eventHide || new cc.EventCustom(a.EVENT_HIDE), a._eventHide.setUserData(a), a._eventShow = a._eventShow || new cc.EventCustom(a.EVENT_SHOW), a._eventShow.setUserData(a), a.onStart(), clearInterval(a._checkPrepare))
        }, 10)) : a.prepare(function () {
            cc._supportRender && (cc._setup(a.config[a.CONFIG_KEY.id]),
                a._runMainLoop(), a._eventHide = a._eventHide || new cc.EventCustom(a.EVENT_HIDE), a._eventHide.setUserData(a), a._eventShow = a._eventShow || new cc.EventCustom(a.EVENT_SHOW), a._eventShow.setUserData(a), a.onStart())
        })
    },
    _initConfig: function () {
        var a = this.CONFIG_KEY,
            b = function (b) {
                b[a.engineDir] = b[a.engineDir] || "libs/cocos2d-html5";
                b[a.debugMode] = b[a.debugMode] || 0;
                b[a.frameRate] = b[a.frameRate] || 60;
                b[a.renderMode] = b[a.renderMode] || 0;
                return b
            };
        if (document.ccConfig) this.config = b(document.ccConfig);
        else try {
            var c =
                cc.loader._loadTxtSync("project.json"),
                d = JSON.parse(c);
            this.config = b(d || {})
        } catch (e) {
            this.config = b({})
        }
        cc._initDebugSetting(this.config[a.debugMode]);
        cc._initSys(this.config, a)
    },
    _jsAddedCache: {},
    _getJsListOfModule: function (a, b, c) {
        var d = this._jsAddedCache;
        if (d[b]) return null;
        c = c || "";
        var e = [],
            f = a[b];
        if (!f) throw "can not find module [" + b + "]";
        b = cc.path;
        for (var g = 0, h = f.length; g < h; g++) {
            var k = f[g];
            if (!d[k]) {
                var m = b.extname(k);
                m ? ".js" == m.toLowerCase() && e.push(b.join(c, k)) : (m = this._getJsListOfModule(a, k, c)) &&
                    (e = e.concat(m));
                d[k] = 1
            }
        }
        return e
    },
    prepare: function (a) {
        var b = this,
            c = b.config,
            d = b.CONFIG_KEY,
            e = c[d.engineDir],
            f = cc.loader;
        if (cc._supportRender) {
            b._prepareCalled = !0;
            var g = c[d.jsList] || [];
            cc.Class ? f.loadJsWithImg("", g, function (c) {
                if (c) throw c;
                b._prepared = !0;
                a && a()
            }) : (d = cc.path.join(e, "moduleConfig.json"), f.loadJson(d, function (d, f) {
                if (d) throw d;
                var m = c.modules || [],
                    n = f.module,
                    p = [];
                cc._renderType == cc._RENDER_TYPE_WEBGL ? m.splice(0, 0, "shaders") : 0 > m.indexOf("core") && m.splice(0, 0, "core");
                for (var r = 0, q = m.length; r <
                    q; r++) {
                    var s = b._getJsListOfModule(n, m[r], e);
                    s && (p = p.concat(s))
                }
                p = p.concat(g);
                cc.loader.loadJsWithImg(p, function (c) {
                    if (c) throw c;
                    b._prepared = !0;
                    a && a()
                })
            }))
        } else cc.error("Can not support render!")
    }
};
cc.game._initConfig();
var cc = cc || {},
    ClassManager = {
        id: 0 | 998 * Math.random(),
        instanceId: 0 | 998 * Math.random(),
        compileSuper: function (a, b, c) {
            a = a.toString();
            var d = a.indexOf("("),
                e = a.indexOf(")"),
                d = a.substring(d + 1, e),
                d = d.trim(),
                e = a.indexOf("{"),
                f = a.lastIndexOf("}");
            for (a = a.substring(e + 1, f); - 1 != a.indexOf("this._super");) {
                var e = a.indexOf("this._super"),
                    f = a.indexOf("(", e),
                    g = a.indexOf(")", f),
                    g = a.substring(f + 1, g),
                    g = (g = g.trim()) ? "," : "";
                a = a.substring(0, e) + "ClassManager[" + c + "]." + b + ".call(this" + g + a.substring(f + 1)
            }
            return Function(d, a)
        },
        getNewID: function () {
            return this.id++
        },
        getNewInstanceId: function () {
            return this.instanceId++
        }
    };
ClassManager.compileSuper.ClassManager = ClassManager;
(function () {
    var a = /\b_super\b/,
        b = cc.game.config[cc.game.CONFIG_KEY.classReleaseMode];
    b && console.log("release Mode");
    cc.Class = function () {};
    cc.Class.extend = function (c) {
        function d() {
            this.__instanceId = ClassManager.getNewInstanceId();
            this.ctor && this.ctor.apply(this, arguments)
        }
        var e = this.prototype,
            f = Object.create(e),
            g = ClassManager.getNewID();
        ClassManager[g] = e;
        var h = {
            writable: !0,
            enumerable: !1,
            configurable: !0
        };
        f.__instanceId = null;
        d.id = g;
        h.value = g;
        Object.defineProperty(f, "__pid", h);
        d.prototype = f;
        h.value = d;
        Object.defineProperty(d.prototype, "constructor", h);
        this.__getters__ && (d.__getters__ = cc.clone(this.__getters__));
        this.__setters__ && (d.__setters__ = cc.clone(this.__setters__));
        for (var k in c) {
            var m = "function" === typeof c[k],
                n = "function" === typeof e[k],
                p = a.test(c[k]);
            b && m && n && p ? (h.value = ClassManager.compileSuper(c[k], k, g), Object.defineProperty(f, k, h)) : m && n && p ? (h.value = function (a, b) {
                return function () {
                    var c = this._super;
                    this._super = e[a];
                    var d = b.apply(this, arguments);
                    this._super = c;
                    return d
                }
            }(k, c[k]), Object.defineProperty(f,
                k, h)) : m ? (h.value = c[k], Object.defineProperty(f, k, h)) : f[k] = c[k];
            if (m) {
                var r, q;
                if (this.__getters__ && this.__getters__[k]) {
                    var m = this.__getters__[k],
                        s;
                    for (s in this.__setters__)
                        if (this.__setters__[s] == m) {
                            q = s;
                            break
                        }
                    cc.defineGetterSetter(f, m, c[k], c[q] ? c[q] : f[q], k, q)
                }
                if (this.__setters__ && this.__setters__[k]) {
                    m = this.__setters__[k];
                    for (s in this.__getters__)
                        if (this.__getters__[s] == m) {
                            r = s;
                            break
                        }
                    cc.defineGetterSetter(f, m, c[r] ? c[r] : f[r], c[k], r, k)
                }
            }
        }
        d.extend = cc.Class.extend;
        d.implement = function (a) {
            for (var b in a) f[b] =
                a[b]
        };
        return d
    };
    Function.prototype.bind = Function.prototype.bind || function (a) {
        var b = this;
        return function () {
            var e = Array.prototype.slice.call(arguments);
            return b.apply(a || null, e)
        }
    }
})();
cc.inherits = function (a, b) {
    function c() {}
    c.prototype = b.prototype;
    a.superClass_ = b.prototype;
    a.prototype = new c;
    a.prototype.constructor = a
};
cc.base = function (a, b, c) {
    var d = arguments.callee.caller;
    if (d.superClass_) return ret = d.superClass_.constructor.apply(a, Array.prototype.slice.call(arguments, 1));
    for (var e = Array.prototype.slice.call(arguments, 2), f = !1, g = a.constructor; g; g = g.superClass_ && g.superClass_.constructor)
        if (g.prototype[b] === d) f = !0;
        else if (f) return g.prototype[b].apply(a, e);
    if (a[b] === d) return a.constructor.prototype[b].apply(a, e);
    throw Error("cc.base called from a method of one name to a method of a different name");
};
cc.concatObjectProperties = function (a, b) {
    a || (a = {});
    for (var c in b) a[c] = b[c];
    return a
};
cc.clone = function (a) {
    var b = a.constructor ? new a.constructor : {},
        c;
    for (c in a) {
        var d = a[c];
        b[c] = "object" != typeof d || !d || d instanceof cc.Node || d instanceof HTMLElement ? d : cc.clone(d)
    }
    return b
};
cc.associateWithNative = function (a, b) {};
cc.KEY = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    ctrl: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    insert: 45,
    Delete: 46,
    0: 48,
    1: 49,
    2: 50,
    3: 51,
    4: 52,
    5: 53,
    6: 54,
    7: 55,
    8: 56,
    9: 57,
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    num0: 96,
    num1: 97,
    num2: 98,
    num3: 99,
    num4: 100,
    num5: 101,
    num6: 102,
    num7: 103,
    num8: 104,
    num9: 105,
    "*": 106,
    "+": 107,
    "-": 109,
    numdel: 110,
    "/": 111,
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    numlock: 144,
    scrolllock: 145,
    semicolon: 186,
    ",": 186,
    equal: 187,
    "\x3d": 187,
    ";": 188,
    comma: 188,
    dash: 189,
    ".": 190,
    period: 190,
    forwardslash: 191,
    grave: 192,
    "[": 219,
    openbracket: 219,
    "]": 221,
    closebracket: 221,
    backslash: 220,
    quote: 222,
    space: 32
};
cc.FMT_JPG = 0;
cc.FMT_PNG = 1;
cc.FMT_TIFF = 2;
cc.FMT_RAWDATA = 3;
cc.FMT_WEBP = 4;
cc.FMT_UNKNOWN = 5;
cc.getImageFormatByData = function (a) {
    return 8 < a.length && 137 == a[0] && 80 == a[1] && 78 == a[2] && 71 == a[3] && 13 == a[4] && 10 == a[5] && 26 == a[6] && 10 == a[7] ? cc.FMT_PNG : 2 < a.length && (73 == a[0] && 73 == a[1] || 77 == a[0] && 77 == a[1] || 255 == a[0] && 216 == a[1]) ? cc.FMT_TIFF : cc.FMT_UNKNOWN
};
cc.defineGetterSetter = function (a, b, c, d, e, f) {
    if (a.__defineGetter__) c && a.__defineGetter__(b, c), d && a.__defineSetter__(b, d);
    else if (Object.defineProperty) {
        var g = {
            enumerable: !1,
            configurable: !0
        };
        c && (g.get = c);
        d && (g.set = d);
        Object.defineProperty(a, b, g)
    } else throw Error("browser does not support getters"); if (!e && !f)
        for (var g = null != c, h = void 0 != d, k = Object.getOwnPropertyNames(a), m = 0; m < k.length; m++) {
            var n = k[m];
            if (!a.__lookupGetter__(n) && "function" === typeof a[n]) {
                var p = a[n];
                if (g && p === c && (e = n, !h || f)) break;
                if (h &&
                    p === d && (f = n, !g || e)) break
            }
        }
    a = a.constructor;
    e && (a.__getters__ || (a.__getters__ = {}), a.__getters__[e] = b);
    f && (a.__setters__ || (a.__setters__ = {}), a.__setters__[f] = b)
};
cc.copyArray = function (a) {
    var b, c = a.length,
        d = Array(c);
    for (b = 0; b < c; b += 1) d[b] = a[b];
    return d
};
cc.Point = function (a, b) {
    this.x = a || 0;
    this.y = b || 0
};
cc.p = function (a, b) {
    return void 0 == a ? {
        x: 0,
        y: 0
    } : void 0 == b ? {
        x: a.x,
        y: a.y
    } : {
        x: a,
        y: b
    }
};
cc.pointEqualToPoint = function (a, b) {
    return a && b ? a.x === b.x && a.y === b.y : !1
};
cc.Size = function (a, b) {
    this.width = a || 0;
    this.height = b || 0
};
cc.size = function (a, b) {
    return void 0 === a ? {
        width: 0,
        height: 0
    } : void 0 === b ? {
        width: a.width,
        height: a.height
    } : {
        width: a,
        height: b
    }
};
cc.sizeEqualToSize = function (a, b) {
    return a && b ? a.width == b.width && a.height == b.height : !1
};
cc.Rect = function (a, b, c, d) {
    this.x = a || 0;
    this.y = b || 0;
    this.width = c || 0;
    this.height = d || 0
};
cc.rect = function (a, b, c, d) {
    return void 0 === a ? {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    } : void 0 === b ? {
        x: a.x,
        y: a.y,
        width: a.width,
        height: a.height
    } : {
        x: a,
        y: b,
        width: c,
        height: d
    }
};
cc.rectEqualToRect = function (a, b) {
    return a && b ? a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height : !1
};
cc._rectEqualToZero = function (a) {
    return a ? 0 === a.x && 0 === a.y && 0 === a.width && 0 === a.height : !1
};
cc.rectContainsRect = function (a, b) {
    return a && b ? !(a.x >= b.x || a.y >= b.y || a.x + a.width <= b.x + b.width || a.y + a.height <= b.y + b.height) : !1
};
cc.rectGetMaxX = function (a) {
    return a.x + a.width
};
cc.rectGetMidX = function (a) {
    return a.x + a.width / 2
};
cc.rectGetMinX = function (a) {
    return a.x
};
cc.rectGetMaxY = function (a) {
    return a.y + a.height
};
cc.rectGetMidY = function (a) {
    return a.y + a.height / 2
};
cc.rectGetMinY = function (a) {
    return a.y
};
cc.rectContainsPoint = function (a, b) {
    return b.x >= cc.rectGetMinX(a) && b.x <= cc.rectGetMaxX(a) && b.y >= cc.rectGetMinY(a) && b.y <= cc.rectGetMaxY(a)
};
cc.rectIntersectsRect = function (a, b) {
    return !(cc.rectGetMaxX(a) < cc.rectGetMinX(b) || cc.rectGetMaxX(b) < cc.rectGetMinX(a) || cc.rectGetMaxY(a) < cc.rectGetMinY(b) || cc.rectGetMaxY(b) < cc.rectGetMinY(a))
};
cc.rectOverlapsRect = function (a, b) {
    return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y)
};
cc.rectUnion = function (a, b) {
    var c = cc.rect(0, 0, 0, 0);
    c.x = Math.min(a.x, b.x);
    c.y = Math.min(a.y, b.y);
    c.width = Math.max(a.x + a.width, b.x + b.width) - c.x;
    c.height = Math.max(a.y + a.height, b.y + b.height) - c.y;
    return c
};
cc.rectIntersection = function (a, b) {
    var c = cc.rect(Math.max(cc.rectGetMinX(a), cc.rectGetMinX(b)), Math.max(cc.rectGetMinY(a), cc.rectGetMinY(b)), 0, 0);
    c.width = Math.min(cc.rectGetMaxX(a), cc.rectGetMaxX(b)) - cc.rectGetMinX(c);
    c.height = Math.min(cc.rectGetMaxY(a), cc.rectGetMaxY(b)) - cc.rectGetMinY(c);
    return c
};
cc.SAXParser = cc.Class.extend({
    _parser: null,
    _isSupportDOMParser: null,
    ctor: function () {
        window.DOMParser ? (this._isSupportDOMParser = !0, this._parser = new DOMParser) : this._isSupportDOMParser = !1
    },
    parse: function (a) {
        return this._parseXML(a)
    },
    _parseXML: function (a) {
        var b;
        this._isSupportDOMParser ? b = this._parser.parseFromString(a, "text/xml") : (b = new ActiveXObject("Microsoft.XMLDOM"), b.async = "false", b.loadXML(a));
        return b
    }
});
cc.PlistParser = cc.SAXParser.extend({
    parse: function (a) {
        a = this._parseXML(a).documentElement;
        if ("plist" != a.tagName) throw "Not a plist file!";
        for (var b = null, c = 0, d = a.childNodes.length; c < d && (b = a.childNodes[c], 1 != b.nodeType); c++);
        return this._parseNode(b)
    },
    _parseNode: function (a) {
        var b = null,
            c = a.tagName;
        if ("dict" == c) b = this._parseDict(a);
        else if ("array" == c) b = this._parseArray(a);
        else if ("string" == c)
            if (1 == a.childNodes.length) b = a.firstChild.nodeValue;
            else
                for (b = "", c = 0; c < a.childNodes.length; c++) b += a.childNodes[c].nodeValue;
        else "false" == c ? b = !1 : "true" == c ? b = !0 : "real" == c ? b = parseFloat(a.firstChild.nodeValue) : "integer" == c && (b = parseInt(a.firstChild.nodeValue, 10));
        return b
    },
    _parseArray: function (a) {
        for (var b = [], c = 0, d = a.childNodes.length; c < d; c++) {
            var e = a.childNodes[c];
            1 == e.nodeType && b.push(this._parseNode(e))
        }
        return b
    },
    _parseDict: function (a) {
        for (var b = {}, c = null, d = 0, e = a.childNodes.length; d < e; d++) {
            var f = a.childNodes[d];
            1 == f.nodeType && ("key" == f.tagName ? c = f.firstChild.nodeValue : b[c] = this._parseNode(f))
        }
        return b
    }
});
cc._txtLoader = {
    load: function (a, b, c, d) {
        cc.loader.loadTxt(a, d)
    }
};
cc.loader.register(["txt", "xml", "vsh", "fsh"], cc._txtLoader);
cc._jsonLoader = {
    load: function (a, b, c, d) {
        cc.loader.loadJson(a, d)
    }
};
cc.loader.register(["json", "ExportJson"], cc._jsonLoader);
cc._imgLoader = {
    load: function (a, b, c, d) {
        a = cc.loader.loadImg(a, function (a, c) {
            if (a) return d(a);
            cc.textureCache.handleLoadedTexture(b);
            d(null, c)
        });
        cc.loader.cache[b] = a
    }
};
cc.loader.register(["png", "jpg", "bmp", "jpeg", "gif"], cc._imgLoader);
cc._plistLoader = {
    load: function (a, b, c, d) {
        cc.loader.loadTxt(a, function (a, b) {
            if (a) return d(a);
            d(null, cc.plistParser.parse(b))
        })
    }
};
cc.loader.register(["plist"], cc._plistLoader);
cc._fontLoader = {
    TYPE: {
        eot: "embedded-opentype",
        ttf: "truetype",
        woff: "woff",
        svg: "svg"
    },
    _loadFont: function (a, b, c) {
        var d = document,
            e = cc.path,
            f = this.TYPE,
            g = d.createElement("style");
        g.type = "text/css";
        d.body.appendChild(g);
        var h = "@font-face { font-family:" + a + "; src:";
        if (b instanceof Array)
            for (var k = 0, m = b.length; k < m; k++) c = e.extname(b[k]), h += "url('" + b[k] + "') format('" + f[c] + "')", h += k == m - 1 ? ";" : ",";
        else h += "url('" + b + "') format('" + f[c] + "');";
        g.textContent += h + "};";
        b = document.createElement("div");
        b.style.fontFamily =
            a;
        b.innerHTML = ".";
        b.style.position = "absolute";
        b.style.left = "-100px";
        b.style.top = "-100px";
        d.body.appendChild(b)
    },
    load: function (a, b, c, d) {
        b = c.type;
        a = c.name;
        b = c.srcs;
        "string" == typeof c ? (b = cc.path.extname(c), a = cc.path.basename(c, b), this._loadFont(a, c, b)) : this._loadFont(a, b);
        d(null, !0)
    }
};
cc.loader.register(["font", "eot", "ttf", "woff", "svg"], cc._fontLoader);
cc._binaryLoader = {
    load: function (a, b, c, d) {
        cc.loader.loadBinary(a, d)
    }
};
cc.ENGINE_VERSION = "Cocos2d-html5-v3.0 alpha";
cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0;
cc.DIRECTOR_STATS_POSITION = cc.p(0, 0);
cc.DIRECTOR_FPS_INTERVAL = 0.5;
cc.COCOSNODE_RENDER_SUBPIXEL = 1;
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1;
cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 0;
cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0;
cc.TEXTURE_ATLAS_USE_VAO = 0;
cc.TEXTURE_NPOT_SUPPORT = 0;
cc.RETINA_DISPLAY_SUPPORT = 1;
cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd";
cc.USE_LA88_LABELS = 1;
cc.SPRITE_DEBUG_DRAW = 0;
cc.SPRITEBATCHNODE_DEBUG_DRAW = 0;
cc.LABELBMFONT_DEBUG_DRAW = 0;
cc.LABELATLAS_DEBUG_DRAW = 0;
cc.IS_RETINA_DISPLAY_SUPPORTED = 1;
cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas";
cc.ENABLE_STACKABLE_ACTIONS = 1;
cc.ENABLE_GL_STATE_CACHE = 1;
cc.openURL = function (a) {
    if (this.isMobile) {
        var b = cc.director.getWinSize(),
            c = b.width + "px",
            b = b.height + "px",
            d = cc.$new("div");
        d.style.backgroundColor = "#ffffff";
        d.style.width = c;
        d.style.height = b;
        d.style.zindex = 1E3;
        d.style.position = "absolute";
        d.style.top = "0px";
        d.style.left = "0px";
        d.id = "cocos2d-browser";
        var e = cc.$new("iframe");
        e.src = a;
        e.style.width = c;
        e.style.height = b;
        e.setAttribute("frameborder", "no");
        e.setAttribute("scrolling", "no");
        d.appendChild(e);
        e.onload = function () {
            var a = document.createElement("img");
            a.src =
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAhCAYAAABX5MJvAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5OERBMEM3OUQzRTMxMUUyODg2Q0RFNjU1QkU1RjlFQSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5OERBMEM3QUQzRTMxMUUyODg2Q0RFNjU1QkU1RjlFQSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjk4REEwQzc3RDNFMzExRTI4ODZDREU2NTVCRTVGOUVBIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjk4REEwQzc4RDNFMzExRTI4ODZDREU2NTVCRTVGOUVBIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+NwBuoAAAA/tJREFUeNrEWF0sW3EUb6+28zFhbGadsBaNhazV+kpDYhFWKRGWbHvwFV5IvPiIFw9evElEPEiWSUgsIWoIglhmUomPxj6aKC0zKVJjtPU5o9j5J7dLdbf33jKc5Jfc3v+v5/+755x7/j1lMoiNBRDh4AO88HvO2m+ACbAC+AJQAyz2JCbBFyMBWQA/xv+3DUAXLuivudhcY4BMwCuAB+NqDPmNAnAAOsCZvQgk4BnjeiwEwAbM2YoQA14yrteQEANgDcML7gXjZgw9OAuJkADu3JAIb7Q/hr+GtCwuLs6LDq+iooLvhBAREhFEl11ZWRne0tIiIeNIpVKv4uJi4dTUVApNt0EY3ohILSIiwqO7u1sql8vD8vLyJJ2dnXH2HDabzczPz3/Y1taWzOfz78XExDxSq9Vyd3d3jMK9F2pWr6lEtLa2RmVnZ4tt7w0NDWlTU1OVtkK7urqSQ0NDzzW5hYWFjcTExAGDwXDkyD+VSkZ7e3tsWlpamP19mUwWplQqk9B1UlKST3NzczxE4K49D4mCiDwn24PyPMjIyHjs6urKIVpLSEgInp6eZsM6Kzw8nEvEMZvNBxC1BbI9KCMhkUgUy8vLRpL1QIFA4EcSyZmcnJzpS4mYnZ3dj46O7p2fn193xIGi/CeiFovlFIp5pqGhYZ5qD1qFiQxCjk1OTsqEQmEAFReloL+/X0sVAadFWE2n02VA+O+TcVZXV01QkO8ODw9P6fjEnO2zvb2936g4XC7XG4rWm65P2iL8/f05kN8nBQUFQkqnGMYcGBjIys3N5dLxjY7ydDrE6urqsNLSUqmbmxuH1tOBkMzMTIHRaNxSqVTmS4soKyvjFRUViTw9PV2dTR901WAOh7M/MjKyeeHCbGpqEhcWFkY5Wl9aWtpUKBRaONziSbsii/Xm5OTk7EIdU6/X7zpaW1xc/Al5HxkfH9/e2dk5rqmpeUrE6+vr06ADzpEIlI5kMjFwPhh5PB5DJBKdK7KDg4Oj2tpaVUdHxw/0eWxszIjyj8Jvy4N60FdVVX2Grnt4dkaowYJESAG3yaLR09Oz5uvrexwbGxuAR2erpKTkI6RqxW5DM6RnLT09PQQV5vDwsDYlJWUU+I4EIDMhEQLAA6q0DA4OrqMCg/c/qL6+XtXY2Kgn4sGJuavRaFbFYrFPeXn5FIj6ReFa64KnIpJOpaMK39vbM9XV1X13lF9kc3Nz+xMTEwZo89s03A4ycRE1N/RjF/WPKgyfDRU39Gu7w1qYyNYAtwDB1yhgGPDBfgzU4bMi7xoEjAI6iWZRdGMGH80Cr2goRlP5W8B7qwBHfw1YO6kEH4yC8EnJ5QKbnuDFh17nr4BPRP9P/BFgAHo7ZNgI9EbHAAAAAElFTkSuQmCC";
            d.appendChild(a);
            a.style.zindex = 1E3;
            a.style.position = "absolute";
            a.style.bottom = "10px";
            a.style.right = "10px";
            a.onclick = function () {
                d.remove()
            }
        };
        (a = document.getElementById(document.ccConfig.tag).parentNode) && a.appendChild(d)
    } //else window.open(a)
};
cc.$ = function (a) {
    var b = this == cc ? document : this;
    if (a = a instanceof HTMLElement ? a : b.querySelector(a)) a.find = a.find || cc.$, a.hasClass = a.hasClass || function (a) {
            return this.className.match(RegExp("(\\s|^)" + a + "(\\s|$)"))
        }, a.addClass = a.addClass || function (a) {
            this.hasClass(a) || (this.className && (this.className += " "), this.className += a);
            return this
        }, a.removeClass = a.removeClass || function (a) {
            this.hasClass(a) && (this.className = this.className.replace(a, ""));
            return this
        }, a.remove = a.remove || function () {
            this.parentNode &&
                this.parentNode.removeChild(this);
            return this
        }, a.appendTo = a.appendTo || function (a) {
            a.appendChild(this);
            return this
        }, a.prependTo = a.prependTo || function (a) {
            a.childNodes[0] ? a.insertBefore(this, a.childNodes[0]) : a.appendChild(this);
            return this
        }, a.transforms = a.transforms || function () {
            this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew);
            return this
        }, a.position = a.position || {
            x: 0,
            y: 0
        }, a.rotation = a.rotation || 0, a.scale = a.scale || {
            x: 1,
            y: 1
        }, a.skew =
        a.skew || {
            x: 0,
            y: 0
        }, a.translates = function (a, b) {
            this.position.x = a;
            this.position.y = b;
            this.transforms();
            return this
        }, a.rotate = function (a) {
            this.rotation = a;
            this.transforms();
            return this
        }, a.resize = function (a, b) {
            this.scale.x = a;
            this.scale.y = b;
            this.transforms();
            return this
        }, a.setSkew = function (a, b) {
            this.skew.x = a;
            this.skew.y = b;
            this.transforms();
            return this
        };
    return a
};
switch (cc.sys.browserType) {
case cc.sys.BROWSER_TYPE_FIREFOX:
    cc.$.pfx = "Moz";
    cc.$.hd = !0;
    break;
case cc.sys.BROWSER_TYPE_CHROME:
case cc.sys.BROWSER_TYPE_SAFARI:
    cc.$.pfx = "webkit";
    cc.$.hd = !0;
    break;
case cc.sys.BROWSER_TYPE_OPERA:
    cc.$.pfx = "O";
    cc.$.hd = !1;
    break;
case cc.sys.BROWSER_TYPE_IE:
    cc.$.pfx = "ms";
    cc.$.hd = !1;
    break;
default:
    cc.$.pfx = "webkit", cc.$.hd = !0
}
cc.$.trans = cc.$.pfx + "Transform";
cc.$.translate = cc.$.hd ? function (a) {
    return "translate3d(" + a.x + "px, " + a.y + "px, 0) "
} : function (a) {
    return "translate(" + a.x + "px, " + a.y + "px) "
};
cc.$.rotate = cc.$.hd ? function (a) {
    return "rotateZ(" + a + "deg) "
} : function (a) {
    return "rotate(" + a + "deg) "
};
cc.$.scale = function (a) {
    return "scale(" + a.x + ", " + a.y + ") "
};
cc.$.skew = function (a) {
    return "skewX(" + -a.x + "deg) skewY(" + a.y + "deg)"
};
cc.$new = function (a) {
    return cc.$(document.createElement(a))
};
cc.$.findpos = function (a) {
    var b = 0,
        c = 0;
    do b += a.offsetLeft, c += a.offsetTop; while (a = a.offsetParent);
    return {
        x: b,
        y: c
    }
};
cc.INVALID_INDEX = -1;
cc.PI = Math.PI;
cc.FLT_MAX = parseFloat("3.402823466e+38F");
cc.RAD = cc.PI / 180;
cc.DEG = 180 / cc.PI;
cc.UINT_MAX = 4294967295;
cc.SWAP = function (a, b, c) {
    if ("object" == typeof c && "undefined" != typeof c.x && "undefined" != typeof c.y) {
        var d = c[a];
        c[a] = c[b];
        c[b] = d
    } else cc.log("cc.SWAP is being modified from original macro, please check usage")
};
cc.lerp = function (a, b, c) {
    return a + (b - a) * c
};
cc.RANDOM_MINUS1_1 = function () {
    return 2 * (Math.random() - 0.5)
};
cc.RANDOM_0_1 = function () {
    return Math.random()
};
cc.DEGREES_TO_RADIANS = function (a) {
    return a * cc.RAD
};
cc.RADIANS_TO_DEGREES = function (a) {
    return a * cc.DEG
};
cc.REPEAT_FOREVER = Number.MAX_VALUE - 1;
cc.BLEND_SRC = cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? 1 : 770;
cc.BLEND_DST = 771;
cc.NODE_DRAW_SETUP = function (a) {
    a._shaderProgram && (a._shaderProgram.use(), a._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4())
};
cc.ENABLE_DEFAULT_GL_STATES = function () {};
cc.DISABLE_DEFAULT_GL_STATES = function () {};
cc.INCREMENT_GL_DRAWS = function (a) {
    cc.g_NumberOfDraws += a
};
cc.FLT_EPSILON = 1.192092896E-7;
cc.CONTENT_SCALE_FACTOR = cc.IS_RETINA_DISPLAY_SUPPORTED ? function () {
    return cc.director.getContentScaleFactor()
} : function () {
    return 1
};
cc.POINT_POINTS_TO_PIXELS = function (a) {
    var b = cc.CONTENT_SCALE_FACTOR();
    return cc.p(a.x * b, a.y * b)
};
cc.SIZE_POINTS_TO_PIXELS = function (a) {
    var b = cc.CONTENT_SCALE_FACTOR();
    return cc.size(a.width * b, a.height * b)
};
cc.SIZE_PIXELS_TO_POINTS = function (a) {
    var b = cc.CONTENT_SCALE_FACTOR();
    return cc.size(a.width / b, a.height / b)
};
cc._SIZE_PIXELS_TO_POINTS_OUT = function (a, b) {
    var c = cc.CONTENT_SCALE_FACTOR();
    b.width = a.width / c;
    b.height = a.height / c
};
cc.POINT_PIXELS_TO_POINTS = function (a) {
    var b = cc.CONTENT_SCALE_FACTOR();
    return cc.p(a.x / b, a.y / b)
};
cc._POINT_PIXELS_TO_POINTS_OUT = function (a, b) {
    var c = cc.CONTENT_SCALE_FACTOR();
    b.x = a.x / c;
    b.y = a.y / c
};
cc.RECT_PIXELS_TO_POINTS = cc.IS_RETINA_DISPLAY_SUPPORTED ? function (a) {
    var b = cc.CONTENT_SCALE_FACTOR();
    return cc.rect(a.x / b, a.y / b, a.width / b, a.height / b)
} : function (a) {
    return a
};
cc.RECT_POINTS_TO_PIXELS = cc.IS_RETINA_DISPLAY_SUPPORTED ? function (a) {
    var b = cc.CONTENT_SCALE_FACTOR();
    return cc.rect(a.x * b, a.y * b, a.width * b, a.height * b)
} : function (a) {
    return a
};
cc.ONE = 1;
cc.ZERO = 0;
cc.SRC_ALPHA = 770;
cc.ONE_MINUS_SRC_ALPHA = 771;
cc.ONE_MINUS_DST_COLOR = 775;
cc.CHECK_GL_ERROR_DEBUG = function () {
    if (cc.renderMode == cc._RENDER_TYPE_WEBGL) {
        var a = cc._renderContext.getError();
        a && cc.log("WebGL error " + a)
    }
};
cc.Color = function (a, b, c, d) {
    this.r = a || 0;
    this.g = b || 0;
    this.b = c || 0;
    this.a = d || 0
};
cc.color = function (a, b, c, d) {
    return void 0 === a ? {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    } : "string" === typeof a ? cc.hexToColor(a) : "object" === typeof a ? {
        r: a.r,
        g: a.g,
        b: a.b,
        a: a.a
    } : {
        r: a,
        g: b,
        b: c,
        a: d
    }
};
cc.colorEqual = function (a, b) {
    return a.r === b.r && a.g === b.g && a.b === b.b
};
cc.Acceleration = function (a, b, c, d) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0;
    this.timestamp = d || 0
};
cc.Vertex2F = function (a, b) {
    this.x = a || 0;
    this.y = b || 0
};
cc.Vertex2 = function (a, b) {
    return new cc.Vertex2F(a, b)
};
cc.Vertex3F = function (a, b, c) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0
};
cc.vertex3 = function (a, b, c) {
    return new cc.Vertex3F(a, b, c)
};
cc.Tex2F = function (a, b) {
    this.u = a || 0;
    this.v = b || 0
};
cc.tex2 = function (a, b) {
    return new cc.Tex2F(a, b)
};
cc.Quad2 = function (a, b, c, d) {
    this.tl = a || new cc.Vertex2F(0, 0);
    this.tr = b || new cc.Vertex2F(0, 0);
    this.bl = c || new cc.Vertex2F(0, 0);
    this.br = d || new cc.Vertex2F(0, 0)
};
cc.Quad3 = function (a, b, c, d) {
    this.bl = a || new cc.Vertex3F(0, 0, 0);
    this.br = b || new cc.Vertex3F(0, 0, 0);
    this.tl = c || new cc.Vertex3F(0, 0, 0);
    this.tr = d || new cc.Vertex3F(0, 0, 0)
};
cc.V2F_C4B_T2F = function (a, b, c) {
    this.vertices = a || new cc.Vertex2F(0, 0);
    this.colors = b || cc.color(0, 0, 0, 0);
    this.texCoords = c || new cc.Tex2F(0, 0)
};
cc.V3F_C4B_T2F = function (a, b, c) {
    this.vertices = a || new cc.Vertex3F(0, 0, 0);
    this.colors = b || cc.color(0, 0, 0, 0);
    this.texCoords = c || new cc.Tex2F(0, 0)
};
cc.V2F_C4B_T2F_Triangle = function (a, b, c) {
    this.a = a || new cc.V2F_C4B_T2F;
    this.b = b || new cc.V2F_C4B_T2F;
    this.c = c || new cc.V2F_C4B_T2F
};
cc.V2F_C4B_T2F_Quad = function (a, b, c, d) {
    this.bl = a || new cc.V2F_C4B_T2F;
    this.br = b || new cc.V2F_C4B_T2F;
    this.tl = c || new cc.V2F_C4B_T2F;
    this.tr = d || new cc.V2F_C4B_T2F
};
cc.V2F_C4B_T2F_QuadZero = function () {
    return new cc.V2F_C4B_T2F_Quad(new cc.V2F_C4B_T2F(new cc.Vertex2F(0, 0), cc.color(0, 0, 0, 255), new cc.Tex2F(0, 0)), new cc.V2F_C4B_T2F(new cc.Vertex2F(0, 0), cc.color(0, 0, 0, 255), new cc.Tex2F(0, 0)), new cc.V2F_C4B_T2F(new cc.Vertex2F(0, 0), cc.color(0, 0, 0, 255), new cc.Tex2F(0, 0)), new cc.V2F_C4B_T2F(new cc.Vertex2F(0, 0), cc.color(0, 0, 0, 255), new cc.Tex2F(0, 0)))
};
cc.V3F_C4B_T2F_Quad = function (a, b, c, d) {
    this.tl = a || new cc.V3F_C4B_T2F;
    this.bl = b || new cc.V3F_C4B_T2F;
    this.tr = c || new cc.V3F_C4B_T2F;
    this.br = d || new cc.V3F_C4B_T2F
};
cc.V3F_C4B_T2F_QuadZero = function () {
    return new cc.V3F_C4B_T2F_Quad(new cc.V3F_C4B_T2F(new cc.Vertex3F(0, 0, 0), cc.color(0, 0, 0, 255), new cc.Tex2F(0, 0)), new cc.V3F_C4B_T2F(new cc.Vertex3F(0, 0, 0), cc.color(0, 0, 0, 255), new cc.Tex2F(0, 0)), new cc.V3F_C4B_T2F(new cc.Vertex3F(0, 0, 0), cc.color(0, 0, 0, 255), new cc.Tex2F(0, 0)), new cc.V3F_C4B_T2F(new cc.Vertex3F(0, 0, 0), cc.color(0, 0, 0, 255), new cc.Tex2F(0, 0)))
};
cc.V3F_C4B_T2F_QuadCopy = function (a) {
    return a ? new cc.V3F_C4B_T2F_Quad(new cc.V3F_C4B_T2F(new cc.Vertex3F(a.tl.vertices.x, a.tl.vertices.y, a.tl.vertices.z), cc.color(a.tl.colors.r, a.tl.colors.g, a.tl.colors.b, a.tl.colors.a), new cc.Tex2F(a.tl.texCoords.u, a.tl.texCoords.v)), new cc.V3F_C4B_T2F(new cc.Vertex3F(a.bl.vertices.x, a.bl.vertices.y, a.bl.vertices.z), cc.color(a.bl.colors.r, a.bl.colors.g, a.bl.colors.b, a.bl.colors.a), new cc.Tex2F(a.bl.texCoords.u, a.bl.texCoords.v)), new cc.V3F_C4B_T2F(new cc.Vertex3F(a.tr.vertices.x,
        a.tr.vertices.y, a.tr.vertices.z), cc.color(a.tr.colors.r, a.tr.colors.g, a.tr.colors.b, a.tr.colors.a), new cc.Tex2F(a.tr.texCoords.u, a.tr.texCoords.v)), new cc.V3F_C4B_T2F(new cc.Vertex3F(a.br.vertices.x, a.br.vertices.y, a.br.vertices.z), cc.color(a.br.colors.r, a.br.colors.g, a.br.colors.b, a.br.colors.a), new cc.Tex2F(a.br.texCoords.u, a.br.texCoords.v))) : cc.V3F_C4B_T2F_QuadZero()
};
cc.V3F_C4B_T2F_QuadsCopy = function (a) {
    if (!a) return [];
    for (var b = [], c = 0; c < a.length; c++) b.push(cc.V3F_C4B_T2F_QuadCopy(a[c]));
    return b
};
cc.BlendFunc = function (a, b) {
    this.src = a;
    this.dst = b
};
cc.BlendFuncDisable = function () {
    return new cc.BlendFunc(cc.ONE, cc.ZERO)
};
cc.T2F_Quad = function (a, b, c, d) {
    this.bl = a;
    this.br = b;
    this.tl = c;
    this.tr = d
};
cc.AnimationFrameData = function (a, b, c) {
    this.texCoords = a;
    this.delay = b;
    this.size = c
};
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.color = function (a, b, c, d, e, f) {
    return void 0 === a ? new cc.Color(0, 0, 0, 255, e, f) : "string" === typeof a ? (a = cc.hexToColor(a), new cc.Color(a.r, a.g, a.b, a.a)) : "object" === typeof a ? new cc.Color(a.r, a.g, a.b, a.a, a.arrayBuffer, a.offset) : new cc.Color(a, b, c, d, e, f)
}, cc.Color = function (a, b, c, d, e, f) {
    this._arrayBuffer = e || new ArrayBuffer(cc.Color.BYTES_PER_ELEMENT);
    this._offset = f || 0;
    e = this._arrayBuffer;
    f = this._offset;
    var g = Uint8Array.BYTES_PER_ELEMENT;
    this._rU8 = new Uint8Array(e, f,
        1);
    this._gU8 = new Uint8Array(e, f + g, 1);
    this._bU8 = new Uint8Array(e, f + 2 * g, 1);
    this._aU8 = new Uint8Array(e, f + 3 * g, 1);
    this._rU8[0] = a || 0;
    this._gU8[0] = b || 0;
    this._bU8[0] = c || 0;
    this._aU8[0] = d || 0;
    void 0 === d && (this.a_undefined = !0)
}, cc.Color.BYTES_PER_ELEMENT = 4, window._p = cc.Color.prototype, _p._getR = function () {
    return this._rU8[0]
}, _p._setR = function (a) {
    this._rU8[0] = 0 > a ? 0 : a
}, _p._getG = function () {
    return this._gU8[0]
}, _p._setG = function (a) {
    this._gU8[0] = 0 > a ? 0 : a
}, _p._getB = function () {
    return this._bU8[0]
}, _p._setB = function (a) {
    this._bU8[0] =
        0 > a ? 0 : a
}, _p._getA = function () {
    return this._aU8[0]
}, _p._setA = function (a) {
    this._aU8[0] = 0 > a ? 0 : a
}, cc.defineGetterSetter(_p, "r", _p._getR, _p._setR), cc.defineGetterSetter(_p, "g", _p._getG, _p._setG), cc.defineGetterSetter(_p, "b", _p._getB, _p._setB), cc.defineGetterSetter(_p, "a", _p._getA, _p._setA), delete window._p, cc.Vertex2F = function (a, b, c, d) {
    this._arrayBuffer = c || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT);
    this._offset = d || 0;
    this._xF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
    this._yF32 = new Float32Array(this._arrayBuffer,
        this._offset + 4, 1);
    this._xF32[0] = a || 0;
    this._yF32[0] = b || 0
}, cc.Vertex2F.BYTES_PER_ELEMENT = 8, Object.defineProperties(cc.Vertex2F.prototype, {
    x: {
        get: function () {
            return this._xF32[0]
        },
        set: function (a) {
            this._xF32[0] = a
        },
        enumerable: !0
    },
    y: {
        get: function () {
            return this._yF32[0]
        },
        set: function (a) {
            this._yF32[0] = a
        },
        enumerable: !0
    }
}), cc.Vertex3F = function (a, b, c, d, e) {
    this._arrayBuffer = d || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT);
    this._offset = e || 0;
    d = this._arrayBuffer;
    e = this._offset;
    this._xF32 = new Float32Array(d, e, 1);
    this._xF32[0] = a || 0;
    this._yF32 = new Float32Array(d, e + Float32Array.BYTES_PER_ELEMENT, 1);
    this._yF32[0] = b || 0;
    this._zF32 = new Float32Array(d, e + 2 * Float32Array.BYTES_PER_ELEMENT, 1);
    this._zF32[0] = c || 0
}, cc.Vertex3F.BYTES_PER_ELEMENT = 12, Object.defineProperties(cc.Vertex3F.prototype, {
    x: {
        get: function () {
            return this._xF32[0]
        },
        set: function (a) {
            this._xF32[0] = a
        },
        enumerable: !0
    },
    y: {
        get: function () {
            return this._yF32[0]
        },
        set: function (a) {
            this._yF32[0] = a
        },
        enumerable: !0
    },
    z: {
        get: function () {
            return this._zF32[0]
        },
        set: function (a) {
            this._zF32[0] =
                a
        },
        enumerable: !0
    }
}), cc.Tex2F = function (a, b, c, d) {
    this._arrayBuffer = c || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT);
    this._offset = d || 0;
    this._uF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
    this._vF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
    this._uF32[0] = a || 0;
    this._vF32[0] = b || 0
}, cc.Tex2F.BYTES_PER_ELEMENT = 8, Object.defineProperties(cc.Tex2F.prototype, {
    u: {
        get: function () {
            return this._uF32[0]
        },
        set: function (a) {
            this._uF32[0] = a
        },
        enumerable: !0
    },
    v: {
        get: function () {
            return this._vF32[0]
        },
        set: function (a) {
            this._vF32[0] =
                a
        },
        enumerable: !0
    }
}), cc.Quad2 = function (a, b, c, d, e, f) {
    this._arrayBuffer = e || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT);
    this._offset = f || 0;
    e = this._arrayBuffer;
    f = cc.Vertex2F.BYTES_PER_ELEMENT;
    this._tl = a ? new cc.Vertex2F(a.x, a.y, e, 0) : new cc.Vertex2F(0, 0, e, 0);
    this._tr = b ? new cc.Vertex2F(b.x, b.y, e, f) : new cc.Vertex2F(0, 0, e, f);
    this._bl = c ? new cc.Vertex2F(c.x, c.y, e, 2 * f) : new cc.Vertex2F(0, 0, e, 2 * f);
    this._br = d ? new cc.Vertex2F(d.x, d.y, e, 3 * f) : new cc.Vertex2F(0, 0, e, 3 * f)
}, cc.Quad2.BYTES_PER_ELEMENT = 32, Object.defineProperties(cc.Quad2.prototype, {
    tl: {
        get: function () {
            return this._tl
        },
        set: function (a) {
            this._tl.x = a.x;
            this._tl.y = a.y
        },
        enumerable: !0
    },
    tr: {
        get: function () {
            return this._tr
        },
        set: function (a) {
            this._tr.x = a.x;
            this._tr.y = a.y
        },
        enumerable: !0
    },
    bl: {
        get: function () {
            return this._bl
        },
        set: function (a) {
            this._bl.x = a.x;
            this._bl.y = a.y
        },
        enumerable: !0
    },
    br: {
        get: function () {
            return this._br
        },
        set: function (a) {
            this._br.x = a.x;
            this._br.y = a.y
        },
        enumerable: !0
    }
}), cc.V3F_C4B_T2F = function (a, b, c, d, e) {
    this._arrayBuffer = d || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT);
    this._offset = e || 0;
    d = this._arrayBuffer;
    e = this._offset;
    var f = cc.Vertex3F.BYTES_PER_ELEMENT;
    this._vertices = a ? new cc.Vertex3F(a.x, a.y, a.z, d, e) : new cc.Vertex3F(0, 0, 0, d, e);
    this._colors = b ? cc.color(b.r, b.g, b.b, b.a, d, e + f) : cc.color(0, 0, 0, 0, d, e + f);
    this._texCoords = c ? new cc.Tex2F(c.u, c.v, d, e + f + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, d, e + f + cc.Color.BYTES_PER_ELEMENT)
}, cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = 24, Object.defineProperties(cc.V3F_C4B_T2F.prototype, {
    vertices: {
        get: function () {
            return this._vertices
        },
        set: function (a) {
            var b =
                this._vertices;
            b.x = a.x;
            b.y = a.y;
            b.z = a.z
        },
        enumerable: !0
    },
    colors: {
        get: function () {
            return this._colors
        },
        set: function (a) {
            var b = this._colors;
            b.r = a.r;
            b.g = a.g;
            b.b = a.b;
            b.a = a.a
        },
        enumerable: !0
    },
    texCoords: {
        get: function () {
            return this._texCoords
        },
        set: function (a) {
            this._texCoords.u = a.u;
            this._texCoords.v = a.v
        },
        enumerable: !0
    }
}), cc.V3F_C4B_T2F_Quad = function (a, b, c, d, e, f) {
    this._arrayBuffer = e || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
    this._offset = f || 0;
    e = this._arrayBuffer;
    f = this._offset;
    var g = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
    this._tl = a ? new cc.V3F_C4B_T2F(a.vertices, a.colors, a.texCoords, e, f) : new cc.V3F_C4B_T2F(null, null, null, e, f);
    this._bl = b ? new cc.V3F_C4B_T2F(b.vertices, b.colors, b.texCoords, e, f + g) : new cc.V3F_C4B_T2F(null, null, null, e, f + g);
    this._tr = c ? new cc.V3F_C4B_T2F(c.vertices, c.colors, c.texCoords, e, f + 2 * g) : new cc.V3F_C4B_T2F(null, null, null, e, f + 2 * g);
    this._br = d ? new cc.V3F_C4B_T2F(d.vertices, d.colors, d.texCoords, e, f + 3 * g) : new cc.V3F_C4B_T2F(null, null, null, e, f + 3 * g)
}, cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = 96, Object.defineProperties(cc.V3F_C4B_T2F_Quad.prototype, {
    tl: {
        get: function () {
            return this._tl
        },
        set: function (a) {
            var b = this._tl;
            b.vertices = a.vertices;
            b.colors = a.colors;
            b.texCoords = a.texCoords
        },
        enumerable: !0
    },
    bl: {
        get: function () {
            return this._bl
        },
        set: function (a) {
            var b = this._bl;
            b.vertices = a.vertices;
            b.colors = a.colors;
            b.texCoords = a.texCoords
        },
        enumerable: !0
    },
    tr: {
        get: function () {
            return this._tr
        },
        set: function (a) {
            var b = this._tr;
            b.vertices = a.vertices;
            b.colors = a.colors;
            b.texCoords = a.texCoords
        },
        enumerable: !0
    },
    br: {
        get: function () {
            return this._br
        },
        set: function (a) {
            var b = this._br;
            b.vertices = a.vertices;
            b.colors = a.colors;
            b.texCoords = a.texCoords
        },
        enumerable: !0
    },
    arrayBuffer: {
        get: function () {
            return this._arrayBuffer
        },
        enumerable: !0
    }
}), cc.V3F_C4B_T2F_QuadZero = function () {
    return new cc.V3F_C4B_T2F_Quad
}, cc.V3F_C4B_T2F_QuadCopy = function (a) {
    if (!a) return cc.V3F_C4B_T2F_QuadZero();
    var b = a.tl,
        c = a.bl,
        d = a.tr;
    a = a.br;
    return {
        tl: {
            vertices: {
                x: b.vertices.x,
                y: b.vertices.y,
                z: b.vertices.z
            },
            colors: {
                r: b.colors.r,
                g: b.colors.g,
                b: b.colors.b,
                a: b.colors.a
            },
            texCoords: {
                u: b.texCoords.u,
                v: b.texCoords.v
            }
        },
        bl: {
            vertices: {
                x: c.vertices.x,
                y: c.vertices.y,
                z: c.vertices.z
            },
            colors: {
                r: c.colors.r,
                g: c.colors.g,
                b: c.colors.b,
                a: c.colors.a
            },
            texCoords: {
                u: c.texCoords.u,
                v: c.texCoords.v
            }
        },
        tr: {
            vertices: {
                x: d.vertices.x,
                y: d.vertices.y,
                z: d.vertices.z
            },
            colors: {
                r: d.colors.r,
                g: d.colors.g,
                b: d.colors.b,
                a: d.colors.a
            },
            texCoords: {
                u: d.texCoords.u,
                v: d.texCoords.v
            }
        },
        br: {
            vertices: {
                x: a.vertices.x,
                y: a.vertices.y,
                z: a.vertices.z
            },
            colors: {
                r: a.colors.r,
                g: a.colors.g,
                b: a.colors.b,
                a: a.colors.a
            },
            texCoords: {
                u: a.texCoords.u,
                v: a.texCoords.v
            }
        }
    }
}, cc.V2F_C4B_T2F = function (a, b, c,
    d, e) {
    this._arrayBuffer = d || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT);
    this._offset = e || 0;
    d = this._arrayBuffer;
    e = this._offset;
    var f = cc.Vertex2F.BYTES_PER_ELEMENT;
    this._vertices = a ? new cc.Vertex2F(a.x, a.y, d, e) : new cc.Vertex2F(0, 0, d, e);
    this._colors = b ? cc.color(b.r, b.g, b.b, b.a, d, e + f) : cc.color(0, 0, 0, 0, d, e + f);
    this._texCoords = c ? new cc.Tex2F(c.u, c.v, d, e + f + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, d, e + f + cc.Color.BYTES_PER_ELEMENT)
}, cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = 20, Object.defineProperties(cc.V2F_C4B_T2F.prototype, {
    vertices: {
        get: function () {
            return this._vertices
        },
        set: function (a) {
            this._vertices.x = a.x;
            this._vertices.y = a.y
        },
        enumerable: !0
    },
    colors: {
        get: function () {
            return this._colors
        },
        set: function (a) {
            var b = this._colors;
            b.r = a.r;
            b.g = a.g;
            b.b = a.b;
            b.a = a.a
        },
        enumerable: !0
    },
    texCoords: {
        get: function () {
            return this._texCoords
        },
        set: function (a) {
            this._texCoords.u = a.u;
            this._texCoords.v = a.v
        },
        enumerable: !0
    }
}), cc.V2F_C4B_T2F_Triangle = function (a, b, c, d, e) {
    this._arrayBuffer = d || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT);
    this._offset = e || 0;
    d = this._arrayBuffer;
    e = this._offset;
    var f = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
    this._a = a ? new cc.V2F_C4B_T2F(a.vertices, a.colors, a.texCoords, d, e) : new cc.V2F_C4B_T2F(null, null, null, d, e);
    this._b = b ? new cc.V2F_C4B_T2F(b.vertices, b.colors, b.texCoords, d, e + f) : new cc.V2F_C4B_T2F(null, null, null, d, e + f);
    this._c = c ? new cc.V2F_C4B_T2F(c.vertices, c.colors, c.texCoords, d, e + 2 * f) : new cc.V2F_C4B_T2F(null, null, null, d, e + 2 * f)
}, cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = 60, Object.defineProperties(cc.V2F_C4B_T2F_Triangle.prototype, {
    a: {
        get: function () {
            return this._a
        },
        set: function (a) {
            var b = this._a;
            b.vertices = a.vertices;
            b.colors = a.colors;
            b.texCoords = a.texCoords
        },
        enumerable: !0
    },
    b: {
        get: function () {
            return this._b
        },
        set: function (a) {
            var b = this._b;
            b.vertices = a.vertices;
            b.colors = a.colors;
            b.texCoords = a.texCoords
        },
        enumerable: !0
    },
    c: {
        get: function () {
            return this._c
        },
        set: function (a) {
            var b = this._c;
            b.vertices = a.vertices;
            b.colors = a.colors;
            b.texCoords = a.texCoords
        },
        enumerable: !0
    }
}));
cc.hexToColor = function (a) {
    a = a.replace(/^#?/, "0x");
    a = parseInt(a);
    return cc.color(a >> 16, (a >> 8) % 256, a % 256)
};
cc.colorToHex = function (a) {
    var b = a.r.toString(16),
        c = a.g.toString(16),
        d = a.b.toString(16);
    return "#" + (16 > a.r ? "0" + b : b) + (16 > a.g ? "0" + c : c) + (16 > a.b ? "0" + d : d)
};
cc.TEXT_ALIGNMENT_LEFT = 0;
cc.TEXT_ALIGNMENT_CENTER = 1;
cc.TEXT_ALIGNMENT_RIGHT = 2;
cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0;
cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1;
cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2;
cc._Dictionary = cc.Class.extend({
    _keyMapTb: null,
    _valueMapTb: null,
    __currId: 0,
    ctor: function () {
        this._keyMapTb = {};
        this._valueMapTb = {};
        this.__currId = 2 << (0 | 10 * Math.random())
    },
    __getKey: function () {
        this.__currId++;
        return "key_" + this.__currId
    },
    setObject: function (a, b) {
        if (null != b) {
            var c = this.__getKey();
            this._keyMapTb[c] = b;
            this._valueMapTb[c] = a
        }
    },
    objectForKey: function (a) {
        if (null == a) return null;
        var b = this._keyMapTb,
            c;
        for (c in b)
            if (b[c] === a) return this._valueMapTb[c];
        return null
    },
    valueForKey: function (a) {
        return this.objectForKey(a)
    },
    removeObjectForKey: function (a) {
        if (null != a) {
            var b = this._keyMapTb,
                c;
            for (c in b)
                if (b[c] === a) {
                    delete this._valueMapTb[c];
                    delete b[c];
                    break
                }
        }
    },
    removeObjectsForKeys: function (a) {
        if (null != a)
            for (var b = 0; b < a.length; b++) this.removeObjectForKey(a[b])
    },
    allKeys: function () {
        var a = [],
            b = this._keyMapTb,
            c;
        for (c in b) a.push(b[c]);
        return a
    },
    removeAllObjects: function () {
        this._keyMapTb = {};
        this._valueMapTb = {}
    },
    count: function () {
        return this.allKeys().length
    }
});
cc.FontDefinition = function () {
    this.fontName = "Arial";
    this.fontSize = 12;
    this.textAlign = cc.TEXT_ALIGNMENT_CENTER;
    this.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
    this.fillStyle = cc.color(255, 255, 255, 255);
    this.boundingHeight = this.boundingWidth = 0;
    this.strokeEnabled = !1;
    this.strokeStyle = cc.color(255, 255, 255, 255);
    this.lineWidth = 1;
    this.shadowEnabled = !1;
    this.shadowBlur = this.shadowOffsetY = this.shadowOffsetX = 0;
    this.shadowOpacity = 1
};
cc.color._getWhite = function () {
    return cc.color(255, 255, 255)
};
cc.color._getYellow = function () {
    return cc.color(255, 255, 0)
};
cc.color._getBlue = function () {
    return cc.color(0, 0, 255)
};
cc.color._getGreen = function () {
    return cc.color(0, 255, 0)
};
cc.color._getRed = function () {
    return cc.color(255, 0, 0)
};
cc.color._getMagenta = function () {
    return cc.color(255, 0, 255)
};
cc.color._getBlack = function () {
    return cc.color(0, 0, 0)
};
cc.color._getOrange = function () {
    return cc.color(255, 127, 0)
};
cc.color._getGray = function () {
    return cc.color(166, 166, 166)
};
window._p = cc.color;
cc.defineGetterSetter(_p, "WHITE", _p._getWhite);
cc.defineGetterSetter(_p, "YELLOW", _p._getYellow);
cc.defineGetterSetter(_p, "BLUE", _p._getBlue);
cc.defineGetterSetter(_p, "GREEN", _p._getGreen);
cc.defineGetterSetter(_p, "RED", _p._getRed);
cc.defineGetterSetter(_p, "MAGENTA", _p._getMagenta);
cc.defineGetterSetter(_p, "BLACK", _p._getBlack);
cc.defineGetterSetter(_p, "ORANGE", _p._getOrange);
cc.defineGetterSetter(_p, "GRAY", _p._getGray);
delete window._p;
cc.Touches = [];
cc.TouchesIntergerDict = {};
cc.EGLView = cc.Class.extend({
    _delegate: null,
    _frameSize: null,
    _designResolutionSize: null,
    _originalDesignResolutionSize: null,
    _viewPortRect: null,
    _visibleRect: null,
    _retinaEnabled: !1,
    _devicePixelRatio: 1,
    _viewName: "",
    _resizeCallback: null,
    _scaleX: 1,
    _originalScaleX: 1,
    _scaleY: 1,
    _originalScaleY: 1,
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _resolutionPolicy: null,
    _rpExactFit: null,
    _rpShowAll: null,
    _rpNoBorder: null,
    _rpFixedHeight: null,
    _rpFixedWidth: null,
    _initialized: !1,
    _captured: !1,
    _wnd: null,
    _hDC: null,
    _hRC: null,
    _supportTouch: !1,
    _contentTranslateLeftTop: null,
    _frame: null,
    _frameZoomFactor: 1,
    __resizeWithBrowserSize: !1,
    _isAdjustViewPort: !0,
    ctor: function () {
        this._frame = cc.container.parentNode === document.body ? document.documentElement : cc.container.parentNode;
        this._frameSize = cc.size(0, 0);
        this._initFrameSize();
        var a = cc._canvas.width,
            b = cc._canvas.height;
        this._designResolutionSize = cc.size(a, b);
        this._originalDesignResolutionSize = cc.size(a, b);
        this._viewPortRect = cc.rect(0, 0, a, b);
        this._visibleRect = cc.rect(0, 0, a, b);
        this._contentTranslateLeftTop = {
            left: 0,
            top: 0
        };
        this._viewName = "Cocos2dHTML5";
        a = cc.sys;
        this.enableRetina(a.os == a.OS_IOS || a.os == a.OS_OSX);
        cc.visibleRect.init(this._designResolutionSize);
        this._rpExactFit = new cc.ResolutionPolicy(cc.ContainerStrategy.EQUAL_TO_FRAME, cc.ContentStrategy.EXACT_FIT);
        this._rpShowAll = new cc.ResolutionPolicy(cc.ContainerStrategy.PROPORTION_TO_FRAME, cc.ContentStrategy.SHOW_ALL);
        this._rpNoBorder = new cc.ResolutionPolicy(cc.ContainerStrategy.EQUAL_TO_FRAME, cc.ContentStrategy.NO_BORDER);
        this._rpFixedHeight = new cc.ResolutionPolicy(cc.ContainerStrategy.EQUAL_TO_FRAME,
            cc.ContentStrategy.FIXED_HEIGHT);
        this._rpFixedWidth = new cc.ResolutionPolicy(cc.ContainerStrategy.EQUAL_TO_FRAME, cc.ContentStrategy.FIXED_WIDTH);
        this._hDC = cc._canvas;
        this._hRC = cc._renderContext
    },
    _resizeEvent: function () {
        var a = this._originalDesignResolutionSize.width,
            b = this._originalDesignResolutionSize.height;
        this._resizeCallback && (this._initFrameSize(), this._resizeCallback.call());
        0 < a && this.setDesignResolutionSize(a, b, this._resolutionPolicy)
    },
    resizeWithBrowserSize: function (a) {
        a ? this.__resizeWithBrowserSize ||
            (this.__resizeWithBrowserSize = !0, a = this._resizeEvent.bind(this), window.addEventListener("resize", a, !1)) : this.__resizeWithBrowserSize && (this.__resizeWithBrowserSize = !0, a = this._resizeEvent.bind(this), window.removeEventListener("resize", a, !1))
    },
    setResizeCallback: function (a) {
        if ("function" == typeof a || null == a) this._resizeCallback = a
    },
    _initFrameSize: function () {
        var a = this._frameSize;
        a.width = this._frame.clientWidth;
        a.height = this._frame.clientHeight
    },
    _adjustSizeKeepCanvasSize: function (a, b) {
        var c = this._originalDesignResolutionSize.width,
            d = this._originalDesignResolutionSize.height;
        0 < c && this.setDesignResolutionSize(c, d, this._resolutionPolicy)
    },
    _setViewPortMeta: function (a, b) {
        if (this._isAdjustViewPort) {
            var c = {
                    "user-scalable": "no",
                    "maximum-scale": "1.0",
                    "initial-scale": "1.0"
                },
                d = document.getElementsByName("viewport"),
                e;
            0 == d.length ? (d = document.createElement("meta"), d.name = "viewport", d.content = "", document.head.appendChild(d)) : d = d[0];
            if (cc.sys.isMobile && cc.sys.browserType == cc.sys.BROWSER_TYPE_FIREFOX) d.content = "initial-scale:1";
            else {
                e = d.content;
                for (var f in c) RegExp(f).test(e) || (e += ("" == e ? "" : ",") + f + "\x3d" + c[f]);
                d.content = e
            }
        }
    },
    _setScaleXYForRenderTexture: function () {
        var a = cc.CONTENT_SCALE_FACTOR();
        this._scaleY = this._scaleX = a
    },
    _resetScale: function () {
        this._scaleX = this._originalScaleX;
        this._scaleY = this._originalScaleY
    },
    _adjustSizeToBrowser: function () {},
    initialize: function () {
        this._initialized = !0
    },
    adjustViewPort: function (a) {
        this._isAdjustViewPort = a
    },
    enableRetina: function (a) {
        this._retinaEnabled = a ? !0 : !1
    },
    isRetinaEnabled: function () {
        return this._retinaEnabled
    },
    end: function () {},
    isOpenGLReady: function () {
        return null != this._hDC && null != this._hRC
    },
    setFrameZoomFactor: function (a) {
        this._frameZoomFactor = a;
        this.centerWindow();
        cc.director.setProjection(cc.director.getProjection())
    },
    swapBuffers: function () {},
    setIMEKeyboardState: function (a) {},
    setContentTranslateLeftTop: function (a, b) {
        this._contentTranslateLeftTop = {
            left: a,
            top: b
        }
    },
    getContentTranslateLeftTop: function () {
        return this._contentTranslateLeftTop
    },
    getFrameSize: function () {
        return cc.size(this._frameSize.width, this._frameSize.height)
    },
    setFrameSize: function (a, b) {
        this._frameSize.width = a;
        this._frameSize.height = b;
        this._frame.style.width = a + "px";
        this._frame.style.height = b + "px";
        this._resizeEvent();
        cc.director.setProjection(cc.director.getProjection())
    },
    centerWindow: function () {},
    getVisibleSize: function () {
        return cc.size(this._visibleRect.width, this._visibleRect.height)
    },
    getVisibleOrigin: function () {
        return cc.p(this._visibleRect.x, this._visibleRect.y)
    },
    canSetContentScaleFactor: function () {
        return !0
    },
    getResolutionPolicy: function () {
        return this._resolutionPolicy
    },
    setResolutionPolicy: function (a) {
        if (a instanceof cc.ResolutionPolicy) this._resolutionPolicy = a;
        else switch (a) {
        case cc.ResolutionPolicy.EXACT_FIT:
            this._resolutionPolicy = this._rpExactFit;
            break;
        case cc.ResolutionPolicy.SHOW_ALL:
            this._resolutionPolicy = this._rpShowAll;
            break;
        case cc.ResolutionPolicy.NO_BORDER:
            this._resolutionPolicy = this._rpNoBorder;
            break;
        case cc.ResolutionPolicy.FIXED_HEIGHT:
            this._resolutionPolicy = this._rpFixedHeight;
            break;
        case cc.ResolutionPolicy.FIXED_WIDTH:
            this._resolutionPolicy = this._rpFixedWidth
        }
    },
    setDesignResolutionSize: function (a, b, c) {
        if (isNaN(a) || 0 == a || isNaN(b) || 0 == b) cc.log("Resolution not valid");
        else {
            this.setResolutionPolicy(c);
            var d = this._resolutionPolicy;
            if (d) {
                d.preApply(this);
                var e = this._frameSize.width,
                    f = this._frameSize.height;
                cc.sys.isMobile && this._setViewPortMeta(this._frameSize.width, this._frameSize.height);
                this._initFrameSize();
                if (c != this._resolutionPolicy || a != this._originalDesignResolutionSize.width || b != this._originalDesignResolutionSize.height || e != this._frameSize.width || f != this._frameSize.height) this._designResolutionSize =
                    cc.size(a, b), this._originalDesignResolutionSize = cc.size(a, b), a = d.apply(this, this._designResolutionSize), a.scale && 2 == a.scale.length && (this._scaleX = a.scale[0], this._scaleY = a.scale[1]), a.viewport && (a = this._viewPortRect = a.viewport, b = this._visibleRect, b.width = cc._canvas.width / this._scaleX, b.height = cc._canvas.height / this._scaleY, b.x = -a.x / this._scaleX, b.y = -a.y / this._scaleY), a = cc.director, a._winSizeInPoints = this.getDesignResolutionSize(), d.postApply(this), cc._renderType == cc._RENDER_TYPE_WEBGL && (a._createStatsLabel(),
                        a.setGLDefaultValues()), this._originalScaleX = this._scaleX, this._originalScaleY = this._scaleY, cc.DOM && cc.DOM._resetEGLViewDiv(), cc.visibleRect.init(this.getVisibleSize())
            } else cc.log("should set resolutionPolicy")
        }
    },
    getDesignResolutionSize: function () {
        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height)
    },
    setViewPortInPoints: function (a, b, c, d) {
        var e = this._frameZoomFactor,
            f = this._scaleX,
            g = this._scaleY;
        cc._renderContext.viewport(a * f * e + this._viewPortRect.x * e, b * g * e + this._viewPortRect.y *
            e, c * f * e, d * g * e)
    },
    setScissorInPoints: function (a, b, c, d) {
        var e = this._frameZoomFactor,
            f = this._scaleX,
            g = this._scaleY;
        cc._renderContext.scissor(a * f * e + this._viewPortRect.x * e, b * g * e + this._viewPortRect.y * e, c * f * e, d * g * e)
    },
    isScissorEnabled: function () {
        var a = cc._renderContext;
        return a.isEnabled(a.SCISSOR_TEST)
    },
    getScissorRect: function () {
        var a = cc._renderContext,
            b = this._scaleX,
            c = this._scaleY,
            a = a.getParameter(a.SCISSOR_BOX);
        return cc.rect((a[0] - this._viewPortRect.x) / b, (a[1] - this._viewPortRect.y) / c, a[2] / b, a[3] / c)
    },
    setViewName: function (a) {
        null !=
            a && 0 < a.length && (this._viewName = a)
    },
    getViewName: function () {
        return this._viewName
    },
    getViewPortRect: function () {
        return this._viewPortRect
    },
    getScaleX: function () {
        return this._scaleX
    },
    getScaleY: function () {
        return this._scaleY
    },
    getDevicePixelRatio: function () {
        return this._devicePixelRatio
    },
    convertToLocationInView: function (a, b, c) {
        return {
            x: this._devicePixelRatio * (a - c.left),
            y: this._devicePixelRatio * (c.top + c.height - b)
        }
    },
    _convertMouseToLocationInView: function (a, b) {
        var c = this._viewPortRect;
        a.x = (this._devicePixelRatio *
            (a.x - b.left) - c.x) / this._scaleX;
        a.y = (this._devicePixelRatio * (b.top + b.height - a.y) - c.y) / this._scaleY
    },
    _convertTouchesWithScale: function (a) {
        for (var b = this._viewPortRect, c = this._scaleX, d = this._scaleY, e, f, g, h = 0; h < a.length; h++) e = a[h], f = e._point, g = e._prevPoint, e._setPoint((f.x - b.x) / c, (f.y - b.y) / d), e._setPrevPoint((g.x - b.x) / c, (g.y - b.y) / d)
    }
});
cc.EGLView._getInstance = function () {
    this._instance || (this._instance = this._instance || new cc.EGLView, this._instance.initialize());
    return this._instance
};
cc.ContainerStrategy = cc.Class.extend({
    preApply: function (a) {},
    apply: function (a, b) {},
    postApply: function (a) {},
    _setupContainer: function (a, b, c) {
        var d = a._frame;
        cc.sys.isMobile && d == document.documentElement && cc.screen.autoFullScreen(d);
        var d = cc._canvas,
            e = cc.container;
        e.style.width = d.style.width = b + "px";
        e.style.height = d.style.height = c + "px";
        e = a._devicePixelRatio = 1;
        a.isRetinaEnabled() && (e = a._devicePixelRatio = window.devicePixelRatio || 1);
        d.width = b * e;
        d.height = c * e;
        a = document.body;
        var f;
        a && (f = a.style) && (f.paddingTop =
            f.paddingTop || "0px", f.paddingRight = f.paddingRight || "0px", f.paddingBottom = f.paddingBottom || "0px", f.paddingLeft = f.paddingLeft || "0px", f.borderTop = f.borderTop || "0px", f.borderRight = f.borderRight || "0px", f.borderBottom = f.borderBottom || "0px", f.borderLeft = f.borderLeft || "0px", f.marginTop = f.marginTop || "0px", f.marginRight = f.marginRight || "0px", f.marginBottom = f.marginBottom || "0px", f.marginLeft = f.marginLeft || "0px")
    },
    _fixContainer: function () {
        document.body.insertBefore(cc.container, document.body.firstChild);
        var a =
            document.body.style;
        a.width = window.innerWidth + "px";
        a.height = window.innerHeight + "px";
        a.overflow = "hidden";
        a = cc.container.style;
        a.position = "fixed";
        a.left = a.top = "0px";
        document.body.scrollTop = 0
    }
});
cc.ContentStrategy = cc.Class.extend({
    _result: {
        scale: [1, 1],
        viewport: null
    },
    _buildResult: function (a, b, c, d, e, f) {
        2 > Math.abs(a - c) && (c = a);
        2 > Math.abs(b - d) && (d = b);
        a = cc.rect(Math.round((a - c) / 2), Math.round((b - d) / 2), c, d);
        cc._renderType == cc._RENDER_TYPE_CANVAS && cc._renderContext.translate(a.x, a.y + d);
        this._result.scale = [e, f];
        this._result.viewport = a;
        return this._result
    },
    preApply: function (a) {},
    apply: function (a, b) {
        return {
            scale: [1, 1]
        }
    },
    postApply: function (a) {}
});
(function () {
    var a = cc.ContainerStrategy.extend({
            apply: function (a) {
                this._setupContainer(a, a._frameSize.width, a._frameSize.height)
            }
        }),
        b = cc.ContainerStrategy.extend({
            apply: function (a, b) {
                var c = a._frameSize.width,
                    d = a._frameSize.height,
                    e = cc.container.style,
                    n = b.width,
                    p = b.height,
                    r = c / n,
                    q = d / p,
                    s, t;
                r < q ? (s = c, t = p * r) : (s = n * q, t = d);
                n = Math.round((c - s) / 2);
                t = Math.round((d - t) / 2);
                this._setupContainer(a, c - 2 * n, d - 2 * t);
                e.marginLeft = n + "px";
                e.marginRight = n + "px";
                e.marginTop = t + "px";
                e.marginBottom = t + "px"
            }
        });
    a.extend({
        preApply: function (a) {
            this._super(a);
            a._frame = document.documentElement
        },
        apply: function (a) {
            this._super(a);
            this._fixContainer()
        }
    });
    b.extend({
        preApply: function (a) {
            this._super(a);
            a._frame = document.documentElement
        },
        apply: function (a, b) {
            this._super(a, b);
            this._fixContainer()
        }
    });
    var c = cc.ContainerStrategy.extend({
        apply: function (a) {
            this._setupContainer(a, cc._canvas.width, cc._canvas.height)
        }
    });
    cc.ContainerStrategy.EQUAL_TO_FRAME = new a;
    cc.ContainerStrategy.PROPORTION_TO_FRAME = new b;
    cc.ContainerStrategy.ORIGINAL_CONTAINER = new c;
    var a = cc.ContentStrategy.extend({
            apply: function (a,
                b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height;
                return this._buildResult(c, d, c, d, c / b.width, d / b.height)
            }
        }),
        b = cc.ContentStrategy.extend({
            apply: function (a, b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height,
                    e = b.width,
                    n = b.height,
                    p = c / e,
                    r = d / n,
                    q = 0,
                    s, t;
                p < r ? (q = p, s = c, t = n * q) : (q = r, s = e * q, t = d);
                return this._buildResult(c, d, s, t, q, q)
            }
        }),
        c = cc.ContentStrategy.extend({
            apply: function (a, b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height,
                    e = b.width,
                    n = b.height,
                    p = c / e,
                    r = d / n,
                    q, s, t;
                p < r ? (q = r, s = e * q, t = d) : (q = p, s = c, t = n * q);
                return this._buildResult(c,
                    d, s, t, q, q)
            }
        }),
        d = cc.ContentStrategy.extend({
            apply: function (a, b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height,
                    e = d / b.height;
                return this._buildResult(c, d, c, d, e, e)
            },
            postApply: function (a) {
                cc.director._winSizeInPoints = a.getVisibleSize()
            }
        }),
        e = cc.ContentStrategy.extend({
            apply: function (a, b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height,
                    e = c / b.width;
                return this._buildResult(c, d, c, d, e, e)
            },
            postApply: function (a) {
                cc.director._winSizeInPoints = a.getVisibleSize()
            }
        });
    cc.ContentStrategy.EXACT_FIT = new a;
    cc.ContentStrategy.SHOW_ALL =
        new b;
    cc.ContentStrategy.NO_BORDER = new c;
    cc.ContentStrategy.FIXED_HEIGHT = new d;
    cc.ContentStrategy.FIXED_WIDTH = new e
})();
cc.ResolutionPolicy = cc.Class.extend({
    _containerStrategy: null,
    _contentStrategy: null,
    ctor: function (a, b) {
        this.setContainerStrategy(a);
        this.setContentStrategy(b)
    },
    preApply: function (a) {
        this._containerStrategy.preApply(a);
        this._contentStrategy.preApply(a)
    },
    apply: function (a, b) {
        this._containerStrategy.apply(a, b);
        return this._contentStrategy.apply(a, b)
    },
    postApply: function (a) {
        this._containerStrategy.postApply(a);
        this._contentStrategy.postApply(a)
    },
    setContainerStrategy: function (a) {
        a instanceof cc.ContainerStrategy &&
            (this._containerStrategy = a)
    },
    setContentStrategy: function (a) {
        a instanceof cc.ContentStrategy && (this._contentStrategy = a)
    }
});
cc.ResolutionPolicy.EXACT_FIT = 0;
cc.ResolutionPolicy.NO_BORDER = 1;
cc.ResolutionPolicy.SHOW_ALL = 2;
cc.ResolutionPolicy.FIXED_HEIGHT = 3;
cc.ResolutionPolicy.FIXED_WIDTH = 4;
cc.ResolutionPolicy.UNKNOWN = 5;
cc.screen = {
    _supportsFullScreen: !1,
    _preOnFullScreenChange: null,
    _touchEvent: "",
    _fn: null,
    _fnMap: [
        ["requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement"],
        ["requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement"],
        ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement"],
        ["mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen",
            "mozFullScreenElement"
        ],
        ["msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement"]
    ],
    init: function () {
        this._fn = {};
        var a, b, c = this._fnMap,
            d;
        a = 0;
        for (l = c.length; a < l; a++)
            if ((b = c[a]) && b[1] in document) {
                a = 0;
                for (d = b.length; a < d; a++) this._fn[c[0][a]] = b[a];
                break
            }
        this._supportsFullScreen = void 0 != this._fn.requestFullscreen;
        this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown"
    },
    fullScreen: function () {
        return this._supportsFullScreen && document[this._fn.fullscreenEnabled]
    },
    requestFullScreen: function (a, b) {
        if (this._supportsFullScreen) {
            a = a || document.documentElement;
            a[this._fn.requestFullscreen]();
            if (b) {
                var c = this._fn.fullscreenchange;
                this._preOnFullScreenChange && document.removeEventListener(c, this._preOnFullScreenChange);
                this._preOnFullScreenChange = b;
                document.addEventListener(c, b, !1)
            }
            return a[this._fn.requestFullscreen]()
        }
    },
    exitFullScreen: function () {
        return this._supportsFullScreen ? document[this._fn.exitFullscreen]() : !0
    },
    autoFullScreen: function (a, b) {
        function c() {
            e.requestFullScreen(a,
                b);
            d.removeEventListener(e._touchEvent, c)
        }
        a = a || document.body;
        var d = cc._canvas || a,
            e = this;
        this.requestFullScreen(a, b);
        d.addEventListener(this._touchEvent, c)
    }
};
cc.screen.init();
cc.visibleRect = {
    _topLeft: cc.p(0, 0),
    _topRight: cc.p(0, 0),
    _top: cc.p(0, 0),
    _bottomLeft: cc.p(0, 0),
    _bottomRight: cc.p(0, 0),
    _bottom: cc.p(0, 0),
    _center: cc.p(0, 0),
    _left: cc.p(0, 0),
    _right: cc.p(0, 0),
    _width: 0,
    _height: 0,
    init: function (a) {
        this._width = a.width;
        this._height = a.height;
        a = this._width;
        var b = this._height;
        this._topLeft.y = b;
        this._topRight.x = a;
        this._topRight.y = b;
        this._top.x = a / 2;
        this._top.y = b;
        this._bottomRight.x = a;
        this._bottom.x = a / 2;
        this._center.x = a / 2;
        this._center.y = b / 2;
        this._left.y = b / 2;
        this._right.x = a;
        this._right.y =
            b / 2
    }
};
cc.defineGetterSetter(cc.visibleRect, "width", function () {
    return this._width
});
cc.defineGetterSetter(cc.visibleRect, "height", function () {
    return this._height
});
cc.defineGetterSetter(cc.visibleRect, "topLeft", function () {
    return this._topLeft
});
cc.defineGetterSetter(cc.visibleRect, "topRight", function () {
    return this._topRight
});
cc.defineGetterSetter(cc.visibleRect, "top", function () {
    return this._top
});
cc.defineGetterSetter(cc.visibleRect, "bottomLeft", function () {
    return this._bottomLeft
});
cc.defineGetterSetter(cc.visibleRect, "bottomRight", function () {
    return this._bottomRight
});
cc.defineGetterSetter(cc.visibleRect, "bottom", function () {
    return this._bottom
});
cc.defineGetterSetter(cc.visibleRect, "center", function () {
    return this._center
});
cc.defineGetterSetter(cc.visibleRect, "left", function () {
    return this._left
});
cc.defineGetterSetter(cc.visibleRect, "right", function () {
    return this._right
});
cc.UIInterfaceOrientationLandscapeLeft = -90;
cc.UIInterfaceOrientationLandscapeRight = 90;
cc.UIInterfaceOrientationPortraitUpsideDown = 180;
cc.UIInterfaceOrientationPortrait = 0;
cc.inputManager = {
    _mousePressed: !1,
    _isRegisterEvent: !1,
    _preTouchPoint: cc.p(0, 0),
    _prevMousePoint: cc.p(0, 0),
    _preTouchPool: [],
    _preTouchPoolPointer: 0,
    _touches: [],
    _touchesIntegerDict: {},
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _accelEnabled: !1,
    _accelInterval: 1 / 30,
    _accelMinus: 1,
    _accelCurTime: 0,
    _acceleration: null,
    _accelDeviceEvent: null,
    setAccelerometerEnabled: function (a) {
        this._accelEnabled !== a && (this._accelEnabled = a, a = cc.director.getScheduler(), this._accelEnabled ? (this._accelCurTime = 0, a.scheduleUpdateForTarget(this)) :
            (this._accelCurTime = 0, a.unscheduleUpdateForTarget(this)))
    },
    setAccelerometerInterval: function (a) {
        this._accelInterval !== a && (this._accelInterval = a)
    },
    _getUnUsedIndex: function () {
        for (var a = this._indexBitsUsed, b = 0; b < this._maxTouches; b++) {
            if (!(a & 1)) return this._indexBitsUsed |= 1 << b, b;
            a >>= 1
        }
        return -1
    },
    _removeUsedIndexBit: function (a) {
        0 > a || a >= this._maxTouches || (a = ~(1 << a), this._indexBitsUsed &= a)
    },
    _glView: null,
    handleTouchesBegin: function (a) {
        for (var b, c, d, e = [], f = this._touchesIntegerDict, g = 0, h = a.length; g < h; g++) b =
            a[g], d = b.getID(), c = f[d], null == c && (c = this._getUnUsedIndex(), -1 == c ? cc.log("The touches is more than MAX_TOUCHES, nUnusedIndex \x3d " + c) : (b = this._touches[c] = b, f[d] = c, e.push(b)));
        0 < e.length && (this._glView._convertTouchesWithScale(e), a = new cc.EventTouch(e), a._eventCode = cc.EventTouch.EventCode.BEGAN, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesMove: function (a) {
        for (var b, c, d = [], e = this._touches, f = 0, g = a.length; f < g; f++) b = a[f], c = b.getID(), c = this._touchesIntegerDict[c], null != c && e[c] && (e[c]._setPoint(b._point),
            e[c]._setPrevPoint(b._prevPoint), d.push(e[c]));
        0 < d.length && (this._glView._convertTouchesWithScale(d), a = new cc.EventTouch(d), a._eventCode = cc.EventTouch.EventCode.MOVED, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesEnd: function (a) {
        a = this.getSetOfTouchesEndOrCancel(a);
        0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.ENDED, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesCancel: function (a) {
        a = this.getSetOfTouchesEndOrCancel(a);
        0 < a.length &&
            (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.CANCELLED, cc.eventManager.dispatchEvent(a))
    },
    getSetOfTouchesEndOrCancel: function (a) {
        for (var b, c, d, e = [], f = this._touches, g = this._touchesIntegerDict, h = 0, k = a.length; h < k; h++) b = a[h], d = b.getID(), c = g[d], null != c && f[c] && (f[c]._setPoint(b._point), f[c]._setPrevPoint(b._prevPoint), e.push(f[c]), this._removeUsedIndexBit(c), delete g[d]);
        return e
    },
    getHTMLElementPosition: function (a) {
        var b = document.documentElement,
            c = window,
            d = null,
            d = "function" === typeof a.getBoundingClientRect ? a.getBoundingClientRect() : a instanceof HTMLCanvasElement ? {
                left: 0,
                top: 0,
                width: a.width,
                height: a.height
            } : {
                left: 0,
                top: 0,
                width: parseInt(a.style.width),
                height: parseInt(a.style.height)
            };
        return {
            left: d.left + c.pageXOffset - b.clientLeft,
            top: d.top + c.pageYOffset - b.clientTop,
            width: d.width,
            height: d.height
        }
    },
    getPreTouch: function (a) {
        for (var b = null, c = this._preTouchPool, d = a.getId(), e = c.length - 1; 0 <= e; e--)
            if (c[e].getId() == d) {
                b = c[e];
                break
            }
        b || (b = a);
        return b
    },
    setPreTouch: function (a) {
        for (var b = !1, c = this._preTouchPool, d = a.getId(), e = c.length - 1; 0 <= e; e--)
            if (c[e].getId() == d) {
                c[e] = a;
                b = !0;
                break
            }
        b || (50 >= c.length ? c.push(a) : (c[this._preTouchPoolPointer] = a, this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50))
    },
    getTouchByXY: function (a, b, c) {
        var d = this._preTouchPoint;
        a = this._glView.convertToLocationInView(a, b, c);
        b = new cc.Touch(a.x, a.y);
        b._setPrevPoint(d.x, d.y);
        d.x = a.x;
        d.y = a.y;
        return b
    },
    getMouseEvent: function (a, b, c) {
        var d = this._prevMousePoint;
        this._glView._convertMouseToLocationInView(a,
            b);
        b = new cc.EventMouse(c);
        b.setLocation(a.x, a.y);
        b._setPrevCursor(d.x, d.y);
        d.x = a.x;
        d.y = a.y;
        return b
    },
    getPointByEvent: function (a, b) {
        if (null != a.pageX) return {
            x: a.pageX,
            y: a.pageY
        };
        b.left -= document.body.scrollLeft;
        b.top -= document.body.scrollTop;
        return {
            x: a.clientX,
            y: a.clientY
        }
    },
    getTouchesByEvent: function (a, b) {
        for (var c = [], d = this._glView, e, f, g = this._preTouchPoint, h = a.changedTouches.length, k = 0; k < h; k++)
            if (e = a.changedTouches[k]) {
                var m = d.convertToLocationInView(e.clientX, e.clientY, b);
                null != e.identifier ? (e = new cc.Touch(m.x,
                    m.y, e.identifier), f = this.getPreTouch(e).getLocation(), e._setPrevPoint(f.x, f.y), this.setPreTouch(e)) : (e = new cc.Touch(m.x, m.y), e._setPrevPoint(g.x, g.y));
                g.x = m.x;
                g.y = m.y;
                c.push(e)
            }
        return c
    },
    registerSystemEvent: function (a) {
        if (!this._isRegisterEvent) {
            var b = this._glView = cc.view,
                c = this,
                d = "touches" in cc.sys.capabilities;
            "mouse" in cc.sys.capabilities && (window.addEventListener("mousedown", function () {
                c._mousePressed = !0
            }, !1), window.addEventListener("mouseup", function (b) {
                var e = c._mousePressed;
                c._mousePressed = !1;
                if (e) {
                    var e = c.getHTMLElementPosition(a),
                        f = c.getPointByEvent(b, e);
                    cc.rectContainsPoint(new cc.Rect(e.left, e.top, e.width, e.height), f) || (d || c.handleTouchesEnd([c.getTouchByXY(f.x, f.y, e)]), e = c.getMouseEvent(f, e, cc.EventMouse.UP), e.setButton(b.button), cc.eventManager.dispatchEvent(e))
                }
            }, !1), a.addEventListener("mousedown", function (b) {
                c._mousePressed = !0;
                var e = c.getHTMLElementPosition(a),
                    f = c.getPointByEvent(b, e);
                d || c.handleTouchesBegin([c.getTouchByXY(f.x, f.y, e)]);
                e = c.getMouseEvent(f, e, cc.EventMouse.DOWN);
                e.setButton(b.button);
                cc.eventManager.dispatchEvent(e);
                b.stopPropagation();
                b.preventDefault()
            }, !1), a.addEventListener("mouseup", function (b) {
                c._mousePressed = !1;
                var e = c.getHTMLElementPosition(a),
                    f = c.getPointByEvent(b, e);
                d || c.handleTouchesEnd([c.getTouchByXY(f.x, f.y, e)]);
                e = c.getMouseEvent(f, e, cc.EventMouse.UP);
                e.setButton(b.button);
                cc.eventManager.dispatchEvent(e);
                b.stopPropagation();
                b.preventDefault()
            }, !1), a.addEventListener("mousemove", function (b) {
                if (c._mousePressed) {
                    var e = c.getHTMLElementPosition(a),
                        f = c.getPointByEvent(b, e);
                    d || c.handleTouchesMove([c.getTouchByXY(f.x, f.y, e)]);
                    e = c.getMouseEvent(f, e, cc.EventMouse.MOVE);
                    e.setButton(b.button);
                    cc.eventManager.dispatchEvent(e);
                    b.stopPropagation();
                    b.preventDefault()
                }
            }, !1), a.addEventListener("mousewheel", function (b) {
                var d = c.getHTMLElementPosition(a),
                    e = c.getPointByEvent(b, d),
                    d = c.getMouseEvent(e, d, cc.EventMouse.SCROLL);
                d.setButton(b.button);
                d.setScrollData(0, b.wheelDelta);
                cc.eventManager.dispatchEvent(d);
                b.stopPropagation();
                b.preventDefault()
            }, !1), a.addEventListener("DOMMouseScroll",
                function (b) {
                    var d = c.getHTMLElementPosition(a),
                        e = c.getPointByEvent(b, d),
                        d = c.getMouseEvent(e, d, cc.EventMouse.SCROLL);
                    d.setButton(b.button);
                    d.setScrollData(0, -120 * b.detail);
                    cc.eventManager.dispatchEvent(d);
                    b.stopPropagation();
                    b.preventDefault()
                }, !1));
            if (window.navigator.msPointerEnabled) {
                var e = {
                        MSPointerDown: "handleTouchesBegin",
                        MSPointerMove: "handleTouchesMove",
                        MSPointerUp: "handleTouchesEnd",
                        MSPointerCancel: "handleTouchesCancel"
                    },
                    f;
                for (f in e)(function (b, d) {
                    a.addEventListener(b, function (b) {
                        var e = c.getHTMLElementPosition(a);
                        e.left -= document.body.scrollLeft;
                        e.top -= document.body.scrollTop;
                        c[d]([c.getTouchByXY(b.clientX, b.clientY, e)]);
                        b.stopPropagation();
                        b.preventDefault()
                    }, !1)
                })(f, e[f])
            }
            d && (a.addEventListener("touchstart", function (b) {
                if (b.changedTouches) {
                    var d = c.getHTMLElementPosition(a);
                    d.left -= document.body.scrollLeft;
                    d.top -= document.body.scrollTop;
                    c.handleTouchesBegin(c.getTouchesByEvent(b, d));
                    b.stopPropagation();
                    b.preventDefault()
                }
            }, !1), a.addEventListener("touchmove", function (b) {
                if (b.changedTouches) {
                    var d = c.getHTMLElementPosition(a);
                    d.left -= document.body.scrollLeft;
                    d.top -= document.body.scrollTop;
                    c.handleTouchesMove(c.getTouchesByEvent(b, d));
                    b.stopPropagation();
                    b.preventDefault()
                }
            }, !1), a.addEventListener("touchend", function (b) {
                if (b.changedTouches) {
                    var d = c.getHTMLElementPosition(a);
                    d.left -= document.body.scrollLeft;
                    d.top -= document.body.scrollTop;
                    c.handleTouchesEnd(c.getTouchesByEvent(b, d));
                    b.stopPropagation();
                    b.preventDefault()
                }
            }, !1), a.addEventListener("touchcancel", function (d) {
                if (d.changedTouches) {
                    var e = c.getHTMLElementPosition(a);
                    e.left -= document.body.scrollLeft;
                    e.top -= document.body.scrollTop;
                    b.handleTouchesCancel(c.getTouchesByEvent(d, e));
                    d.stopPropagation();
                    d.preventDefault()
                }
            }, !1));
            this._registerKeyboardEvent();
            this._registerAccelerometerEvent();
            this._isRegisterEvent = !0
        }
    },
    _registerKeyboardEvent: function () {
        document.addEventListener("keydown", function (a) {
            cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !0))
        });
        document.addEventListener("keyup", function (a) {
            cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !1))
        })
    },
    _registerAccelerometerEvent: function () {
        this._acceleration = new cc.Acceleration;
        var a = window;
        this._accelDeviceEvent = a.DeviceMotionEvent || a.DeviceOrientationEvent;
        cc.sys.browserType == cc.sys.BROWSER_TYPE_MOBILE_QQ && (this._accelDeviceEvent = window.DeviceOrientationEvent);
        var b = this._accelDeviceEvent == a.DeviceMotionEvent ? "devicemotion" : "deviceorientation",
            c = navigator.userAgent;
        if (/Android/.test(c) || /Adr/.test(c) && cc.sys.browserType == cc.BROWSER_TYPE_UC) this._minus = -1;
        a.addEventListener(b, this.didAccelerate.bind(this), !1)
    },
    didAccelerate: function (a) {
        if (this._accelEnabled) {
            var b = this._acceleration;
            if (this._accelDeviceEvent == window.DeviceMotionEvent) {
                var c = a.accelerationIncludingGravity;
                b.x = this._accelMinus * c.x * 0.1;
                b.y = this._accelMinus * c.y * 0.1;
                b.z = 0.1 * c.z
            } else b.x = a.gamma / 90 * 0.981, b.y = 0.981 * -(a.beta / 90), b.z = a.alpha / 90 * 0.981;
            b.timestamp = a.timeStamp || Date.now();
            a = b.x;
            switch (window.orientation) {
            case cc.UIInterfaceOrientationLandscapeRight:
                b.x = -b.y;
                b.y = a;
                break;
            case cc.UIInterfaceOrientationLandscapeLeft:
                b.x = b.y;
                b.y = -a;
                break;
            case cc.UIInterfaceOrientationPortraitUpsideDown:
                b.x = -b.x, b.y = -b.y
            }
        }
    },
    update: function (a) {
        this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval, cc.eventManager.dispatchEvent(new cc.EventAcceleration(this._acceleration)));
        this._accelCurTime += a
    }
};
cc.AffineTransform = function (a, b, c, d, e, f) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = e;
    this.ty = f
};
cc.__AffineTransformMake = function (a, b, c, d, e, f) {
    return {
        a: a,
        b: b,
        c: c,
        d: d,
        tx: e,
        ty: f
    }
};
cc.AffineTransformMake = function (a, b, c, d, e, f) {
    return {
        a: a,
        b: b,
        c: c,
        d: d,
        tx: e,
        ty: f
    }
};
cc.__PointApplyAffineTransform = function (a, b) {
    return {
        x: b.a * a.x + b.c * a.y + b.tx,
        y: b.b * a.x + b.d * a.y + b.ty
    }
};
cc.PointApplyAffineTransform = function (a, b) {
    return {
        x: b.a * a.x + b.c * a.y + b.tx,
        y: b.b * a.x + b.d * a.y + b.ty
    }
};
cc._PointApplyAffineTransform = function (a, b, c) {
    return {
        x: c.a * a + c.c * b + c.tx,
        y: c.b * a + c.d * b + c.ty
    }
};
cc.__SizeApplyAffineTransform = function (a, b) {
    return {
        width: b.a * a.width + b.c * a.height,
        height: b.b * a.width + b.d * a.height
    }
};
cc.SizeApplyAffineTransform = function (a, b) {
    return {
        width: b.a * a.width + b.c * a.height,
        height: b.b * a.width + b.d * a.height
    }
};
cc.AffineTransformMakeIdentity = function () {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }
};
cc.AffineTransformIdentity = function () {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }
};
cc.RectApplyAffineTransform = function (a, b) {
    var c = cc.rectGetMinY(a),
        d = cc.rectGetMinX(a),
        e = cc.rectGetMaxX(a),
        f = cc.rectGetMaxY(a),
        g = cc._PointApplyAffineTransform(d, c, b),
        c = cc._PointApplyAffineTransform(e, c, b),
        d = cc._PointApplyAffineTransform(d, f, b),
        h = cc._PointApplyAffineTransform(e, f, b),
        e = Math.min(g.x, c.x, d.x, h.x),
        f = Math.max(g.x, c.x, d.x, h.x),
        k = Math.min(g.y, c.y, d.y, h.y),
        g = Math.max(g.y, c.y, d.y, h.y);
    return cc.rect(e, k, f - e, g - k)
};
cc._RectApplyAffineTransformIn = function (a, b) {
    var c = cc.rectGetMinY(a),
        d = cc.rectGetMinX(a),
        e = cc.rectGetMaxX(a),
        f = cc.rectGetMaxY(a),
        g = cc._PointApplyAffineTransform(d, c, b),
        c = cc._PointApplyAffineTransform(e, c, b),
        d = cc._PointApplyAffineTransform(d, f, b),
        h = cc._PointApplyAffineTransform(e, f, b),
        e = Math.min(g.x, c.x, d.x, h.x),
        f = Math.max(g.x, c.x, d.x, h.x),
        k = Math.min(g.y, c.y, d.y, h.y),
        g = Math.max(g.y, c.y, d.y, h.y);
    a.x = e;
    a.y = k;
    a.width = f - e;
    a.height = g - k;
    return a
};
cc.AffineTransformTranslate = function (a, b, c) {
    return {
        a: a.a,
        b: a.b,
        c: a.c,
        d: a.d,
        tx: a.tx + a.a * b + a.c * c,
        ty: a.ty + a.b * b + a.d * c
    }
};
cc.AffineTransformScale = function (a, b, c) {
    return {
        a: a.a * b,
        b: a.b * b,
        c: a.c * c,
        d: a.d * c,
        tx: a.tx,
        ty: a.ty
    }
};
cc.AffineTransformRotate = function (a, b) {
    var c = Math.sin(b),
        d = Math.cos(b);
    return {
        a: a.a * d + a.c * c,
        b: a.b * d + a.d * c,
        c: a.c * d - a.a * c,
        d: a.d * d - a.b * c,
        tx: a.tx,
        ty: a.ty
    }
};
cc.AffineTransformConcat = function (a, b) {
    return {
        a: a.a * b.a + a.b * b.c,
        b: a.a * b.b + a.b * b.d,
        c: a.c * b.a + a.d * b.c,
        d: a.c * b.b + a.d * b.d,
        tx: a.tx * b.a + a.ty * b.c + b.tx,
        ty: a.tx * b.b + a.ty * b.d + b.ty
    }
};
cc.AffineTransformEqualToTransform = function (a, b) {
    return a.a === b.a && a.b === b.b && a.c === b.c && a.d === b.d && a.tx === b.tx && a.ty === b.ty
};
cc.AffineTransformInvert = function (a) {
    var b = 1 / (a.a * a.d - a.b * a.c);
    return {
        a: b * a.d,
        b: -b * a.b,
        c: -b * a.c,
        d: b * a.a,
        tx: b * (a.c * a.ty - a.d * a.tx),
        ty: b * (a.b * a.tx - a.a * a.ty)
    }
};
cc.POINT_EPSILON = parseFloat("1.192092896e-07F");
cc.pNeg = function (a) {
    return cc.p(-a.x, -a.y)
};
cc.pAdd = function (a, b) {
    return cc.p(a.x + b.x, a.y + b.y)
};
cc.pSub = function (a, b) {
    return cc.p(a.x - b.x, a.y - b.y)
};
cc.pMult = function (a, b) {
    return cc.p(a.x * b, a.y * b)
};
cc.pMidpoint = function (a, b) {
    return cc.pMult(cc.pAdd(a, b), 0.5)
};
cc.pDot = function (a, b) {
    return a.x * b.x + a.y * b.y
};
cc.pCross = function (a, b) {
    return a.x * b.y - a.y * b.x
};
cc.pPerp = function (a) {
    return cc.p(-a.y, a.x)
};
cc.pRPerp = function (a) {
    return cc.p(a.y, -a.x)
};
cc.pProject = function (a, b) {
    return cc.pMult(b, cc.pDot(a, b) / cc.pDot(b, b))
};
cc.pRotate = function (a, b) {
    return cc.p(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x)
};
cc.pUnrotate = function (a, b) {
    return cc.p(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y)
};
cc.pLengthSQ = function (a) {
    return cc.pDot(a, a)
};
cc.pDistanceSQ = function (a, b) {
    return cc.pLengthSQ(cc.pSub(a, b))
};
cc.pLength = function (a) {
    return Math.sqrt(cc.pLengthSQ(a))
};
cc.pDistance = function (a, b) {
    return cc.pLength(cc.pSub(a, b))
};
cc.pNormalize = function (a) {
    return cc.pMult(a, 1 / cc.pLength(a))
};
cc.pForAngle = function (a) {
    return cc.p(Math.cos(a), Math.sin(a))
};
cc.pToAngle = function (a) {
    return Math.atan2(a.y, a.x)
};
cc.clampf = function (a, b, c) {
    if (b > c) {
        var d = b;
        b = c;
        c = d
    }
    return a < b ? b : a < c ? a : c
};
cc.pClamp = function (a, b, c) {
    return cc.p(cc.clampf(a.x, b.x, c.x), cc.clampf(a.y, b.y, c.y))
};
cc.pFromSize = function (a) {
    return cc.p(a.width, a.height)
};
cc.pCompOp = function (a, b) {
    return cc.p(b(a.x), b(a.y))
};
cc.pLerp = function (a, b, c) {
    return cc.pAdd(cc.pMult(a, 1 - c), cc.pMult(b, c))
};
cc.pFuzzyEqual = function (a, b, c) {
    return a.x - c <= b.x && b.x <= a.x + c && a.y - c <= b.y && b.y <= a.y + c ? !0 : !1
};
cc.pCompMult = function (a, b) {
    return cc.p(a.x * b.x, a.y * b.y)
};
cc.pAngleSigned = function (a, b) {
    var c = cc.pNormalize(a),
        d = cc.pNormalize(b),
        c = Math.atan2(c.x * d.y - c.y * d.x, cc.pDot(c, d));
    return Math.abs(c) < cc.POINT_EPSILON ? 0 : c
};
cc.pAngle = function (a, b) {
    var c = Math.acos(cc.pDot(cc.pNormalize(a), cc.pNormalize(b)));
    return Math.abs(c) < cc.POINT_EPSILON ? 0 : c
};
cc.pRotateByAngle = function (a, b, c) {
    a = cc.pSub(a, b);
    var d = Math.cos(c);
    c = Math.sin(c);
    var e = a.x;
    a.x = e * d - a.y * c + b.x;
    a.y = e * c + a.y * d + b.y;
    return a
};
cc.pLineIntersect = function (a, b, c, d, e) {
    if (a.x == b.x && a.y == b.y || c.x == d.x && c.y == d.y) return !1;
    var f = b.x - a.x;
    b = b.y - a.y;
    var g = d.x - c.x;
    d = d.y - c.y;
    var h = a.x - c.x;
    a = a.y - c.y;
    c = d * f - g * b;
    e.x = g * a - d * h;
    e.y = f * a - b * h;
    if (0 == c) return 0 == e.x || 0 == e.y ? !0 : !1;
    e.x /= c;
    e.y /= c;
    return !0
};
cc.pSegmentIntersect = function (a, b, c, d) {
    var e = cc.p(0, 0);
    return cc.pLineIntersect(a, b, c, d, e) && 0 <= e.x && 1 >= e.x && 0 <= e.y && 1 >= e.y ? !0 : !1
};
cc.pIntersectPoint = function (a, b, c, d) {
    var e = cc.p(0, 0);
    return cc.pLineIntersect(a, b, c, d, e) ? (c = cc.p(0, 0), c.x = a.x + e.x * (b.x - a.x), c.y = a.y + e.x * (b.y - a.y), c) : cc.p(0, 0)
};
cc.pSameAs = function (a, b) {
    return null != a && null != b ? a.x == b.x && a.y == b.y : !1
};
cc.pZeroIn = function (a) {
    a.x = 0;
    a.y = 0
};
cc.pIn = function (a, b) {
    a.x = b.x;
    a.y = b.y
};
cc.pMultIn = function (a, b) {
    a.x *= b;
    a.y *= b
};
cc.pSubIn = function (a, b) {
    a.x -= b.x;
    a.y -= b.y
};
cc.pAddIn = function (a, b) {
    a.x += b.x;
    a.y += b.y
};
cc.pNormalizeIn = function (a) {
    cc.pMultIn(a, 1 / Math.sqrt(a.x * a.x + a.y * a.y))
};
cc.vertexLineToPolygon = function (a, b, c, d, e) {
    e += d;
    if (!(1 >= e)) {
        b *= 0.5;
        for (var f, g = e - 1, h = d; h < e; h++) {
            f = 2 * h;
            var k = cc.p(a[2 * h], a[2 * h + 1]),
                m;
            if (0 === h) m = cc.pPerp(cc.pNormalize(cc.pSub(k, cc.p(a[2 * (h + 1)], a[2 * (h + 1) + 1]))));
            else if (h === g) m = cc.pPerp(cc.pNormalize(cc.pSub(cc.p(a[2 * (h - 1)], a[2 * (h - 1) + 1]), k)));
            else {
                m = cc.p(a[2 * (h - 1)], a[2 * (h - 1) + 1]);
                var n = cc.p(a[2 * (h + 1)], a[2 * (h + 1) + 1]),
                    p = cc.pNormalize(cc.pSub(n, k)),
                    r = cc.pNormalize(cc.pSub(m, k)),
                    q = Math.acos(cc.pDot(p, r));
                m = q < cc.DEGREES_TO_RADIANS(70) ? cc.pPerp(cc.pNormalize(cc.pMidpoint(p,
                    r))) : q < cc.DEGREES_TO_RADIANS(170) ? cc.pNormalize(cc.pMidpoint(p, r)) : cc.pPerp(cc.pNormalize(cc.pSub(n, m)))
            }
            m = cc.pMult(m, b);
            c[2 * f] = k.x + m.x;
            c[2 * f + 1] = k.y + m.y;
            c[2 * (f + 1)] = k.x - m.x;
            c[2 * (f + 1) + 1] = k.y - m.y
        }
        for (h = 0 == d ? 0 : d - 1; h < g; h++) f = 2 * h, a = f + 2, b = cc.Vertex2(c[2 * f], c[2 * f + 1]), e = cc.Vertex2(c[2 * (f + 1)], c[2 * (f + 1) + 1]), f = cc.Vertex2(c[2 * a], c[2 * a]), d = cc.Vertex2(c[2 * (a + 1)], c[2 * (a + 1) + 1]), b = !cc.vertexLineIntersect(b.x, b.y, d.x, d.y, e.x, e.y, f.x, f.y), !b.isSuccess && (0 > b.value || 1 < b.value) && (b.isSuccess = !0), b.isSuccess && (c[2 * a] = d.x,
            c[2 * a + 1] = d.y, c[2 * (a + 1)] = f.x, c[2 * (a + 1) + 1] = f.y)
    }
};
cc.vertexLineIntersect = function (a, b, c, d, e, f, g, h) {
    if (a == c && b == d || e == g && f == h) return {
        isSuccess: !1,
        value: 0
    };
    c -= a;
    d -= b;
    e -= a;
    f -= b;
    g -= a;
    h -= b;
    a = Math.sqrt(c * c + d * d);
    c /= a;
    d /= a;
    b = e * c + f * d;
    f = f * c - e * d;
    e = b;
    b = g * c + h * d;
    h = h * c - g * d;
    g = b;
    return f == h ? {
        isSuccess: !1,
        value: 0
    } : {
        isSuccess: !0,
        value: (g + (e - g) * h / (h - f)) / a
    }
};
cc.CGAffineToGL = function (a, b) {
    b[2] = b[3] = b[6] = b[7] = b[8] = b[9] = b[11] = b[14] = 0;
    b[10] = b[15] = 1;
    b[0] = a.a;
    b[4] = a.c;
    b[12] = a.tx;
    b[1] = a.b;
    b[5] = a.d;
    b[13] = a.ty
};
cc.GLToCGAffine = function (a, b) {
    b.a = a[0];
    b.c = a[4];
    b.tx = a[12];
    b.b = a[1];
    b.d = a[5];
    b.ty = a[13]
};
cc.Touch = cc.Class.extend({
    _point: null,
    _prevPoint: null,
    _id: 0,
    _startPointCaptured: !1,
    _startPoint: null,
    ctor: function (a, b, c) {
        this._point = cc.p(a || 0, b || 0);
        this._id = c || 0
    },
    getLocation: function () {
        return this._point
    },
    getLocationX: function () {
        return this._point.x
    },
    getLocationY: function () {
        return this._point.y
    },
    getPreviousLocation: function () {
        return this._prevPoint
    },
    getStartLocation: function () {
        return this._startPoint
    },
    getDelta: function () {
        return cc.pSub(this._point, this._prevPoint)
    },
    getLocationInView: function () {
        return this._point
    },
    getPreviousLocationInView: function () {
        return this._prevPoint
    },
    getStartLocationInView: function () {
        return this._startPoint
    },
    getID: function () {
        return this._id
    },
    getId: function () {
        return this._id
    },
    setTouchInfo: function (a, b, c) {
        this._prevPoint = this._point;
        this._point = cc.p(b || 0, c || 0);
        this._id = a;
        this._startPointCaptured || (this._startPoint = cc.p(this._point), this._startPointCaptured = !0)
    },
    _setPoint: function (a, b) {
        void 0 === b ? (this._point.x = a.x, this._point.y = a.y) : (this._point.x = a, this._point.y = b)
    },
    _setPrevPoint: function (a,
        b) {
        this._prevPoint = void 0 === b ? cc.p(a.x, a.y) : cc.p(a || 0, b || 0)
    }
});
cc.Touch.ALL_AT_ONCE = 0;
cc.Touch.ONE_BY_ONE = 1;
cc.Event = cc.Class.extend({
    _type: 0,
    _isStopped: !1,
    _currentTarget: null,
    _setCurrentTarget: function (a) {
        this._currentTarget = a
    },
    ctor: function (a) {
        this._type = a
    },
    getType: function () {
        return this._type
    },
    stopPropagation: function () {
        this._isStopped = !0
    },
    isStopped: function () {
        return this._isStopped
    },
    getCurrentTarget: function () {
        return this._currentTarget
    }
});
cc.Event.TOUCH = 0;
cc.Event.KEYBOARD = 1;
cc.Event.ACCELERATION = 2;
cc.Event.MOUSE = 3;
cc.Event.CUSTOM = 4;
cc.EventAcceleration = cc.Event.extend({
    _acc: null,
    ctor: function (a) {
        cc.Event.prototype.ctor.call(this, cc.Event.ACCELERATION);
        this._acc = a
    }
});
cc.EventCustom = cc.Event.extend({
    _eventName: null,
    _userData: null,
    ctor: function (a) {
        cc.Event.prototype.ctor.call(this, cc.Event.CUSTOM);
        this._eventName = a
    },
    setUserData: function (a) {
        this._userData = a
    },
    getUserData: function () {
        return this._userData
    },
    getEventName: function () {
        return this._eventName
    }
});
cc.EventKeyboard = cc.Event.extend({
    _keyCode: 0,
    _isPressed: !1,
    ctor: function (a, b) {
        cc.Event.prototype.ctor.call(this, cc.Event.KEYBOARD);
        this._keyCode = a;
        this._isPressed = b
    }
});
cc.EventMouse = cc.Event.extend({
    _eventType: 0,
    _button: 0,
    _x: 0,
    _y: 0,
    _prevX: 0,
    _prevY: 0,
    _scrollX: 0,
    _scrollY: 0,
    ctor: function (a) {
        cc.Event.prototype.ctor.call(this, cc.Event.MOUSE);
        this._eventType = a
    },
    setScrollData: function (a, b) {
        this._scrollX = a;
        this._scrollY = b
    },
    getScrollX: function () {
        return this._scrollX
    },
    getScrollY: function () {
        return this._scrollY
    },
    setLocation: function (a, b) {
        this._x = a;
        this._y = b
    },
    getLocation: function () {
        return {
            x: this._x,
            y: this._y
        }
    },
    getLocationInView: function () {
        return {
            x: this._x,
            y: cc.view._designResolutionSize.height -
                this._y
        }
    },
    _setPrevCursor: function (a, b) {
        this._prevX = a;
        this._prevY = b
    },
    getDelta: function () {
        return {
            x: this._x - this._prevX,
            y: this._y - this._prevY
        }
    },
    getDeltaX: function () {
        return this._x - this._prevX
    },
    getDeltaY: function () {
        return this._y - this._prevY
    },
    setButton: function (a) {
        this._button = a
    },
    getButton: function () {
        return this._button
    },
    getLocationX: function () {
        return this._x
    },
    getLocationY: function () {
        return this._y
    }
});
cc.EventMouse.NONE = 0;
cc.EventMouse.DOWN = 1;
cc.EventMouse.UP = 2;
cc.EventMouse.MOVE = 3;
cc.EventMouse.SCROLL = 4;
cc.EventMouse.BUTTON_LEFT = 0;
cc.EventMouse.BUTTON_RIGHT = 2;
cc.EventMouse.BUTTON_MIDDLE = 1;
cc.EventMouse.BUTTON_4 = 3;
cc.EventMouse.BUTTON_5 = 4;
cc.EventMouse.BUTTON_6 = 5;
cc.EventMouse.BUTTON_7 = 6;
cc.EventMouse.BUTTON_8 = 7;
cc.EventTouch = cc.Event.extend({
    _eventCode: 0,
    _touches: null,
    ctor: function (a) {
        cc.Event.prototype.ctor.call(this, cc.Event.TOUCH);
        this._touches = a || []
    },
    getEventCode: function () {
        return this._eventCode
    },
    getTouches: function () {
        return this._touches
    },
    _setEventCode: function (a) {
        this._eventCode = a
    },
    _setTouches: function (a) {
        this._touches = a
    }
});
cc.EventTouch.MAX_TOUCHES = 5;
cc.EventTouch.EventCode = {
    BEGAN: 0,
    MOVED: 1,
    ENDED: 2,
    CANCELLED: 3
};
cc.EventListener = cc.Class.extend({
    _onEvent: null,
    _type: 0,
    _listenerID: null,
    _registered: !1,
    _fixedPriority: 0,
    _node: null,
    _paused: !1,
    ctor: function (a, b, c) {
        this._onEvent = c;
        this._type = a || 0;
        this._listenerID = b || ""
    },
    _setPaused: function (a) {
        this._paused = a
    },
    _isPaused: function () {
        return this._paused
    },
    _setRegistered: function (a) {
        this._registered = a
    },
    _isRegistered: function () {
        return this._registered
    },
    _getType: function () {
        return this._type
    },
    _getListenerID: function () {
        return this._listenerID
    },
    _setFixedPriority: function (a) {
        this._fixedPriority =
            a
    },
    _getFixedPriority: function () {
        return this._fixedPriority
    },
    _setSceneGraphPriority: function (a) {
        this._node = a
    },
    _getSceneGraphPriority: function () {
        return this._node
    },
    checkAvailable: function () {
        return null != this._onEvent
    },
    clone: function () {
        return null
    },
    retain: function () {},
    release: function () {}
});
cc.EventListener.UNKNOWN = 0;
cc.EventListener.TOUCH_ONE_BY_ONE = 1;
cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
cc.EventListener.KEYBOARD = 3;
cc.EventListener.MOUSE = 4;
cc.EventListener.ACCELERATION = 5;
cc.EventListener.CUSTOM = 6;
cc._EventListenerCustom = cc.EventListener.extend({
    _onCustomEvent: null,
    ctor: function (a, b) {
        this._onCustomEvent = b;
        var c = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, a, function (a) {
            null != c._onCustomEvent && c._onCustomEvent(a)
        })
    },
    checkAvailable: function () {
        return cc.EventListener.prototype.checkAvailable.call(this) && null != this._onCustomEvent
    },
    clone: function () {
        return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent)
    }
});
cc._EventListenerCustom.create = function (a, b) {
    return new cc._EventListenerCustom(a, b)
};
cc._EventListenerAcceleration = cc.EventListener.extend({
    _onAccelerationEvent: null,
    ctor: function (a) {
        this._onAccelerationEvent = a;
        var b = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.ACCELERATION, cc._EventListenerAcceleration.LISTENER_ID, function (a) {
            b._onAccelerationEvent(a._acc, a)
        })
    },
    checkAvailable: function () {
        if (!this._onAccelerationEvent) throw "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil";
        return !0
    },
    clone: function () {
        return new cc._EventListenerAcceleration(this._onAccelerationEvent)
    }
});
cc._EventListenerAcceleration.LISTENER_ID = "__cc_acceleration";
cc._EventListenerAcceleration.create = function (a) {
    return new cc._EventListenerAcceleration(a)
};
cc._EventListenerKeyboard = cc.EventListener.extend({
    onKeyPressed: null,
    onKeyReleased: null,
    ctor: function () {
        var a = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.KEYBOARD, cc._EventListenerKeyboard.LISTENER_ID, function (b) {
            if (b._isPressed) {
                if (a.onKeyPressed) a.onKeyPressed(b._keyCode, b)
            } else if (a.onKeyReleased) a.onKeyReleased(b._keyCode, b)
        })
    },
    clone: function () {
        var a = new cc._EventListenerKeyboard;
        a.onKeyPressed = this.onKeyPressed;
        a.onKeyReleased = this.onKeyReleased;
        return a
    },
    checkAvailable: function () {
        return null ==
            this.onKeyPressed && null == this.onKeyReleased ? (cc.log("cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!"), !1) : !0
    }
});
cc._EventListenerKeyboard.LISTENER_ID = "__cc_keyboard";
cc._EventListenerKeyboard.create = function () {
    return new cc._EventListenerKeyboard
};
cc._EventListenerMouse = cc.EventListener.extend({
    onMouseDown: null,
    onMouseUp: null,
    onMouseMove: null,
    onMouseScroll: null,
    ctor: function () {
        var a = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, function (b) {
            var c = cc.EventMouse;
            switch (b._eventType) {
            case c.DOWN:
                if (a.onMouseDown) a.onMouseDown(b);
                break;
            case c.UP:
                if (a.onMouseUp) a.onMouseUp(b);
                break;
            case c.MOVE:
                if (a.onMouseMove) a.onMouseMove(b);
                break;
            case c.SCROLL:
                if (a.onMouseScroll) a.onMouseScroll(b)
            }
        })
    },
    clone: function () {
        var a = new cc._EventListenerMouse;
        a.onMouseDown = this.onMouseDown;
        a.onMouseUp = this.onMouseUp;
        a.onMouseMove = this.onMouseMove;
        a.onMouseScroll = this.onMouseScroll;
        return a
    },
    checkAvailable: function () {
        return !0
    }
});
cc._EventListenerMouse.LISTENER_ID = "__cc_mouse";
cc._EventListenerMouse.create = function () {
    return new cc._EventListenerMouse
};
cc._EventListenerTouchOneByOne = cc.EventListener.extend({
    _claimedTouches: null,
    swallowTouches: !1,
    onTouchBegan: null,
    onTouchMoved: null,
    onTouchEnded: null,
    onTouchCancelled: null,
    ctor: function () {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null);
        this._claimedTouches = []
    },
    setSwallowTouches: function (a) {
        this.swallowTouches = a
    },
    clone: function () {
        var a = new cc._EventListenerTouchOneByOne;
        a.onTouchBegan = this.onTouchBegan;
        a.onTouchMoved = this.onTouchMoved;
        a.onTouchEnded = this.onTouchEnded;
        a.onTouchCancelled = this.onTouchCancelled;
        a.swallowTouches = this.swallowTouches;
        return a
    },
    checkAvailable: function () {
        return this.onTouchBegan ? !0 : (cc.log("cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!"), !1)
    }
});
cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one";
cc._EventListenerTouchOneByOne.create = function () {
    return new cc._EventListenerTouchOneByOne
};
cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
    onTouchesBegan: null,
    onTouchesMoved: null,
    onTouchesEnded: null,
    onTouchesCancelled: null,
    ctor: function () {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null)
    },
    clone: function () {
        var a = new cc._EventListenerTouchAllAtOnce;
        a.onTouchesBegan = this.onTouchesBegan;
        a.onTouchesMoved = this.onTouchesMoved;
        a.onTouchesEnded = this.onTouchesEnded;
        a.onTouchesCancelled = this.onTouchesCancelled;
        return a
    },
    checkAvailable: function () {
        return null == this.onTouchesBegan && null == this.onTouchesMoved && null == this.onTouchesEnded && null == this.onTouchesCancelled ? (cc.log("cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!"), !1) : !0
    }
});
cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once";
cc._EventListenerTouchAllAtOnce.create = function () {
    return new cc._EventListenerTouchAllAtOnce
};
cc.EventListener.create = function (a) {
    if (!a || !a.event) throw "Invalid parameter.";
    var b = a.event;
    delete a.event;
    var c = null;
    b === cc.EventListener.TOUCH_ONE_BY_ONE ? c = new cc._EventListenerTouchOneByOne : b === cc.EventListener.TOUCH_ALL_AT_ONCE ? c = new cc._EventListenerTouchAllAtOnce : b === cc.EventListener.MOUSE ? c = new cc._EventListenerMouse : b === cc.EventListener.CUSTOM ? (c = new cc._EventListenerCustom(a.eventName, a.callback), delete a.eventName, delete a.callback) : b === cc.EventListener.KEYBOARD ? c = new cc._EventListenerKeyboard :
        b === cc.EventListener.ACCELERATION && (c = new cc._EventListenerAcceleration(a.callback), delete a.callback);
    for (var d in a) c[d] = a[d];
    return c
};
cc._EventListenerVector = cc.Class.extend({
    _fixedListeners: null,
    _sceneGraphListeners: null,
    gt0Index: 0,
    ctor: function () {
        this._fixedListeners = [];
        this._sceneGraphListeners = []
    },
    size: function () {
        return this._fixedListeners.length + this._sceneGraphListeners.length
    },
    empty: function () {
        return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length
    },
    push: function (a) {
        0 == a._getFixedPriority() ? this._sceneGraphListeners.push(a) : this._fixedListeners.push(a)
    },
    clearSceneGraphListeners: function () {
        this._sceneGraphListeners.length =
            0
    },
    clearFixedListeners: function () {
        this._fixedListeners.length = 0
    },
    clear: function () {
        this._sceneGraphListeners.length = 0;
        this._fixedListeners.length = 0
    },
    getFixedPriorityListeners: function () {
        return this._fixedListeners
    },
    getSceneGraphPriorityListeners: function () {
        return this._sceneGraphListeners
    }
});
cc.__getListenerID = function (a) {
    var b = cc.Event;
    switch (a.getType()) {
    case b.ACCELERATION:
        return cc._EventListenerAcceleration.LISTENER_ID;
    case b.CUSTOM:
        return a.getEventName();
    case b.KEYBOARD:
        return cc._EventListenerKeyboard.LISTENER_ID;
    case b.MOUSE:
        return cc._EventListenerMouse.LISTENER_ID;
    case b.TOUCH:
        return cc.log("Don't call this method if the event is for touch."), "";
    default:
        return cc.log("Invalid event type!"), ""
    }
};
cc.eventManager = {
    DIRTY_NONE: 0,
    DIRTY_FIXED_PRIORITY: 1,
    DIRTY_SCENE_GRAPH_PRIORITY: 2,
    DIRTY_ALL: 3,
    _listenersMap: {},
    _priorityDirtyFlagMap: {},
    _nodeListenersMap: {},
    _nodePriorityMap: {},
    _globalZOrderNodeMap: {},
    _toAddedListeners: [],
    _dirtyNodes: [],
    _inDispatch: 0,
    _isEnabled: !0,
    _nodePriorityIndex: 0,
    _internalCustomListenerIDs: [cc.game.EVENT_HIDE, cc.game.EVENT_SHOW],
    _setDirtyForNode: function (a) {
        null != this._nodeListenersMap[a.__instanceId] && this._dirtyNodes.push(a)
    },
    pauseTarget: function (a, b) {
        var c = this._nodeListenersMap[a.__instanceId],
            d, e;
        if (c)
            for (d = 0, e = c.length; d < e; d++) c[d]._setPaused(!0);
        if (!0 === b)
            for (c = a.getChildren(), d = 0, e = c.length; d < e; d++) this.pauseTarget(c[d], !0)
    },
    resumeTarget: function (a, b) {
        var c = this._nodeListenersMap[a.__instanceId],
            d, e;
        if (c)
            for (d = 0, e = c.length; d < e; d++) c[d]._setPaused(!1);
        this._setDirtyForNode(a);
        if (!0 === b)
            for (c = a.getChildren(), d = 0, e = c.length; d < e; d++) this.resumeTarget(c[d], !0)
    },
    _addListener: function (a) {
        0 === this._inDispatch ? this._forceAddEventListener(a) : this._toAddedListeners.push(a)
    },
    _forceAddEventListener: function (a) {
        var b =
            a._getListenerID(),
            c = this._listenersMap[b];
        c || (c = new cc._EventListenerVector, this._listenersMap[b] = c);
        c.push(a);
        0 == a._getFixedPriority() ? (this._setDirty(b, this.DIRTY_SCENE_GRAPH_PRIORITY), b = a._getSceneGraphPriority(), null == b && cc.log("Invalid scene graph priority!"), this._associateNodeAndEventListener(b, a), b.isRunning() && this.resumeTarget(b)) : this._setDirty(b, this.DIRTY_FIXED_PRIORITY)
    },
    _getListeners: function (a) {
        return this._listenersMap[a]
    },
    _updateDirtyFlagForSceneGraph: function () {
        if (0 != this._dirtyNodes.length) {
            for (var a =
                this._dirtyNodes, b, c, d = this._nodeListenersMap, e = 0, f = a.length; e < f; e++)
                if (b = d[a[e].__instanceId])
                    for (var g = 0, h = b.length; g < h; g++)(c = b[g]) && this._setDirty(c._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
            this._dirtyNodes.length = 0
        }
    },
    _removeAllListenersInVector: function (a) {
        if (a)
            for (var b, c = 0; c < a.length;) b = a[c], b._setRegistered(!1), null != b._getSceneGraphPriority() && this._dissociateNodeAndEventListener(b._getSceneGraphPriority(), b), 0 === this._inDispatch ? cc.arrayRemoveObject(a, b) : ++c
    },
    _removeListenersForListenerID: function (a) {
        var b =
            this._listenersMap[a];
        if (b) {
            var c = b.getFixedPriorityListeners(),
                d = b.getSceneGraphPriorityListeners();
            this._removeAllListenersInVector(d);
            this._removeAllListenersInVector(c);
            delete this._priorityDirtyFlagMap[a];
            this._inDispatch || (b.clear(), delete this._listenersMap[a])
        }
        c = this._toAddedListeners;
        for (b = 0; b < c.length;)(d = c[b]) && d._getListenerID() == a ? cc.arrayRemoveObject(c, d) : ++b
    },
    _sortEventListeners: function (a) {
        var b = this.DIRTY_NONE;
        this._priorityDirtyFlagMap[a] && (b = this._priorityDirtyFlagMap[a]);
        b != this.DIRTY_NONE &&
            (b & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(a), b & this.DIRTY_SCENE_GRAPH_PRIORITY && this._sortListenersOfSceneGraphPriority(a), this._priorityDirtyFlagMap[a] = this.DIRTY_NONE)
    },
    _sortListenersOfSceneGraphPriority: function (a) {
        if (a = this._getListeners(a)) {
            var b = a.getSceneGraphPriorityListeners();
            b && 0 !== b.length && (b = cc.director.getRunningScene(), this._nodePriorityIndex = 0, this._nodePriorityMap = {}, this._visitTarget(b, !0), a.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes))
        }
    },
    _sortEventListenersOfSceneGraphPriorityDes: function (a, b) {
        var c = cc.eventManager._nodePriorityMap;
        return c[b._getSceneGraphPriority().__instanceId] - c[a._getSceneGraphPriority().__instanceId]
    },
    _sortListenersOfFixedPriority: function (a) {
        if (a = this._listenersMap[a]) {
            var b = a.getFixedPriorityListeners();
            if (b && 0 !== b.length) {
                b.sort(this._sortListenersOfFixedPriorityAsc);
                for (var c = 0, d = b.length; c < d && !(0 <= b[c]._getFixedPriority());)++c;
                a.gt0Index = c
            }
        }
    },
    _sortListenersOfFixedPriorityAsc: function (a, b) {
        return a._getFixedPriority() -
            b._getFixedPriority()
    },
    _onUpdateListeners: function (a) {
        if (a = this._listenersMap[a]) {
            var b = a.getFixedPriorityListeners(),
                c = a.getSceneGraphPriorityListeners(),
                d, e;
            if (c)
                for (d = 0; d < c.length;) e = c[d], e._isRegistered() ? ++d : cc.arrayRemoveObject(c, e);
            if (b)
                for (d = 0; d < b.length;) e = b[d], e._isRegistered() ? ++d : cc.arrayRemoveObject(b, e);
            c && 0 === c.length && a.clearSceneGraphListeners();
            b && 0 === b.length && a.clearFixedListeners()
        }
    },
    _updateListeners: function (a) {
        var b = this._inDispatch;
        cc.assert(0 < b, "If program goes here, there should be event in dispatch.");
        a.getType() == cc.Event.TOUCH ? (this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID)) : this._onUpdateListeners(cc.__getListenerID(a));
        if (!(1 < b)) {
            cc.assert(1 == b, "_inDispatch should be 1 here.");
            a = this._listenersMap;
            var b = this._priorityDirtyFlagMap,
                c;
            for (c in a) a[c].empty() && (delete b[c], delete a[c]);
            c = this._toAddedListeners;
            if (0 !== c.length) {
                a = 0;
                for (b = c.length; a < b; a++) this._forceAddEventListener(c[a]);
                this._toAddedListeners.length =
                    0
            }
        }
    },
    _onTouchEventCallback: function (a, b) {
        if (!a._isRegistered) return !1;
        var c = b.event,
            d = b.selTouch;
        c._setCurrentTarget(a._node);
        var e = !1,
            f, g = c.getEventCode(),
            h = cc.EventTouch.EventCode;
        if (g == h.BEGAN) a.onTouchBegan && (e = a.onTouchBegan(d, c)) && a._registered && a._claimedTouches.push(d);
        else if (0 < a._claimedTouches.length && -1 != (f = a._claimedTouches.indexOf(d))) switch (e = !0, g) {
        case h.MOVED:
            if (a.onTouchMoved) a.onTouchMoved(d, c);
            break;
        case h.ENDED:
            if (a.onTouchEnded) a.onTouchEnded(d, c);
            a._registered && a._claimedTouches.splice(f,
                1);
            break;
        case h.CANCELLED:
            if (a.onTouchCancelled) a.onTouchCancelled(d, c);
            a._registered && a._claimedTouches.splice(f, 1);
            break;
        default:
            cc.log("The event code is invalid.")
        }
        return c.isStopped() ? (cc.eventManager._updateListeners(c), !0) : e && a._registered && a.swallowTouches ? (b.needsMutableSet && b.touches.splice(d, 1), !0) : !1
    },
    _dispatchTouchEvent: function (a) {
        this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
        this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        var b = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID),
            c = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        if (null != b || null != c) {
            var d = a.getTouches(),
                e = cc.copyArray(d),
                f = {
                    event: a,
                    needsMutableSet: b && c,
                    touches: e,
                    selTouch: null
                };
            if (b)
                for (var g = 0; g < d.length; g++)
                    if (f.selTouch = d[g], this._dispatchEventToListeners(b, this._onTouchEventCallback, f), a.isStopped()) return;
            if (c && 0 < e.length && (this._dispatchEventToListeners(c, this._onTouchesEventCallback, {
                event: a,
                touches: e
            }), a.isStopped())) return;
            this._updateListeners(a)
        }
    },
    _onTouchesEventCallback: function (a,
        b) {
        if (!a._registered) return !1;
        var c = cc.EventTouch.EventCode,
            d = b.event,
            e = b.touches;
        d._setCurrentTarget(a._node);
        switch (d.getEventCode()) {
        case c.BEGAN:
            if (a.onTouchesBegan) a.onTouchesBegan(e, d);
            break;
        case c.MOVED:
            if (a.onTouchesMoved) a.onTouchesMoved(e, d);
            break;
        case c.ENDED:
            if (a.onTouchesEnded) a.onTouchesEnded(e, d);
            break;
        case c.CANCELLED:
            if (a.onTouchesCancelled) a.onTouchesCancelled(e, d);
            break;
        default:
            cc.log("The event code is invalid.")
        }
        return d.isStopped() ? (cc.eventManager._updateListeners(d), !0) : !1
    },
    _associateNodeAndEventListener: function (a, b) {
        var c = this._nodeListenersMap[a.__instanceId];
        c || (c = [], this._nodeListenersMap[a.__instanceId] = c);
        c.push(b)
    },
    _dissociateNodeAndEventListener: function (a, b) {
        var c = this._nodeListenersMap[a.__instanceId];
        c && (cc.arrayRemoveObject(c, b), 0 === c.length && delete this._nodeListenersMap[a.__instanceId])
    },
    _dispatchEventToListeners: function (a, b, c) {
        var d = !1,
            e = a.getFixedPriorityListeners(),
            f = a.getSceneGraphPriorityListeners(),
            g = 0,
            h;
        if (e && 0 !== e.length)
            for (; g < a.gt0Index; ++g)
                if (h =
                    e[g], !h._isPaused() && h._isRegistered() && b(h, c)) {
                    d = !0;
                    break
                }
        if (f && !d)
            for (a = 0; a < f.length; a++)
                if (h = f[a], !h._isPaused() && h._isRegistered() && b(h, c)) {
                    d = !0;
                    break
                }
        if (e && !d)
            for (; g < e.length && (h = e[g], h._isPaused() || !h._isRegistered() || !b(h, c)); ++g);
    },
    _setDirty: function (a, b) {
        var c = this._priorityDirtyFlagMap;
        c[a] = null == c[a] ? b : b | c[a]
    },
    _visitTarget: function (a, b) {
        var c = 0,
            d = a.getChildren(),
            e = d.length,
            f = this._globalZOrderNodeMap,
            g = this._nodeListenersMap;
        if (0 < e) {
            for (var h; c < e; c++)
                if ((h = d[c]) && 0 > h.getLocalZOrder()) this._visitTarget(h, !1);
                else break;
            null != g[a.__instanceId] && (f[a.getGlobalZOrder()] || (f[a.getGlobalZOrder()] = []), f[a.getGlobalZOrder()].push(a.__instanceId));
            for (; c < e; c++)(h = d[c]) && this._visitTarget(h, !1)
        } else null != g[a.__instanceId] && (f[a.getGlobalZOrder()] || (f[a.getGlobalZOrder()] = []), f[a.getGlobalZOrder()].push(a.__instanceId)); if (b) {
            var d = [],
                k;
            for (k in f) d.push(k);
            d.sort(this._sortNumberAsc);
            k = d.length;
            h = this._nodePriorityMap;
            for (c = 0; c < k; c++)
                for (e = f[d[c]], g = 0; g < e.length; g++) h[e[g]] = ++this._nodePriorityIndex;
            this._globalZOrderNodeMap = {}
        }
    },
    _sortNumberAsc: function (a, b) {
        return a - b
    },
    addListener: function (a, b) {
        if (!a || !b) throw "Invalid parameters.";
        if (!(a instanceof cc.EventListener)) {
            if ("number" === typeof b) throw "listener must be a cc.EventListener object when adding a fixed priority listener";
            a = cc.EventListener.create(a)
        } else if (a._isRegistered()) throw "The listener has been registered.";
        a.checkAvailable() && ("number" == typeof b ? 0 == b ? cc.log("0 priority is forbidden for fixed priority since it's used for scene graph based priority.") : (a._setSceneGraphPriority(null),
            a._setFixedPriority(b), a._setRegistered(!0), a._setPaused(!1), this._addListener(a)) : (a._setSceneGraphPriority(b), a._setFixedPriority(0), a._setRegistered(!0), this._addListener(a)))
    },
    addCustomListener: function (a, b) {
        var c = cc._EventListenerCustom.create(a, b);
        this.addListener(c, 1);
        return c
    },
    removeListener: function (a) {
        if (null != a) {
            var b, c = this._listenersMap,
                d;
            for (d in c) {
                var e = c[d],
                    f = e.getFixedPriorityListeners();
                b = e.getSceneGraphPriorityListeners();
                (b = this._removeListenerInVector(b, a)) ? this._setDirty(a._getListenerID(),
                    this.DIRTY_SCENE_GRAPH_PRIORITY): (b = this._removeListenerInVector(f, a)) && this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY);
                e.empty() && (delete this._priorityDirtyFlagMap[a._getListenerID()], delete c[d]);
                if (b) break
            }
            if (!b)
                for (c = this._toAddedListeners, d = 0, e = c.length; d < e; d++)
                    if (f = c[d], f == a) {
                        cc.arrayRemoveObject(c, f);
                        break
                    }
        }
    },
    _removeListenerInVector: function (a, b) {
        if (null == a) return !1;
        for (var c = 0, d = a.length; c < d; c++) {
            var e = a[c];
            if (e == b) return e._setRegistered(!1), null != e._getSceneGraphPriority() &&
                this._dissociateNodeAndEventListener(e._getSceneGraphPriority(), e), 0 == this._inDispatch && cc.arrayRemoveObject(a, e), !0
        }
        return !1
    },
    removeListeners: function (a, b) {
        if (a instanceof cc.Node) {
            var c = this._nodeListenersMap[a.__instanceId];
            if (c) {
                for (var c = cc.copyArray(c), d = 0; d < c.length; d++) this.removeListener(c[d]);
                c.length = 0
            }
        } else a == cc.EventListener.TOUCH_ONE_BY_ONE ? this._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID) : a == cc.EventListener.TOUCH_ALL_AT_ONCE ? this._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID) :
            a == cc.EventListener.MOUSE ? this._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID) : a == cc.EventListener.ACCELERATION ? this._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID) : a == cc.EventListener.KEYBOARD ? this._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID) : cc.log("Invalid listener type!")
    },
    removeCustomListeners: function (a) {
        this._removeListenersForListenerID(a)
    },
    removeAllListeners: function () {
        var a = this._listenersMap,
            b = this._internalCustomListenerIDs,
            c;
        for (c in a) - 1 === b.indexOf(c) && this._removeListenersForListenerID(c)
    },
    setPriority: function (a, b) {
        if (null != a) {
            var c = this._listenersMap,
                d;
            for (d in c) {
                var e = c[d].getFixedPriorityListeners();
                if (e && -1 != e.indexOf(a)) {
                    null != a._getSceneGraphPriority() && cc.log("Can't set fixed priority with scene graph based listener.");
                    a._getFixedPriority() !== b && (a._setFixedPriority(b), this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY));
                    break
                }
            }
        }
    },
    setEnabled: function (a) {
        this._isEnabled = a
    },
    isEnabled: function () {
        return this._isEnabled
    },
    dispatchEvent: function (a) {
        if (this._isEnabled) {
            this._updateDirtyFlagForSceneGraph();
            this._inDispatch++;
            if (a.getType() == cc.Event.TOUCH) this._dispatchTouchEvent(a);
            else {
                var b = cc.__getListenerID(a);
                this._sortEventListeners(b);
                b = this._listenersMap[b];
                null != b && this._dispatchEventToListeners(b, this._onListenerCallback, a);
                this._updateListeners(a)
            }
            this._inDispatch--
        }
    },
    _onListenerCallback: function (a, b) {
        b._setCurrentTarget(a._getSceneGraphPriority());
        a._onEvent(b);
        return b.isStopped()
    },
    dispatchCustomEvent: function (a,
        b) {
        var c = new cc.EventCustom(a);
        c.setUserData(b);
        this.dispatchEvent(c)
    }
};
cc.NODE_TAG_INVALID = -1;
cc.NODE_ON_ENTER = null;
cc.NODE_ON_EXIT = null;
cc.s_globalOrderOfArrival = 1;
cc.Node = cc.Class.extend({
    _localZOrder: 0,
    _globalZOrder: 0,
    _vertexZ: 0,
    _rotationX: 0,
    _rotationY: 0,
    _scaleX: 1,
    _scaleY: 1,
    _position: null,
    _skewX: 0,
    _skewY: 0,
    _children: null,
    _visible: !0,
    _anchorPoint: null,
    _anchorPointInPoints: null,
    _contentSize: null,
    _running: !1,
    _parent: null,
    _ignoreAnchorPointForPosition: !1,
    tag: cc.NODE_TAG_INVALID,
    userData: null,
    userObject: null,
    _transformDirty: !0,
    _inverseDirty: !0,
    _cacheDirty: !0,
    _cachedParent: null,
    _transformGLDirty: null,
    _transform: null,
    _inverse: null,
    _reorderChildDirty: !1,
    _shaderProgram: null,
    arrivalOrder: 0,
    _actionManager: null,
    _scheduler: null,
    _eventDispatcher: null,
    _initializedNode: !1,
    _additionalTransformDirty: !1,
    _additionalTransform: null,
    _componentContainer: null,
    _isTransitionFinished: !1,
    _rotationRadiansX: 0,
    _rotationRadiansY: 0,
    _className: "Node",
    _showNode: !1,
    _initNode: function () {
        this._anchorPoint = cc.p(0, 0);
        this._anchorPointInPoints = cc.p(0, 0);
        this._contentSize = cc.size(0, 0);
        this._position = cc.p(0, 0);
        this._children = [];
        this._transform = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            tx: 0,
            ty: 0
        };
        var a = cc.director;
        this._actionManager =
            a.getActionManager();
        this._scheduler = a.getScheduler();
        this._initializedNode = !0;
        this._additionalTransform = cc.AffineTransformMakeIdentity();
        cc.ComponentContainer && (this._componentContainer = new cc.ComponentContainer(this))
    },
    init: function () {
        !1 === this._initializedNode && this._initNode();
        return !0
    },
    _arrayMakeObjectsPerformSelector: function (a, b) {
        if (a && 0 !== a.length) {
            var c, d = a.length,
                e;
            c = cc.Node.StateCallbackType;
            switch (b) {
            case c.onEnter:
                for (c = 0; c < d; c++)
                    if (e = a[c]) e.onEnter();
                break;
            case c.onExit:
                for (c = 0; c < d; c++)
                    if (e =
                        a[c]) e.onExit();
                break;
            case c.onEnterTransitionDidFinish:
                for (c = 0; c < d; c++)
                    if (e = a[c]) e.onEnterTransitionDidFinish();
                break;
            case c.cleanup:
                for (c = 0; c < d; c++)(e = a[c]) && e.cleanup();
                break;
            case c.updateTransform:
                for (c = 0; c < d; c++)(e = a[c]) && e.updateTransform();
                break;
            case c.onExitTransitionDidStart:
                for (c = 0; c < d; c++)
                    if (e = a[c]) e.onExitTransitionDidStart();
                break;
            case c.sortAllChildren:
                for (c = 0; c < d; c++)(e = a[c]) && e.sortAllChildren();
                break;
            default:
                throw "Unknown callback function";
            }
        }
    },
    setNodeDirty: null,
    _setNodeDirtyForCanvas: function () {
        this._setNodeDirtyForCache();
        !1 === this._transformDirty && (this._transformDirty = this._inverseDirty = !0)
    },
    _setNodeDirtyForWebGL: function () {
        !1 === this._transformDirty && (this._transformDirty = this._inverseDirty = !0)
    },
    attr: function (a) {
        for (var b in a) this[b] = a[b]
    },
    getSkewX: function () {
        return this._skewX
    },
    setSkewX: function (a) {
        this._skewX = a;
        this.setNodeDirty()
    },
    getSkewY: function () {
        return this._skewY
    },
    setSkewY: function (a) {
        this._skewY = a;
        this.setNodeDirty()
    },
    setLocalZOrder: function (a) {
        this._localZOrder = a;
        this._parent && this._parent.reorderChild(this,
            a);
        cc.eventManager._setDirtyForNode(this)
    },
    _setLocalZOrder: function (a) {
        this._localZOrder = a
    },
    getLocalZOrder: function () {
        return this._localZOrder
    },
    getZOrder: function () {
        cc.log("getZOrder is deprecated. Please use getLocalZOrder instead.");
        return this.getLocalZOrder()
    },
    setZOrder: function (a) {
        cc.log("setZOrder is deprecated. Please use setLocalZOrder instead.");
        this.setLocalZOrder(a)
    },
    setGlobalZOrder: function (a) {
        this._globalZOrder != a && (this._globalZOrder = a, cc.eventManager._setDirtyForNode(this))
    },
    getGlobalZOrder: function () {
        return this._globalZOrder
    },
    getVertexZ: function () {
        return this._vertexZ
    },
    setVertexZ: function (a) {
        this._vertexZ = a
    },
    getRotation: function () {
        this._rotationX !== this._rotationY && cc.log("cc.Node.rotation(): RotationX !\x3d RotationY. Don't know which one to return");
        return this._rotationX
    },
    setRotation: function (a) {
        this._rotationX = this._rotationY = a;
        this._rotationRadiansX = 0.017453292519943295 * this._rotationX;
        this._rotationRadiansY = 0.017453292519943295 * this._rotationY;
        this.setNodeDirty()
    },
    getRotationX: function () {
        return this._rotationX
    },
    setRotationX: function (a) {
        this._rotationX = a;
        this._rotationRadiansX = 0.017453292519943295 * this._rotationX;
        this.setNodeDirty()
    },
    getRotationY: function () {
        return this._rotationY
    },
    setRotationY: function (a) {
        this._rotationY = a;
        this._rotationRadiansY = 0.017453292519943295 * this._rotationY;
        this.setNodeDirty()
    },
    getScale: function () {
        this._scaleX !== this._scaleY && cc.log("cc.Node.getScale(): ScaleX !\x3d ScaleY. Don't know which one to return");
        return this._scaleX
    },
    setScale: function (a, b) {
        this._scaleX = a;
        this._scaleY = b ||
            0 === b ? b : a;
        this.setNodeDirty()
    },
    getScaleX: function () {
        return this._scaleX
    },
    setScaleX: function (a) {
        this._scaleX = a;
        this.setNodeDirty()
    },
    getScaleY: function () {
        return this._scaleY
    },
    setScaleY: function (a) {
        this._scaleY = a;
        this.setNodeDirty()
    },
    setPosition: function (a, b) {
        var c = this._position;
        void 0 === b ? (c.x = a.x, c.y = a.y) : (c.x = a, c.y = b);
        this.setNodeDirty()
    },
    getPosition: function () {
        return this._position
    },
    getPositionX: function () {
        return this._position.x
    },
    setPositionX: function (a) {
        this._position.x = a;
        this.setNodeDirty()
    },
    getPositionY: function () {
        return this._position.y
    },
    setPositionY: function (a) {
        this._position.y = a;
        this.setNodeDirty()
    },
    getChildrenCount: function () {
        return this._children.length
    },
    getChildren: function () {
        return this._children
    },
    isVisible: function () {
        return this._visible
    },
    setVisible: function (a) {
        this._visible = a;
        this.setNodeDirty()
    },
    getAnchorPoint: function () {
        return this._anchorPoint
    },
    setAnchorPoint: function (a, b) {
        var c = this._anchorPoint;
        if (void 0 === b) {
            if (a.x === c.x && a.y === c.y) return;
            c.x = a.x;
            c.y = a.y
        } else {
            if (a === c.x &&
                b === c.y) return;
            c.x = a;
            c.y = b
        }
        var d = this._anchorPointInPoints,
            e = this._contentSize;
        d.x = e.width * c.x;
        d.y = e.height * c.y;
        this.setNodeDirty()
    },
    _getAnchor: function () {
        return this._anchorPoint
    },
    _setAnchor: function (a) {
        var b = a.x;
        a = a.y;
        this._anchorPoint.x !== b && (this._anchorPoint.x = b, this._anchorPointInPoints.x = this._contentSize.width * b);
        this._anchorPoint.y !== a && (this._anchorPoint.y = a, this._anchorPointInPoints.y = this._contentSize.height * a);
        this.setNodeDirty()
    },
    _getAnchorX: function () {
        return this._anchorPoint.x
    },
    _setAnchorX: function (a) {
        this._anchorPoint.x !==
            a && (this._anchorPoint.x = a, this._anchorPointInPoints.x = this._contentSize.width * a, this.setNodeDirty())
    },
    _getAnchorY: function () {
        return this._anchorPoint.y
    },
    _setAnchorY: function (a) {
        this._anchorPoint.y !== a && (this._anchorPoint.y = a, this._anchorPointInPoints.y = this._contentSize.height * a, this.setNodeDirty())
    },
    getAnchorPointInPoints: function () {
        return this._anchorPointInPoints
    },
    _getWidth: function () {
        return this._contentSize.width
    },
    _setWidth: function (a) {
        this._contentSize.width = a;
        this._anchorPointInPoints.x = a *
            this._anchorPoint.x;
        this.setNodeDirty()
    },
    _getHeight: function () {
        return this._contentSize.height
    },
    _setHeight: function (a) {
        this._contentSize.height = a;
        this._anchorPointInPoints.y = a * this._anchorPoint.y;
        this.setNodeDirty()
    },
    getContentSize: function () {
        return this._contentSize
    },
    setContentSize: function (a, b) {
        var c = this._contentSize;
        if (void 0 === b) {
            if (a.width === c.width && a.height === c.height) return;
            c.width = a.width;
            c.height = a.height
        } else {
            if (a === c.width && b === c.height) return;
            c.width = a;
            c.height = b
        }
        var d = this._anchorPointInPoints,
            e = this._anchorPoint;
        d.x = c.width * e.x;
        d.y = c.height * e.y;
        this.setNodeDirty()
    },
    isRunning: function () {
        return this._running
    },
    getParent: function () {
        return this._parent
    },
    setParent: function (a) {
        this._parent = a
    },
    isIgnoreAnchorPointForPosition: function () {
        return this._ignoreAnchorPointForPosition
    },
    ignoreAnchorPointForPosition: function (a) {
        a != this._ignoreAnchorPointForPosition && (this._ignoreAnchorPointForPosition = a, this.setNodeDirty())
    },
    getTag: function () {
        return this.tag
    },
    setTag: function (a) {
        this.tag = a
    },
    getUserData: function () {
        return this.userData
    },
    setUserData: function (a) {
        this.userData = a
    },
    getUserObject: function () {
        return this.userObject
    },
    setUserObject: function (a) {
        this.userObject != a && (this.userObject = a)
    },
    getOrderOfArrival: function () {
        return this.arrivalOrder
    },
    setOrderOfArrival: function (a) {
        this.arrivalOrder = a
    },
    getActionManager: function () {
        this._actionManager || (this._actionManager = cc.director.getActionManager());
        return this._actionManager
    },
    setActionManager: function (a) {
        this._actionManager != a && (this.stopAllActions(), this._actionManager = a)
    },
    getScheduler: function () {
        this._scheduler ||
            (this._scheduler = cc.director.getScheduler());
        return this._scheduler
    },
    setScheduler: function (a) {
        this._scheduler != a && (this.unscheduleAllCallbacks(), this._scheduler = a)
    },
    getBoundingBox: function () {
        var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc._RectApplyAffineTransformIn(a, this.nodeToParentTransform())
    },
    cleanup: function () {
        this.stopAllActions();
        this.unscheduleAllCallbacks();
        cc.eventManager.removeListeners(this);
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.cleanup)
    },
    getChildByTag: function (a) {
        var b = this._children;
        if (null != b)
            for (var c = 0; c < b.length; c++) {
                var d = b[c];
                if (d && d.tag == a) return d
            }
        return null
    },
    addChild: function (a, b, c) {
        if (!a) throw "cc.Node.addChild(): child must be non-null";
        if (a === this) cc.log("cc.Node.addChild(): An Node can't be added as a child of itself.");
        else if (null !== a._parent) cc.log("cc.Node.addChild(): child already added. It can't be added again");
        else if (b = null != b ? b : a._localZOrder, a.tag = null != c ? c : a.tag, this._insertChild(a, b), a._parent = this, this._cachedParent &&
            (a._cachedParent = this._cachedParent), this._running && (a.onEnter(), this._isTransitionFinished)) a.onEnterTransitionDidFinish()
    },
    removeFromParent: function (a) {
        this._parent && (null == a && (a = !0), this._parent.removeChild(this, a))
    },
    removeFromParentAndCleanup: function (a) {
        cc.log("removeFromParentAndCleanup is deprecated. Use removeFromParent instead");
        this.removeFromParent(a)
    },
    removeChild: function (a, b) {
        0 !== this._children.length && (null == b && (b = !0), -1 < this._children.indexOf(a) && this._detachChild(a, b), this.setNodeDirty())
    },
    removeChildByTag: function (a, b) {
        a === cc.NODE_TAG_INVALID && cc.log("cc.Node.removeChildByTag(): argument tag is an invalid tag");
        var c = this.getChildByTag(a);
        null == c ? cc.log("cocos2d: removeChildByTag(tag \x3d " + a + "): child not found!") : this.removeChild(c, b)
    },
    removeAllChildrenWithCleanup: function (a) {
        cc.log("removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead");
        this.removeAllChildren(a)
    },
    removeAllChildren: function (a) {
        var b = this._children;
        if (null != b) {
            null == a && (a = !0);
            for (var c = 0; c < b.length; c++) {
                var d =
                    b[c];
                d && (this._running && (d.onExitTransitionDidStart(), d.onExit()), a && d.cleanup(), d.parent = null)
            }
            this._children.length = 0
        }
    },
    _detachChild: function (a, b) {
        this._running && (a.onExitTransitionDidStart(), a.onExit());
        b && a.cleanup();
        a.parent = null;
        cc.arrayRemoveObject(this._children, a)
    },
    _insertChild: function (a, b) {
        this._reorderChildDirty = !0;
        this._children.push(a);
        a._setLocalZOrder(b)
    },
    reorderChild: function (a, b) {
        if (!a) throw "cc.Node.reorderChild(): child must be non-null";
        this._reorderChildDirty = !0;
        a.arrivalOrder =
            cc.s_globalOrderOfArrival;
        cc.s_globalOrderOfArrival++;
        a._setLocalZOrder(b);
        this.setNodeDirty()
    },
    sortAllChildren: function () {
        if (this._reorderChildDirty) {
            var a = this._children,
                b, c, d = a.length,
                e;
            for (b = 0; b < d; b++) {
                var f = a[b];
                c = b - 1;
                for (e = a[c]; 0 <= c && (f._localZOrder < e._localZOrder || f._localZOrder == e._localZOrder && f.arrivalOrder < e.arrivalOrder);) a[c + 1] = e, c -= 1, e = a[c];
                a[c + 1] = f
            }
            this._reorderChildDirty = !1
        }
    },
    draw: function (a) {},
    transformAncestors: function () {
        null != this._parent && (this._parent.transformAncestors(), this._parent.transform())
    },
    onEnter: function () {
        this._isTransitionFinished = !1;
        this._running = !0;
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onEnter);
        this.resume()
    },
    onEnterTransitionDidFinish: function () {
        this._isTransitionFinished = !0;
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onEnterTransitionDidFinish)
    },
    onExitTransitionDidStart: function () {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onExitTransitionDidStart)
    },
    onExit: function () {
        this._running = !1;
        this.pause();
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onExit);
        this._componentContainer && this._componentContainer.removeAll()
    },
    runAction: function (a) {
        if (!a) throw "cc.Node.runAction(): action must be non-null";
        this.actionManager.addAction(a, this, !this._running);
        return a
    },
    stopAllActions: function () {
        this.actionManager.removeAllActionsFromTarget(this)
    },
    stopAction: function (a) {
        this.actionManager.removeAction(a)
    },
    stopActionByTag: function (a) {
        a === cc.ACTION_TAG_INVALID ?
            cc.log("cc.Node.stopActionBy(): argument tag an invalid tag") : this.actionManager.removeActionByTag(a, this)
    },
    getActionByTag: function (a) {
        return a === cc.ACTION_TAG_INVALID ? (cc.log("cc.Node.getActionByTag(): argument tag is an invalid tag"), null) : this.actionManager.getActionByTag(a, this)
    },
    getNumberOfRunningActions: function () {
        return this.actionManager.numberOfRunningActionsInTarget(this)
    },
    scheduleUpdate: function () {
        this.scheduleUpdateWithPriority(0)
    },
    scheduleUpdateWithPriority: function (a) {
        this.scheduler.scheduleUpdateForTarget(this,
            a, !this._running)
    },
    unscheduleUpdate: function () {
        this.scheduler.unscheduleUpdateForTarget(this)
    },
    schedule: function (a, b, c, d) {
        b = b || 0;
        if (!a) throw "cc.Node.schedule(): callback function must be non-null";
        if (0 > b) throw "cc.Node.schedule(): interval must be positive";
        c = null == c ? cc.REPEAT_FOREVER : c;
        this.scheduler.scheduleCallbackForTarget(this, a, b, c, d || 0, !this._running)
    },
    scheduleOnce: function (a, b) {
        this.schedule(a, 0, 0, b)
    },
    unschedule: function (a) {
        a && this.scheduler.unscheduleCallbackForTarget(this, a)
    },
    unscheduleAllCallbacks: function () {
        this.scheduler.unscheduleAllCallbacksForTarget(this)
    },
    resumeSchedulerAndActions: function () {
        cc.log("resumeSchedulerAndActions is deprecated, please use resume instead.");
        this.resume()
    },
    resume: function () {
        this.scheduler.resumeTarget(this);
        this.actionManager.resumeTarget(this);
        cc.eventManager.resumeTarget(this)
    },
    pauseSchedulerAndActions: function () {
        cc.log("pauseSchedulerAndActions is deprecated, please use pause instead.");
        this.pause()
    },
    pause: function () {
        this.scheduler.pauseTarget(this);
        this.actionManager.pauseTarget(this);
        cc.eventManager.pauseTarget(this)
    },
    setAdditionalTransform: function (a) {
        this._additionalTransform = a;
        this._additionalTransformDirty = this._transformDirty = !0
    },
    parentToNodeTransform: function () {
        this._inverseDirty && (this._inverse = cc.AffineTransformInvert(this.nodeToParentTransform()), this._inverseDirty = !1);
        return this._inverse
    },
    nodeToWorldTransform: function () {
        for (var a = this.nodeToParentTransform(), b = this._parent; null != b; b = b.parent) a = cc.AffineTransformConcat(a, b.nodeToParentTransform());
        return a
    },
    worldToNodeTransform: function () {
        return cc.AffineTransformInvert(this.nodeToWorldTransform())
    },
    convertToNodeSpace: function (a) {
        return cc.PointApplyAffineTransform(a, this.worldToNodeTransform())
    },
    convertToWorldSpace: function (a) {
        return cc.PointApplyAffineTransform(a, this.nodeToWorldTransform())
    },
    convertToNodeSpaceAR: function (a) {
        return cc.pSub(this.convertToNodeSpace(a), this._anchorPointInPoints)
    },
    convertToWorldSpaceAR: function (a) {
        a = cc.pAdd(a, this._anchorPointInPoints);
        return this.convertToWorldSpace(a)
    },
    _convertToWindowSpace: function (a) {
        a = this.convertToWorldSpace(a);
        return cc.director.convertToUI(a)
    },
    convertTouchToNodeSpace: function (a) {
        a = a.getLocation();
        return this.convertToNodeSpace(a)
    },
    convertTouchToNodeSpaceAR: function (a) {
        a = a.getLocation();
        a = cc.director.convertToGL(a);
        return this.convertToNodeSpaceAR(a)
    },
    update: function (a) {
        this._componentContainer && !this._componentContainer.isEmpty() && this._componentContainer.visit(a)
    },
    updateTransform: function () {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform)
    },
    retain: function () {},
    release: function () {},
    getComponent: function (a) {
        return this._componentContainer.getComponent(a)
    },
    addComponent: function (a) {
        this._componentContainer.add(a)
    },
    removeComponent: function (a) {
        return this._componentContainer.remove(a)
    },
    removeAllComponents: function () {
        this._componentContainer.removeAll()
    },
    _transform4x4: null,
    _stackMatrix: null,
    _glServerState: null,
    _camera: null,
    grid: null,
    ctor: null,
    _ctorForCanvas: function () {
        this._initNode()
    },
    _ctorForWebGL: function () {
        this._initNode();
        var a = new cc.kmMat4;
        a.mat[2] = a.mat[3] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = a.mat[14] = 0;
        a.mat[10] = a.mat[15] = 1;
        this._transform4x4 =
            a;
        this._glServerState = 0;
        this._stackMatrix = new cc.kmMat4
    },
    visit: null,
    _visitForCanvas: function (a) {
        if (this._visible) {
            a = a || cc._renderContext;
            var b, c = this._children,
                d;
            a.save();
            this.transform(a);
            var e = c.length;
            if (0 < e) {
                this.sortAllChildren();
                for (b = 0; b < e; b++)
                    if (d = c[b], 0 > d._localZOrder) d.visit(a);
                    else break;
                for (this.draw(a); b < e; b++) c[b].visit(a)
            } else this.draw(a);
            this.arrivalOrder = 0;
            a.restore()
        }
    },
    _visitForWebGL: function () {
        if (this._visible) {
            var a = cc._renderContext,
                b, c = cc.current_stack;
            c.stack.push(c.top);
            cc.kmMat4Assign(this._stackMatrix,
                c.top);
            c.top = this._stackMatrix;
            var d = this.grid;
            d && d._active && d.beforeDraw();
            this.transform();
            var e = this._children;
            if (e && 0 < e.length) {
                var f = e.length;
                this.sortAllChildren();
                for (b = 0; b < f; b++)
                    if (e[b] && 0 > e[b]._localZOrder) e[b].visit();
                    else break;
                for (this.draw(a); b < f; b++) e[b] && e[b].visit()
            } else this.draw(a);
            this.arrivalOrder = 0;
            d && d._active && d.afterDraw(this);
            c.top = c.stack.pop()
        }
    },
    transform: null,
    _transformForCanvas: function (a) {
        a = a || cc._renderContext;
        var b = cc.view,
            c = this.nodeToParentTransform();
        a.transform(c.a,
            c.c, c.b, c.d, c.tx * b.getScaleX(), -c.ty * b.getScaleY())
    },
    _transformForWebGL: function () {
        var a = this._transform4x4,
            b = cc.current_stack.top,
            c = this.nodeToParentTransform(),
            d = a.mat;
        d[0] = c.a;
        d[4] = c.c;
        d[12] = c.tx;
        d[1] = c.b;
        d[5] = c.d;
        d[13] = c.ty;
        d[14] = this._vertexZ;
        cc.kmMat4Multiply(b, b, a);
        null == this._camera || null != this.grid && this.grid.isActive() || (a = this._anchorPointInPoints.x, b = this._anchorPointInPoints.y, 0 !== a || 0 !== b ? (cc.kmGLTranslatef(cc.RENDER_IN_SUBPIXEL(a), cc.RENDER_IN_SUBPIXEL(b), 0), this._camera.locate(), cc.kmGLTranslatef(cc.RENDER_IN_SUBPIXEL(-a),
            cc.RENDER_IN_SUBPIXEL(-b), 0)) : this._camera.locate())
    },
    nodeToParentTransform: null,
    _nodeToParentTransformForCanvas: function () {
        if (this._transformDirty) {
            var a = this._transform;
            a.tx = this._position.x;
            a.ty = this._position.y;
            var b = 1,
                c = 0;
            this._rotationX && (b = Math.cos(this._rotationRadiansX), c = Math.sin(this._rotationRadiansX));
            a.a = a.d = b;
            a.b = -c;
            a.c = c;
            var d = this._scaleX,
                e = this._scaleY,
                f = this._anchorPointInPoints.x,
                g = this._anchorPointInPoints.y,
                h = 1E-6 > d && -1E-6 < d ? 1E-6 : d,
                k = 1E-6 > e && -1E-6 < e ? 1E-6 : e;
            if (this._skewX || this._skewY) {
                var m =
                    Math.tan(-this._skewX * Math.PI / 180),
                    n = Math.tan(-this._skewY * Math.PI / 180),
                    p = g * m * h,
                    r = f * n * k;
                a.a = b + -c * n;
                a.b = b * m + -c;
                a.c = c + b * n;
                a.d = c * m + b;
                a.tx += b * p + -c * r;
                a.ty += c * p + b * r
            }
            if (1 !== d || 1 !== e) a.a *= h, a.c *= h, a.b *= k, a.d *= k;
            a.tx += b * -f * h + -c * g * k;
            a.ty -= c * -f * h + b * g * k;
            this._ignoreAnchorPointForPosition && (a.tx += f, a.ty += g);
            this._additionalTransformDirty && (this._transform = cc.AffineTransformConcat(a, this._additionalTransform), this._additionalTransformDirty = !1);
            this._transformDirty = !1
        }
        return this._transform
    },
    _nodeToParentTransformForWebGL: function () {
        if (this._transformDirty) {
            var a =
                this._position.x,
                b = this._position.y,
                c = this._anchorPointInPoints.x,
                d = -c,
                e = this._anchorPointInPoints.y,
                f = -e,
                g = this._scaleX,
                h = this._scaleY;
            this._ignoreAnchorPointForPosition && (a += c, b += e);
            var k = 1,
                m = 0,
                n = 1,
                p = 0;
            if (0 !== this._rotationX || 0 !== this._rotationY) k = Math.cos(-this._rotationRadiansX), m = Math.sin(-this._rotationRadiansX), n = Math.cos(-this._rotationRadiansY), p = Math.sin(-this._rotationRadiansY);
            var r = this._skewX || this._skewY;
            r || 0 === c && 0 === e || (a += n * d * g + -m * f * h, b += p * d * g + k * f * h);
            var q = this._transform;
            q.a = n *
                g;
            q.b = p * g;
            q.c = -m * h;
            q.d = k * h;
            q.tx = a;
            q.ty = b;
            r && (q = cc.AffineTransformConcat({
                a: 1,
                b: Math.tan(cc.DEGREES_TO_RADIANS(this._skewY)),
                c: Math.tan(cc.DEGREES_TO_RADIANS(this._skewX)),
                d: 1,
                tx: 0,
                ty: 0
            }, q), 0 !== c || 0 !== e) && (q = cc.AffineTransformTranslate(q, d, f));
            this._additionalTransformDirty && (q = cc.AffineTransformConcat(q, this._additionalTransform), this._additionalTransformDirty = !1);
            this._transform = q;
            this._transformDirty = !1
        }
        return this._transform
    },
    _setNodeDirtyForCache: function () {
        if (!1 === this._cacheDirty) {
            this._cacheDirty = !0;
            var a = this._cachedParent;
            a && a != this && a._setNodeDirtyForCache()
        }
    },
    getCamera: function () {
        this._camera || (this._camera = new cc.Camera);
        return this._camera
    },
    getGrid: function () {
        return this.grid
    },
    setGrid: function (a) {
        this.grid = a
    },
    getShaderProgram: function () {
        return this._shaderProgram
    },
    setShaderProgram: function (a) {
        this._shaderProgram = a
    },
    getGLServerState: function () {
        return this._glServerState
    },
    setGLServerState: function (a) {
        this._glServerState = a
    },
    getBoundingBoxToWorld: function () {
        var a = cc.rect(0, 0, this._contentSize.width,
                this._contentSize.height),
            b = this.nodeToWorldTransform(),
            a = cc.RectApplyAffineTransform(a, this.nodeToWorldTransform());
        if (!this._children) return a;
        for (var c = this._children, d = 0; d < c.length; d++) {
            var e = c[d];
            e && e._visible && (e = e._getBoundingBoxToCurrentNode(b)) && (a = cc.rectUnion(a, e))
        }
        return a
    },
    _getBoundingBoxToCurrentNode: function (a) {
        var b = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        a = null == a ? this.nodeToParentTransform() : cc.AffineTransformConcat(this.nodeToParentTransform(), a);
        b = cc.RectApplyAffineTransform(b,
            a);
        if (!this._children) return b;
        for (var c = this._children, d = 0; d < c.length; d++) {
            var e = c[d];
            e && e._visible && (e = e._getBoundingBoxToCurrentNode(a)) && (b = cc.rectUnion(b, e))
        }
        return b
    }
});
window._p = cc.Node.prototype;
cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.ctor = _p._ctorForWebGL, _p.setNodeDirty = _p._setNodeDirtyForWebGL, _p.visit = _p._visitForWebGL, _p.transform = _p._transformForWebGL, _p.nodeToParentTransform = _p._nodeToParentTransformForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.setNodeDirty = _p._setNodeDirtyForCanvas, _p.visit = _p._visitForCanvas, _p.transform = _p._transformForCanvas, _p.nodeToParentTransform = _p._nodeToParentTransformForCanvas);
cc.defineGetterSetter(_p, "x", _p.getPositionX, _p.setPositionX);
cc.defineGetterSetter(_p, "y", _p.getPositionY, _p.setPositionY);
cc.defineGetterSetter(_p, "width", _p._getWidth, _p._setWidth);
cc.defineGetterSetter(_p, "height", _p._getHeight, _p._setHeight);
cc.defineGetterSetter(_p, "anchorX", _p._getAnchorX, _p._setAnchorX);
cc.defineGetterSetter(_p, "anchorY", _p._getAnchorY, _p._setAnchorY);
cc.defineGetterSetter(_p, "skewX", _p.getSkewX, _p.setSkewX);
cc.defineGetterSetter(_p, "skewY", _p.getSkewY, _p.setSkewY);
cc.defineGetterSetter(_p, "zIndex", _p.getLocalZOrder, _p.setLocalZOrder);
cc.defineGetterSetter(_p, "vertexZ", _p.getVertexZ, _p.setVertexZ);
cc.defineGetterSetter(_p, "rotation", _p.getRotation, _p.setRotation);
cc.defineGetterSetter(_p, "rotationX", _p.getRotationX, _p.setRotationX);
cc.defineGetterSetter(_p, "rotationY", _p.getRotationY, _p.setRotationY);
cc.defineGetterSetter(_p, "scale", _p.getScale, _p.setScale);
cc.defineGetterSetter(_p, "scaleX", _p.getScaleX, _p.setScaleX);
cc.defineGetterSetter(_p, "scaleY", _p.getScaleY, _p.setScaleY);
cc.defineGetterSetter(_p, "children", _p.getChildren);
cc.defineGetterSetter(_p, "childrenCount", _p.getChildrenCount);
cc.defineGetterSetter(_p, "parent", _p.getParent, _p.setParent);
cc.defineGetterSetter(_p, "visible", _p.isVisible, _p.setVisible);
cc.defineGetterSetter(_p, "running", _p.isRunning);
cc.defineGetterSetter(_p, "ignoreAnchor", _p.isIgnoreAnchorPointForPosition, _p.ignoreAnchorPointForPosition);
cc.defineGetterSetter(_p, "actionManager", _p.getActionManager, _p.setActionManager);
cc.defineGetterSetter(_p, "scheduler", _p.getScheduler, _p.setScheduler);
cc.defineGetterSetter(_p, "shaderProgram", _p.getShaderProgram, _p.setShaderProgram);
cc.defineGetterSetter(_p, "glServerState", _p.getGLServerState, _p.setGLServerState);
delete window._p;
cc.Node.create = function () {
    return new cc.Node
};
cc.Node.StateCallbackType = {
    onEnter: 1,
    onExit: 2,
    cleanup: 3,
    onEnterTransitionDidFinish: 4,
    updateTransform: 5,
    onExitTransitionDidStart: 6,
    sortAllChildren: 7
};
cc.NodeRGBA = cc.Node.extend({
    RGBAProtocol: !0,
    _displayedOpacity: 255,
    _realOpacity: 255,
    _displayedColor: null,
    _realColor: null,
    _cascadeColorEnabled: !1,
    _cascadeOpacityEnabled: !1,
    ctor: function () {
        cc.Node.prototype.ctor.call(this);
        this._realOpacity = this._displayedOpacity = 255;
        this._displayedColor = cc.color(255, 255, 255, 255);
        this._realColor = cc.color(255, 255, 255, 255);
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1
    },
    getOpacity: function () {
        return this._realOpacity
    },
    getDisplayedOpacity: function () {
        return this._displayedOpacity
    },
    setOpacity: function (a) {
        this._displayedOpacity = this._realOpacity = a;
        var b = 255,
            c = this._parent;
        c && c.RGBAProtocol && c.cascadeOpacity && (b = c.getDisplayedOpacity());
        this.updateDisplayedOpacity(b);
        this._displayedColor.a = this._realColor.a = a
    },
    updateDisplayedOpacity: function (a) {
        this._displayedOpacity = this._realOpacity * a / 255;
        if (this._cascadeOpacityEnabled) {
            a = this._children;
            for (var b = 0; b < a.length; b++) {
                var c = a[b];
                c && c.RGBAProtocol && c.updateDisplayedOpacity(this._displayedOpacity)
            }
        }
    },
    isCascadeOpacityEnabled: function () {
        return this._cascadeOpacityEnabled
    },
    setCascadeOpacityEnabled: function (a) {
        this._cascadeOpacityEnabled !== a && ((this._cascadeOpacityEnabled = a) ? this._enableCascadeOpacity() : this._disableCascadeOpacity())
    },
    _enableCascadeOpacity: function () {
        var a = 255,
            b = this._parent;
        b && b.RGBAProtocol && b.cascadeOpacity && (a = b.getDisplayedOpacity());
        this.updateDisplayedOpacity(a)
    },
    _disableCascadeOpacity: function () {
        this._displayedOpacity = this._realOpacity;
        for (var a = this._children, b = 0; b < a.length; b++) {
            var c = a[b];
            c && c.RGBAProtocol && c.updateDisplayedOpacity(255)
        }
    },
    getColor: function () {
        var a = this._realColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getDisplayedColor: function () {
        return this._displayedColor
    },
    setColor: function (a) {
        var b = this._displayedColor,
            c = this._realColor;
        b.r = c.r = a.r;
        b.g = c.g = a.g;
        b.b = c.b = a.b;
        b = (b = this._parent) && b.RGBAProtocol && b.cascadeColor ? b.getDisplayedColor() : cc.color.WHITE;
        this.updateDisplayedColor(b);
        void 0 === a.a || a.a_undefined || this.setOpacity(a.a)
    },
    updateDisplayedColor: function (a) {
        var b = this._displayedColor,
            c = this._realColor;
        b.r = 0 | c.r * a.r / 255;
        b.g =
            0 | c.g * a.g / 255;
        b.b = 0 | c.b * a.b / 255;
        if (this._cascadeColorEnabled)
            for (a = this._children, c = 0; c < a.length; c++) {
                var d = a[c];
                d && d.RGBAProtocol && d.updateDisplayedColor(b)
            }
    },
    isCascadeColorEnabled: function () {
        return this._cascadeColorEnabled
    },
    setCascadeColorEnabled: function (a) {
        this._cascadeColorEnabled !== a && ((this._cascadeColorEnabled = a) ? this._enableCascadeColor() : this._disableCascadeColor())
    },
    _enableCascadeColor: function () {
        var a;
        a = (a = this._parent) && a.RGBAProtocol && a.cascadeColor ? a.getDisplayedColor() : cc.color.WHITE;
        this.updateDisplayedColor(a)
    },
    _disableCascadeColor: function () {
        var a = this._displayedColor,
            b = this._realColor;
        a.r = b.r;
        a.g = b.g;
        a.b = b.b;
        for (var a = this._children, b = cc.color.WHITE, c = 0; c < a.length; c++) {
            var d = a[c];
            d && d.RGBAProtocol && d.updateDisplayedColor(b)
        }
    },
    addChild: function (a, b, c) {
        cc.Node.prototype.addChild.call(this, a, b, c);
        this._cascadeColorEnabled && this._enableCascadeColor();
        this._cascadeOpacityEnabled && this._enableCascadeOpacity()
    },
    setOpacityModifyRGB: function (a) {},
    isOpacityModifyRGB: function () {
        return !1
    }
});
cc.NodeRGBA.create = function () {
    var a = new cc.NodeRGBA;
    a.init();
    return a
};
window._p = cc.NodeRGBA.prototype;
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
cc.defineGetterSetter(_p, "cascadeOpacity", _p.isCascadeOpacityEnabled, _p.setCascadeOpacityEnabled);
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, "cascadeColor", _p.isCascadeColorEnabled, _p.setCascadeColorEnabled);
delete window._p;
cc.AtlasNode = cc.NodeRGBA.extend({
    textureAtlas: null,
    quadsToDraw: 0,
    RGBAProtocol: !0,
    _itemsPerRow: 0,
    _itemsPerColumn: 0,
    _itemWidth: 0,
    _itemHeight: 0,
    _colorUnmodified: null,
    _opacityModifyRGB: !1,
    _blendFunc: null,
    _ignoreContentScaleFactor: !1,
    _className: "AtlasNode",
    ctor: function () {
        cc.NodeRGBA.prototype.ctor.call(this);
        this._colorUnmodified = cc.color.WHITE;
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._ignoreContentScaleFactor = !1
    },
    updateAtlasValues: function () {
        cc.log("cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses")
    },
    getColor: function () {
        return this._opacityModifyRGB ? this._colorUnmodified : cc.NodeRGBA.prototype.getColor.call(this)
    },
    setOpacityModifyRGB: function (a) {
        var b = this.color;
        this._opacityModifyRGB = a;
        this.color = b
    },
    isOpacityModifyRGB: function () {
        return this._opacityModifyRGB
    },
    getBlendFunc: function () {
        return this._blendFunc
    },
    setBlendFunc: function (a, b) {
        this._blendFunc = void 0 === b ? a : {
            src: a,
            dst: b
        }
    },
    setTextureAtlas: function (a) {
        this.textureAtlas = a
    },
    getTextureAtlas: function () {
        return this.textureAtlas
    },
    getQuadsToDraw: function () {
        return this.quadsToDraw
    },
    setQuadsToDraw: function (a) {
        this.quadsToDraw = a
    },
    _textureForCanvas: null,
    _originalTexture: null,
    _uniformColor: null,
    _colorF32Array: null,
    initWithTileFile: function (a, b, c, d) {
        if (!a) throw "cc.AtlasNode.initWithTileFile(): title should not be null";
        a = cc.textureCache.addImage(a);
        return this.initWithTexture(a, b, c, d)
    },
    initWithTexture: null,
    _initWithTextureForCanvas: function (a, b, c, d) {
        this._itemWidth = b;
        this._itemHeight = c;
        this._opacityModifyRGB = !0;
        this._originalTexture = a;
        if (!this._originalTexture) return cc.log("cocos2d: Could not initialize cc.AtlasNode. Invalid Texture."), !1;
        this._textureForCanvas = this._originalTexture;
        this._calculateMaxItems();
        this.quadsToDraw = d;
        return !0
    },
    _initWithTextureForWebGL: function (a, b, c, d) {
        this._itemWidth = b;
        this._itemHeight = c;
        this._colorUnmodified = cc.color.WHITE;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        b = this._realColor;
        this._colorF32Array = new Float32Array([b.r / 255, b.g / 255, b.b / 255, this._realOpacity / 255]);
        this.textureAtlas = new cc.TextureAtlas;
        this.textureAtlas.initWithTexture(a, d);
        if (!this.textureAtlas) return cc.log("cocos2d: Could not initialize cc.AtlasNode. Invalid Texture."), !1;
        this._updateBlendFunc();
        this._updateOpacityModifyRGB();
        this._calculateMaxItems();
        this.quadsToDraw = d;
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
        this._uniformColor = cc._renderContext.getUniformLocation(this.shaderProgram.getProgram(), "u_color");
        return !0
    },
    draw: null,
    _drawForWebGL: function (a) {
        a = a || cc._renderContext;
        cc.NODE_DRAW_SETUP(this);
        cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
        a.uniform4fv(this._uniformColor, this._colorF32Array);
        this.textureAtlas.drawNumberOfQuads(this.quadsToDraw,
            0)
    },
    setColor: null,
    _setColorForCanvas: function (a) {
        var b = this._realColor;
        if (b.r != a.r || b.g != a.g || b.b != a.b) {
            b = cc.color(a.r, a.g, a.b);
            this._colorUnmodified = a;
            if (this._opacityModifyRGB) {
                var c = this._displayedOpacity;
                b.r = b.r * c / 255;
                b.g = b.g * c / 255;
                b.b = b.b * c / 255
            }
            cc.NodeRGBA.prototype.setColor.call(this, a);
            this.texture && (a = this._originalTexture.getHtmlElementObj()) && (b = cc.textureCache.getTextureColors(a)) && (c = cc.rect(0, 0, a.width, a.height), a = cc.generateTintImage(a, b, this._realColor, c), b = new cc.Texture2D, b.initWithElement(a),
                b.handleLoadedTexture(), this.texture = b)
        }
    },
    _setColorForWebGL: function (a) {
        var b = cc.color(a.r, a.g, a.b);
        this._colorUnmodified = a;
        var c = this._displayedOpacity;
        this._opacityModifyRGB && (b.r = b.r * c / 255, b.g = b.g * c / 255, b.b = b.b * c / 255);
        cc.NodeRGBA.prototype.setColor.call(this, a);
        a = this._displayedColor;
        this._colorF32Array = new Float32Array([a.r / 255, a.g / 255, a.b / 255, c / 255])
    },
    setOpacity: function (a) {},
    _setOpacityForCanvas: function (a) {
        cc.NodeRGBA.prototype.setOpacity.call(this, a);
        this._opacityModifyRGB && (this.color = this._colorUnmodified)
    },
    _setOpacityForWebGL: function (a) {
        cc.NodeRGBA.prototype.setOpacity.call(this, a);
        this._opacityModifyRGB ? this.color = this._colorUnmodified : (a = this._displayedColor, this._colorF32Array = new Float32Array([a.r / 255, a.g / 255, a.b / 255, this._displayedOpacity / 255]))
    },
    getTexture: null,
    _getTextureForCanvas: function () {
        return this._textureForCanvas
    },
    _getTextureForWebGL: function () {
        return this.textureAtlas.texture
    },
    setTexture: null,
    _setTextureForCanvas: function (a) {
        this._textureForCanvas = a
    },
    _setTextureForWebGL: function (a) {
        this.textureAtlas.texture =
            a;
        this._updateBlendFunc();
        this._updateOpacityModifyRGB()
    },
    _calculateMaxItems: null,
    _calculateMaxItemsForCanvas: function () {
        var a = this.texture.getContentSize();
        this._itemsPerColumn = 0 | a.height / this._itemHeight;
        this._itemsPerRow = 0 | a.width / this._itemWidth
    },
    _calculateMaxItemsForWebGL: function () {
        var a = this.texture,
            b = a.getContentSize();
        this._ignoreContentScaleFactor && (b = a.getContentSizeInPixels());
        this._itemsPerColumn = 0 | b.height / this._itemHeight;
        this._itemsPerRow = 0 | b.width / this._itemWidth
    },
    _updateBlendFunc: function () {
        this.textureAtlas.texture.hasPremultipliedAlpha() ||
            (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    _updateOpacityModifyRGB: function () {
        this._opacityModifyRGB = this.textureAtlas.texture.hasPremultipliedAlpha()
    },
    _setIgnoreContentScaleFactor: function (a) {
        this._ignoreContentScaleFactor = a
    }
});
window._p = cc.AtlasNode.prototype;
cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.initWithTexture = _p._initWithTextureForWebGL, _p.draw = _p._drawForWebGL, _p.setColor = _p._setColorForWebGL, _p.setOpacity = _p._setOpacityForWebGL, _p.getTexture = _p._getTextureForWebGL, _p.setTexture = _p._setTextureForWebGL, _p._calculateMaxItems = _p._calculateMaxItemsForWebGL) : (_p.initWithTexture = _p._initWithTextureForCanvas, _p.draw = cc.Node.prototype.draw, _p.setColor = _p._setColorForCanvas, _p.setOpacity = _p._setOpacityForCanvas, _p.getTexture = _p._getTextureForCanvas, _p.setTexture =
    _p._setTextureForCanvas, _p._calculateMaxItems = _p._calculateMaxItemsForCanvas);
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
delete window._p;
cc.AtlasNode.create = function (a, b, c, d) {
    var e = new cc.AtlasNode;
    return e.initWithTileFile(a, b, c, d) ? e : null
};
cc.ALIGN_CENTER = 51;
cc.ALIGN_TOP = 19;
cc.ALIGN_TOP_RIGHT = 18;
cc.ALIGN_RIGHT = 50;
cc.ALIGN_BOTTOM_RIGHT = 34;
cc.ALIGN_BOTTOM = 35;
cc.ALIGN_BOTTOM_LEFT = 33;
cc.ALIGN_LEFT = 49;
cc.ALIGN_TOP_LEFT = 17;
cc.PVRHaveAlphaPremultiplied_ = !1;
cc.Texture2DWebGL = cc.Class.extend({
    _pVRHaveAlphaPremultiplied: !0,
    _pixelFormat: null,
    _pixelsWide: 0,
    _pixelsHigh: 0,
    _name: "",
    _contentSize: null,
    maxS: 0,
    maxT: 0,
    _hasPremultipliedAlpha: !1,
    _hasMipmaps: !1,
    shaderProgram: null,
    _isLoaded: !1,
    _htmlElementObj: null,
    _webTextureObj: null,
    url: null,
    _loadedEventListeners: null,
    ctor: function () {
        this._contentSize = cc.size(0, 0);
        this._pixelFormat = cc.Texture2D.defaultPixelFormat
    },
    releaseTexture: function () {
        this._webTextureObj && cc._renderContext.deleteTexture(this._webTextureObj);
        cc.loader.release(this.url)
    },
    getPixelFormat: function () {
        return this._pixelFormat
    },
    getPixelsWide: function () {
        return this._pixelsWide
    },
    getPixelsHigh: function () {
        return this._pixelsHigh
    },
    getName: function () {
        return this._webTextureObj
    },
    getContentSize: function () {
        return cc.size(this._contentSize.width / cc.CONTENT_SCALE_FACTOR(), this._contentSize.height / cc.CONTENT_SCALE_FACTOR())
    },
    _getWidth: function () {
        return this._contentSize.width / cc.CONTENT_SCALE_FACTOR()
    },
    _getHeight: function () {
        return this._contentSize.height / cc.CONTENT_SCALE_FACTOR()
    },
    getContentSizeInPixels: function () {
        return this._contentSize
    },
    getMaxS: function () {
        return this.maxS
    },
    setMaxS: function (a) {
        this.maxS = a
    },
    getMaxT: function () {
        return this.maxT
    },
    setMaxT: function (a) {
        this.maxT = a
    },
    getShaderProgram: function () {
        return this.shaderProgram
    },
    setShaderProgram: function (a) {
        this.shaderProgram = a
    },
    hasPremultipliedAlpha: function () {
        return this._hasPremultipliedAlpha
    },
    hasMipmaps: function () {
        return this._hasMipmaps
    },
    description: function () {
        return "\x3ccc.Texture2D | Name \x3d " + this._name + " | Dimensions \x3d " +
            this._pixelsWide + " x " + this._pixelsHigh + " | Coordinates \x3d (" + this.maxS + ", " + this.maxT + ")\x3e"
    },
    releaseData: function (a) {},
    keepData: function (a, b) {
        return a
    },
    initWithData: function (a, b, c, d, e) {
        var f = cc.Texture2D,
            g = cc._renderContext,
            h = g.RGBA,
            k = g.UNSIGNED_BYTE,
            m = c * cc.Texture2D._B[b] / 8;
        0 === m % 8 ? g.pixelStorei(g.UNPACK_ALIGNMENT, 8) : 0 === m % 4 ? g.pixelStorei(g.UNPACK_ALIGNMENT, 4) : 0 === m % 2 ? g.pixelStorei(g.UNPACK_ALIGNMENT, 2) : g.pixelStorei(g.UNPACK_ALIGNMENT, 1);
        this._webTextureObj = g.createTexture();
        cc.glBindTexture2D(this);
        g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MIN_FILTER, g.LINEAR);
        g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MAG_FILTER, g.LINEAR);
        g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_S, g.CLAMP_TO_EDGE);
        g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_T, g.CLAMP_TO_EDGE);
        switch (b) {
        case f.PIXEL_FORMAT_RGBA8888:
            h = g.RGBA;
            break;
        case f.PIXEL_FORMAT_RGB888:
            h = g.RGB;
            break;
        case f.PIXEL_FORMAT_RGBA4444:
            k = g.UNSIGNED_SHORT_4_4_4_4;
            break;
        case f.PIXEL_FORMAT_RGB5A1:
            k = g.UNSIGNED_SHORT_5_5_5_1;
            break;
        case f.PIXEL_FORMAT_RGB565:
            k = g.UNSIGNED_SHORT_5_6_5;
            break;
        case f.PIXEL_FORMAT_AI88:
            h = g.LUMINANCE_ALPHA;
            break;
        case f.PIXEL_FORMAT_A8:
            h = g.ALPHA;
            break;
        case f.PIXEL_FORMAT_I8:
            h = g.LUMINANCE;
            break;
        default:
            throw "NSInternalInconsistencyException";
        }
        g.texImage2D(g.TEXTURE_2D, 0, h, c, d, 0, h, k, a);
        this._contentSize.width = e.width;
        this._contentSize.height = e.height;
        this._pixelsWide = c;
        this._pixelsHigh = d;
        this._pixelFormat = b;
        this.maxS = e.width / c;
        this.maxT = e.height / d;
        this._hasMipmaps = this._hasPremultipliedAlpha = !1;
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
        return this._isLoaded = !0
    },
    drawAtPoint: function (a) {
        var b = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0],
            c = this._pixelsWide * this.maxS,
            d = this._pixelsHigh * this.maxT;
        a = [a.x, a.y, 0, c + a.x, a.y, 0, a.x, d + a.y, 0, c + a.x, d + a.y, 0];
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
        this._shaderProgram.use();
        this._shaderProgram.setUniformsForBuiltins();
        cc.glBindTexture2D(this);
        c = cc._renderContext;
        c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, a);
        c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
            2, c.FLOAT, !1, 0, b);
        c.drawArrays(c.TRIANGLE_STRIP, 0, 4)
    },
    drawInRect: function (a) {
        var b = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0];
        a = [a.x, a.y, a.x + a.width, a.y, a.x, a.y + a.height, a.x + a.width, a.y + a.height];
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
        this._shaderProgram.use();
        this._shaderProgram.setUniformsForBuiltins();
        cc.glBindTexture2D(this);
        var c = cc._renderContext;
        c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, a);
        c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
            2, c.FLOAT, !1, 0, b);
        c.drawArrays(c.TRIANGLE_STRIP, 0, 4)
    },
    initWithImage: function (a) {
        if (null == a) return cc.log("cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil"), !1;
        var b = a.getWidth(),
            c = a.getHeight(),
            d = cc.configuration.getMaxTextureSize();
        if (b > d || c > d) return cc.log("cocos2d: WARNING: Image (" + b + " x " + c + ") is bigger than the supported " + d + " x " + d), !1;
        this._isLoaded = !0;
        return this._initPremultipliedATextureWithImage(a, b, c)
    },
    initWithElement: function (a) {
        a && (this._webTextureObj = cc._renderContext.createTexture(),
            this._htmlElementObj = a)
    },
    getHtmlElementObj: function () {
        return this._htmlElementObj
    },
    isLoaded: function () {
        return this._isLoaded
    },
    handleLoadedTexture: function () {
        if (cc._rendererInitialized) {
            if (!this._htmlElementObj) {
                var a = cc.loader.getRes(this.url);
                if (!a) return;
                this.initWithElement(a)
            }
            this._isLoaded = !0;
            a = cc._renderContext;
            cc.glBindTexture2D(this);
            a.pixelStorei(a.UNPACK_ALIGNMENT, 4);
            a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, a.RGBA, a.UNSIGNED_BYTE, this._htmlElementObj);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER,
                a.LINEAR);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE);
            this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
            cc.glBindTexture2D(null);
            a = this._htmlElementObj.height;
            this._pixelsWide = this._contentSize.width = this._htmlElementObj.width;
            this._pixelsHigh = this._contentSize.height = a;
            this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888;
            this.maxT =
                this.maxS = 1;
            this._hasMipmaps = this._hasPremultipliedAlpha = !1;
            this._callLoadedEventCallbacks()
        }
    },
    initWithString: function (a, b, c, d, e, f) {
        cc.log("initWithString isn't supported on cocos2d-html5");
        return null
    },
    initWithETCFile: function (a) {
        cc.log("initWithETCFile does not support on HTML5");
        return !1
    },
    initWithPVRFile: function (a) {
        cc.log("initWithPVRFile does not support on HTML5");
        return !1
    },
    initWithPVRTCData: function (a, b, c, d, e, f) {
        cc.log("initWithPVRTCData does not support on HTML5");
        return !1
    },
    setTexParameters: function (a) {
        var b =
            cc._renderContext;
        cc.assert(this._pixelsWide == cc.NextPOT(this._pixelsWide) && this._pixelsHigh == cc.NextPOT(this._pixelsHigh) || a.wrapS == b.CLAMP_TO_EDGE && a.wrapT == b.CLAMP_TO_EDGE, "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures");
        cc.glBindTexture2D(this);
        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, a.minFilter);
        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, a.magFilter);
        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, a.wrapS);
        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, a.wrapT)
    },
    setAntiAliasTexParameters: function () {
        var a = cc._renderContext;
        cc.glBindTexture2D(this);
        this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR);
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST)
    },
    setAliasTexParameters: function () {
        var a = cc._renderContext;
        cc.glBindTexture2D(this);
        this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D,
            a.TEXTURE_MIN_FILTER, a.NEAREST);
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST)
    },
    generateMipmap: function () {
        cc.assert(this._pixelsWide == cc.NextPOT(this._pixelsWide) && this._pixelsHigh == cc.NextPOT(this._pixelsHigh), "Mimpap texture only works in POT textures");
        cc.glBindTexture2D(this);
        cc._renderContext.generateMipmap(cc._renderContext.TEXTURE_2D);
        this._hasMipmaps = !0
    },
    stringForFormat: function () {
        return cc.Texture2D._M[this._pixelFormat]
    },
    bitsPerPixelForFormat: function (a) {
        a = a || this._pixelFormat;
        var b = cc.Texture2D._B[a];
        if (null != b) return b;
        cc.log("bitsPerPixelForFormat: " + a + ", cannot give useful result, it's a illegal pixel format");
        return -1
    },
    _initPremultipliedATextureWithImage: function (a, b, c) {
        var d = cc.Texture2D,
            e = a.getData(),
            f = null,
            f = null,
            g = a.hasAlpha(),
            h = cc.size(a.getWidth(), a.getHeight()),
            k = d.defaultPixelFormat,
            m = a.getBitsPerComponent();
        g || (8 <= m ? k = d.PIXEL_FORMAT_RGB888 : (cc.log("cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha"), k = d.PIXEL_FORMAT_RGB565));
        var n = b * c;
        if (k ==
            d.PIXEL_FORMAT_RGB565)
            if (g)
                for (e = new Uint16Array(b * c), f = a.getData(), m = 0; m < n; ++m) e[m] = (f[m] >> 0 & 255) >> 3 << 11 | (f[m] >> 8 & 255) >> 2 << 5 | (f[m] >> 16 & 255) >> 3 << 0;
            else
                for (e = new Uint16Array(b * c), f = a.getData(), m = 0; m < n; ++m) e[m] = (f[m] & 255) >> 3 << 11 | (f[m] & 255) >> 2 << 5 | (f[m] & 255) >> 3 << 0;
        else if (k == d.PIXEL_FORMAT_RGBA4444)
            for (e = new Uint16Array(b * c), f = a.getData(), m = 0; m < n; ++m) e[m] = (f[m] >> 0 & 255) >> 4 << 12 | (f[m] >> 8 & 255) >> 4 << 8 | (f[m] >> 16 & 255) >> 4 << 4 | (f[m] >> 24 & 255) >> 4 << 0;
        else if (k == d.PIXEL_FORMAT_RGB5A1)
            for (e = new Uint16Array(b * c), f = a.getData(),
                m = 0; m < n; ++m) e[m] = (f[m] >> 0 & 255) >> 3 << 11 | (f[m] >> 8 & 255) >> 3 << 6 | (f[m] >> 16 & 255) >> 3 << 1 | (f[m] >> 24 & 255) >> 7 << 0;
        else if (k == d.PIXEL_FORMAT_A8)
            for (e = new Uint8Array(b * c), f = a.getData(), m = 0; m < n; ++m) e[m] = f >> 24 & 255;
        if (g && k == d.PIXEL_FORMAT_RGB888)
            for (f = a.getData(), e = new Uint8Array(b * c * 3), m = 0; m < n; ++m) e[3 * m] = f >> 0 & 255, e[3 * m + 1] = f >> 8 & 255, e[3 * m + 2] = f >> 16 & 255;
        this.initWithData(e, k, b, c, h);
        a.getData();
        this._hasPremultipliedAlpha = a.isPremultipliedAlpha();
        return !0
    },
    addLoadedEventListener: function (a, b) {
        this._loadedEventListeners ||
            (this._loadedEventListeners = []);
        this._loadedEventListeners.push({
            eventCallback: a,
            eventTarget: b
        })
    },
    removeLoadedEventListener: function (a) {
        if (this._loadedEventListeners)
            for (var b = this._loadedEventListeners, c = 0; c < b.length; c++) b[c].eventTarget == a && b.splice(c, 1)
    },
    _callLoadedEventCallbacks: function () {
        if (this._loadedEventListeners) {
            for (var a = this._loadedEventListeners, b = 0, c = a.length; b < c; b++) {
                var d = a[b];
                d.eventCallback.call(d.eventTarget, this)
            }
            a.length = 0
        }
    }
});
cc.Texture2DCanvas = cc.Class.extend({
    _contentSize: null,
    _isLoaded: !1,
    _htmlElementObj: null,
    _loadedEventListeners: null,
    url: null,
    ctor: function () {
        this._contentSize = cc.size(0, 0);
        this._isLoaded = !1;
        this._htmlElementObj = null
    },
    getPixelsWide: function () {
        return this._contentSize.width
    },
    getPixelsHigh: function () {
        return this._contentSize.height
    },
    getContentSize: function () {
        var a = cc.CONTENT_SCALE_FACTOR();
        return cc.size(this._contentSize.width / a, this._contentSize.height / a)
    },
    _getWidth: function () {
        return this._contentSize.width /
            cc.CONTENT_SCALE_FACTOR()
    },
    _getHeight: function () {
        return this._contentSize.height / cc.CONTENT_SCALE_FACTOR()
    },
    getContentSizeInPixels: function () {
        return this._contentSize
    },
    initWithElement: function (a) {
        a && (this._htmlElementObj = a)
    },
    getHtmlElementObj: function () {
        return this._htmlElementObj
    },
    isLoaded: function () {
        return this._isLoaded
    },
    handleLoadedTexture: function () {
        if (!this._isLoaded) {
            if (!this._htmlElementObj) {
                var a = cc.loader.getRes(this.url);
                if (!a) return;
                this.initWithElement(a)
            }
            this._isLoaded = !0;
            a = this._htmlElementObj;
            this._contentSize.width = a.width;
            this._contentSize.height = a.height;
            this._callLoadedEventCallbacks()
        }
    },
    description: function () {
        return "\x3ccc.Texture2D | width \x3d " + this._contentSize.width + " height " + this._contentSize.height + "\x3e"
    },
    initWithData: function (a, b, c, d, e) {
        return !1
    },
    initWithImage: function (a) {
        return !1
    },
    initWithString: function (a, b, c, d, e, f) {
        return !1
    },
    releaseTexture: function () {},
    getName: function () {
        return null
    },
    getMaxS: function () {
        return 1
    },
    setMaxS: function (a) {},
    getMaxT: function () {
        return 1
    },
    setMaxT: function (a) {},
    getPixelFormat: function () {
        return null
    },
    getShaderProgram: function () {
        return null
    },
    setShaderProgram: function (a) {},
    hasPremultipliedAlpha: function () {
        return !1
    },
    hasMipmaps: function () {
        return !1
    },
    releaseData: function (a) {},
    keepData: function (a, b) {
        return a
    },
    drawAtPoint: function (a) {},
    drawInRect: function (a) {},
    initWithETCFile: function (a) {
        cc.log("initWithETCFile does not support on HTML5");
        return !1
    },
    initWithPVRFile: function (a) {
        cc.log("initWithPVRFile does not support on HTML5");
        return !1
    },
    initWithPVRTCData: function (a,
        b, c, d, e, f) {
        cc.log("initWithPVRTCData does not support on HTML5");
        return !1
    },
    setTexParameters: function (a) {},
    setAntiAliasTexParameters: function () {},
    setAliasTexParameters: function () {},
    generateMipmap: function () {},
    stringForFormat: function () {
        return ""
    },
    bitsPerPixelForFormat: function (a) {
        return -1
    },
    addLoadedEventListener: function (a, b) {
        this._loadedEventListeners || (this._loadedEventListeners = []);
        this._loadedEventListeners.push({
            eventCallback: a,
            eventTarget: b
        })
    },
    removeLoadedEventListener: function (a) {
        if (this._loadedEventListeners)
            for (var b =
                this._loadedEventListeners, c = 0; c < b.length; c++) b[c].eventTarget == a && b.splice(c, 1)
    },
    _callLoadedEventCallbacks: function () {
        if (this._loadedEventListeners) {
            for (var a = this._loadedEventListeners, b = 0, c = a.length; b < c; b++) {
                var d = a[b];
                d.eventCallback.call(d.eventTarget, this)
            }
            a.length = 0
        }
    }
});
cc.Texture2D = cc._renderType === cc._RENDER_TYPE_WEBGL ? cc.Texture2DWebGL : cc.Texture2DCanvas;
cc.Texture2D.PVRImagesHavePremultipliedAlpha = function (a) {
    cc.PVRHaveAlphaPremultiplied_ = a
};
window._c = cc.Texture2D;
_c.PIXEL_FORMAT_RGBA8888 = 0;
_c.PIXEL_FORMAT_RGB888 = 1;
_c.PIXEL_FORMAT_RGB565 = 2;
_c.PIXEL_FORMAT_A8 = 3;
_c.PIXEL_FORMAT_I8 = 4;
_c.PIXEL_FORMAT_AI88 = 5;
_c.PIXEL_FORMAT_RGBA4444 = 6;
_c.PIXEL_FORMAT_RGB5A1 = 7;
_c.PIXEL_FORMAT_PVRTC4 = 8;
_c.PIXEL_FORMAT_PVRTC2 = 9;
_c.PIXEL_FORMAT_DEFAULT = _c.PIXEL_FORMAT_RGBA8888;
window._M = cc.Texture2D._M = {};
_M[_c.PIXEL_FORMAT_RGBA8888] = "RGBA8888";
_M[_c.PIXEL_FORMAT_RGB888] = "RGB888";
_M[_c.PIXEL_FORMAT_RGB565] = "RGB565";
_M[_c.PIXEL_FORMAT_A8] = "A8";
_M[_c.PIXEL_FORMAT_I8] = "I8";
_M[_c.PIXEL_FORMAT_AI88] = "AI88";
_M[_c.PIXEL_FORMAT_RGBA4444] = "RGBA4444";
_M[_c.PIXEL_FORMAT_RGB5A1] = "RGB5A1";
_M[_c.PIXEL_FORMAT_PVRTC4] = "PVRTC4";
_M[_c.PIXEL_FORMAT_PVRTC2] = "PVRTC2";
window._B = cc.Texture2D._B = {};
_B[_c.PIXEL_FORMAT_RGBA8888] = 32;
_B[_c.PIXEL_FORMAT_RGB888] = 24;
_B[_c.PIXEL_FORMAT_RGB565] = 16;
_B[_c.PIXEL_FORMAT_A8] = 8;
_B[_c.PIXEL_FORMAT_I8] = 8;
_B[_c.PIXEL_FORMAT_AI88] = 16;
_B[_c.PIXEL_FORMAT_RGBA4444] = 16;
_B[_c.PIXEL_FORMAT_RGB5A1] = 16;
_B[_c.PIXEL_FORMAT_PVRTC4] = 4;
_B[_c.PIXEL_FORMAT_PVRTC2] = 3;
window._p = cc.Texture2D.prototype;
cc.defineGetterSetter(_p, "name", _p.getName);
cc.defineGetterSetter(_p, "pixelFormat", _p.getPixelFormat);
cc.defineGetterSetter(_p, "pixelsWidth", _p.getPixelsWide);
cc.defineGetterSetter(_p, "pixelsHeight", _p.getPixelsHigh);
cc.defineGetterSetter(_p, "width", _p._getWidth, _p._setWidth);
cc.defineGetterSetter(_p, "height", _p._getHeight, _p._setHeight);
cc.Texture2D.defaultPixelFormat = _c.PIXEL_FORMAT_DEFAULT;
delete window._p;
delete window._c;
delete window._M;
delete window._B;
cc.textureCache = {
    _textures: {},
    _textureColorsCache: {},
    _textureKeySeq: 0 | 1E3 * Math.random(),
    _loadedTexturesBefore: {},
    handleLoadedTexture: function (a) {
        var b = this._textures;
        cc._renderType !== cc._RENDER_TYPE_WEBGL || cc._rendererInitialized || (b = this._loadedTexturesBefore);
        var c = b[a];
        c || (c = b[a] = new cc.Texture2D, c.url = a);
        c.handleLoadedTexture()
    },
    _initializingRenderer: function () {
        var a, b = this._loadedTexturesBefore,
            c = this._textures;
        for (a in b) {
            var d = b[a];
            d.handleLoadedTexture();
            c[a] = d
        }
        this._loadedTexturesBefore = {}
    },
    addPVRTCImage: function (a) {
        cc.log("TextureCache:addPVRTCImage does not support on HTML5")
    },
    addETCImage: function (a) {
        cc.log("TextureCache:addPVRTCImage does not support on HTML5")
    },
    description: function () {
        return "\x3cTextureCache | Number of textures \x3d " + this._textures.length + "\x3e"
    },
    textureForKey: function (a) {
        return this._textures[a] || this._textures[cc.loader._aliases[a]]
    },
    getKeyByTexture: function (a) {
        for (var b in this._textures)
            if (this._textures[b] == a) return b;
        return null
    },
    _generalTextureKey: function () {
        this._textureKeySeq++;
        return "_textureKey_" + this._textureKeySeq
    },
    getTextureColors: function (a) {
        var b = this.getKeyByTexture(a);
        b || (b = a instanceof HTMLImageElement ? a.src : this._generalTextureKey());
        this._textureColorsCache[b] || (this._textureColorsCache[b] = cc.generateTextureCacheForColor(a));
        return this._textureColorsCache[b]
    },
    addPVRImage: function (a) {
        cc.log("addPVRImage does not support on HTML5")
    },
    removeAllTextures: function () {
        var a = this._textures,
            b;
        for (b in a) a[b] && a[b].releaseTexture();
        this._textures = {}
    },
    removeTexture: function (a) {
        if (a) {
            var b =
                this._textures,
                c;
            for (c in b) b[c] == a && (b[c].releaseTexture(), delete b[c])
        }
    },
    removeTextureForKey: function (a) {
        null != a && this._textures[a] && delete this._textures[a]
    },
    addImage: function (a, b, c) {
        if (!a) throw "cc.Texture.addImage(): path should be non-null";
        2 == arguments.length && (c = b, b = null);
        var d = this._textures;
        cc._renderType !== cc._RENDER_TYPE_WEBGL || cc._rendererInitialized || (d = this._loadedTexturesBefore);
        var e = d[a] || d[cc.loader._aliases[a]];
        if (e) return c && c.call(b), e;
        cc.loader.getRes(a) || cc.loader.load(a, function (a) {
            c &&
                c.call(b)
        });
        e = d[a] = new cc.Texture2D;
        e.url = a;
        return e
    },
    cacheImage: function (a, b) {
        if (b instanceof cc.Texture2D) this._textures[a] = b;
        else {
            var c = new cc.Texture2D;
            c.initWithElement(b);
            c.handleLoadedTexture();
            this._textures[a] = c
        }
    },
    addUIImage: function (a, b) {
        if (!a) throw "cc.Texture.addUIImage(): image should be non-null";
        if (b && this._textures[b]) return this._textures[b];
        var c = new cc.Texture2D;
        c.initWithImage(a);
        null != b && null != c ? this._textures[b] = c : cc.log("cocos2d: Couldn't add UIImage in TextureCache");
        return c
    },
    dumpCachedTextureInfo: function () {
        var a = 0,
            b = 0,
            c = this._textures,
            d;
        for (d in c) {
            var e = c[d];
            a++;
            e.getHtmlElementObj() instanceof HTMLImageElement ? cc.log("cocos2d: '" + d + "' id\x3d" + e.getHtmlElementObj().src + " " + e.pixelsWidth + " x " + e.pixelsHeight) : cc.log("cocos2d: '" + d + "' id\x3d HTMLCanvasElement " + e.pixelsWidth + " x " + e.pixelsHeight);
            b += e.pixelsWidth * e.pixelsHeight * 4
        }
        c = this._textureColorsCache;
        for (d in c) {
            var e = c[d],
                f;
            for (f in e) {
                var g = e[f];
                a++;
                cc.log("cocos2d: '" + d + "' id\x3d HTMLCanvasElement " + g.width + " x " +
                    g.height);
                b += g.width * g.height * 4
            }
        }
        cc.log("cocos2d: TextureCache dumpDebugInfo: " + a + " textures, HTMLCanvasElement for " + b / 1024 + " KB (" + (b / 1048576).toFixed(2) + " MB)")
    },
    _clear: function () {
        this._textures = {};
        this._textureColorsCache = {};
        this._textureKeySeq = 0 | 1E3 * Math.random();
        this._loadedTexturesBefore = {}
    }
};
cc.TextureAtlas = cc.Class.extend({
    dirty: !1,
    texture: null,
    _indices: null,
    _buffersVBO: null,
    _capacity: 0,
    _quads: null,
    _quadsArrayBuffer: null,
    _quadsWebBuffer: null,
    _quadsReader: null,
    ctor: function () {
        this._buffersVBO = []
    },
    getTotalQuads: function () {
        return this._totalQuads
    },
    getCapacity: function () {
        return this._capacity
    },
    getTexture: function () {
        return this.texture
    },
    setTexture: function (a) {
        this.texture = a
    },
    setDirty: function (a) {
        this.dirty = a
    },
    isDirty: function () {
        return this.dirty
    },
    getQuads: function () {
        return this._quads
    },
    setQuads: function (a) {
        this._quads =
            a
    },
    _copyQuadsToTextureAtlas: function (a, b) {
        if (a)
            for (var c = 0; c < a.length; c++) this._setQuadToArray(a[c], b + c)
    },
    _setQuadToArray: function (a, b) {
        var c = this._quads;
        c[b] ? (c[b].bl = a.bl, c[b].br = a.br, c[b].tl = a.tl, c[b].tr = a.tr) : c[b] = new cc.V3F_C4B_T2F_Quad(a.tl, a.bl, a.tr, a.br, this._quadsArrayBuffer, b * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT)
    },
    description: function () {
        return "\x3ccc.TextureAtlas | totalQuads \x3d" + this._totalQuads + "\x3e"
    },
    _setupIndices: function () {
        if (0 !== this._capacity)
            for (var a = this._indices, b = this._capacity,
                c = 0; c < b; c++) cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? (a[6 * c + 0] = 4 * c + 0, a[6 * c + 1] = 4 * c + 0, a[6 * c + 2] = 4 * c + 2, a[6 * c + 3] = 4 * c + 1, a[6 * c + 4] = 4 * c + 3, a[6 * c + 5] = 4 * c + 3) : (a[6 * c + 0] = 4 * c + 0, a[6 * c + 1] = 4 * c + 1, a[6 * c + 2] = 4 * c + 2, a[6 * c + 3] = 4 * c + 3, a[6 * c + 4] = 4 * c + 2, a[6 * c + 5] = 4 * c + 1)
    },
    _setupVBO: function () {
        var a = cc._renderContext;
        this._buffersVBO[0] = a.createBuffer();
        this._buffersVBO[1] = a.createBuffer();
        this._quadsWebBuffer = a.createBuffer();
        this._mapBuffers()
    },
    _mapBuffers: function () {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
    },
    initWithFile: function (a, b) {
        var c = cc.textureCache.addImage(a);
        if (c) return this.initWithTexture(c, b);
        cc.log("cocos2d: Could not open file: " + a);
        return !1
    },
    initWithTexture: function (a, b) {
        if (!a) throw "cc.TextureAtlas.initWithTexture():texture should be non-null";
        this._capacity = b |= 0;
        this._totalQuads = 0;
        this.texture = a;
        this._quads = [];
        this._indices = new Uint16Array(6 * b);
        var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._quadsArrayBuffer = new ArrayBuffer(c * b);
        this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
        if ((!this._quads || !this._indices) && 0 < b) return !1;
        for (var d = this._quads, e = 0; e < b; e++) d[e] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, e * c);
        this._setupIndices();
        this._setupVBO();
        return this.dirty = !0
    },
    updateQuad: function (a, b) {
        if (!a) throw "cc.TextureAtlas.updateQuad(): quad should be non-null";
        if (0 > b ||
            b >= this._capacity) throw "cc.TextureAtlas.updateQuad(): Invalid index";
        this._totalQuads = Math.max(b + 1, this._totalQuads);
        this._setQuadToArray(a, b);
        this.dirty = !0
    },
    insertQuad: function (a, b) {
        if (b >= this._capacity) throw "cc.TextureAtlas.insertQuad(): Invalid index";
        this._totalQuads++;
        if (this._totalQuads > this._capacity) cc.log("cc.TextureAtlas.insertQuad(): invalid totalQuads");
        else {
            var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                d = b * c,
                e = (this._totalQuads - 1 - b) * c;
            this._quads[this._totalQuads - 1] = new cc.V3F_C4B_T2F_Quad(null,
                null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * c);
            this._quadsReader.set(this._quadsReader.subarray(d, d + e), d + c);
            this._setQuadToArray(a, b);
            this.dirty = !0
        }
    },
    insertQuads: function (a, b, c) {
        c = c || a.length;
        if (b + c > this._capacity) throw "cc.TextureAtlas.insertQuad(): Invalid index + amount";
        var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._totalQuads += c;
        if (this._totalQuads > this._capacity) cc.log("cc.TextureAtlas.insertQuad(): invalid totalQuads");
        else {
            var e = b * d,
                f = (this._totalQuads - 1 - b - c) * d,
                g = this._totalQuads -
                1 - c,
                h;
            for (h = 0; h < c; h++) this._quads[g + h] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * d);
            this._quadsReader.set(this._quadsReader.subarray(e, e + f), e + d * c);
            for (h = 0; h < c; h++) this._setQuadToArray(a[h], b + h);
            this.dirty = !0
        }
    },
    insertQuadFromIndex: function (a, b) {
        if (a !== b) {
            if (0 > b && b >= this._totalQuads) throw "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex";
            if (0 > a && a >= this._totalQuads) throw "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex";
            var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                d = this._quadsReader,
                e = d.subarray(a * c, c),
                f;
            a > b ? (f = b * c, d.set(d.subarray(f, f + (a - b) * c), f + c), d.set(e, f)) : (f = (a + 1) * c, d.set(d.subarray(f, f + (b - a) * c), f - c), d.set(e, b * c));
            this.dirty = !0
        }
    },
    removeQuadAtIndex: function (a) {
        if (a >= this._totalQuads) throw "cc.TextureAtlas.removeQuadAtIndex(): Invalid index";
        var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._totalQuads--;
        this._quads.length = this._totalQuads;
        if (a !== this._totalQuads) {
            var c = (a + 1) * b;
            this._quadsReader.set(this._quadsReader.subarray(c, c + (this._totalQuads - a) * b),
                c - b)
        }
        this.dirty = !0
    },
    removeQuadsAtIndex: function (a, b) {
        if (a + b > this._totalQuads) throw "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds";
        this._totalQuads -= b;
        if (a !== this._totalQuads) {
            var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                d = (a + b) * c,
                e = a * c;
            this._quadsReader.set(this._quadsReader.subarray(d, d + (this._totalQuads - a) * c), e)
        }
        this.dirty = !0
    },
    removeAllQuads: function () {
        this._totalQuads = this._quads.length = 0
    },
    _setDirty: function (a) {
        this.dirty = a
    },
    resizeCapacity: function (a) {
        if (a == this._capacity) return !0;
        var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            c = this._capacity;
        this._totalQuads = Math.min(this._totalQuads, a);
        var d = this._capacity = 0 | a,
            e = this._totalQuads;
        if (null == this._quads)
            for (this._quads = [], this._quadsArrayBuffer = new ArrayBuffer(b * d), this._quadsReader = new Uint8Array(this._quadsArrayBuffer), a = 0; a < d; a++) this._quads = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, a * b);
        else {
            var f, g, h = this._quads;
            if (d > c) {
                f = [];
                g = new ArrayBuffer(b * d);
                for (a = 0; a < e; a++) f[a] = new cc.V3F_C4B_T2F_Quad(h[a].tl,
                    h[a].bl, h[a].tr, h[a].br, g, a * b);
                for (; a < d; a++) f[a] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, g, a * b)
            } else
                for (e = Math.max(e, d), f = [], g = new ArrayBuffer(b * d), a = 0; a < e; a++) f[a] = new cc.V3F_C4B_T2F_Quad(h[a].tl, h[a].bl, h[a].tr, h[a].br, g, a * b);
            this._quadsReader = new Uint8Array(g);
            this._quads = f;
            this._quadsArrayBuffer = g
        }
        null == this._indices ? this._indices = new Uint16Array(6 * d) : d > c ? (b = new Uint16Array(6 * d), b.set(this._indices, 0), this._indices = b) : this._indices = this._indices.subarray(0, 6 * d);
        this._setupIndices();
        this._mapBuffers();
        return this.dirty = !0
    },
    increaseTotalQuadsWith: function (a) {
        this._totalQuads += a
    },
    moveQuadsFromIndex: function (a, b, c) {
        if (void 0 === c) {
            c = b;
            b = this._totalQuads - a;
            if (c + (this._totalQuads - a) > this._capacity) throw "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds";
            if (0 === b) return
        } else {
            if (c + b > this._totalQuads) throw "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex";
            if (a >= this._totalQuads) throw "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex";
            if (a == c) return
        }
        var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            e = a * d,
            f = b * d,
            g = this._quadsReader,
            h = g.subarray(e, e + f),
            k = c * d;
        c < a ? (b = c * d, g.set(g.subarray(b, b + (a - c) * d), b + f)) : (b = (a + b) * d, g.set(g.subarray(b, b + (c - a) * d), e));
        g.set(h, k);
        this.dirty = !0
    },
    fillWithEmptyQuadsFromIndex: function (a, b) {
        for (var c = b * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, d = new Uint8Array(this._quadsArrayBuffer, a * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, c), e = 0; e < c; e++) d[e] = 0
    },
    drawNumberOfQuads: function (a, b) {
        b = b || 0;
        if (0 !== a && this.texture && this.texture.isLoaded()) {
            var c = cc._renderContext;
            cc.glBindTexture2D(this.texture);
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
            c.bindBuffer(c.ARRAY_BUFFER, this._quadsWebBuffer);
            this.dirty && c.bufferData(c.ARRAY_BUFFER, this._quadsArrayBuffer, c.DYNAMIC_DRAW);
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, c.FLOAT, !1, 24, 0);
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, c.UNSIGNED_BYTE, !0, 24, 12);
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, c.FLOAT, !1, 24, 16);
            this.dirty && (this.dirty = !1);
            c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
            cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ?
                c.drawElements(c.TRIANGLE_STRIP, 6 * a, c.UNSIGNED_SHORT, 6 * b * this._indices.BYTES_PER_ELEMENT) : c.drawElements(c.TRIANGLES, 6 * a, c.UNSIGNED_SHORT, 6 * b * this._indices.BYTES_PER_ELEMENT);
            cc.g_NumberOfDraws++
        }
    },
    drawQuads: function () {
        this.drawNumberOfQuads(this._totalQuads, 0)
    },
    _releaseBuffer: function () {
        var a = cc._renderContext;
        this._buffersVBO && (this._buffersVBO[0] && a.deleteBuffer(this._buffersVBO[0]), this._buffersVBO[1] && a.deleteBuffer(this._buffersVBO[1]));
        this._quadsWebBuffer && a.deleteBuffer(this._quadsWebBuffer)
    }
});
window._p = cc.TextureAtlas.prototype;
cc.defineGetterSetter(_p, "totalQuads", _p.getTotalQuads);
cc.defineGetterSetter(_p, "capacity", _p.getCapacity);
cc.defineGetterSetter(_p, "quads", _p.getQuads, _p.setQuads);
delete window._p;
cc.TextureAtlas.create = function (a, b) {
    var c = new cc.TextureAtlas;
    if ("string" == typeof a) {
        if (c.initWithFile(a, b)) return c
    } else if (a instanceof cc.Texture2D && c.initWithTexture(file, b)) return c;
    return null
};
cc.Scene = cc.Node.extend({
    _className: "Scene",
    ctor: function () {
        cc.Node.prototype.ctor.call(this);
        this._ignoreAnchorPointForPosition = !0;
        this.setAnchorPoint(0.5, 0.5);
        this.setContentSize(cc.director.getWinSize())
    }
});
cc.Scene.create = function () {
    return new cc.Scene
};
cc.LoaderScene = cc.Scene.extend({
    _interval: null,
    _length: 0,
    _count: 0,
    _label: null,
    _className: "LoaderScene",
    init: function () {
        var a = this,
            b = cc.director.getWinSize(),
            c = 200,
            d = cc.p(b.width / 2, b.height / 2),
            b = a._bgLayer = cc.LayerColor.create(cc.color(32, 32, 32, 255));
        b.setPosition(0, 0);
        a.addChild(b, 0);
        cc.loader.loadImg("data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAlAAD/4QMpaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjM4MDBEMDY2QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjM4MDBEMDY1QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2RTk0OEM4OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2RTk0OEM5OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/+4ADkFkb2JlAGTAAAAAAf/bAIQADQkJCQoJDQoKDRMMCwwTFhENDREWGhUVFhUVGhkUFhUVFhQZGR0fIB8dGScnKionJzk4ODg5QEBAQEBAQEBAQAEODAwOEA4RDw8RFA4RDhQVERISERUfFRUXFRUfKB0ZGRkZHSgjJiAgICYjLCwoKCwsNzc1NzdAQEBAQEBAQEBA/8AAEQgAyACgAwEiAAIRAQMRAf/EALAAAAEFAQEAAAAAAAAAAAAAAAQAAgMFBgcBAQEAAwEBAAAAAAAAAAAAAAAAAQMEAgUQAAIBAgIEBwoLBgQGAwAAAAECAwAEEQUhMRIGQVFxsTITFGGBwdEiQlKSMzWRoeFicqKyI1NzFYJjJDQWB9KjVCbxwkNkJWXik3QRAAIBAgMFBQcDBQEAAAAAAAABAhEDIRIEMUFRcTJhwVIUBZGhsSJyEzOB0ULhYpIjUxX/2gAMAwEAAhEDEQA/AMJSpUqAVKlXuFAeUq9wpUB5XuFe4V6ooDzZHDox0CnGMinzwl7Z8NajaHeoO3vmTBZBtp9YUIqTEV5ROxHKnWRnaU8VRMhFBUjpV7hSoSeUq9pUB5Sr2lhQHlKvcK8oBV7hSFSRrtaKAZs07YNPM1pG2xJIAw1jSeandry/8X4m8VCKkWwaWwam7Xl/4v1W8VLtmX/i/VbxUoKkWwakSM407tmX/i/VbxUmzGwjQsjdY41IARie/U0IbZO0kNtCXnOCkEBeFu4KI3Bs7DNb27ya+jDx3kJeEnpJJEcQVbWDsk17u5urd591ucZkWhym2Vnd9RkCDEpFxDRpbw0bunu5mlp2De2FMLYXOD2wB2xbOeraUcYGJ72mlSUiqzzdzMd3Z3mixltA2yzcK/NlHM1DQyRXce1HocdNOEfJXZ88y9ZojOqhiBszIRiHQ8Y4cK5TvHuzLljHNMqxNoDjLFraHHnjPxcNCGVbxEUzYNTx5jZSxhpW6qTzlwJ+DCvO2Zf+L9VvFSgqyHYNLYNTdssPxfibxUu15f8Ai/VPiqCakOwa82DU/a8v/F+JvFTDdWPBL8R8VKCvYRYV5UzoMAy6QdIIqI0B4KJtxiRQwou16QoGUkntH5Tz0RbZbmF2hktraSVBo2lUkY8tDye0flPPXTslVUyiyVRsjqUOA4yMT8dW2ram2m6UVTNq9S7EIyUVJydMTn/6DnP+im9Wl+g5z/opvVrpteEhQWY4AaSTwAVf5WPiZh/9S5/zj7zltzlmYWkfWXNvJDGTgGcYDHirR7i7mSbwXParsFMrgb7w6jKw/wCmnc9I14kF3vpvCljbMyWMOJL4aEiB8qU/ObUK7HYWVrl1pFZWiCOCBQqKOLjPGTrNZZqKbUXVHq2nNwTuJRk1VpbgXN8s7Rk5ym0UQQzhIG2NAjhxHWbI+gCBVjBBFbwxwQqEiiUJGg1BVGAFe7dV28WYLYZFmF2Th1UD7JGjymGyn1iK5OyzIBGB1HgrLZhamzumQAGJwSqnSCh1q3GOCodxt4cxurdcpzuN4cyhiWaF5Bg09udUmnWw1H/jV9nFuJ7Quo+8h8peThFA+047vduyMtk7fYqTl07YFdfUufMPzT5p71UdtlmYXaGS2t3mQHAsgxANdadYJopLe4QS2867EsZ4QfCNYrCFbjdDPmgkYyWFxgVf04ifJf6ScNdRUW1XBb6FU5TjF5EpSSrGu/s5lN+g5z/opvVpfoOc/wCim9WtdHnatvObJXDW7xLGhB8nrPaY9/HCr+tEdPCVaSeDoYLnqF63lzW4/PFSW3ecxbI84VSzWUwUaSdg0DXXK5nvAipnd6qgKvWnQO7pri9ZUEmm3Vl2j1kr8pRlFRyquBNZjGxQ/S56Y1S2fu9OVueon11Szahoou06QoQUXadIVCD2FJJ7R+U89dMydv8Axdn+TH9muZye0flPPXQstlK5Tbka1gUjlC1q0vVLkeb6r+O3Tx9xcY1nt8c0NrZCyiOE1108NYjGv1joo7Js1jzKyScYLIvkzL6LDwHXVJksH9Sb49dKNq0tj1jA6uriOCL+02FWX7iVtZX1/AzaHTyeoauKn2MX9W79zebiZCuR5MjSrhfXuEtwTrUeZH+yNfdrRNcxI6IzhXlJEak6WIGJ2Rw4ChWnChndtlVBLMdQA0k1gbXNMzzDfDLs6mjaPKppJbWwJ1bOwwxw43OnHh71YT3DpfWUJmFlb5jHHDdeXBHIsrRea5TSqvxqG04cNN62vetoCS4tre5mgnkGE9q+3DKOkuI2WX6LDQRRHWDh1UCtwj7QRg2wdl8Djgw1qe7XvW0BQ3kfZ7mSLgU+T9E6RVbnuVrnWVSWqj+Lt8ZbRuHEdKPkYVcZ2MJY5fSGyeVar45+rkWQHAqccalPE5km1htWK5nK4Wnt5FuUBUwOMG4nGkA/BXUrW4S6torlOjMgcd/xVn7rLo7zKs0uEjCNeSvdwoBhgsZxX1l2j36k3Lu+uyprdj5Vs5A+i/lD48a0aaVJOPi7jB6lbzWozpjB48pf1NDXNN4vfl7+Z4BXS65pvF78vfzPAK71XTHmZ/S/yT+jvJ7L3fHytz1E+upbL+Qj5W56jfXWRnsIYKLtekKEFGWvSFQgyjk9o/Keet3YthlMP/5x9msJJ7R+U89biyb/AMXEv7gD6tadL1T+kwepRrC39ZkLDMbiwMvUHRPG0bjlGg8ore/23sxBldxfMPLupNhT8yL/AORNZbdzJ484scytxgLqJY5LZj6Q2sV5G1Vud1mjjyG0ij0NEGSZToKyhjtqw4waztuiXA3qKTbSxltfGhbZlE95ZtZqxVbgiOZhrER9ph3Svk9+pJILZ4Y4DGBFCUMKjRsGPobPFhUfW0NJmljE2xJcIrcI2vFUEln1lRXd6lrazXT9GCNpD+yNqoI7mOVduNw6nzlOIoPOUa6yye1XXcbMR5GdQ3xY0BSbj31/FcTQZirJ+q431q7anbHCTZ72Bw7lbPrKBMcBWNNgbMBBh+bsjBdni0VJ1lARZs6yWiupxCuMDy6KpS2IwOo6DTr3Mre3e5tZZVUM4ZBjqOOJoWO4jkXajcOOMHGgDISvWIrdAkKR80+TzVl908bPPL3LzxOuHdifxVfiTAg92qI/w+/8gGgSyN/mR7XPVlp0lF/3L3mbVKtu5Hjbk/8AHE2Fc03i9+Xv5ngFdKNc13i9+Xv5ngFaNV0x5nn+l/kn9HeEWXu+PlbnqJ9dS2Xu9OVueon11kZ7CGCjLXpCgxRlr0hUIPYUcntH5Tz1s8vb+Bt1/dqPirGSe0flPPWusG/g4Py15q06XqlyMWvVYQ+ruI9xJOqzO9hOto/sP8tbGOFIrmWeM7IuMDMnAXXQJOUjQeOsJk0nY96ip0CYunrjaHx1t+srPJUbXBm2LrFPikwTOb+T+VhbZxGMrDXp83x1QSy2tucJpUjPETp+Cn5/ftaRvKvtp3Kx48HG3erHMzOxZiWZtLMdJNQSbbL71Vk6yynViOkqnEEfOWtPbXi3EQkGg6mXiNckjeSJxJGxR10qw0GtxuxmvbImD4CZMFlA4fRfv0BqesqqzTMZNMEDbIHtHH2QeCiZJSqMQdOGiue53mz3czQwsRbIcNHnkec3c4qAMuriz68gTIToxwOOnlp0MjxMJYW741Gs3RVldtbygE/dMcHX/moDaxTiWNZB53B3arb8/wC+4SOF4sf/AKxU9kcBsfOGHfoUHtG/RbzY5Die5HHhXdvavqiZ9Q8Jdlq4/gbKua7xe/L38zwCuhpf2Uk/Zo50kmwJKIdogDjw1VzzeL35e/meAVp1LTgqY4nn+mRauzqmqwrjzCLL3fHytz1E+upLL+Qj5W56jfXWRnroYKLtekKEFF2vSFQg9hSSe0flPPWosm/hIfoLzVl5PaPynnrRWb/w0X0F5q06XqlyM2sVYx5gmbFre/t71NY2T+0h8VbSO5SWNJUOKSAMp7jDGspmMPaLRlXS6eWve1/FRO7WYdbZm1Y/eW/R7qHxHRXGojlm3ulid6aVbaW+OALvgCLq2Hm9WxHKWqjhj6xsK1e8dm15l4niG1LZkswGsxtrPeOmsvayBJA1VItlWjptLuTdPMo7LtjRDq9naK4+WF9IrUW7BaHOljGqVHB7w2hzVoZt87d8vaNYSLl02CcRsDEbJbj71Uu7UBkvJ7/D7q2QoDxySaAO8MTXdxRVMpRp5XZOWdF/ms7R5XdyKfKWJsO/5PhrG5XlNxmEywW6bTnTxAAcJNbGSMXkM1pjgbiNo1PziPJ+Os7u7m/6ReM00ZOgxSpqYYHT3wRXMKN4ll9zUG4bQfNshu8sZVuEA2hirA4qe/VOwwrVbzbww5mI44UKRRYkbWG0S3JWctbd7u5WFfOOLHiUdJqmaipfLsIsObhWe001lMkMVvJNjhghIALMcBxCs7fxXQmkupx1bXDswGPlaTidVaEyKNXkoo4eBV+Sq7L7Vs9zcBgeyQ4GQ/MB1crmoim2orezqcowTuSeEY48jQ7oZX2PLzdyLhNd6RjrEY6I7+uspvH78vfzPAK6UAAAFGAGgAcArmu8Xvy9/M8ArTfio24RW5nnaG67uou3H/KPuqT2X8hHytz1G+upLL3enK3PUb66ys9RDBRdr0hQgou06QqEGUkntH5Tz1e238vF9BeaqKT2j8p56vbb+Xi+gvNWjTdUuRn1XTHmTh8KrJTJlt8t1CPIY44cGnpJVjTJYkmjaN9Ib4u7V923njTethRauZJV3PaW1rfLIiXEDYg6R4VYc9CXW7thfOZbKdbGZtLW8uPVY/u3GrkNUkM9zlcxUjbhfWOA90cRq4gv4LhdqN+VToNYWmnRm9NNVWNTyHc6VWBv8wt4YeHqm6xyPmroq1Z7WGFLSxTq7WLSuPSdjrkfumq5yHXDUeA92oO2SKpVumNAaoJLMXH3myp0rpJ4uKhc3tbDM5BMri1zAj79j7KTiY8TcdBpcsith0286o+sPCagEX9Pzg4zXUCp6QYse8oouCG3tk6m1BYv05W6T+IdyolxbHDAAa2OgDlNCz3ryN2WxBd5PJMg1t81eId2ukqnLlTBbfcuY+9uJLiRcvtPvHdsHK+cfRHcHDWsyawjyy0WBcDI3lTP6TeIcFV+S5OmXx9bJg1048o8Cj0V8Jq2DVu09nL80up7OxHi+oal3P8AXB/IsZS8T/YOV65zvCcc7vfzPAK3ivWCz445zeH954BXOr6I8yfSfyz+jvCLP3fHytz1G+upLP3fHytz1E+usbPaQ0UXadIUIKLtekKhB7Ckk9o/Keer22/l4/oLzVRSe0flPPV7b/y8X0F5q0abqlyM+q6Y8yQsBTDMor1o8aiaE1pbluMqS3sbLLHIhSRQyngqukhaJ9uBjo+H5aOa3ao2t34qouRlLajTalGP8v0IY8ylXQ+PKPFU/bYXOLPge6CKia0LaxTOxHu1Q7cuBd9yPEJ7TbjXKO8CajbMIF6CNIeNvJHjqIWJ7tSpYkalqVblwIdyG+RGXur0hXYJFxal+Dhq5y3slkv3Y2pD0pTr+QUClpJRUdo9XW4OLrTHtM16cZLLWkeC7y4jvlNEpcRtw1Ux27Ci448NZrTFy3nn3IQWxlgGrDZ3pza7/M8ArZo+ArF5171uvp+CqdV0R5l/psUrs2vB3hdl7vTlbnqJ9dS2Xu+PlbnqJ9dY2eshooq16QoQUXa9IVCD2FLJ7RuU89WNtmUSQqkgYMgw0accKrpPaPynnrZWG4Vi+VWmY5tnMWXG+XrIYnA0rhj0mdcTgdNdwnKDqjmduM1SRR/qlr8/4KX6pa8T/BVzDuLZXudRZblmbxXcPUNPc3KqCIwrbOzgrHEnHjoyD+3eSXkht7DeKG4umDGOJVUklfouThXfmbnZ7Cvy1vt9pmv1W1+d8FL9VteJvgq5yrcOGfLmzHN80iyyETPbptAEFo2ZG8pmUa1OFNn3Ky6W/sbDKM5hv5bx2WTZA+7RF2y52WOPJTzE+z2Dy1vt9pT/AKpacTerS/U7Tib1a04/t7kDXPY03jhN0W6sQ7K7W3q2dnrMccaDy/8At80kuZfqWYxWNtlcvUPPhiGYhWDeUy7IwYU8xPs9g8tb7faUn6pacTerTxm9oOBvVq3v9z927aynuId44LiWKNnjhAXF2UYhRg516qpsryjLr21665zFLSTaK9U2GOA87SwqY37knRU+BzOzags0s1Oyr+BKM6sxwP6tSDPLMen6vy0rvdm3Sxlu7K/S7WDDrFUDUTxgnTU826eXW7KlxmqQuwDBXUKcD+1Xee/wXuKX5XDGWLapSVcOyhEM/seJ/V+WnjeGx4pPV+Wkm6kKZlFay3Jlt7iFpYZY8ASVK6DjtDDA0f8A0Tl340/1f8Ndx8xJVWXB0KbktFFpNzdVXAC/qOwA0CQni2flrO3Vwbm5lnI2TKxbDirX/wBE5d+NcfV/wVR7xZPa5U9utvI8nWhmbbw0YEAYYAVxfhfy5rlKR4Fulu6X7mW1mzT8S4Yis/5CPlbnqJ9dSWfu9OVueon11mZvQ2i7XpChKKtekKhBlNJ7R+U89bDfGTb3a3ZX0Lcj6kdY+T2j8p560288m1kWQr6MJ+ylSAr+2cnV5renjs3H1loX+3j9XvbbtxLN9lqW4UnV5jdnjtXHxihtyZNjeSBu5J9k1BJe7xy7W5CJ/wCzuD/mTVTf2+fq97LJuLrPsNRueS7W6aJ/38x+vLVXuY+xvHaNxbf2GoCezf8A36j/APsSf8w1sLnqczTefJluYoLm5uo5F61sBshItP1cNFYe1f8A3ir/APfE/wCZUe9bB94r5jwuPsrQFhmG4l/Z2M17HdW90tuu3IkTHaCjWdIw0VVZdks9/C06yJFEp2dp+E1bbqybGTZ8vpQD7L1XRv8A7blT96Oda7tpNuuNE37Cq9KSisjyuUoxrStKllHbLlWTXsMs8chuSuwEPDqwoLe5y+YRE/gLzmqRekvKKtd4327yM/ulHxmrHJStySWVRyrjxKI2XC/CTlnlPPKTpTdFbP0L1bgrf5Lp0G3dPhQHwV0S1lzBsns3sESR8Crh9WAJGjSOKuU3E+zdZQ3oJh8IArdZXFDmOTpHa3i2+YrI2KtKy4ricBsBuHHgFXSo440+Wa2qqxjvM9uMoy+WvzWpLCWWWE28HxL6e43ojgkeSCBY1Ri5BGIUDT51cl3vm276BBqSEH4WbxV0tlkyXJcxTMb+OW6uY9mGHrCzDQwwAbTp2uKuTZ9N1uYsfRRR8WPhrm419mSSjRyiqxVK7y23B/ftuTm2oSdJyzNVw3BFn7vTlbnqF9dS2fu9OVueon11lZuQ2iLdsGFD05H2dNQGV0ntG5Tz1dWm9N1b2kVq8EVwsI2UaQaQOKhmitZGLOmk68DhSFvY+gfWNSAg7z3Qvo7yKCKIohiaNR5LKxx8qpxvjcqS0VpbxvwOAcRQPZ7D0G9Y0uz2HoH1jUCpLY7zXlpbm3eKO5QuzjrBqZji3x17PvNcyT288VvDBJbMWUovS2hslW7mFQ9nsPQPrGl2ew9A+saCod/WNxtbYsrfb17WBxx5ddD2281xC88klvDcSXEnWuzrqOGGC9zRUPZ7D0G9Y0uzWHoH1jQVCLreq6ntZbaO3it1mGy7RjTs1X2mYy20ZiCq8ZOODcdEdmsPQb1jS7PYegfWNdJuLqnQiSUlRqpFLmryxtH1Ma7Qw2gNNPOdSt0oI27p007s9h6B9Y0uz2HoH1jXX3Z+I4+1b8IJdX89xLHKQFMXQUahpxoiPN5P+onfU+A0/s9h6DesaXZ7D0D6xpG7OLbUtu0StW5JJx2bBsmbtiSiEk+cxoCWWSaVpZOk2vDVo0VYdnsPQb1jSNvZcCH1jSd2c+p1XAmFqEOmOPEfaH+BQd1ueo211IzrgFUYKNAAqI1WztCpUqVCRUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoD/9k\x3d", {
            isCrossOrigin: !1
        }, function (b, e) {
            c = e.height;
            a._initStage(e, d)
        });
        var e = a._label = cc.LabelTTF.create("Loading... 0%", "Arial", 14);
        e.setColor(cc.color(180, 180, 180));
        e.setPosition(cc.pAdd(d, cc.p(0, -c / 2 - 10)));
        b.addChild(this._label, 10);
        return !0
    },
    _initStage: function (a, b) {
        var c = this._texture2d = new cc.Texture2D;
        c.initWithElement(a);
        c.handleLoadedTexture();
        c = this._logo = cc.Sprite.create(c);
        c.setScale(cc.CONTENT_SCALE_FACTOR());
        c.x = b.x;
        c.y = b.y;
        this._bgLayer.addChild(c, 10)
    },
    onEnter: function () {
        cc.Node.prototype.onEnter.call(this);
        this.schedule(this._startLoading, 0.3)
    },
    onExit: function () {
        cc.Node.prototype.onExit.call(this);
        this._label.setString("Loading... 0%")
    },
    initWithResources: function (a, b) {
        "string" == typeof a && (a = [a]);
        this.resources = a || [];
        this.cb = b
    },
    _startLoading: function () {
        var a = this;
        a.unschedule(a._startLoading);
        var b = a.resources;
        a._length = b.length;
        cc.loader.load(b, function (b, d) {
            a._count = d
        }, function () {
            a.cb()
        });
        a.schedule(a._updatePercent)
    },
    _updatePercent: function () {
        var a = this._count,
            b = this._length,
            c;
        c = Math.min(a / b * 100 |
            0, 100);
        this._label.setString("Loading... " + c + "%");
        a >= b && this.unschedule(this._updatePercent)
    }
});
cc.LoaderScene.preload = function (a, b) {
    var c = cc;
    c.loaderScene || (c.loaderScene = new cc.LoaderScene, c.loaderScene.init());
    c.loaderScene.initWithResources(a, b);
    cc.director.runScene(c.loaderScene);
    return c.loaderScene
};
cc.Layer = cc.Node.extend({
    _className: "Layer",
    ctor: function () {
        var a = cc.Node.prototype;
        a.ctor.call(this);
        this._ignoreAnchorPointForPosition = !0;
        a.setAnchorPoint.call(this, 0.5, 0.5);
        a.setContentSize.call(this, cc.winSize)
    }
});
cc.Layer.create = function () {
    return new cc.Layer
};
cc.LayerRGBA = cc.Layer.extend({
    RGBAProtocol: !0,
    _displayedOpacity: 255,
    _realOpacity: 255,
    _displayedColor: null,
    _realColor: null,
    _cascadeOpacityEnabled: !1,
    _cascadeColorEnabled: !1,
    _className: "LayerRGBA",
    ctor: function () {
        cc.Layer.prototype.ctor.call(this);
        this._displayedColor = cc.color(255, 255, 255, 255);
        this._realColor = cc.color(255, 255, 255, 255)
    },
    init: function () {
        var a = cc.Layer.prototype;
        this._ignoreAnchorPointForPosition = !0;
        a.setAnchorPoint.call(this, 0.5, 0.5);
        a.setContentSize.call(this, cc.winSize);
        this.cascadeColor =
            this.cascadeOpacity = !1;
        return !0
    },
    getOpacity: function () {
        return this._realOpacity
    },
    getDisplayedOpacity: function () {
        return this._displayedOpacity
    },
    setOpacity: function (a) {
        this._displayedOpacity = this._realOpacity = a;
        var b = 255,
            c = this._parent;
        c && c.RGBAProtocol && c.cascadeOpacity && (b = c.getDisplayedOpacity());
        this.updateDisplayedOpacity(b);
        this._displayedColor.a = this._realColor.a = a
    },
    updateDisplayedOpacity: function (a) {
        this._displayedOpacity = 0 | this._realOpacity * a / 255;
        if (this._cascadeOpacityEnabled) {
            a = this._children;
            for (var b = 0; b < a.length; b++) {
                var c = a[b];
                c && c.RGBAProtocol && c.updateDisplayedOpacity(this._displayedOpacity)
            }
        }
    },
    isCascadeOpacityEnabled: function () {
        return this._cascadeOpacityEnabled
    },
    setCascadeOpacityEnabled: function (a) {
        this._cascadeOpacityEnabled !== a && ((this._cascadeOpacityEnabled = a) ? this._enableCascadeOpacity() : this._disableCascadeOpacity())
    },
    _enableCascadeOpacity: function () {
        var a = 255,
            b = this._parent;
        b && b.RGBAProtocol && b.cascadeOpacity && (a = b.getDisplayedOpacity());
        this.updateDisplayedOpacity(a)
    },
    _disableCascadeOpacity: function () {
        this._displayedOpacity =
            this._realOpacity;
        for (var a = this._children, b = 0; b < a.length; b++) {
            var c = a[b];
            c && c.RGBAProtocol && c.updateDisplayedOpacity(255)
        }
    },
    getColor: function () {
        var a = this._realColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getDisplayedColor: function () {
        var a = this._displayedColor;
        return cc.color(a.r, a.g, a.b)
    },
    setColor: function (a) {
        var b = this._displayedColor,
            c = this._realColor;
        b.r = c.r = a.r;
        b.g = c.g = a.g;
        b.b = c.b = a.b;
        b = (b = this._parent) && b.RGBAProtocol && b.cascadeColor ? b.getDisplayedColor() : cc.color.WHITE;
        this.updateDisplayedColor(b);
        void 0 === a.a || a.a_undefined || this.setOpacity(a.a)
    },
    updateDisplayedColor: function (a) {
        var b = this._displayedColor,
            c = this._realColor;
        b.r = 0 | c.r * a.r / 255;
        b.g = 0 | c.g * a.g / 255;
        b.b = 0 | c.b * a.b / 255;
        if (this._cascadeColorEnabled)
            for (a = this._children, c = 0; c < a.length; c++) {
                var d = a[c];
                d && d.RGBAProtocol && d.updateDisplayedColor(b)
            }
    },
    isCascadeColorEnabled: function () {
        return this._cascadeColorEnabled
    },
    setCascadeColorEnabled: function (a) {
        this._cascadeColorEnabled !== a && ((this._cascadeColorEnabled = a) ? this._enableCascadeColor() :
            this._disableCascadeColor())
    },
    _enableCascadeColor: function () {
        var a;
        a = (a = this._parent) && a.RGBAProtocol && a.cascadeColor ? a.getDisplayedColor() : cc.color.WHITE;
        this.updateDisplayedColor(a)
    },
    _disableCascadeColor: function () {
        var a = this._displayedColor,
            b = this._realColor;
        a.r = b.r;
        a.g = b.g;
        a.b = b.b;
        for (var a = this._children, b = cc.color.WHITE, c = 0; c < a.length; c++) {
            var d = a[c];
            d && d.RGBAProtocol && d.updateDisplayedColor(b)
        }
    },
    addChild: function (a, b, c) {
        cc.Node.prototype.addChild.call(this, a, b, c);
        this._cascadeColorEnabled &&
            this._enableCascadeColor();
        this._cascadeOpacityEnabled && this._enableCascadeOpacity()
    },
    setOpacityModifyRGB: function (a) {},
    isOpacityModifyRGB: function () {
        return !1
    }
});
window._p = cc.LayerRGBA.prototype;
cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "cascadeOpacity", _p.isCascadeOpacityEnabled, _p.setCascadeOpacityEnabled);
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, "cascadeColor", _p.isCascadeColorEnabled, _p.setCascadeColorEnabled);
delete window._p;
cc.LayerColor = cc.LayerRGBA.extend({
    _blendFunc: null,
    _className: "LayerColor",
    getBlendFunc: function () {
        return this._blendFunc
    },
    changeWidthAndHeight: function (a, b) {
        this.width = a;
        this.height = b
    },
    changeWidth: function (a) {
        this.width = a
    },
    changeHeight: function (a) {
        this.height = a
    },
    setOpacityModifyRGB: function (a) {},
    isOpacityModifyRGB: function () {
        return !1
    },
    setColor: function (a) {
        cc.LayerRGBA.prototype.setColor.call(this, a);
        this._updateColor()
    },
    setOpacity: function (a) {
        cc.LayerRGBA.prototype.setOpacity.call(this, a);
        this._updateColor()
    },
    _isLighterMode: !1,
    _squareVertices: null,
    _squareColors: null,
    _verticesFloat32Buffer: null,
    _colorsUint8Buffer: null,
    _squareVerticesAB: null,
    _squareColorsAB: null,
    ctor: null,
    _ctorForCanvas: function (a, b, c) {
        cc.LayerRGBA.prototype.ctor.call(this);
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        cc.LayerColor.prototype.init.call(this, a, b, c)
    },
    _ctorForWebGL: function (a, b, c) {
        this._squareVerticesAB = new ArrayBuffer(32);
        this._squareColorsAB = new ArrayBuffer(16);
        var d = this._squareVerticesAB,
            e = this._squareColorsAB,
            f = cc.Vertex2F.BYTES_PER_ELEMENT,
            g = cc.Color.BYTES_PER_ELEMENT;
        this._squareVertices = [new cc.Vertex2F(0, 0, d, 0), new cc.Vertex2F(0, 0, d, f), new cc.Vertex2F(0, 0, d, 2 * f), new cc.Vertex2F(0, 0, d, 3 * f)];
        this._squareColors = [cc.color(0, 0, 0, 255, e, 0), cc.color(0, 0, 0, 255, e, g), cc.color(0, 0, 0, 255, e, 2 * g), cc.color(0, 0, 0, 255, e, 3 * g)];
        this._verticesFloat32Buffer = cc._renderContext.createBuffer();
        this._colorsUint8Buffer = cc._renderContext.createBuffer();
        cc.LayerRGBA.prototype.ctor.call(this);
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC,
            cc.BLEND_DST);
        cc.LayerColor.prototype.init.call(this, a, b, c)
    },
    init: function (a, b, c) {
        cc._renderType !== cc._RENDER_TYPE_CANVAS && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR));
        var d = cc.director.getWinSize();
        a = a || cc.color(0, 0, 0, 255);
        b = void 0 === b ? d.width : b;
        c = void 0 === c ? d.height : c;
        d = this._displayedColor;
        d.r = a.r;
        d.g = a.g;
        d.b = a.b;
        d = this._realColor;
        d.r = a.r;
        d.g = a.g;
        d.b = a.b;
        this._realOpacity = this._displayedOpacity = a.a;
        a = cc.LayerColor.prototype;
        a.setContentSize.call(this, b, c);
        a._updateColor.call(this);
        return !0
    },
    setBlendFunc: function (a, b) {
        this._blendFunc = void 0 === b ? a : {
            src: a,
            dst: b
        };
        cc._renderType === cc._RENDER_TYPE_CANVAS && (this._isLighterMode = this._blendFunc && 1 == this._blendFunc.src && 771 == this._blendFunc.dst)
    },
    setContentSize: null,
    _setContentSizeForWebGL: function (a, b) {
        var c = this._squareVertices;
        void 0 === b ? (c[1].x = a.width, c[2].y = a.height, c[3].x = a.width, c[3].y = a.height) : (c[1].x = a, c[2].y = b, c[3].x = a, c[3].y = b);
        this._bindLayerVerticesBufferData();
        cc.Layer.prototype.setContentSize.call(this, a, b)
    },
    _setWidthForWebGL: function (a) {
        var b =
            this._squareVertices;
        b[1].x = a;
        b[3].x = a;
        this._bindLayerVerticesBufferData();
        cc.Layer.prototype._setWidth.call(this, a)
    },
    _setHeightForWebGL: function (a) {
        var b = this._squareVertices;
        b[2].y = a;
        b[3].y = a;
        this._bindLayerVerticesBufferData();
        cc.Layer.prototype._setHeight.call(this, a)
    },
    _updateColor: null,
    _updateColorForCanvas: function () {},
    _updateColorForWebGL: function () {
        for (var a = this._displayedColor, b = this._displayedOpacity, c = this._squareColors, d = 0; 4 > d; d++) c[d].r = a.r, c[d].g = a.g, c[d].b = a.b, c[d].a = b;
        this._bindLayerColorsBufferData()
    },
    updateDisplayedColor: function (a) {
        cc.LayerRGBA.prototype.updateDisplayedColor.call(this, a);
        this._updateColor()
    },
    updateDisplayedOpacity: function (a) {
        cc.LayerRGBA.prototype.updateDisplayedOpacity.call(this, a);
        this._updateColor()
    },
    _bindLayerVerticesBufferData: function () {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
        a.bufferData(a.ARRAY_BUFFER, this._squareVerticesAB, a.STATIC_DRAW)
    },
    _bindLayerColorsBufferData: function () {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER,
            this._colorsUint8Buffer);
        a.bufferData(a.ARRAY_BUFFER, this._squareColorsAB, a.STATIC_DRAW)
    },
    draw: null,
    _drawForCanvas: function (a) {
        a = a || cc._renderContext;
        var b = cc.view,
            c = this._displayedColor;
        a.fillStyle = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b) + "," + this._displayedOpacity / 255 + ")";
        a.fillRect(0, 0, this.width * b.getScaleX(), -this.height * b.getScaleY());
        cc.g_NumberOfDraws++
    },
    _drawForWebGL: function (a) {
        a = a || cc._renderContext;
        cc.NODE_DRAW_SETUP(this);
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR);
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0);
        cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
        a.drawArrays(a.TRIANGLE_STRIP, 0, 4)
    }
});
window._p = cc.LayerColor.prototype;
cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.ctor = _p._ctorForWebGL, _p.setContentSize = _p._setContentSizeForWebGL, _p._setWidth = _p._setWidthForWebGL, _p._setHeight = _p._setHeightForWebGL, _p._updateColor = _p._updateColorForWebGL, _p.draw = _p._drawForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.setContentSize = cc.LayerRGBA.prototype.setContentSize, _p._setWidth = cc.LayerRGBA.prototype._setWidth, _p._setHeight = cc.LayerRGBA.prototype._setHeight, _p._updateColor = _p._updateColorForCanvas, _p.draw = _p._drawForCanvas);
cc.defineGetterSetter(_p, "width", _p._getWidth, _p._setWidth);
cc.defineGetterSetter(_p, "height", _p._getHeight, _p._setHeight);
delete window._p;
cc.LayerColor.create = function (a, b, c) {
    return new cc.LayerColor(a, b, c)
};
cc.LayerGradient = cc.LayerColor.extend({
    _startColor: null,
    _endColor: null,
    _startOpacity: 255,
    _endOpacity: 255,
    _alongVector: null,
    _compressedInterpolation: !1,
    _gradientStartPoint: null,
    _gradientEndPoint: null,
    _className: "LayerGradient",
    ctor: function (a, b, c) {
        cc.LayerColor.prototype.ctor.call(this);
        this._startColor = cc.color(0, 0, 0, 255);
        this._endColor = cc.color(0, 0, 0, 255);
        this._alongVector = cc.p(0, -1);
        this._endOpacity = this._startOpacity = 255;
        this._gradientStartPoint = cc.p(0, 0);
        this._gradientEndPoint = cc.p(0, 0);
        cc.LayerGradient.prototype.init.call(this,
            a, b, c)
    },
    init: function (a, b, c) {
        a = a || cc.color(0, 0, 0, 255);
        b = b || cc.color(0, 0, 0, 255);
        c = c || cc.p(0, -1);
        var d = this._startColor,
            e = this._endColor;
        d.r = a.r;
        d.g = a.g;
        d.b = a.b;
        this._startOpacity = a.a;
        e.r = b.r;
        e.g = b.g;
        e.b = b.b;
        this._endOpacity = b.a;
        this._alongVector = c;
        this._compressedInterpolation = !0;
        this._gradientStartPoint = cc.p(0, 0);
        this._gradientEndPoint = cc.p(0, 0);
        cc.LayerColor.prototype.init.call(this, cc.color(a.r, a.g, a.b, 255));
        cc.LayerGradient.prototype._updateColor.call(this);
        return !0
    },
    setContentSize: function (a,
        b) {
        cc.LayerColor.prototype.setContentSize.call(this, a, b);
        this._updateColor()
    },
    _setWidth: function (a) {
        cc.LayerColor.prototype._setWidth.call(this, a);
        this._updateColor()
    },
    _setHeight: function (a) {
        cc.LayerColor.prototype._setHeight.call(this, a);
        this._updateColor()
    },
    getStartColor: function () {
        return this._realColor
    },
    setStartColor: function (a) {
        this.color = a
    },
    setEndColor: function (a) {
        this._endColor = a;
        this._updateColor()
    },
    getEndColor: function () {
        return this._endColor
    },
    setStartOpacity: function (a) {
        this._startOpacity =
            a;
        this._updateColor()
    },
    getStartOpacity: function () {
        return this._startOpacity
    },
    setEndOpacity: function (a) {
        this._endOpacity = a;
        this._updateColor()
    },
    getEndOpacity: function () {
        return this._endOpacity
    },
    setVector: function (a) {
        this._alongVector.x = a.x;
        this._alongVector.y = a.y;
        this._updateColor()
    },
    getVector: function () {
        return cc.p(this._alongVector.x, this._alongVector.y)
    },
    isCompressedInterpolation: function () {
        return this._compressedInterpolation
    },
    setCompressedInterpolation: function (a) {
        this._compressedInterpolation =
            a;
        this._updateColor()
    },
    draw: function (a) {
        if (cc._renderType === cc._RENDER_TYPE_WEBGL) cc.LayerColor.prototype.draw.call(this, a);
        else {
            a = a || cc._renderContext;
            this._isLighterMode && (a.globalCompositeOperation = "lighter");
            a.save();
            var b = cc.view,
                c = this._displayedOpacity / 255,
                d = this.width * b.getScaleX(),
                b = this.height * b.getScaleY(),
                e = a.createLinearGradient(this._gradientStartPoint.x, this._gradientStartPoint.y, this._gradientEndPoint.x, this._gradientEndPoint.y),
                f = this._displayedColor,
                g = this._endColor;
            e.addColorStop(0,
                "rgba(" + Math.round(f.r) + "," + Math.round(f.g) + "," + Math.round(f.b) + "," + (this._startOpacity / 255 * c).toFixed(4) + ")");
            e.addColorStop(1, "rgba(" + Math.round(g.r) + "," + Math.round(g.g) + "," + Math.round(g.b) + "," + (this._endOpacity / 255 * c).toFixed(4) + ")");
            a.fillStyle = e;
            a.fillRect(0, 0, d, -b);
            0 != this._rotation && a.rotate(this._rotationRadians);
            a.restore()
        }
    },
    _updateColor: function () {
        var a = this._alongVector;
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
            var b = 0.5 * this.width,
                c = 0.5 * this.height;
            this._gradientStartPoint.x = b * -a.x +
                b;
            this._gradientStartPoint.y = c * a.y - c;
            this._gradientEndPoint.x = b * a.x + b;
            this._gradientEndPoint.y = c * -a.y - c
        } else if (c = cc.pLength(a), 0 !== c) {
            b = Math.sqrt(2);
            a = cc.p(a.x / c, a.y / c);
            this._compressedInterpolation && (c = 1 / (Math.abs(a.x) + Math.abs(a.y)), a = cc.pMult(a, c * b));
            var d = this._displayedOpacity / 255,
                c = this._displayedColor,
                e = this._endColor,
                c = {
                    r: c.r,
                    g: c.g,
                    b: c.b,
                    a: this._startOpacity * d
                },
                d = {
                    r: e.r,
                    g: e.g,
                    b: e.b,
                    a: this._endOpacity * d
                },
                f = this._squareColors,
                e = f[0],
                g = f[1],
                h = f[2],
                f = f[3];
            e.r = d.r + (b + a.x + a.y) / (2 * b) * (c.r - d.r);
            e.g = d.g + (b + a.x + a.y) / (2 * b) * (c.g - d.g);
            e.b = d.b + (b + a.x + a.y) / (2 * b) * (c.b - d.b);
            e.a = d.a + (b + a.x + a.y) / (2 * b) * (c.a - d.a);
            g.r = d.r + (b - a.x + a.y) / (2 * b) * (c.r - d.r);
            g.g = d.g + (b - a.x + a.y) / (2 * b) * (c.g - d.g);
            g.b = d.b + (b - a.x + a.y) / (2 * b) * (c.b - d.b);
            g.a = d.a + (b - a.x + a.y) / (2 * b) * (c.a - d.a);
            h.r = d.r + (b + a.x - a.y) / (2 * b) * (c.r - d.r);
            h.g = d.g + (b + a.x - a.y) / (2 * b) * (c.g - d.g);
            h.b = d.b + (b + a.x - a.y) / (2 * b) * (c.b - d.b);
            h.a = d.a + (b + a.x - a.y) / (2 * b) * (c.a - d.a);
            f.r = d.r + (b - a.x - a.y) / (2 * b) * (c.r - d.r);
            f.g = d.g + (b - a.x - a.y) / (2 * b) * (c.g - d.g);
            f.b = d.b + (b - a.x - a.y) / (2 * b) * (c.b - d.b);
            f.a = d.a + (b - a.x - a.y) / (2 * b) * (c.a - d.a);
            this._bindLayerColorsBufferData()
        }
    }
});
window._p = cc.LayerGradient.prototype;
cc.defineGetterSetter(_p, "startColor", _p.getStartColor, _p.setStartColor);
cc.defineGetterSetter(_p, "endColor", _p.getEndColor, _p.setEndColor);
cc.defineGetterSetter(_p, "startOpacity", _p.getStartOpacity, _p.setStartOpacity);
cc.defineGetterSetter(_p, "endOpacity", _p.getEndOpacity, _p.setEndOpacity);
cc.defineGetterSetter(_p, "vector", _p.getVector, _p.setVector);
delete window._p;
cc.LayerGradient.create = function (a, b, c) {
    return new cc.LayerGradient(a, b, c)
};
cc.LayerMultiplex = cc.Layer.extend({
    _enabledLayer: 0,
    _layers: null,
    _className: "LayerMultiplex",
    ctor: function (a) {
        cc.Layer.prototype.ctor.call(this);
        a && cc.LayerMultiplex.prototype.initWithLayers.call(this, a)
    },
    initWithLayers: function (a) {
        0 < a.length && null == a[a.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        this._layers = a;
        this._enabledLayer = 0;
        this.addChild(this._layers[this._enabledLayer]);
        return !0
    },
    switchTo: function (a) {
        a >= this._layers.length ? cc.log("cc.LayerMultiplex.switchTo():Invalid index in MultiplexLayer switchTo message") :
            (this.removeChild(this._layers[this._enabledLayer], !0), this._enabledLayer = a, this.addChild(this._layers[a]))
    },
    switchToAndReleaseMe: function (a) {
        a >= this._layers.length ? cc.log("cc.LayerMultiplex.switchToAndReleaseMe():Invalid index in MultiplexLayer switchTo message") : (this.removeChild(this._layers[this._enabledLayer], !0), this._layers[this._enabledLayer] = null, this._enabledLayer = a, this.addChild(this._layers[a]))
    },
    addLayer: function (a) {
        a ? this._layers.push(a) : cc.log("cc.Layer.addLayer(): layer should be non-null")
    }
});
cc.LayerMultiplex.create = function () {
    return new cc.LayerMultiplex(arguments)
};
cc.SPRITE_INDEX_NOT_INITIALIZED = -1;
cc.generateTextureCacheForColor = function (a) {
    function b() {
        var b = cc.generateTextureCacheForColor,
            d = a.width,
            g = a.height;
        c[0].width = d;
        c[0].height = g;
        c[1].width = d;
        c[1].height = g;
        c[2].width = d;
        c[2].height = g;
        c[3].width = d;
        c[3].height = g;
        b.canvas.width = d;
        b.canvas.height = g;
        var h = b.canvas.getContext("2d");
        h.drawImage(a, 0, 0);
        b.tempCanvas.width = d;
        b.tempCanvas.height = g;
        for (var h = h.getImageData(0, 0, d, g).data, k = 0; 4 > k; k++) {
            var m = c[k].getContext("2d");
            m.getImageData(0, 0, d, g).data;
            b.tempCtx.drawImage(a, 0, 0);
            for (var n = b.tempCtx.getImageData(0,
                0, d, g), p = n.data, r = 0; r < h.length; r += 4) p[r] = 0 === k ? h[r] : 0, p[r + 1] = 1 === k ? h[r + 1] : 0, p[r + 2] = 2 === k ? h[r + 2] : 0, p[r + 3] = h[r + 3];
            m.putImageData(n, 0, 0)
        }
        a.onload = null
    }
    if (a.channelCache) return a.channelCache;
    var c = [document.createElement("canvas"), document.createElement("canvas"), document.createElement("canvas"), document.createElement("canvas")];
    try {
        b()
    } catch (d) {
        a.onload = b
    }
    return a.channelCache = c
};
cc.generateTextureCacheForColor.canvas = document.createElement("canvas");
cc.generateTextureCacheForColor.tempCanvas = document.createElement("canvas");
cc.generateTextureCacheForColor.tempCtx = cc.generateTextureCacheForColor.tempCanvas.getContext("2d");
cc.generateTintImage2 = function (a, b, c) {
    c || (c = cc.rect(0, 0, a.width, a.height), c = cc.RECT_PIXELS_TO_POINTS(c));
    var d = document.createElement("canvas"),
        e = d.getContext("2d");
    d.width != c.width && (d.width = c.width);
    d.height != c.height && (d.height = c.height);
    e.save();
    e.drawImage(a, c.x, c.y, c.width, c.height, 0, 0, c.width, c.height);
    e.globalCompositeOperation = "source-in";
    e.globalAlpha = b.a / 255;
    e.fillStyle = "rgb(" + b.r + "," + b.g + "," + b.b + ")";
    e.fillRect(0, 0, c.width, c.height);
    e.restore();
    return d
};
cc.generateTintImage = function (a, b, c, d, e) {
    d || (d = cc.rect(0, 0, a.width, a.height));
    a = c.r / 255;
    var f = c.g / 255;
    c = c.b / 255;
    var g = Math.min(d.width, b[0].width),
        h = Math.min(d.height, b[0].height),
        k;
    e ? (k = e.getContext("2d"), k.clearRect(0, 0, g, h)) : (e = document.createElement("canvas"), e.width = g, e.height = h, k = e.getContext("2d"));
    k.save();
    k.globalCompositeOperation = "lighter";
    var m = k.globalAlpha;
    0 < a && (k.globalAlpha = a * m, k.drawImage(b[0], d.x, d.y, g, h, 0, 0, g, h));
    0 < f && (k.globalAlpha = f * m, k.drawImage(b[1], d.x, d.y, g, h, 0, 0, g, h));
    0 <
        c && (k.globalAlpha = c * m, k.drawImage(b[2], d.x, d.y, g, h, 0, 0, g, h));
    1 > a + f + c && (k.globalAlpha = m, k.drawImage(b[3], d.x, d.y, g, h, 0, 0, g, h));
    k.restore();
    return e
};
cc.cutRotateImageToCanvas = function (a, b) {
    if (!a) return null;
    if (!b) return a;
    var c = document.createElement("canvas");
    c.width = b.width;
    c.height = b.height;
    var d = c.getContext("2d");
    d.translate(c.width / 2, c.height / 2);
    d.rotate(-1.5707963267948966);
    d.drawImage(a, b.x, b.y, b.height, b.width, -b.height / 2, -b.width / 2, b.height, b.width);
    return c
};
cc.RENDER_IN_SUBPIXEL = function (a) {
    return 0 | a
};
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL && (cc.RENDER_IN_SUBPIXEL = function (a) {
    return a
});
cc.Sprite = cc.NodeRGBA.extend({
    RGBAProtocol: !0,
    dirty: !1,
    atlasIndex: 0,
    textureAtlas: null,
    _batchNode: null,
    _recursiveDirty: null,
    _hasChildren: null,
    _shouldBeHidden: !1,
    _transformToBatch: null,
    _blendFunc: null,
    _texture: null,
    _rect: null,
    _rectRotated: !1,
    _offsetPosition: null,
    _unflippedOffsetPositionFromCenter: null,
    _opacityModifyRGB: !1,
    _flippedX: !1,
    _flippedY: !1,
    _textureLoaded: !1,
    _loadedEventListeners: null,
    _newTextureWhenChangeColor: null,
    _className: "Sprite",
    textureLoaded: function () {
        return this._textureLoaded
    },
    addLoadedEventListener: function (a,
        b) {
        this._loadedEventListeners || (this._loadedEventListeners = []);
        this._loadedEventListeners.push({
            eventCallback: a,
            eventTarget: b
        })
    },
    _callLoadedEventCallbacks: function () {
        if (this._loadedEventListeners) {
            for (var a = this._loadedEventListeners, b = 0, c = a.length; b < c; b++) {
                var d = a[b];
                d.eventCallback.call(d.eventTarget, this)
            }
            a.length = 0
        }
    },
    isDirty: function () {
        return this.dirty
    },
    setDirty: function (a) {
        this.dirty = a
    },
    isTextureRectRotated: function () {
        return this._rectRotated
    },
    getAtlasIndex: function () {
        return this.atlasIndex
    },
    setAtlasIndex: function (a) {
        this.atlasIndex = a
    },
    getTextureRect: function () {
        return cc.rect(this._rect.x, this._rect.y, this._rect.width, this._rect.height)
    },
    getTextureAtlas: function () {
        return this.textureAtlas
    },
    setTextureAtlas: function (a) {
        this.textureAtlas = a
    },
    getOffsetPosition: function () {
        return this._offsetPosition
    },
    _getOffsetX: function () {
        return this._offsetPosition.x
    },
    _getOffsetY: function () {
        return this._offsetPosition.y
    },
    getBlendFunc: function () {
        return this._blendFunc
    },
    initWithSpriteFrame: function (a) {
        if (!a) throw "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null";
        a.textureLoaded() || (this._textureLoaded = !1, a.addLoadedEventListener(this._spriteFrameLoadedCallback, this));
        var b = this.initWithTexture(a.getTexture(), a.getRect());
        this.setSpriteFrame(a);
        return b
    },
    _spriteFrameLoadedCallback: null,
    _spriteFrameLoadedCallbackForWebGL: function (a) {
        this.setNodeDirty(!0);
        this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
        this._callLoadedEventCallbacks()
    },
    _spriteFrameLoadedCallbackForCanvas: function (a) {
        this.setNodeDirty(!0);
        this.setTextureRect(a.getRect(), a.isRotated(),
            a.getOriginalSize());
        a = this.color;
        255 === a.r && 255 === a.g && 255 === a.b || this._changeTextureColor();
        this._callLoadedEventCallbacks()
    },
    initWithSpriteFrameName: function (a) {
        if (!a) throw "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null";
        a = cc.spriteFrameCache.getSpriteFrame(a);
        return this.initWithSpriteFrame(a)
    },
    useBatchNode: function (a) {
        this.textureAtlas = a.textureAtlas;
        this._batchNode = a
    },
    setVertexRect: function (a) {
        this._rect.x = a.x;
        this._rect.y = a.y;
        this._rect.width = a.width;
        this._rect.height =
            a.height
    },
    sortAllChildren: function () {
        if (this._reorderChildDirty) {
            for (var a, b, c = this._children, d, e = 1; e < c.length; e++) {
                b = c[e];
                a = e - 1;
                for (d = c[a]; 0 <= a && (b._localZOrder < d._localZOrder || b._localZOrder == d._localZOrder && b.arrivalOrder < d.arrivalOrder);) c[a + 1] = d, a -= 1, d = c[a];
                c[a + 1] = b
            }
            this._batchNode && this._arrayMakeObjectsPerformSelector(c, cc.Node.StateCallbackType.sortAllChildren);
            this._reorderChildDirty = !1
        }
    },
    reorderChild: function (a, b) {
        if (!a) throw "cc.Sprite.reorderChild(): child should be non-null"; - 1 === this._children.indexOf(a) ?
            cc.log("cc.Sprite.reorderChild(): this child is not in children list") : b !== a.zIndex && (this._batchNode && !this._reorderChildDirty && (this._setReorderChildDirtyRecursively(), this._batchNode.reorderBatch(!0)), cc.Node.prototype.reorderChild.call(this, a, b))
    },
    removeChild: function (a, b) {
        this._batchNode && this._batchNode.removeSpriteFromAtlas(a);
        cc.Node.prototype.removeChild.call(this, a, b)
    },
    removeAllChildren: function (a) {
        var b = this._children,
            c = this._batchNode;
        if (c && null != b)
            for (var d = 0, e = b.length; d < e; d++) c.removeSpriteFromAtlas(b[d]);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this._hasChildren = !1
    },
    setDirtyRecursively: function (a) {
        this.dirty = this._recursiveDirty = a;
        a = this._children;
        for (var b, c = a ? a.length : 0, d = 0; d < c; d++) b = a[d], b instanceof cc.Sprite && b.setDirtyRecursively(!0)
    },
    setNodeDirty: function (a) {
        cc.Node.prototype.setNodeDirty.call(this);
        a || !this._batchNode || this._recursiveDirty || (this._hasChildren ? this.setDirtyRecursively(!0) : this.dirty = this._recursiveDirty = !0)
    },
    ignoreAnchorPointForPosition: function (a) {
        this._batchNode ?
            cc.log("cc.Sprite.ignoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode") : cc.Node.prototype.ignoreAnchorPointForPosition.call(this, a)
    },
    setFlippedX: function (a) {
        this._flippedX != a && (this._flippedX = a, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
    },
    setFlippedY: function (a) {
        this._flippedY != a && (this._flippedY = a, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
    },
    isFlippedX: function () {
        return this._flippedX
    },
    isFlippedY: function () {
        return this._flippedY
    },
    setOpacityModifyRGB: null,
    _setOpacityModifyRGBForWebGL: function (a) {
        this._opacityModifyRGB !== a && (this._opacityModifyRGB = a, this.updateColor())
    },
    _setOpacityModifyRGBForCanvas: function (a) {
        this._opacityModifyRGB !== a && (this._opacityModifyRGB = a, this.setNodeDirty(!0))
    },
    isOpacityModifyRGB: function () {
        return this._opacityModifyRGB
    },
    updateDisplayedOpacity: null,
    _updateDisplayedOpacityForWebGL: function (a) {
        cc.NodeRGBA.prototype.updateDisplayedOpacity.call(this, a);
        this.updateColor()
    },
    _updateDisplayedOpacityForCanvas: function (a) {
        cc.NodeRGBA.prototype.updateDisplayedOpacity.call(this, a);
        this._setNodeDirtyForCache()
    },
    setDisplayFrameWithAnimationName: function (a, b) {
        if (!a) throw "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null";
        var c = cc.animationCache.getAnimation(a);
        c ? (c = c.getFrames()[b]) ? this.setSpriteFrame(c.getSpriteFrame()) : cc.log("cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index") : cc.log("cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found")
    },
    getBatchNode: function () {
        return this._batchNode
    },
    _setReorderChildDirtyRecursively: function () {
        if (!this._reorderChildDirty) {
            this._reorderChildDirty = !0;
            for (var a = this._parent; a && a != this._batchNode;) a._setReorderChildDirtyRecursively(), a = a.parent
        }
    },
    getTexture: function () {
        return this._texture
    },
    _quad: null,
    _quadWebBuffer: null,
    _quadDirty: !1,
    _colorized: !1,
    _isLighterMode: !1,
    _originalTexture: null,
    _textureRect_Canvas: null,
    _drawSize_Canvas: null,
    ctor: null,
    _ctorForWebGL: function (a, b) {
        cc.NodeRGBA.prototype.ctor.call(this);
        this._shouldBeHidden = !1;
        this._offsetPosition = cc.p(0, 0);
        this._unflippedOffsetPositionFromCenter = cc.p(0, 0);
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._rect = cc.rect(0, 0, 0, 0);
        this._quad = new cc.V3F_C4B_T2F_Quad;
        this._quadWebBuffer = cc._renderContext.createBuffer();
        this._textureLoaded = this._quadDirty = !0;
        this._softInit(a, b)
    },
    _ctorForCanvas: function (a, b) {
        cc.NodeRGBA.prototype.ctor.call(this);
        this._shouldBeHidden = !1;
        this._offsetPosition = cc.p(0, 0);
        this._unflippedOffsetPositionFromCenter = cc.p(0,
            0);
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._rect = cc.rect(0, 0, 0, 0);
        this._newTextureWhenChangeColor = !1;
        this._textureLoaded = !0;
        this._textureRect_Canvas = {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            validRect: !1
        };
        this._drawSize_Canvas = cc.size(0, 0);
        this._softInit(a, b)
    },
    _softInit: function (a, b) {
        if (void 0 === a) cc.Sprite.prototype.init.call(this);
        else if ("string" === typeof a)
            if ("#" === a[0]) {
                var c = a.substr(1, a.length - 1),
                    c = cc.spriteFrameCache.getSpriteFrame(c);
                this.initWithSpriteFrame(c)
            } else cc.Sprite.prototype.init.call(this,
                a, b);
        else if ("object" === typeof a)
            if (a instanceof cc.Texture2D) this.initWithTexture(a, b);
            else if (a instanceof cc.SpriteFrame) this.initWithSpriteFrame(a);
        else if (a instanceof HTMLImageElement || a instanceof HTMLCanvasElement) c = new cc.Texture2D, c.initWithElement(a), c.handleLoadedTexture(), this.initWithTexture(c)
    },
    getQuad: function () {
        return this._quad
    },
    setBlendFunc: null,
    _setBlendFuncForWebGL: function (a, b) {
        var c = this._blendFunc;
        void 0 === b ? (c.src = a.src, c.dst = a.dst) : (c.src = a, c.dst = b)
    },
    _setBlendFuncForCanvas: function (a,
        b) {
        var c = this._blendFunc;
        void 0 === b ? (c.src = a.src, c.dst = a.dst) : (c.src = a, c.dst = b);
        this._isLighterMode = c && (c.src == cc.SRC_ALPHA && c.dst == cc.ONE || c.src == cc.ONE && c.dst == cc.ONE)
    },
    init: null,
    _initForWebGL: function () {
        if (0 < arguments.length) return this.initWithFile(arguments[0], arguments[1]);
        cc.NodeRGBA.prototype.init.call(this);
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this.texture = null;
        this._textureLoaded = !0;
        this._flippedX =
            this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        var a = {
            r: 255,
            g: 255,
            b: 255,
            a: 255
        };
        this._quad.bl.colors = a;
        this._quad.br.colors = a;
        this._quad.tl.colors = a;
        this._quad.tr.colors = a;
        this._quadDirty = !0;
        this.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0));
        return !0
    },
    _initForCanvas: function () {
        if (0 < arguments.length) return this.initWithFile(arguments[0], arguments[1]);
        cc.NodeRGBA.prototype.init.call(this);
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this.texture = null;
        this._textureLoaded = !0;
        this._flippedX = this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        this.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0));
        return !0
    },
    initWithFile: function (a, b) {
        if (!a) throw "cc.Sprite.initWithFile(): filename should be non-null";
        var c = cc.textureCache.textureForKey(a);
        if (!c) c = cc.textureCache.addImage(a);
        else if (!b) {
            var d = c.getContentSize();
            b = cc.rect(0, 0, d.width, d.height)
        }
        return this.initWithTexture(c, b)
    },
    initWithTexture: null,
    _initWithTextureForWebGL: function (a, b, c) {
        if (0 == arguments.length) throw "Sprite.initWithTexture(): Argument must be non-nil ";
        c = c || !1;
        if (!cc.NodeRGBA.prototype.init.call(this)) return !1;
        this._batchNode = null;
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this._flippedX = this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x =
            0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        var d = cc.color(255, 255, 255, 255),
            e = this._quad;
        e.bl.colors = d;
        e.br.colors = d;
        e.tl.colors = d;
        e.tr.colors = d;
        this._textureLoaded = d = a.isLoaded();
        if (!d) return this._rectRotated = c || !1, b && (d = this._rect, d.x = b.x, d.y = b.y, d.width = b.width, d.height = b.height), a.addLoadedEventListener(this._textureLoadedCallback, this), !0;
        b || (b = cc.rect(0, 0, a.width, a.height));
        this.texture = a;
        this.setTextureRect(b, c);
        this.batchNode = null;
        return this._quadDirty = !0
    },
    _initWithTextureForCanvas: function (a,
        b, c) {
        if (0 == arguments.length) throw "Sprite.initWithTexture(): Argument must be non-nil ";
        c = c || !1;
        if (!cc.NodeRGBA.prototype.init.call(this)) return !1;
        this._batchNode = null;
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this._flippedX = this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        var d = a.isLoaded();
        this._textureLoaded = d;
        if (!d) return this._rectRotated = c ||
            !1, b && (this._rect.x = b.x, this._rect.y = b.y, this._rect.width = b.width, this._rect.height = b.height), a.addLoadedEventListener(this._textureLoadedCallback, this), !0;
        b || (b = cc.rect(0, 0, a.width, a.height));
        this.texture = this._originalTexture = a;
        this.setTextureRect(b, c);
        this.batchNode = null;
        return !0
    },
    _textureLoadedCallback: null,
    _textureLoadedCallbackForWebGL: function (a) {
        if (!this._textureLoaded) {
            this._textureLoaded = !0;
            var b = this._rect;
            b ? cc._rectEqualToZero(b) && (b.width = a.width, b.height = a.height) : b = cc.rect(0, 0, a.width,
                a.height);
            this.texture = a;
            this.setTextureRect(b, this._rectRotated);
            this.batchNode = null;
            this._quadDirty = !0;
            this._callLoadedEventCallbacks()
        }
    },
    _textureLoadedCallbackForCanvas: function (a) {
        if (!this._textureLoaded) {
            this._textureLoaded = !0;
            var b = this._rect;
            b ? cc._rectEqualToZero(b) && (b.width = a.width, b.height = a.height) : b = cc.rect(0, 0, a.width, a.height);
            this.texture = this._originalTexture = a;
            this.setTextureRect(b, this._rectRotated);
            this.batchNode = null;
            this._callLoadedEventCallbacks()
        }
    },
    setTextureRect: null,
    _setTextureRectForWebGL: function (a,
        b, c) {
        this._rectRotated = b || !1;
        this.setContentSize(c || a);
        this.setVertexRect(a);
        this._setTextureCoords(a);
        a = this._unflippedOffsetPositionFromCenter;
        this._flippedX && (a.x = -a.x);
        this._flippedY && (a.y = -a.y);
        var d = this._rect;
        this._offsetPosition.x = a.x + (this._contentSize.width - d.width) / 2;
        this._offsetPosition.y = a.y + (this._contentSize.height - d.height) / 2;
        if (this._batchNode) this.dirty = !0;
        else {
            a = 0 + this._offsetPosition.x;
            b = 0 + this._offsetPosition.y;
            c = a + d.width;
            var d = b + d.height,
                e = this._quad;
            e.bl.vertices = {
                x: a,
                y: b,
                z: 0
            };
            e.br.vertices = {
                x: c,
                y: b,
                z: 0
            };
            e.tl.vertices = {
                x: a,
                y: d,
                z: 0
            };
            e.tr.vertices = {
                x: c,
                y: d,
                z: 0
            };
            this._quadDirty = !0
        }
    },
    _setTextureRectForCanvas: function (a, b, c) {
        this._rectRotated = b || !1;
        this.setContentSize(c || a);
        this.setVertexRect(a);
        b = this._textureRect_Canvas;
        c = cc.CONTENT_SCALE_FACTOR();
        b.x = 0 | a.x * c;
        b.y = 0 | a.y * c;
        b.width = 0 | a.width * c;
        b.height = 0 | a.height * c;
        b.validRect = !(0 === b.width || 0 === b.height || 0 > b.x || 0 > b.y);
        a = this._unflippedOffsetPositionFromCenter;
        this._flippedX && (a.x = -a.x);
        this._flippedY && (a.y = -a.y);
        this._offsetPosition.x =
            a.x + (this._contentSize.width - this._rect.width) / 2;
        this._offsetPosition.y = a.y + (this._contentSize.height - this._rect.height) / 2;
        this._batchNode && (this.dirty = !0)
    },
    updateTransform: null,
    _updateTransformForWebGL: function () {
        if (this.dirty) {
            var a = this._quad,
                b = this._parent;
            if (!this._visible || b && b != this._batchNode && b._shouldBeHidden) a.br.vertices = {
                x: 0,
                y: 0,
                z: 0
            }, a.tl.vertices = {
                x: 0,
                y: 0,
                z: 0
            }, a.tr.vertices = {
                x: 0,
                y: 0,
                z: 0
            }, a.bl.vertices = {
                x: 0,
                y: 0,
                z: 0
            }, this._shouldBeHidden = !0;
            else {
                this._shouldBeHidden = !1;
                var c = this._transformToBatch =
                    b && b != this._batchNode ? cc.AffineTransformConcat(this.nodeToParentTransform(), b._transformToBatch) : this.nodeToParentTransform(),
                    d = this._rect,
                    b = this._offsetPosition.x,
                    e = this._offsetPosition.y,
                    f = b + d.width,
                    g = e + d.height,
                    d = c.tx,
                    h = c.ty,
                    k = c.a,
                    m = c.b,
                    n = c.d,
                    c = -c.c,
                    p = b * m + e * n + h,
                    r = f * k - e * c + d,
                    q = f * m + e * n + h,
                    s = f * k - g * c + d,
                    f = f * m + g * n + h,
                    t = b * k - g * c + d,
                    g = b * m + g * n + h,
                    h = this._vertexZ;
                a.bl.vertices = {
                    x: cc.RENDER_IN_SUBPIXEL(b * k - e * c + d),
                    y: cc.RENDER_IN_SUBPIXEL(p),
                    z: h
                };
                a.br.vertices = {
                    x: cc.RENDER_IN_SUBPIXEL(r),
                    y: cc.RENDER_IN_SUBPIXEL(q),
                    z: h
                };
                a.tl.vertices = {
                    x: cc.RENDER_IN_SUBPIXEL(t),
                    y: cc.RENDER_IN_SUBPIXEL(g),
                    z: h
                };
                a.tr.vertices = {
                    x: cc.RENDER_IN_SUBPIXEL(s),
                    y: cc.RENDER_IN_SUBPIXEL(f),
                    z: h
                }
            }
            this.textureAtlas.updateQuad(a, this.atlasIndex);
            this.dirty = this._recursiveDirty = !1
        }
        this._hasChildren && this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform);
        cc.SPRITE_DEBUG_DRAW && (a = [cc.p(this._quad.bl.vertices.x, this._quad.bl.vertices.y), cc.p(this._quad.br.vertices.x, this._quad.br.vertices.y), cc.p(this._quad.tr.vertices.x,
            this._quad.tr.vertices.y), cc.p(this._quad.tl.vertices.x, this._quad.tl.vertices.y)], cc._drawingUtil.drawPoly(a, 4, !0))
    },
    _updateTransformForCanvas: function () {
        if (this.dirty) {
            var a = this._parent;
            !this._visible || a && a != this._batchNode && a._shouldBeHidden ? this._shouldBeHidden = !0 : (this._shouldBeHidden = !1, this._transformToBatch = a && a != this._batchNode ? cc.AffineTransformConcat(this.nodeToParentTransform(), a._transformToBatch) : this.nodeToParentTransform());
            this.dirty = this._recursiveDirty = !1
        }
        this._hasChildren && this._arrayMakeObjectsPerformSelector(this._children,
            cc.Node.StateCallbackType.updateTransform)
    },
    addChild: null,
    _addChildForWebGL: function (a, b, c) {
        if (!a) throw "cc.Sprite.addChild(): child should be non-null";
        null == b && (b = a._localZOrder);
        null == c && (c = a.tag);
        if (this._batchNode) {
            if (!(a instanceof cc.Sprite)) {
                cc.log("cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode");
                return
            }
            a.texture._webTextureObj !== this.textureAtlas.texture._webTextureObj && cc.log("cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode");
            this._batchNode.appendChild(a);
            this._reorderChildDirty || this._setReorderChildDirtyRecursively()
        }
        cc.NodeRGBA.prototype.addChild.call(this, a, b, c);
        this._hasChildren = !0
    },
    _addChildForCanvas: function (a, b, c) {
        if (!a) throw "cc.Sprite.addChild(): child should be non-null";
        null == b && (b = a._localZOrder);
        null == c && (c = a.tag);
        cc.NodeRGBA.prototype.addChild.call(this, a, b, c);
        this._hasChildren = !0
    },
    updateColor: function () {
        var a = this._displayedColor,
            b = this._displayedOpacity,
            a = {
                r: a.r,
                g: a.g,
                b: a.b,
                a: b
            };
        this._opacityModifyRGB &&
            (a.r *= b / 255, a.g *= b / 255, a.b *= b / 255);
        b = this._quad;
        b.bl.colors = a;
        b.br.colors = a;
        b.tl.colors = a;
        b.tr.colors = a;
        this._batchNode && (this.atlasIndex != cc.SPRITE_INDEX_NOT_INITIALIZED ? this.textureAtlas.updateQuad(b, this.atlasIndex) : this.dirty = !0);
        this._quadDirty = !0
    },
    setOpacity: null,
    _setOpacityForWebGL: function (a) {
        cc.NodeRGBA.prototype.setOpacity.call(this, a);
        this.updateColor()
    },
    _setOpacityForCanvas: function (a) {
        cc.NodeRGBA.prototype.setOpacity.call(this, a);
        this._setNodeDirtyForCache()
    },
    setColor: null,
    _setColorForWebGL: function (a) {
        cc.NodeRGBA.prototype.setColor.call(this,
            a);
        this.updateColor()
    },
    _setColorForCanvas: function (a) {
        var b = this.color;
        if (b.r !== a.r || b.g !== a.g || b.b !== a.b || b.a !== a.a) cc.NodeRGBA.prototype.setColor.call(this, a), this._changeTextureColor(), this._setNodeDirtyForCache()
    },
    updateDisplayedColor: null,
    _updateDisplayedColorForWebGL: function (a) {
        cc.NodeRGBA.prototype.updateDisplayedColor.call(this, a);
        this.updateColor()
    },
    _updateDisplayedColorForCanvas: function (a) {
        var b = this.color;
        cc.NodeRGBA.prototype.updateDisplayedColor.call(this, a);
        a = this._displayedColor;
        if (b.r !== a.r || b.g !== a.g || b.b !== a.b) this._changeTextureColor(), this._setNodeDirtyForCache()
    },
    setSpriteFrame: null,
    _setSpriteFrameForWebGL: function (a) {
        if ("string" == typeof a && (a = cc.spriteFrameCache.getSpriteFrame(a), !a)) throw "Invalid spriteFrameName";
        this.setNodeDirty(!0);
        var b = a.getOffset();
        this._unflippedOffsetPositionFromCenter.x = b.x;
        this._unflippedOffsetPositionFromCenter.y = b.y;
        b = a.getTexture();
        a.textureLoaded() || (this._textureLoaded = !1, a.addLoadedEventListener(function (a) {
            this._textureLoaded = !0;
            var b = a.getTexture();
            b != this._texture && (this.texture = b);
            this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
            this._callLoadedEventCallbacks()
        }, this));
        b != this._texture && (this.texture = b);
        this._rectRotated = a.isRotated();
        this.setTextureRect(a.getRect(), this._rectRotated, a.getOriginalSize())
    },
    _setSpriteFrameForCanvas: function (a) {
        if ("string" == typeof a && (a = cc.spriteFrameCache.getSpriteFrame(a), !a)) throw "Invalid spriteFrameName";
        this.setNodeDirty(!0);
        var b = a.getOffset();
        this._unflippedOffsetPositionFromCenter.x =
            b.x;
        this._unflippedOffsetPositionFromCenter.y = b.y;
        this._rectRotated = a.isRotated();
        var b = a.getTexture(),
            c = a.textureLoaded();
        c || (this._textureLoaded = !1, a.addLoadedEventListener(function (a) {
            this._textureLoaded = !0;
            var b = a.getTexture();
            b != this._texture && (this.texture = b);
            this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
            this._callLoadedEventCallbacks()
        }, this));
        b != this._texture && (this.texture = b);
        this._rectRotated && (this._originalTexture = b);
        this.setTextureRect(a.getRect(), this._rectRotated,
            a.getOriginalSize());
        this._colorized = !1;
        c && (a = this.color, 255 === a.r && 255 === a.g && 255 === a.b || this._changeTextureColor())
    },
    setDisplayFrame: function (a) {
        cc.log("setDisplayFrame is deprecated, please use setSpriteFrame instead.");
        this.setSpriteFrame(a)
    },
    isFrameDisplayed: null,
    _isFrameDisplayedForWebGL: function (a) {
        return cc.rectEqualToRect(a.getRect(), this._rect) && a.getTexture().getName() == this._texture.getName() && cc.pointEqualToPoint(a.getOffset(), this._unflippedOffsetPositionFromCenter)
    },
    _isFrameDisplayedForCanvas: function (a) {
        return a.getTexture() !=
            this._texture ? !1 : cc.rectEqualToRect(a.getRect(), this._rect)
    },
    displayFrame: function () {
        return cc.SpriteFrame.create(this._texture, cc.RECT_POINTS_TO_PIXELS(this._rect), this._rectRotated, cc.POINT_POINTS_TO_PIXELS(this._unflippedOffsetPositionFromCenter), cc.SIZE_POINTS_TO_PIXELS(this._contentSize))
    },
    setBatchNode: null,
    _setBatchNodeForWebGL: function (a) {
        if (this._batchNode = a) this._transformToBatch = cc.AffineTransformIdentity(), this.textureAtlas = this._batchNode.textureAtlas;
        else {
            this.atlasIndex = cc.SPRITE_INDEX_NOT_INITIALIZED;
            this.textureAtlas = null;
            this.dirty = this._recursiveDirty = !1;
            a = this._offsetPosition.x;
            var b = this._offsetPosition.y,
                c = a + this._rect.width,
                d = b + this._rect.height,
                e = this._quad;
            e.bl.vertices = {
                x: a,
                y: b,
                z: 0
            };
            e.br.vertices = {
                x: c,
                y: b,
                z: 0
            };
            e.tl.vertices = {
                x: a,
                y: d,
                z: 0
            };
            e.tr.vertices = {
                x: c,
                y: d,
                z: 0
            };
            this._quadDirty = !0
        }
    },
    _setBatchNodeForCanvas: function (a) {
        (this._batchNode = a) ? (this._transformToBatch = cc.AffineTransformIdentity(), this.textureAtlas = this._batchNode.textureAtlas) : (this.atlasIndex = cc.SPRITE_INDEX_NOT_INITIALIZED,
            this.textureAtlas = null, this.dirty = this._recursiveDirty = !1)
    },
    setTexture: null,
    _setTextureForWebGL: function (a) {
        if (a && "string" === typeof a) a = cc.textureCache.addImage(a), this._setTextureForWebGL(a), a = a.getContentSize(), this.setTextureRect(cc.rect(0, 0, a.width, a.height));
        else {
            if (a && !(a instanceof cc.Texture2D)) throw "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.";
            this._batchNode && this._batchNode.texture != a ? cc.log("cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode") :
                (this.shaderProgram = a ? cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR) : cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR), this._batchNode || this._texture == a || (this._texture = a, this._updateBlendFunc()))
        }
    },
    _setTextureForCanvas: function (a) {
        if (a && "string" === typeof a) a = cc.textureCache.addImage(a), this._setTextureForCanvas(a), a = a.getContentSize(), this.setTextureRect(cc.rect(0, 0, a.width, a.height));
        else {
            if (a && !(a instanceof cc.Texture2D)) throw "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.";
            this._texture != a && (a && a.getHtmlElementObj() instanceof HTMLImageElement && (this._originalTexture = a), this._texture = a)
        }
    },
    _updateBlendFunc: function () {
        this._batchNode ? cc.log("cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode") : this._texture && this._texture.hasPremultipliedAlpha() ? (this._blendFunc.src = cc.BLEND_SRC, this._blendFunc.dst = cc.BLEND_DST, this.opacityModifyRGB = !0) : (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA,
            this.opacityModifyRGB = !1)
    },
    _changeTextureColor: function () {
        var a, b = this._texture,
            c = this._textureRect_Canvas;
        b && c.validRect && this._originalTexture && (a = b.getHtmlElementObj()) && (b = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj())) && (this._colorized = !0, a instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor ? cc.generateTintImage(a, b, this._displayedColor, c, a) : (a = cc.generateTintImage(a, b, this._displayedColor, c), b = new cc.Texture2D, b.initWithElement(a),
            b.handleLoadedTexture(), this.texture = b))
    },
    _setTextureCoords: function (a) {
        a = cc.RECT_POINTS_TO_PIXELS(a);
        var b = this._batchNode ? this.textureAtlas.texture : this._texture;
        if (b) {
            var c = b.pixelsWidth,
                d = b.pixelsHeight,
                e, f = this._quad;
            this._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (b = (2 * a.x + 1) / (2 * c), c = b + (2 * a.height - 2) / (2 * c), e = (2 * a.y + 1) / (2 * d), a = e + (2 * a.width - 2) / (2 * d)) : (b = a.x / c, c = (a.x + a.height) / c, e = a.y / d, a = (a.y + a.width) / d), this._flippedX && (d = e, e = a, a = d), this._flippedY && (d = b, b = c, c = d), f.bl.texCoords.u = b, f.bl.texCoords.v =
                e, f.br.texCoords.u = b, f.br.texCoords.v = a, f.tl.texCoords.u = c, f.tl.texCoords.v = e, f.tr.texCoords.u = c, f.tr.texCoords.v = a) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (b = (2 * a.x + 1) / (2 * c), c = b + (2 * a.width - 2) / (2 * c), e = (2 * a.y + 1) / (2 * d), a = e + (2 * a.height - 2) / (2 * d)) : (b = a.x / c, c = (a.x + a.width) / c, e = a.y / d, a = (a.y + a.height) / d), this._flippedX && (d = b, b = c, c = d), this._flippedY && (d = e, e = a, a = d), f.bl.texCoords.u = b, f.bl.texCoords.v = a, f.br.texCoords.u = c, f.br.texCoords.v = a, f.tl.texCoords.u = b, f.tl.texCoords.v = e, f.tr.texCoords.u = c, f.tr.texCoords.v =
                e);
            this._quadDirty = !0
        }
    },
    draw: null,
    _drawForWebGL: function () {
        if (this._textureLoaded) {
            var a = cc._renderContext,
                b = this._texture;
            b ? b._isLoaded && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2DN(0, b), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (a.bufferData(a.ARRAY_BUFFER, this._quad.arrayBuffer, a.DYNAMIC_DRAW),
                this._quadDirty = !1), a.vertexAttribPointer(0, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(1, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.vertexAttribPointer(2, 2, a.FLOAT, !1, 24, 16), a.drawArrays(a.TRIANGLE_STRIP, 0, 4)) : (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2D(null), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer),
                this._quadDirty && (cc._renderContext.bufferData(cc._renderContext.ARRAY_BUFFER, this._quad.arrayBuffer, cc._renderContext.STATIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.drawArrays(a.TRIANGLE_STRIP, 0, 4));
            cc.g_NumberOfDraws++;
            if (0 !== cc.SPRITE_DEBUG_DRAW || this._showNode) 1 === cc.SPRITE_DEBUG_DRAW || this._showNode ? (a = this._quad, a = [cc.p(a.tl.vertices.x, a.tl.vertices.y), cc.p(a.bl.vertices.x,
                a.bl.vertices.y), cc.p(a.br.vertices.x, a.br.vertices.y), cc.p(a.tr.vertices.x, a.tr.vertices.y)], cc._drawingUtil.drawPoly(a, 4, !0)) : 2 === cc.SPRITE_DEBUG_DRAW && (a = this.getTextureRect(), b = this.getOffsetPosition(), a = [cc.p(b.x, b.y), cc.p(b.x + a.width, b.y), cc.p(b.x + a.width, b.y + a.height), cc.p(b.x, b.y + a.height)], cc._drawingUtil.drawPoly(a, 4, !0))
        }
    },
    _drawForCanvas: function (a) {
        if (this._textureLoaded) {
            a = a || cc._renderContext;
            this._isLighterMode && (a.globalCompositeOperation = "lighter");
            var b = cc.view.getScaleX(),
                c = cc.view.getScaleY();
            a.globalAlpha = this._displayedOpacity / 255;
            var d = this._rect,
                e = this._contentSize,
                f = this._offsetPosition,
                g = this._drawSize_Canvas,
                h = 0 | f.x,
                k = -f.y - d.height,
                m = this._textureRect_Canvas;
            g.width = d.width * b;
            g.height = d.height * c;
            if (this._flippedX || this._flippedY) a.save(), this._flippedX && (h = -f.x - d.width, a.scale(-1, 1)), this._flippedY && (k = f.y, a.scale(1, -1));
            h *= b;
            k *= c;
            this._texture && m.validRect ? (e = this._texture.getHtmlElementObj(), this._colorized ? a.drawImage(e, 0, 0, m.width, m.height, h, k, g.width, g.height) : a.drawImage(e,
                m.x, m.y, m.width, m.height, h, k, g.width, g.height)) : 0 !== e.width && (g = this.color, a.fillStyle = "rgba(" + g.r + "," + g.g + "," + g.b + ",1)", a.fillRect(h, k, e.width * b, e.height * c));
            1 === cc.SPRITE_DEBUG_DRAW || this._showNode ? (a.strokeStyle = "rgba(0,255,0,1)", h /= b, k = -(k / c), h = [cc.p(h, k), cc.p(h + d.width, k), cc.p(h + d.width, k - d.height), cc.p(h, k - d.height)], cc._drawingUtil.drawPoly(h, 4, !0)) : 2 === cc.SPRITE_DEBUG_DRAW && (a.strokeStyle = "rgba(0,255,0,1)", b = this._rect, k = -k, h = [cc.p(h, k), cc.p(h + b.width, k), cc.p(h + b.width, k - b.height), cc.p(h,
                k - b.height)], cc._drawingUtil.drawPoly(h, 4, !0));
            (this._flippedX || this._flippedY) && a.restore();
            cc.g_NumberOfDraws++
        }
    }
});
window._p = cc.Sprite.prototype;
cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p._spriteFrameLoadedCallback = _p._spriteFrameLoadedCallbackForWebGL, _p.setOpacityModifyRGB = _p._setOpacityModifyRGBForWebGL, _p.updateDisplayedOpacity = _p._updateDisplayedOpacityForWebGL, _p.ctor = _p._ctorForWebGL, _p.setBlendFunc = _p._setBlendFuncForWebGL, _p.init = _p._initForWebGL, _p.initWithTexture = _p._initWithTextureForWebGL, _p._textureLoadedCallback = _p._textureLoadedCallbackForWebGL, _p.setTextureRect = _p._setTextureRectForWebGL, _p.updateTransform = _p._updateTransformForWebGL,
    _p.addChild = _p._addChildForWebGL, _p.setOpacity = _p._setOpacityForWebGL, _p.setColor = _p._setColorForWebGL, _p.updateDisplayedColor = _p._updateDisplayedColorForWebGL, _p.setSpriteFrame = _p._setSpriteFrameForWebGL, _p.isFrameDisplayed = _p._isFrameDisplayedForWebGL, _p.setBatchNode = _p._setBatchNodeForWebGL, _p.setTexture = _p._setTextureForWebGL, _p.draw = _p._drawForWebGL) : (_p._spriteFrameLoadedCallback = _p._spriteFrameLoadedCallbackForCanvas, _p.setOpacityModifyRGB = _p._setOpacityModifyRGBForCanvas, _p.updateDisplayedOpacity =
    _p._updateDisplayedOpacityForCanvas, _p.ctor = _p._ctorForCanvas, _p.setBlendFunc = _p._setBlendFuncForCanvas, _p.init = _p._initForCanvas, _p.initWithTexture = _p._initWithTextureForCanvas, _p._textureLoadedCallback = _p._textureLoadedCallbackForCanvas, _p.setTextureRect = _p._setTextureRectForCanvas, _p.updateTransform = _p._updateTransformForCanvas, _p.addChild = _p._addChildForCanvas, _p.setOpacity = _p._setOpacityForCanvas, _p.setColor = _p._setColorForCanvas, _p.updateDisplayedColor = _p._updateDisplayedColorForCanvas, _p.setSpriteFrame =
    _p._setSpriteFrameForCanvas, _p.isFrameDisplayed = _p._isFrameDisplayedForCanvas, _p.setBatchNode = _p._setBatchNodeForCanvas, _p.setTexture = _p._setTextureForCanvas, _p.draw = _p._drawForCanvas);
cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, "flippedX", _p.isFlippedX, _p.setFlippedX);
cc.defineGetterSetter(_p, "flippedY", _p.isFlippedY, _p.setFlippedY);
cc.defineGetterSetter(_p, "offsetX", _p._getOffsetX);
cc.defineGetterSetter(_p, "offsetY", _p._getOffsetY);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "textureRectRotated", _p.isTextureRectRotated);
cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode);
cc.defineGetterSetter(_p, "quad", _p.getQuad);
delete window._p;
cc.Sprite.create = function (a, b) {
    return new cc.Sprite(a, b)
};
cc.AnimationFrame = cc.Class.extend({
    _spriteFrame: null,
    _delayPerUnit: 0,
    _userInfo: null,
    ctor: function () {
        this._delayPerUnit = 0
    },
    clone: function () {
        var a = new cc.AnimationFrame;
        a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
        return a
    },
    copyWithZone: function (a) {
        return cc.clone(this)
    },
    copy: function (a) {
        a = new cc.AnimationFrame;
        a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
        return a
    },
    initWithSpriteFrame: function (a, b, c) {
        this._spriteFrame = a;
        this._delayPerUnit =
            b;
        this._userInfo = c;
        return !0
    },
    getSpriteFrame: function () {
        return this._spriteFrame
    },
    setSpriteFrame: function (a) {
        this._spriteFrame = a
    },
    getDelayUnits: function () {
        return this._delayPerUnit
    },
    setDelayUnits: function (a) {
        this._delayPerUnit = a
    },
    getUserInfo: function () {
        return this._userInfo
    },
    setUserInfo: function (a) {
        this._userInfo = a
    }
});
cc.Animation = cc.Class.extend({
    _frames: null,
    _loops: 0,
    _restoreOriginalFrame: !1,
    _duration: 0,
    _delayPerUnit: 0,
    _totalDelayUnits: 0,
    ctor: function () {
        this._frames = []
    },
    getFrames: function () {
        return this._frames
    },
    setFrames: function (a) {
        this._frames = a
    },
    addSpriteFrame: function (a) {
        var b = new cc.AnimationFrame;
        b.initWithSpriteFrame(a, 1, null);
        this._frames.push(b);
        this._totalDelayUnits++
    },
    addSpriteFrameWithFile: function (a) {
        a = cc.textureCache.addImage(a);
        var b = cc.rect(0, 0, 0, 0);
        b.width = a.width;
        b.height = a.height;
        a = cc.SpriteFrame.create(a,
            b);
        this.addSpriteFrame(a)
    },
    addSpriteFrameWithTexture: function (a, b) {
        var c = cc.SpriteFrame.create(a, b);
        this.addSpriteFrame(c)
    },
    initWithAnimationFrames: function (a, b, c) {
        cc.arrayVerifyType(a, cc.AnimationFrame);
        this._delayPerUnit = b;
        this._loops = c;
        this._totalDelayUnits = 0;
        b = this._frames;
        for (c = b.length = 0; c < a.length; c++) {
            var d = a[c];
            b.push(d);
            this._totalDelayUnits += d.getDelayUnits()
        }
        return !0
    },
    clone: function () {
        var a = new cc.Animation;
        a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
        a.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return a
    },
    copyWithZone: function (a) {
        a = new cc.Animation;
        a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
        a.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return a
    },
    _copyFrames: function () {
        for (var a = [], b = 0; b < this._frames.length; b++) a.push(this._frames[b].clone());
        return a
    },
    copy: function (a) {
        return this.copyWithZone(null)
    },
    getLoops: function () {
        return this._loops
    },
    setLoops: function (a) {
        this._loops = a
    },
    setRestoreOriginalFrame: function (a) {
        this._restoreOriginalFrame = a
    },
    getRestoreOriginalFrame: function () {
        return this._restoreOriginalFrame
    },
    getDuration: function () {
        return this._totalDelayUnits * this._delayPerUnit
    },
    getDelayPerUnit: function () {
        return this._delayPerUnit
    },
    setDelayPerUnit: function (a) {
        this._delayPerUnit = a
    },
    getTotalDelayUnits: function () {
        return this._totalDelayUnits
    },
    initWithSpriteFrames: function (a, b) {
        cc.arrayVerifyType(a, cc.SpriteFrame);
        this._loops = 1;
        this._delayPerUnit = b || 0;
        this._totalDelayUnits = 0;
        var c = this._frames;
        c.length = 0;
        if (a) {
            for (var d = 0; d < a.length; d++) {
                var e = a[d],
                    f = new cc.AnimationFrame;
                f.initWithSpriteFrame(e, 1, null);
                c.push(f)
            }
            this._totalDelayUnits += a.length
        }
        return !0
    },
    retain: function () {},
    release: function () {}
});
cc.Animation.create = function (a, b, c) {
    var d = arguments.length,
        e = new cc.Animation;
    0 == d ? e.initWithSpriteFrames(null, 0) : (d = a[0]) && (d instanceof cc.SpriteFrame ? e.initWithSpriteFrames(a, b) : d instanceof cc.AnimationFrame && e.initWithAnimationFrames(a, b, c));
    return e
};
cc.animationCache = {
    _animations: {},
    addAnimation: function (a, b) {
        this._animations[b] = a
    },
    removeAnimation: function (a) {
        a && this._animations[a] && delete this._animations[a]
    },
    getAnimation: function (a) {
        return this._animations[a] ? this._animations[a] : null
    },
    _addAnimationsWithDictionary: function (a, b) {
        var c = a.animations;
        if (c) {
            var d = 1,
                e = a.properties;
            if (e)
                for (var d = null != e.format ? parseInt(e.format) : d, e = e.spritesheets, f = cc.spriteFrameCache, g = cc.path, h = 0; h < e.length; h++) f.addSpriteFrames(g.changeBasename(b, e[h]));
            switch (d) {
            case 1:
                this._parseVersion1(c);
                break;
            case 2:
                this._parseVersion2(c);
                break;
            default:
                cc.log("cc.AnimationCache. Invalid animation format")
            }
        } else cc.log("cocos2d: cc.AnimationCache: No animations were found in provided dictionary.")
    },
    addAnimations: function (a) {
        if (!a) throw "cc.AnimationCache.addAnimations(): Invalid texture file name";
        var b = cc.loader.getRes(a);
        b ? this._addAnimationsWithDictionary(b, a) : cc.log("cc.AnimationCache.addAnimations(): File could not be found")
    },
    _parseVersion1: function (a) {
        var b = cc.spriteFrameCache,
            c;
        for (c in a) {
            var d =
                a[c],
                e = d.frames,
                d = parseFloat(d.delay) || 0,
                f = null;
            if (e) {
                for (var f = [], g = 0; g < e.length; g++) {
                    var h = b.getSpriteFrame(e[g]);
                    if (h) {
                        var k = new cc.AnimationFrame;
                        k.initWithSpriteFrame(h, 1, null);
                        f.push(k)
                    } else cc.log("cocos2d: cc.AnimationCache: Animation '" + c + "' refers to frame '" + e[g] + "' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.")
                }
                0 === f.length ? cc.log("cocos2d: cc.AnimationCache: None of the frames for animation '" + c + "' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.") :
                    (f.length != e.length && cc.log("cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '" + c + "' may be missing."), f = cc.Animation.create(f, d, 1), cc.animationCache.addAnimation(f, c))
            } else cc.log("cocos2d: cc.AnimationCache: Animation '" + c + "' found in dictionary without any frames - cannot add to animation cache.")
        }
    },
    _parseVersion2: function (a) {
        var b = cc.spriteFrameCache,
            c;
        for (c in a) {
            var d = a[c],
                e = d.loop,
                f = parseInt(d.loops),
                e = e ? cc.REPEAT_FOREVER : isNaN(f) ? 1 : f,
                f = d.restoreOriginalFrame && !0 == d.restoreOriginalFrame ? !0 : !1,
                g = d.frames;
            if (g) {
                for (var h = [], k = 0; k < g.length; k++) {
                    var m = g[k],
                        n = m.spriteframe,
                        p = b.getSpriteFrame(n);
                    if (p) {
                        var n = parseFloat(m.delayUnits) || 0,
                            m = m.notification,
                            r = new cc.AnimationFrame;
                        r.initWithSpriteFrame(p, n, m);
                        h.push(r)
                    } else cc.log("cocos2d: cc.AnimationCache: Animation '" + c + "' refers to frame '" + n + "' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.")
                }
                d =
                    parseFloat(d.delayPerUnit) || 0;
                g = new cc.Animation;
                g.initWithAnimationFrames(h, d, e);
                g.setRestoreOriginalFrame(f);
                cc.animationCache.addAnimation(g, c)
            } else cc.log("cocos2d: CCAnimationCache: Animation '" + c + "' found in dictionary without any frames - cannot add to animation cache.")
        }
    },
    _clear: function () {
        this._animations = {}
    }
};
cc.SpriteFrame = cc.Class.extend({
    _offset: null,
    _originalSize: null,
    _rectInPixels: null,
    _rotated: !1,
    _rect: null,
    _offsetInPixels: null,
    _originalSizeInPixels: null,
    _texture: null,
    _textureFilename: "",
    _textureLoaded: !1,
    _eventListeners: null,
    ctor: function () {
        this._offset = cc.p(0, 0);
        this._offsetInPixels = cc.p(0, 0);
        this._originalSize = cc.size(0, 0);
        this._rotated = !1;
        this._originalSizeInPixels = cc.size(0, 0);
        this._textureFilename = "";
        this._texture = null;
        this._textureLoaded = !1
    },
    textureLoaded: function () {
        return this._textureLoaded
    },
    addLoadedEventListener: function (a, b) {
        null == this._eventListeners && (this._eventListeners = []);
        this._eventListeners.push({
            eventCallback: a,
            eventTarget: b
        })
    },
    _callLoadedEventCallbacks: function () {
        var a = this._eventListeners;
        if (a) {
            for (var b = 0, c = a.length; b < c; b++) {
                var d = a[b];
                d.eventCallback.call(d.eventTarget, this)
            }
            a.length = 0
        }
    },
    getRectInPixels: function () {
        var a = this._rectInPixels;
        return cc.rect(a.x, a.y, a.width, a.height)
    },
    setRectInPixels: function (a) {
        this._rectInPixels || (this._rectInPixels = cc.rect(0, 0, 0, 0));
        this._rectInPixels.x =
            a.x;
        this._rectInPixels.y = a.y;
        this._rectInPixels.width = a.width;
        this._rectInPixels.height = a.height;
        this._rect = cc.RECT_PIXELS_TO_POINTS(a)
    },
    isRotated: function () {
        return this._rotated
    },
    setRotated: function (a) {
        this._rotated = a
    },
    getRect: function () {
        var a = this._rect;
        return cc.rect(a.x, a.y, a.width, a.height)
    },
    setRect: function (a) {
        this._rect || (this._rect = cc.rect(0, 0, 0, 0));
        this._rect.x = a.x;
        this._rect.y = a.y;
        this._rect.width = a.width;
        this._rect.height = a.height;
        this._rectInPixels = cc.RECT_POINTS_TO_PIXELS(this._rect)
    },
    getOffsetInPixels: function () {
        return this._offsetInPixels
    },
    setOffsetInPixels: function (a) {
        this._offsetInPixels.x = a.x;
        this._offsetInPixels.y = a.y;
        cc._POINT_PIXELS_TO_POINTS_OUT(this._offsetInPixels, this._offset)
    },
    getOriginalSizeInPixels: function () {
        return this._originalSizeInPixels
    },
    setOriginalSizeInPixels: function (a) {
        this._originalSizeInPixels.width = a.width;
        this._originalSizeInPixels.height = a.height
    },
    getOriginalSize: function () {
        return this._originalSize
    },
    setOriginalSize: function (a) {
        this._originalSize.width =
            a.width;
        this._originalSize.height = a.height
    },
    getTexture: function () {
        if (this._texture) return this._texture;
        if ("" !== this._textureFilename) {
            var a = cc.textureCache.addImage(this._textureFilename);
            a && (this._textureLoaded = a.isLoaded());
            return a
        }
        return null
    },
    setTexture: function (a) {
        if (this._texture != a) {
            var b = a.isLoaded();
            this._textureLoaded = b;
            this._texture = a;
            b || a.addLoadedEventListener(function (a) {
                this._textureLoaded = !0;
                if (this._rotated && cc._renderType === cc._RENDER_TYPE_CANVAS) {
                    var b = a.getHtmlElementObj(),
                        b =
                        cc.cutRotateImageToCanvas(b, this.getRect()),
                        e = new cc.Texture2D;
                    e.initWithElement(b);
                    e.handleLoadedTexture();
                    this.setTexture(e);
                    b = this.getRect();
                    this.setRect(cc.rect(0, 0, b.width, b.height))
                }
                b = this._rect;
                0 === b.width && 0 === b.height && (b = a.width, a = a.height, this._rect.width = b, this._rect.height = a, this._rectInPixels = cc.RECT_POINTS_TO_PIXELS(this._rect), this._originalSizeInPixels.width = this._rectInPixels.width, this._originalSizeInPixels.height = this._rectInPixels.height, this._originalSize.width = b, this._originalSize.height =
                    a);
                this._callLoadedEventCallbacks()
            }, this)
        }
    },
    getOffset: function () {
        return this._offset
    },
    setOffset: function (a) {
        this._offset.x = a.x;
        this._offset.y = a.y
    },
    clone: function () {
        var a = new cc.SpriteFrame;
        a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        a.setTexture(this._texture);
        return a
    },
    copyWithZone: function () {
        var a = new cc.SpriteFrame;
        a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        a.setTexture(this._texture);
        return a
    },
    copy: function () {
        return this.copyWithZone()
    },
    initWithTexture: function (a, b, c, d, e) {
        2 === arguments.length && (b = cc.RECT_POINTS_TO_PIXELS(b));
        d = d || cc.p(0, 0);
        e = e || b;
        c = c || !1;
        "string" == typeof a ? (this._texture = null, this._textureFilename = a) : a instanceof cc.Texture2D && this.setTexture(a);
        this._rectInPixels = b;
        this._rect = cc.RECT_PIXELS_TO_POINTS(b);
        this._offsetInPixels.x = d.x;
        this._offsetInPixels.y = d.y;
        cc._POINT_PIXELS_TO_POINTS_OUT(d, this._offset);
        this._originalSizeInPixels.width =
            e.width;
        this._originalSizeInPixels.height = e.height;
        cc._SIZE_PIXELS_TO_POINTS_OUT(e, this._originalSize);
        this._rotated = c;
        return !0
    }
});
cc.SpriteFrame.create = function (a, b, c, d, e) {
    var f = new cc.SpriteFrame;
    switch (arguments.length) {
    case 2:
        f.initWithTexture(a, b);
        break;
    case 5:
        f.initWithTexture(a, b, c, d, e);
        break;
    default:
        throw "Argument must be non-nil ";
    }
    return f
};
cc.SpriteFrame._frameWithTextureForCanvas = function (a, b, c, d, e) {
    var f = new cc.SpriteFrame;
    f._texture = a;
    f._rectInPixels = b;
    f._rect = cc.RECT_PIXELS_TO_POINTS(b);
    f._offsetInPixels.x = d.x;
    f._offsetInPixels.y = d.y;
    cc._POINT_PIXELS_TO_POINTS_OUT(f._offsetInPixels, f._offset);
    f._originalSizeInPixels.width = e.width;
    f._originalSizeInPixels.height = e.height;
    cc._SIZE_PIXELS_TO_POINTS_OUT(f._originalSizeInPixels, f._originalSize);
    f._rotated = c;
    return f
};
cc.spriteFrameCache = {
    _CCNS_REG1: /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/,
    _CCNS_REG2: /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/,
    _spriteFrames: {},
    _spriteFramesAliases: {},
    _frameConfigCache: {},
    _rectFromString: function (a) {
        return (a = this._CCNS_REG2.exec(a)) ? cc.rect(parseFloat(a[1]), parseFloat(a[2]), parseFloat(a[3]), parseFloat(a[4])) : cc.rect(0, 0, 0, 0)
    },
    _pointFromString: function (a) {
        return (a = this._CCNS_REG1.exec(a)) ?
            cc.p(parseFloat(a[1]), parseFloat(a[2])) : cc.p(0, 0)
    },
    _sizeFromString: function (a) {
        return (a = this._CCNS_REG1.exec(a)) ? cc.size(parseFloat(a[1]), parseFloat(a[2])) : cc.size(0, 0)
    },
    _getFrameConfig: function (a) {
        var b = cc.loader.getRes(a);
        if (!b) throw "Please load the resource first : " + a;
        cc.loader.release(a);
        if (b._inited) return this._frameConfigCache[a] = b;
        var c = b.frames,
            d = b.metadata || b.meta,
            b = {},
            e = {},
            f = 0;
        d && (f = d.format, f = 1 >= f.length ? parseInt(f) : f, e.image = d.textureFileName || d.textureFileName || d.image);
        for (var g in c) {
            var h =
                c[g];
            if (h) {
                d = {};
                if (0 == f) {
                    d.rect = cc.rect(h.x, h.y, h.width, h.height);
                    d.rotated = !1;
                    d.offset = cc.p(h.offsetX, h.offsetY);
                    var k = h.originalWidth,
                        h = h.originalHeight;
                    k && h || cc.log("cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist");
                    k = Math.abs(k);
                    h = Math.abs(h);
                    d.size = cc.size(k, h)
                } else if (1 == f || 2 == f) d.rect = this._rectFromString(h.frame), d.rotated = h.rotated || !1, d.offset = this._pointFromString(h.offset), d.size = this._sizeFromString(h.sourceSize);
                else if (3 == f) {
                    var k = this._sizeFromString(h.spriteSize),
                        m = this._rectFromString(h.textureRect);
                    k && (m = cc.rect(m.x, m.y, k.width, k.height));
                    d.rect = m;
                    d.rotated = h.textureRotated || !1;
                    d.offset = this._pointFromString(h.spriteOffset);
                    d.size = this._sizeFromString(h.spriteSourceSize);
                    d.aliases = h.aliases
                } else k = h.frame, m = h.sourceSize, g = h.filename || g, d.rect = cc.rect(k.x, k.y, k.w, k.h), d.rotated = h.rotated || !1, d.offset = cc.p(0, 0), d.size = cc.size(m.w, m.h);
                b[g] = d
            }
        }
        return this._frameConfigCache[a] = {
            _inited: !0,
            frames: b,
            meta: e
        }
    },
    addSpriteFrames: function (a, b) {
        if (!a) throw "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null";
        var c = this._frameConfigCache[a] || this._getFrameConfig(a),
            d = c.frames,
            c = c.meta;
        if (!b) c = cc.path.changeBasename(a, c.image || ".png"), b = cc.textureCache.addImage(c);
        else if (!(b instanceof cc.Texture2D))
            if ("string" == typeof b) b = cc.textureCache.addImage(b);
            else throw "Argument must be non-nil";
        var c = this._spriteFramesAliases,
            e = this._spriteFrames,
            f;
        for (f in d) {
            var g = d[f],
                h = e[f];
            if (!h) {
                h = cc.SpriteFrame.create(b,
                    g.rect, g.rotated, g.offset, g.size);
                if (g = g.aliases)
                    for (var k = 0, m = g.length; k < m; k++) {
                        var n = g[k];
                        c[n] && cc.log("cocos2d: WARNING: an alias with name " + n + " already exists");
                        c[n] = f
                    }
                cc._renderType === cc._RENDER_TYPE_CANVAS && h.isRotated() && h.getTexture().isLoaded() && (g = h.getTexture().getHtmlElementObj(), g = cc.cutRotateImageToCanvas(g, h.getRectInPixels()), k = new cc.Texture2D, k.initWithElement(g), k.handleLoadedTexture(), h.setTexture(k), g = h._rect, h.setRect(cc.rect(0, 0, g.width, g.height)));
                e[f] = h
            }
        }
    },
    _checkConflict: function (a) {
        a =
            a.frames;
        for (var b in a) this._spriteFrames[b] && cc.log("cocos2d: WARNING: Sprite frame: " + b + " has already been added by another source, please fix name conflit")
    },
    addSpriteFrame: function (a, b) {
        this._spriteFrames[b] = a
    },
    removeSpriteFrames: function () {
        this._spriteFrames = {};
        this._spriteFramesAliases = {}
    },
    removeSpriteFrameByName: function (a) {
        a && (this._spriteFramesAliases[a] && delete this._spriteFramesAliases[a], this._spriteFrames[a] && delete this._spriteFrames[a])
    },
    removeSpriteFramesFromFile: function (a) {
        var b =
            this._spriteFrames,
            c = this._spriteFramesAliases;
        if (a = this._frameConfigCache[a]) {
            a = a.frames;
            for (var d in a)
                if (b[d]) {
                    delete b[d];
                    for (var e in c) c[e] == d && delete c[e]
                }
        }
    },
    removeSpriteFramesFromTexture: function (a) {
        var b = this._spriteFrames,
            c = this._spriteFramesAliases,
            d;
        for (d in b) {
            var e = b[d];
            if (e && e.getTexture() == a) {
                delete b[d];
                for (var f in c) c[f] == d && delete c[f]
            }
        }
    },
    getSpriteFrame: function (a) {
        var b = this._spriteFrames[a];
        if (!b) {
            var c = this._spriteFramesAliases[a];
            c && ((b = this._spriteFrames[c.toString()]) || delete this._spriteFramesAliases[a])
        }
        b ||
            cc.log("cocos2d: cc.SpriteFrameCahce: Frame " + a + " not found");
        return b
    },
    _clear: function () {
        this._spriteFrames = {};
        this._spriteFramesAliases = {};
        this._frameConfigCache = {}
    }
};
cc.DEFAULT_SPRITE_BATCH_CAPACITY = 29;
cc.SpriteBatchNode = cc.Node.extend({
    textureAtlas: null,
    _blendFunc: null,
    _descendants: null,
    _className: "SpriteBatchNode",
    addSpriteWithoutQuad: function (a, b, c) {
        if (!a) throw "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null";
        if (!(a instanceof cc.Sprite)) return cc.log("cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children"), null;
        a.atlasIndex = b;
        var d = 0,
            e = this._descendants;
        if (e && 0 < e.length)
            for (var f = 0; f < e.length; f++) {
                var g = e[f];
                g && g.atlasIndex >= b && ++d
            }
        e.splice(d,
            0, a);
        cc.Node.prototype.addChild.call(this, a, b, c);
        this.reorderBatch(!1);
        return this
    },
    getTextureAtlas: function () {
        return this.textureAtlas
    },
    setTextureAtlas: function (a) {
        a != this.textureAtlas && (this.textureAtlas = a)
    },
    getDescendants: function () {
        return this._descendants
    },
    initWithFile: function (a, b) {
        var c = cc.textureCache.textureForKey(a);
        c || (c = cc.textureCache.addImage(a));
        return this.initWithTexture(c, b)
    },
    _setNodeDirtyForCache: function () {
        this._cacheDirty = !0
    },
    init: function (a, b) {
        var c = cc.textureCache.textureForKey(a);
        c || (c = cc.textureCache.addImage(a));
        return this.initWithTexture(c, b)
    },
    increaseAtlasCapacity: function () {
        var a = this.textureAtlas.capacity,
            b = Math.floor(4 * (a + 1) / 3);
        cc.log("cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from " + a + " to " + b + ".");
        this.textureAtlas.resizeCapacity(b) || cc.log("cocos2d: WARNING: Not enough memory to resize the atlas")
    },
    removeChildAtIndex: function (a, b) {
        this.removeChild(this._children[a], b)
    },
    rebuildIndexInOrder: function (a, b) {
        var c = a.children;
        if (c && 0 < c.length)
            for (var d =
                0; d < c.length; d++) {
                var e = c[d];
                e && 0 > e.zIndex && (b = this.rebuildIndexInOrder(e, b))
            }!a == this && (a.atlasIndex = b, b++);
        if (c && 0 < c.length)
            for (d = 0; d < c.length; d++)(e = c[d]) && 0 <= e.zIndex && (b = this.rebuildIndexInOrder(e, b));
        return b
    },
    highestAtlasIndexInChild: function (a) {
        var b = a.children;
        return b && 0 != b.length ? this.highestAtlasIndexInChild(b[b.length - 1]) : a.atlasIndex
    },
    lowestAtlasIndexInChild: function (a) {
        var b = a.children;
        return b && 0 != b.length ? this.lowestAtlasIndexInChild(b[b.length - 1]) : a.atlasIndex
    },
    atlasIndexForChild: function (a,
        b) {
        var c = a.parent,
            d = c.children,
            e = d.indexOf(a),
            f = null;
        0 < e && e < cc.UINT_MAX && (f = d[e - 1]);
        return c == this ? 0 == e ? 0 : this.highestAtlasIndexInChild(f) + 1 : 0 == e ? 0 > b ? c.atlasIndex : c.atlasIndex + 1 : 0 > f.zIndex && 0 > b || 0 <= f.zIndex && 0 <= b ? this.highestAtlasIndexInChild(f) + 1 : c.atlasIndex + 1
    },
    reorderBatch: function (a) {
        this._reorderChildDirty = a
    },
    setBlendFunc: function (a, b) {
        this._blendFunc = void 0 === b ? a : {
            src: a,
            dst: b
        }
    },
    getBlendFunc: function () {
        return this._blendFunc
    },
    reorderChild: function (a, b) {
        if (!a) throw "cc.SpriteBatchNode.addChild():child should be non-null"; - 1 === this._children.indexOf(a) ? cc.log("cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite") : b !== a.zIndex && (cc.Node.prototype.reorderChild.call(this, a, b), this.setNodeDirty())
    },
    removeChild: function (a, b) {
        null != a && (-1 === this._children.indexOf(a) ? cc.log("cc.SpriteBatchNode.addChild(): sprite batch node should contain the child") : (this.removeSpriteFromAtlas(a), cc.Node.prototype.removeChild.call(this, a, b)))
    },
    _mvpMatrix: null,
    _textureForCanvas: null,
    _useCache: !1,
    _originalTexture: null,
    ctor: null,
    _ctorForCanvas: function (a,
        b) {
        cc.Node.prototype.ctor.call(this);
        var c;
        b = b || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
        "string" == typeof a ? (c = cc.textureCache.textureForKey(a)) || (c = cc.textureCache.addImage(a)) : a instanceof cc.Texture2D && (c = a);
        c && this.initWithTexture(c, b)
    },
    _ctorForWebGL: function (a, b) {
        cc.Node.prototype.ctor.call(this);
        this._mvpMatrix = new cc.kmMat4;
        var c;
        b = b || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
        "string" == typeof a ? (c = cc.textureCache.textureForKey(a)) || (c = cc.textureCache.addImage(a)) : a instanceof cc.Texture2D && (c = a);
        c && this.initWithTexture(c,
            b)
    },
    updateQuadFromSprite: null,
    _updateQuadFromSpriteForCanvas: function (a, b) {
        if (!a) throw "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null";
        a instanceof cc.Sprite ? (a.batchNode = this, a.atlasIndex = b, a.dirty = !0, a.updateTransform()) : cc.log("cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children")
    },
    _updateQuadFromSpriteForWebGL: function (a, b) {
        if (!a) throw "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null";
        if (a instanceof cc.Sprite) {
            for (var c =
                this.textureAtlas.capacity; b >= c || c == this.textureAtlas.totalQuads;) this.increaseAtlasCapacity();
            a.batchNode = this;
            a.atlasIndex = b;
            a.dirty = !0;
            a.updateTransform()
        } else cc.log("cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children")
    },
    _swap: function (a, b) {
        var c = this._descendants,
            d = this.textureAtlas,
            e = d.quads,
            f = c[a],
            g = cc.V3F_C4B_T2F_QuadCopy(e[a]);
        c[b].atlasIndex = a;
        c[a] = c[b];
        d.updateQuad(e[b], a);
        c[b] = f;
        d.updateQuad(g, b)
    },
    insertQuadFromSprite: null,
    _insertQuadFromSpriteForCanvas: function (a,
        b) {
        if (!a) throw "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null";
        a instanceof cc.Sprite ? (a.batchNode = this, a.atlasIndex = b, a.dirty = !0, a.updateTransform(), this._children.splice(b, 0, a)) : cc.log("cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children")
    },
    _insertQuadFromSpriteForWebGL: function (a, b) {
        if (!a) throw "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null";
        if (a instanceof cc.Sprite) {
            for (var c = this.textureAtlas; b >= c.capacity ||
                c.capacity === c.totalQuads;) this.increaseAtlasCapacity();
            a.batchNode = this;
            a.atlasIndex = b;
            c.insertQuad(a.quad, b);
            a.dirty = !0;
            a.updateTransform()
        } else cc.log("cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children")
    },
    _updateAtlasIndex: function (a, b) {
        var c = 0,
            d = a.children;
        d && (c = d.length);
        var e = 0;
        if (0 === c) e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e, b), b++;
        else {
            e = !0;
            0 <= d[0].zIndex && (e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e,
                b), b++, e = !1);
            for (c = 0; c < d.length; c++) {
                var f = d[c];
                e && 0 <= f.zIndex && (e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e, b), b++, e = !1);
                b = this._updateAtlasIndex(f, b)
            }
            e && (e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e, b), b++)
        }
        return b
    },
    _updateBlendFunc: function () {
        this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    initWithTexture: null,
    _initWithTextureForCanvas: function (a, b) {
        this._children = [];
        this._descendants = [];
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        this._textureForCanvas = this._originalTexture = a;
        return !0
    },
    _initWithTextureForWebGL: function (a, b) {
        this._children = [];
        this._descendants = [];
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        b = b || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
        this.textureAtlas = new cc.TextureAtlas;
        this.textureAtlas.initWithTexture(a, b);
        this._updateBlendFunc();
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        return !0
    },
    insertChild: function (a,
        b) {
        a.batchNode = this;
        a.atlasIndex = b;
        a.dirty = !0;
        var c = this.textureAtlas;
        c.totalQuads >= c.capacity && this.increaseAtlasCapacity();
        c.insertQuad(a.quad, b);
        this._descendants.splice(b, 0, a);
        var c = b + 1,
            d = this._descendants;
        if (d && 0 < d.length)
            for (; c < d.length; c++) d[c].atlasIndex++;
        var d = a.children,
            e;
        if (d)
            for (c = 0, l = d.length || 0; c < l; c++)
                if (e = d[c]) {
                    var f = this.atlasIndexForChild(e, e.zIndex);
                    this.insertChild(e, f)
                }
    },
    appendChild: null,
    _appendChildForCanvas: function (a) {
        this._reorderChildDirty = !0;
        a.batchNode = this;
        a.dirty = !0;
        this._descendants.push(a);
        a.atlasIndex = this._descendants.length - 1;
        a = a.children;
        for (var b = 0, c = a.length || 0; b < c; b++) this.appendChild(a[b])
    },
    _appendChildForWebGL: function (a) {
        this._reorderChildDirty = !0;
        a.batchNode = this;
        a.dirty = !0;
        this._descendants.push(a);
        var b = this._descendants.length - 1;
        a.atlasIndex = b;
        var c = this.textureAtlas;
        c.totalQuads == c.capacity && this.increaseAtlasCapacity();
        c.insertQuad(a.quad, b);
        a = a.children;
        b = 0;
        for (c = a.length || 0; b < c; b++) this.appendChild(a[b])
    },
    removeSpriteFromAtlas: null,
    _removeSpriteFromAtlasForCanvas: function (a) {
        a.batchNode =
            null;
        var b = this._descendants,
            c = b.indexOf(a);
        if (-1 != c) {
            b.splice(c, 1);
            for (var d = b.length; c < d; ++c) b[c].atlasIndex--
        }
        if (a = a.children)
            for (b = 0, c = a.length || 0; b < c; b++) a[b] && this.removeSpriteFromAtlas(a[b])
    },
    _removeSpriteFromAtlasForWebGL: function (a) {
        this.textureAtlas.removeQuadAtIndex(a.atlasIndex);
        a.batchNode = null;
        var b = this._descendants,
            c = b.indexOf(a);
        if (-1 != c) {
            b.splice(c, 1);
            for (var d = b.length; c < d; ++c) b[c].atlasIndex--
        }
        if (a = a.children)
            for (b = 0, c = a.length || 0; b < c; b++) a[b] && this.removeSpriteFromAtlas(a[b])
    },
    getTexture: null,
    _getTextureForCanvas: function () {
        return this._textureForCanvas
    },
    _getTextureForWebGL: function () {
        return this.textureAtlas.texture
    },
    setTexture: null,
    _setTextureForCanvas: function (a) {
        this._textureForCanvas = a;
        for (var b = this._children, c = 0; c < b.length; c++) b[c].texture = a
    },
    _setTextureForWebGL: function (a) {
        this.textureAtlas.texture = a;
        this._updateBlendFunc()
    },
    visit: null,
    _visitForCanvas: function (a) {
        var b = a || cc._renderContext;
        if (this._visible) {
            b.save();
            this.transform(a);
            var c = this._children;
            if (c)
                for (this.sortAllChildren(),
                    a = 0; a < c.length; a++) c[a] && c[a].visit(b);
            b.restore()
        }
    },
    _visitForWebGL: function (a) {
        a = a || cc._renderContext;
        if (this._visible) {
            cc.kmGLPushMatrix();
            var b = this.grid;
            b && b.isActive() && (b.beforeDraw(), this.transformAncestors());
            this.sortAllChildren();
            this.transform(a);
            this.draw(a);
            b && b.isActive() && b.afterDraw(this);
            cc.kmGLPopMatrix();
            this.arrivalOrder = 0
        }
    },
    addChild: null,
    _addChildForCanvas: function (a, b, c) {
        if (null == a) throw "cc.SpriteBatchNode.addChild(): child should be non-null";
        a instanceof cc.Sprite ? (b = null ==
            b ? a.zIndex : b, c = null == c ? a.tag : c, cc.Node.prototype.addChild.call(this, a, b, c), this.appendChild(a), this.setNodeDirty()) : cc.log("cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children")
    },
    _addChildForWebGL: function (a, b, c) {
        if (null == a) throw "cc.SpriteBatchNode.addChild(): child should be non-null";
        a instanceof cc.Sprite ? a.texture != this.textureAtlas.texture ? cc.log("cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture") : (b = null == b ? a.zIndex : b, c = null == c ? a.tag :
            c, cc.Node.prototype.addChild.call(this, a, b, c), this.appendChild(a), this.setNodeDirty()) : cc.log("cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children")
    },
    removeAllChildren: null,
    _removeAllChildrenForCanvas: function (a) {
        var b = this._descendants;
        if (b && 0 < b.length)
            for (var c = 0, d = b.length; c < d; c++) b[c] && (b[c].batchNode = null);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this._descendants.length = 0
    },
    _removeAllChildrenForWebGL: function (a) {
        var b = this._descendants;
        if (b && 0 < b.length)
            for (var c =
                0, d = b.length; c < d; c++) b[c] && (b[c].batchNode = null);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this._descendants.length = 0;
        this.textureAtlas.removeAllQuads()
    },
    sortAllChildren: null,
    _sortAllChildrenForCanvas: function () {
        if (this._reorderChildDirty) {
            var a, b = 0,
                c = this._children,
                d = c.length,
                e;
            for (a = 1; a < d; a++) {
                var f = c[a],
                    b = a - 1;
                for (e = c[b]; 0 <= b && (f._localZOrder < e._localZOrder || f._localZOrder == e._localZOrder && f.arrivalOrder < e.arrivalOrder);) c[b + 1] = e, b -= 1, e = c[b];
                c[b + 1] = f
            }
            0 < c.length && this._arrayMakeObjectsPerformSelector(c,
                cc.Node.StateCallbackType.sortAllChildren);
            this._reorderChildDirty = !1
        }
    },
    _sortAllChildrenForWebGL: function () {
        if (this._reorderChildDirty) {
            var a = this._children,
                b, c = 0,
                d = a.length,
                e;
            for (b = 1; b < d; b++) {
                var f = a[b],
                    c = b - 1;
                for (e = a[c]; 0 <= c && (f._localZOrder < e._localZOrder || f._localZOrder == e._localZOrder && f.arrivalOrder < e.arrivalOrder);) a[c + 1] = e, c -= 1, e = a[c];
                a[c + 1] = f
            }
            if (0 < a.length)
                for (this._arrayMakeObjectsPerformSelector(a, cc.Node.StateCallbackType.sortAllChildren), b = c = 0; b < a.length; b++) c = this._updateAtlasIndex(a[b],
                    c);
            this._reorderChildDirty = !1
        }
    },
    draw: null,
    _drawForWebGL: function () {
        0 !== this.textureAtlas.totalQuads && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), this.textureAtlas.drawQuads())
    }
});
window._p = cc.SpriteBatchNode.prototype;
cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.ctor = _p._ctorForWebGL, _p.updateQuadFromSprite = _p._updateQuadFromSpriteForWebGL, _p.insertQuadFromSprite = _p._insertQuadFromSpriteForWebGL, _p.initWithTexture = _p._initWithTextureForWebGL, _p.appendChild = _p._appendChildForWebGL, _p.removeSpriteFromAtlas = _p._removeSpriteFromAtlasForWebGL, _p.getTexture = _p._getTextureForWebGL, _p.setTexture = _p._setTextureForWebGL, _p.visit = _p._visitForWebGL, _p.addChild = _p._addChildForWebGL, _p.removeAllChildren = _p._removeAllChildrenForWebGL,
    _p.sortAllChildren = _p._sortAllChildrenForWebGL, _p.draw = _p._drawForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.updateQuadFromSprite = _p._updateQuadFromSpriteForCanvas, _p.insertQuadFromSprite = _p._insertQuadFromSpriteForCanvas, _p.initWithTexture = _p._initWithTextureForCanvas, _p.appendChild = _p._appendChildForCanvas, _p.removeSpriteFromAtlas = _p._removeSpriteFromAtlasForCanvas, _p.getTexture = _p._getTextureForCanvas, _p.setTexture = _p._setTextureForCanvas, _p.visit = _p._visitForCanvas, _p.removeAllChildren = _p._removeAllChildrenForCanvas,
    _p.addChild = _p._addChildForCanvas, _p.sortAllChildren = _p._sortAllChildrenForCanvas, _p.draw = cc.Node.prototype.draw);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "descendants", _p.getDescendants);
delete window._p;
cc.SpriteBatchNode.create = function (a, b) {
    return new cc.SpriteBatchNode(a, b)
};
cc.configuration = {
    ERROR: 0,
    STRING: 1,
    INT: 2,
    DOUBLE: 3,
    BOOLEAN: 4,
    _maxTextureSize: 0,
    _maxModelviewStackDepth: 0,
    _supportsPVRTC: !1,
    _supportsNPOT: !1,
    _supportsBGRA8888: !1,
    _supportsDiscardFramebuffer: !1,
    _supportsShareableVAO: !1,
    _maxSamplesAllowed: 0,
    _maxTextureUnits: 0,
    _GlExtensions: "",
    _valueDict: {},
    _inited: !1,
    _init: function () {
        var a = this._valueDict;
        a["cocos2d.x.version"] = cc.ENGINE_VERSION;
        a["cocos2d.x.compiled_with_profiler"] = !1;
        a["cocos2d.x.compiled_with_gl_state_cache"] = cc.ENABLE_GL_STATE_CACHE;
        this._inited = !0
    },
    getMaxTextureSize: function () {
        return this._maxTextureSize
    },
    getMaxModelviewStackDepth: function () {
        return this._maxModelviewStackDepth
    },
    getMaxTextureUnits: function () {
        return this._maxTextureUnits
    },
    supportsNPOT: function () {
        return this._supportsNPOT
    },
    supportsPVRTC: function () {
        return this._supportsPVRTC
    },
    supportsETC: function () {
        return !1
    },
    supportsS3TC: function () {
        return !1
    },
    supportsATITC: function () {
        return !1
    },
    supportsBGRA8888: function () {
        return this._supportsBGRA8888
    },
    supportsDiscardFramebuffer: function () {
        return this._supportsDiscardFramebuffer
    },
    supportsShareableVAO: function () {
        return this._supportsShareableVAO
    },
    checkForGLExtension: function (a) {
        return -1 < this._GlExtensions.indexOf(a)
    },
    getValue: function (a, b) {
        this._inited || this._init();
        var c = this._valueDict;
        return c[a] ? c[a] : b
    },
    setValue: function (a, b) {
        this._valueDict[a] = b
    },
    dumpInfo: function () {
        0 === cc.ENABLE_GL_STATE_CACHE && (cc.log(""), cc.log("cocos2d: **** WARNING **** CC_ENABLE_PROFILERS is defined. Disable it when you finish profiling (from ccConfig.js)"), cc.log(""))
    },
    gatherGPUInfo: function () {
        if (cc._renderType !==
            cc._RENDER_TYPE_CANVAS) {
            this._inited || this._init();
            var a = cc._renderContext,
                b = this._valueDict;
            b["gl.vendor"] = a.getParameter(a.VENDOR);
            b["gl.renderer"] = a.getParameter(a.RENDERER);
            b["gl.version"] = a.getParameter(a.VERSION);
            this._GlExtensions = "";
            for (var c = a.getSupportedExtensions(), d = 0; d < c.length; d++) this._GlExtensions += c[d] + " ";
            this._maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE);
            b["gl.max_texture_size"] = this._maxTextureSize;
            this._maxTextureUnits = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            b["gl.max_texture_units"] = this._maxTextureUnits;
            this._supportsPVRTC = this.checkForGLExtension("GL_IMG_texture_compression_pvrtc");
            b["gl.supports_PVRTC"] = this._supportsPVRTC;
            this._supportsNPOT = !1;
            b["gl.supports_NPOT"] = this._supportsNPOT;
            this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888");
            b["gl.supports_BGRA8888"] = this._supportsBGRA8888;
            this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer");
            b["gl.supports_discard_framebuffer"] = this._supportsDiscardFramebuffer;
            this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object");
            b["gl.supports_vertex_array_object"] = this._supportsShareableVAO;
            cc.CHECK_GL_ERROR_DEBUG()
        }
    },
    loadConfigFile: function (a) {
        this._inited || this._init();
        var b = cc.loader.getRes(a);
        if (!b) throw "Please load the resource first : " + a;
        if (b = b.data)
            for (var c in b) this._valueDict[c] = b[c];
        else cc.log("Expected 'data' dict, but not found. Config file: " + a)
    }
};
cc.DIRECTOR_PROJECTION_2D = 0;
cc.g_NumberOfDraws = 0;
cc.DIRECTOR_PROJECTION_3D = 1;
cc.DIRECTOR_PROJECTION_CUSTOM = 3;
cc.DIRECTOR_PROJECTION_DEFAULT = cc.DIRECTOR_PROJECTION_3D;
cc.DEVICE_ORIENTATION_PORTRAIT = 0;
cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1;
cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2;
cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3;
cc.DEVICE_MAX_ORIENTATIONS = 2;
cc.DirectorDelegate = cc.Class.extend({
    updateProjection: function () {}
});
cc.GLToClipTransform = function (a) {
    var b = new cc.kmMat4;
    cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, b);
    var c = new cc.kmMat4;
    cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, c);
    cc.kmMat4Multiply(a, b, c)
};
cc.Director = cc.Class.extend({
    _landscape: !1,
    _nextDeltaTimeZero: !1,
    _paused: !1,
    _purgeDirectorInNextLoop: !1,
    _sendCleanupToScene: !1,
    _animationInterval: 0,
    _oldAnimationInterval: 0,
    _projection: 0,
    _accumDt: 0,
    _contentScaleFactor: 1,
    _displayStats: !1,
    _deltaTime: 0,
    _frameRate: 0,
    _FPSLabel: null,
    _SPFLabel: null,
    _drawsLabel: null,
    _winSizeInPoints: null,
    _lastUpdate: null,
    _nextScene: null,
    _notificationNode: null,
    _openGLView: null,
    _scenesStack: null,
    _projectionDelegate: null,
    _runningScene: null,
    _frames: 0,
    _totalFrames: 0,
    _secondsPerFrame: 0,
    _dirtyRegion: null,
    _scheduler: null,
    _actionManager: null,
    _eventProjectionChanged: null,
    _eventAfterDraw: null,
    _eventAfterVisit: null,
    _eventAfterUpdate: null,
    ctor: function () {
        var a = this;
        a._lastUpdate = Date.now();
        cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function () {
            a._lastUpdate = Date.now()
        })
    },
    init: function () {
        this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS;
        this._scenesStack = [];
        this._projection = cc.DIRECTOR_PROJECTION_DEFAULT;
        this._projectionDelegate = null;
        this._frameRate = this._accumDt =
            0;
        this._displayStats = !1;
        this._totalFrames = this._frames = 0;
        this._lastUpdate = Date.now();
        this._purgeDirectorInNextLoop = this._paused = !1;
        this._winSizeInPoints = cc.size(0, 0);
        this._openGLView = null;
        this._contentScaleFactor = 1;
        this._scheduler = new cc.Scheduler;
        this._actionManager = new cc.ActionManager;
        this._scheduler.scheduleUpdateForTarget(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, !1);
        this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW);
        this._eventAfterDraw.setUserData(this);
        this._eventAfterVisit =
            new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT);
        this._eventAfterVisit.setUserData(this);
        this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE);
        this._eventAfterUpdate.setUserData(this);
        this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED);
        this._eventProjectionChanged.setUserData(this);
        return !0
    },
    calculateDeltaTime: function () {
        var a = Date.now();
        this._nextDeltaTimeZero ? (this._deltaTime = 0, this._nextDeltaTimeZero = !1) : this._deltaTime = (a - this._lastUpdate) /
            1E3;
        0 < cc.game.config[cc.game.CONFIG_KEY.debugMode] && 0.2 < this._deltaTime && (this._deltaTime = 1 / 60);
        this._lastUpdate = a
    },
    convertToGL: function (a) {
        var b = new cc.kmMat4;
        cc.GLToClipTransform(b);
        var c = new cc.kmMat4;
        cc.kmMat4Inverse(c, b);
        var b = b.mat[14] / b.mat[15],
            d = this._openGLView.getDesignResolutionSize();
        a = new cc.kmVec3(2 * a.x / d.width - 1, 1 - 2 * a.y / d.height, b);
        b = new cc.kmVec3;
        cc.kmVec3TransformCoord(b, a, c);
        return cc.p(b.x, b.y)
    },
    convertToUI: function (a) {
        var b = new cc.kmMat4;
        cc.GLToClipTransform(b);
        var c = new cc.kmVec3;
        a = new cc.kmVec3(a.x, a.y, 0);
        cc.kmVec3TransformCoord(c, a, b);
        b = this._openGLView.getDesignResolutionSize();
        return cc.p(b.width * (0.5 * c.x + 0.5), b.height * (0.5 * -c.y + 0.5))
    },
    drawScene: function () {
        this.calculateDeltaTime();
        this._paused || (this._scheduler.update(this._deltaTime), cc.eventManager.dispatchEvent(this._eventAfterUpdate));
        this._clear();
        this._nextScene && this.setNextScene();
        this._beforeVisitScene && this._beforeVisitScene();
        this._runningScene && (this._runningScene.visit(), cc.eventManager.dispatchEvent(this._eventAfterVisit));
        this._notificationNode && this._notificationNode.visit();
        this._displayStats && this._showStats();
        this._afterVisitScene && this._afterVisitScene();
        cc.eventManager.dispatchEvent(this._eventAfterDraw);
        this._totalFrames++;
        this._displayStats && this._calculateMPF()
    },
    _clearCanvas: function () {
        var a = this._openGLView.getViewPortRect();
        cc._renderContext.clearRect(-a.x, a.y, a.width, -a.height)
    },
    _clearWebGL: function () {
        var a = cc._renderContext;
        a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
    },
    _beforeVisitScene: null,
    _afterVisitScene: null,
    _beforeVisitSceneWebGL: function () {
        cc.kmGLPushMatrix()
    },
    _afterVisitSceneWebGL: function () {
        cc.kmGLPopMatrix()
    },
    end: function () {
        this._purgeDirectorInNextLoop = !0
    },
    getContentScaleFactor: function () {
        return this._contentScaleFactor
    },
    getNotificationNode: function () {
        return this._notificationNode
    },
    getWinSize: function () {
        return this._winSizeInPoints
    },
    getWinSizeInPixels: function () {
        return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor)
    },
    getVisibleSize: function () {
        return this._openGLView ?
            this._openGLView.getVisibleSize() : this.getWinSize()
    },
    getVisibleOrigin: function () {
        return this._openGLView ? this._openGLView.getVisibleOrigin() : cc.p(0, 0)
    },
    getZEye: function () {
        return this._winSizeInPoints.height / 1.1566
    },
    pause: function () {
        this._paused || (this._oldAnimationInterval = this._animationInterval, this.setAnimationInterval(0.25), this._paused = !0)
    },
    popScene: function () {
        if (!this._runningScene) throw "running scene should not null";
        this._scenesStack.pop();
        var a = this._scenesStack.length;
        0 == a ? this.end() : (this._sendCleanupToScene = !0, this._nextScene = this._scenesStack[a - 1])
    },
    purgeCachedData: function () {
        cc.animationCache._clear();
        cc.spriteFrameCache._clear();
        cc.textureCache._clear()
    },
    purgeDirector: function () {
        this.getScheduler().unscheduleAllCallbacks();
        this._runningScene && (this._runningScene.onExitTransitionDidStart(), this._runningScene.onExit(), this._runningScene.cleanup());
        this._nextScene = this._runningScene = null;
        this._scenesStack.length = 0;
        this.stopAnimation();
        this.purgeCachedData();
        cc.CHECK_GL_ERROR_DEBUG()
    },
    pushScene: function (a) {
        if (!a) throw "the scene should not null";
        this._sendCleanupToScene = !1;
        this._scenesStack.push(a);
        this._nextScene = a
    },
    runScene: function (a) {
        if (!a) throw "the scene should not be null";
        if (this._runningScene) {
            var b = this._scenesStack.length;
            0 === b ? (this._sendCleanupToScene = !0, this._scenesStack[b] = a) : (this._sendCleanupToScene = !0, this._scenesStack[b - 1] = a);
            this._nextScene = a
        } else this.pushScene(a), this.startAnimation()
    },
    resume: function () {
        this._paused && (this.setAnimationInterval(this._oldAnimationInterval), (this._lastUpdate = Date.now()) || cc.log("cocos2d: Director: Error in gettimeofday"),
            this._paused = !1, this._deltaTime = 0)
    },
    setAlphaBlending: function (a) {
        a ? cc.glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST) : cc.glBlendFunc(cc._renderContext.ONE, cc._renderContext.ZERO)
    },
    setContentScaleFactor: function (a) {
        a != this._contentScaleFactor && (this._contentScaleFactor = a, this._createStatsLabel())
    },
    setDepthTest: function (a) {
        if (cc._renderType !== cc._RENDER_TYPE_CANVAS) {
            var b = cc._renderContext;
            a ? (b.clearDepth(1), b.enable(b.DEPTH_TEST), b.depthFunc(b.LEQUAL)) : b.disable(b.DEPTH_TEST)
        }
    },
    setDefaultValues: function () {},
    setGLDefaultValues: function () {
        this.setAlphaBlending(!0);
        this.setDepthTest(!1);
        this.setProjection(this._projection);
        cc._renderContext.clearColor(0, 0, 0, 1)
    },
    setNextDeltaTimeZero: function (a) {
        this._nextDeltaTimeZero = a
    },
    setNextScene: function () {
        var a = !1,
            b = !1;
        cc.TransitionScene && (a = this._runningScene ? this._runningScene instanceof cc.TransitionScene : !1, b = this._nextScene ? this._nextScene instanceof cc.TransitionScene : !1);
        if (!b) {
            if (b = this._runningScene) b.onExitTransitionDidStart(), b.onExit();
            this._sendCleanupToScene &&
                b && b.cleanup()
        }
        this._runningScene = this._nextScene;
        this._nextScene = null;
        a || null == this._runningScene || (this._runningScene.onEnter(), this._runningScene.onEnterTransitionDidFinish())
    },
    setNotificationNode: function (a) {
        this._notificationNode = a
    },
    getDelegate: function () {
        return this._projectionDelegate
    },
    setDelegate: function (a) {
        this._projectionDelegate = a
    },
    setOpenGLView: function (a) {
        this._winSizeInPoints.width = cc._canvas.width;
        this._winSizeInPoints.height = cc._canvas.height;
        this._openGLView = a || cc.view;
        cc._renderType !==
            cc._RENDER_TYPE_CANVAS && (a = cc.configuration, a.gatherGPUInfo(), a.dumpInfo(), this._createStatsLabel(), this.setGLDefaultValues())
    },
    setViewport: function () {
        if (this._openGLView) {
            var a = this._winSizeInPoints;
            this._openGLView.setViewPortInPoints(0, 0, a.width, a.height)
        }
    },
    setProjection: function (a) {
        var b = this._winSizeInPoints;
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) this._projection = a, cc.eventManager.dispatchEvent(this._eventProjectionChanged);
        else {
            this.setViewport();
            switch (a) {
            case cc.DIRECTOR_PROJECTION_2D:
                cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                cc.kmGLLoadIdentity();
                var c = new cc.kmMat4;
                cc.kmMat4OrthographicProjection(c, 0, b.width, 0, b.height, -1024, 1024);
                cc.kmGLMultMatrix(c);
                cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                cc.kmGLLoadIdentity();
                break;
            case cc.DIRECTOR_PROJECTION_3D:
                var d = this.getZEye(),
                    e = new cc.kmMat4,
                    c = new cc.kmMat4;
                cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                cc.kmGLLoadIdentity();
                cc.kmMat4PerspectiveProjection(e, 60, b.width / b.height, 0.1, 2 * d);
                cc.kmGLMultMatrix(e);
                cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                cc.kmGLLoadIdentity();
                d = cc.kmVec3Fill(null,
                    b.width / 2, b.height / 2, d);
                b = cc.kmVec3Fill(null, b.width / 2, b.height / 2, 0);
                e = cc.kmVec3Fill(null, 0, 1, 0);
                cc.kmMat4LookAt(c, d, b, e);
                cc.kmGLMultMatrix(c);
                break;
            case cc.DIRECTOR_PROJECTION_CUSTOM:
                this._projectionDelegate && this._projectionDelegate.updateProjection();
                break;
            default:
                cc.log("cocos2d: Director: unrecognized projection")
            }
            this._projection = a;
            cc.eventManager.dispatchEvent(this._eventProjectionChanged);
            cc.setProjectionMatrixDirty()
        }
    },
    _showStats: function () {
        this._frames++;
        this._accumDt += this._deltaTime;
        this._FPSLabel &&
            this._SPFLabel && this._drawsLabel ? (this._accumDt > cc.DIRECTOR_FPS_INTERVAL && (this._SPFLabel.string = this._secondsPerFrame.toFixed(3), this._frameRate = this._frames / this._accumDt, this._accumDt = this._frames = 0, this._FPSLabel.string = this._frameRate.toFixed(1), this._drawsLabel.string = (0 | cc.g_NumberOfDraws).toString()), this._FPSLabel.visit(), this._SPFLabel.visit(), this._drawsLabel.visit()) : this._createStatsLabel();
        cc.g_NumberOfDraws = 0
    },
    isSendCleanupToScene: function () {
        return this._sendCleanupToScene
    },
    getRunningScene: function () {
        return this._runningScene
    },
    getAnimationInterval: function () {
        return this._animationInterval
    },
    isDisplayStats: function () {
        return this._displayStats
    },
    setDisplayStats: function (a) {
        this._displayStats = a
    },
    getSecondsPerFrame: function () {
        return this._secondsPerFrame
    },
    getOpenGLView: function () {
        return this._openGLView
    },
    isNextDeltaTimeZero: function () {
        return this._nextDeltaTimeZero
    },
    isPaused: function () {
        return this._paused
    },
    getTotalFrames: function () {
        return this._totalFrames
    },
    getProjection: function () {
        return this._projection
    },
    popToRootScene: function () {
        this.popToSceneStackLevel(1)
    },
    popToSceneStackLevel: function (a) {
        if (!this._runningScene) throw "A running Scene is needed";
        var b = this._scenesStack,
            c = b.length;
        if (0 == c) this.end();
        else if (!(a > c)) {
            for (; c > a;) {
                var d = b.pop();
                d.running && (d.onExitTransitionDidStart(), d.onExit());
                d.cleanup();
                c--
            }
            this._nextScene = b[b.length - 1];
            this._sendCleanupToScene = !1
        }
    },
    getScheduler: function () {
        return this._scheduler
    },
    setScheduler: function (a) {
        this._scheduler != a && (this._scheduler = a)
    },
    getActionManager: function () {
        return this._actionManager
    },
    setActionManager: function (a) {
        this._actionManager !=
            a && (this._actionManager = a)
    },
    getDeltaTime: function () {
        return this._deltaTime
    },
    _createStatsLabel: null,
    _createStatsLabelForWebGL: function () {
        if (!cc.LabelAtlas) return this._createStatsLabelForCanvas();
        if (null != cc.Director._fpsImageLoaded && !1 != cc.Director._fpsImageLoaded) {
            var a = new cc.Texture2D;
            a.initWithElement(cc.Director._fpsImage);
            a.handleLoadedTexture();
            var b = cc.view.getDesignResolutionSize().height / 320;
            0 === b && (b = this._winSizeInPoints.height / 320);
            var c = new cc.LabelAtlas;
            c._setIgnoreContentScaleFactor(!0);
            c.initWithString("00.0", a, 12, 32, ".");
            c.scale = b;
            this._FPSLabel = c;
            c = new cc.LabelAtlas;
            c._setIgnoreContentScaleFactor(!0);
            c.initWithString("0.000", a, 12, 32, ".");
            c.scale = b;
            this._SPFLabel = c;
            c = new cc.LabelAtlas;
            c._setIgnoreContentScaleFactor(!0);
            c.initWithString("000", a, 12, 32, ".");
            c.scale = b;
            this._drawsLabel = c;
            a = cc.DIRECTOR_STATS_POSITION;
            this._drawsLabel.setPosition(a.x, 34 * b + a.y);
            this._SPFLabel.setPosition(a.x, 17 * b + a.y);
            this._FPSLabel.setPosition(a)
        }
    },
    _createStatsLabelForCanvas: function () {
        var a = 0,
            a = this._winSizeInPoints.width >
            this._winSizeInPoints.height ? 0 | this._winSizeInPoints.height / 320 * 24 : 0 | this._winSizeInPoints.width / 320 * 24;
        this._FPSLabel = cc.LabelTTF.create("000.0", "Arial", a);
        this._SPFLabel = cc.LabelTTF.create("0.000", "Arial", a);
        this._drawsLabel = cc.LabelTTF.create("0000", "Arial", a);
        a = cc.DIRECTOR_STATS_POSITION;
        this._drawsLabel.setPosition(this._drawsLabel.width / 2 + a.x, 5 * this._drawsLabel.height / 2 + a.y);
        this._SPFLabel.setPosition(this._SPFLabel.width / 2 + a.x, 3 * this._SPFLabel.height / 2 + a.y);
        this._FPSLabel.setPosition(this._FPSLabel.width /
            2 + a.x, this._FPSLabel.height / 2 + a.y)
    },
    _calculateMPF: function () {
        this._secondsPerFrame = (Date.now() - this._lastUpdate) / 1E3
    }
});
cc._renderType === cc._RENDER_TYPE_WEBGL ? (cc.Director.prototype._clear = cc.Director.prototype._clearWebGL, cc.Director.prototype._beforeVisitScene = cc.Director.prototype._beforeVisitSceneWebGL, cc.Director.prototype._afterVisitScene = cc.Director.prototype._afterVisitSceneWebGL, cc.Director.prototype._createStatsLabel = cc.Director.prototype._createStatsLabelForWebGL) : (cc.Director.prototype._clear = cc.Director.prototype._clearCanvas, cc.Director.prototype._createStatsLabel = cc.Director.prototype._createStatsLabelForCanvas);
cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
cc.Director.EVENT_AFTER_VISIT = "director_after_visit";
cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
cc.DisplayLinkDirector = cc.Director.extend({
    invalid: !1,
    startAnimation: function () {
        this._nextDeltaTimeZero = !0;
        this.invalid = !1
    },
    mainLoop: function () {
        this._purgeDirectorInNextLoop ? (this._purgeDirectorInNextLoop = !1, this.purgeDirector()) : this.invalid || this.drawScene()
    },
    stopAnimation: function () {
        this.invalid = !0
    },
    setAnimationInterval: function (a) {
        this._animationInterval = a;
        this.invalid || (this.stopAnimation(), this.startAnimation())
    }
});
cc.Director.sharedDirector = null;
cc.Director.firstUseDirector = !0;
cc.Director._getInstance = function () {
    cc.Director.firstUseDirector && (cc.Director.firstUseDirector = !1, cc.Director.sharedDirector = new cc.DisplayLinkDirector, cc.Director.sharedDirector.init());
    return cc.Director.sharedDirector
};
cc.defaultFPS = 60;
cc.Director._fpsImage = new Image;
cc.Director._fpsImage.addEventListener("load", function () {
    cc.Director._fpsImageLoaded = !0
});
cc.Director._fpsImage.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAgCAYAAAD9qabkAAAKQ2lDQ1BJQ0MgcHJvZmlsZQAAeNqdU3dYk/cWPt/3ZQ9WQtjwsZdsgQAiI6wIyBBZohCSAGGEEBJAxYWIClYUFRGcSFXEgtUKSJ2I4qAouGdBiohai1VcOO4f3Ke1fXrv7e371/u855zn/M55zw+AERImkeaiagA5UoU8Otgfj09IxMm9gAIVSOAEIBDmy8JnBcUAAPADeXh+dLA//AGvbwACAHDVLiQSx+H/g7pQJlcAIJEA4CIS5wsBkFIAyC5UyBQAyBgAsFOzZAoAlAAAbHl8QiIAqg0A7PRJPgUA2KmT3BcA2KIcqQgAjQEAmShHJAJAuwBgVYFSLALAwgCgrEAiLgTArgGAWbYyRwKAvQUAdo5YkA9AYACAmUIszAAgOAIAQx4TzQMgTAOgMNK/4KlfcIW4SAEAwMuVzZdL0jMUuJXQGnfy8ODiIeLCbLFCYRcpEGYJ5CKcl5sjE0jnA0zODAAAGvnRwf44P5Dn5uTh5mbnbO/0xaL+a/BvIj4h8d/+vIwCBAAQTs/v2l/l5dYDcMcBsHW/a6lbANpWAGjf+V0z2wmgWgrQevmLeTj8QB6eoVDIPB0cCgsL7SViob0w44s+/zPhb+CLfvb8QB7+23rwAHGaQJmtwKOD/XFhbnauUo7nywRCMW735yP+x4V//Y4p0eI0sVwsFYrxWIm4UCJNx3m5UpFEIcmV4hLpfzLxH5b9CZN3DQCshk/ATrYHtctswH7uAQKLDljSdgBAfvMtjBoLkQAQZzQyefcAAJO/+Y9AKwEAzZek4wAAvOgYXKiUF0zGCAAARKCBKrBBBwzBFKzADpzBHbzAFwJhBkRADCTAPBBCBuSAHAqhGJZBGVTAOtgEtbADGqARmuEQtMExOA3n4BJcgetwFwZgGJ7CGLyGCQRByAgTYSE6iBFijtgizggXmY4EImFINJKApCDpiBRRIsXIcqQCqUJqkV1II/ItchQ5jVxA+pDbyCAyivyKvEcxlIGyUQPUAnVAuagfGorGoHPRdDQPXYCWomvRGrQePYC2oqfRS+h1dAB9io5jgNExDmaM2WFcjIdFYIlYGibHFmPlWDVWjzVjHVg3dhUbwJ5h7wgkAouAE+wIXoQQwmyCkJBHWExYQ6gl7CO0EroIVwmDhDHCJyKTqE+0JXoS+cR4YjqxkFhGrCbuIR4hniVeJw4TX5NIJA7JkuROCiElkDJJC0lrSNtILaRTpD7SEGmcTCbrkG3J3uQIsoCsIJeRt5APkE+S+8nD5LcUOsWI4kwJoiRSpJQSSjVlP+UEpZ8yQpmgqlHNqZ7UCKqIOp9aSW2gdlAvU4epEzR1miXNmxZDy6Qto9XQmmlnafdoL+l0ugndgx5Fl9CX0mvoB+nn6YP0dwwNhg2Dx0hiKBlrGXsZpxi3GS+ZTKYF05eZyFQw1zIbmWeYD5hvVVgq9ip8FZHKEpU6lVaVfpXnqlRVc1U/1XmqC1SrVQ+rXlZ9pkZVs1DjqQnUFqvVqR1Vu6k2rs5Sd1KPUM9RX6O+X/2C+mMNsoaFRqCGSKNUY7fGGY0hFsYyZfFYQtZyVgPrLGuYTWJbsvnsTHYF+xt2L3tMU0NzqmasZpFmneZxzQEOxrHg8DnZnErOIc4NznstAy0/LbHWaq1mrX6tN9p62r7aYu1y7Rbt69rvdXCdQJ0snfU6bTr3dQm6NrpRuoW623XP6j7TY+t56Qn1yvUO6d3RR/Vt9KP1F+rv1u/RHzcwNAg2kBlsMThj8MyQY+hrmGm40fCE4agRy2i6kcRoo9FJoye4Ju6HZ+M1eBc+ZqxvHGKsNN5l3Gs8YWJpMtukxKTF5L4pzZRrmma60bTTdMzMyCzcrNisyeyOOdWca55hvtm82/yNhaVFnMVKizaLx5balnzLBZZNlvesmFY+VnlW9VbXrEnWXOss623WV2xQG1ebDJs6m8u2qK2brcR2m23fFOIUjynSKfVTbtox7PzsCuya7AbtOfZh9iX2bfbPHcwcEh3WO3Q7fHJ0dcx2bHC866ThNMOpxKnD6VdnG2ehc53zNRemS5DLEpd2lxdTbaeKp26fesuV5RruutK10/Wjm7ub3K3ZbdTdzD3Ffav7TS6bG8ldwz3vQfTw91jicczjnaebp8LzkOcvXnZeWV77vR5Ps5wmntYwbcjbxFvgvct7YDo+PWX6zukDPsY+Ap96n4e+pr4i3z2+I37Wfpl+B/ye+zv6y/2P+L/hefIW8U4FYAHBAeUBvYEagbMDawMfBJkEpQc1BY0FuwYvDD4VQgwJDVkfcpNvwBfyG/ljM9xnLJrRFcoInRVaG/owzCZMHtYRjobPCN8Qfm+m+UzpzLYIiOBHbIi4H2kZmRf5fRQpKjKqLupRtFN0cXT3LNas5Fn7Z72O8Y+pjLk722q2cnZnrGpsUmxj7Ju4gLiquIF4h/hF8ZcSdBMkCe2J5MTYxD2J43MC52yaM5zkmlSWdGOu5dyiuRfm6c7Lnnc8WTVZkHw4hZgSl7I/5YMgQlAvGE/lp25NHRPyhJuFT0W+oo2iUbG3uEo8kuadVpX2ON07fUP6aIZPRnXGMwlPUit5kRmSuSPzTVZE1t6sz9lx2S05lJyUnKNSDWmWtCvXMLcot09mKyuTDeR55m3KG5OHyvfkI/lz89sVbIVM0aO0Uq5QDhZML6greFsYW3i4SL1IWtQz32b+6vkjC4IWfL2QsFC4sLPYuHhZ8eAiv0W7FiOLUxd3LjFdUrpkeGnw0n3LaMuylv1Q4lhSVfJqedzyjlKD0qWlQyuCVzSVqZTJy26u9Fq5YxVhlWRV72qX1VtWfyoXlV+scKyorviwRrjm4ldOX9V89Xlt2treSrfK7etI66Trbqz3Wb+vSr1qQdXQhvANrRvxjeUbX21K3nShemr1js20zcrNAzVhNe1bzLas2/KhNqP2ep1/XctW/a2rt77ZJtrWv913e/MOgx0VO97vlOy8tSt4V2u9RX31btLugt2PGmIbur/mft24R3dPxZ6Pe6V7B/ZF7+tqdG9s3K+/v7IJbVI2jR5IOnDlm4Bv2pvtmne1cFoqDsJB5cEn36Z8e+NQ6KHOw9zDzd+Zf7f1COtIeSvSOr91rC2jbaA9ob3v6IyjnR1eHUe+t/9+7zHjY3XHNY9XnqCdKD3x+eSCk+OnZKeenU4/PdSZ3Hn3TPyZa11RXb1nQ8+ePxd07ky3X/fJ897nj13wvHD0Ivdi2yW3S609rj1HfnD94UivW2/rZffL7Vc8rnT0Tes70e/Tf/pqwNVz1/jXLl2feb3vxuwbt24m3Ry4Jbr1+Hb27Rd3Cu5M3F16j3iv/L7a/eoH+g/qf7T+sWXAbeD4YMBgz8NZD+8OCYee/pT/04fh0kfMR9UjRiONj50fHxsNGr3yZM6T4aeypxPPyn5W/3nrc6vn3/3i+0vPWPzY8Av5i8+/rnmp83Lvq6mvOscjxx+8znk98ab8rc7bfe+477rfx70fmSj8QP5Q89H6Y8en0E/3Pud8/vwv94Tz+4A5JREAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfcAgcQLxxUBNp/AAAQZ0lEQVR42u2be3QVVZbGv1N17829eRLyIKAEOiISEtPhJTJAYuyBDmhWjAEx4iAGBhxA4wABbVAMWUAeykMCM+HRTcBRWkNH2l5moS0LCCrQTkYeQWBQSCAIgYRXEpKbW/XNH5zS4noR7faPEeu31l0h4dSpvc+t/Z199jkFWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhY/H9D/MR9qfKnLj/00U71aqfJn9+HCkCR/Wk36ddsgyJ/1wF4fkDfqqm9/gPsUeTnVr6a2xlQfnxdI7zs0W7irzD17Ytb2WT7EeNv/r4ox1O3Quf2QP2pgt9utwfout4FQE8AVBSlnaRmfvAURQkg2RlAbwB9AThlW5L0GaiKojhJhgOIBqDa7XaPrusdPtr5kQwF0BVAAoBIABRCKDd5aFUhRDAAw57eAOwAhKIoupft3zoqhB1AqLwuHIBut9uFt02qqvqRDJR2dAEQJj/BAOjn56dqmma+xiaECAEQAWAggLsB6A6HQ2iaZggBhBAqgEAAnQB0kzaEmT4hAITT6VQ8Ho/HJAKKECJQtr8LwD1y/A1/vcdfEUIEyfZ9AcQbYvZ942Px88L2UwlJR0dH0EMPPbRj5syZPUeNGrXR7Xb/641xIwJ1XY9NSUlZm52dfW+XLl1w8uRJzJ8//+OGhoYJqqqe1TSt1Wsm9NN1PSIqKmr12rVrR5WUlHy1bdu2AQCumWc3IYRD1/UwVVXnFRQUTIuNjUVzczN2797dWFJSkq8oymZd15sAGAEnFEUJ1nX9nzIzM1dnZmZGh4SE4OTJk5g5c+Zf29vbp9pstrMej6fVOyhIhgAYU1hY+B+hoaGoqKg4XVlZea+XTULTNFdCQsLGiRMnPuR2u3UhBOV9eeDAAWXTpk095DUe6WsoyRE5OTlr0tLSAux2O/bs2cO5c+e+pijKUpIXSHaQVAGkvPLKK++6XK4OksJLCFlXV2cvKSlJBFAjhU+x2WwhHo9nUHp6+urMzMy7wsLCUF9fjxdffPHjxsbGiTab7WuPx9NiEutOuq4PyMjI+M+srKyYqKgoHD58GDNmzNjq8XhyVFU9b/q+LH7hBAEYu3PnTlZVVRFAGgCX6f/tAHoOHDjwa0p27txp/JO9e/f+QM7cipw9nfL3kQBKt2zZQpJ87rnn6mQmoHilw2EACs+cOUOSrK+vZ1NTE0nyo48+IoBpxswoBcMJ4Ndjx471kOTFixe5d+9ekqTH42H//v13A4jyzpAURfEH0H/OnDnthu1z5sw558MmFUCPWbNmnaMP3nrrLZoyDmP8Hl68eDFJ8siRI9/Yc+zYMQKYKdtAztrTrl27xptRXV1NAKMAOAyBBBA/Y8aMdpLs6Ojgxx9//E37+++//29yvFXppwvAwMcee8xjtDHsuXLlCqOjo//ia3wsfpkoALqFhoZuIckJEyackimm3dQmEMDUmpoakmRISMhhAHOHDx/eQJIbN24kgKEyMAHAFRMTs2XXrl1saWkhSZ0kp0+ffhrAr3wEW/S8efOukORLL72kA1gKYMPWrVtJkk899dRJAHeYrgsEsIQkjx8/TgDvAPjd448/3kaSb7zxBmUa7vC6z53BwcFbSHL9+vU6Sc6aNes8gF5ewWAH0PfVV18lSQL4DMBGIcQ6AKtcLleBFC2jXtFt8ODBe0iyoqKCAJYByC8qKmJDQwOzsrK+MAmqo1OnTveHhoa+GRkZ+XZkZOSWiIiIvzgcjk9mzpypkWRmZuZpmbYbGV4AgPnNzc1sa2sjgN0A5iQmJtaSZHl5OQHcb/K3s81mW0uSTU1NBFAFYFbfvn1Pk+Tbb79NAA8IIVzW42/hByA+Pz/fLR/2ZXIda05NI/z9/TeR5J49ewhgqlxTrtI0jY2NjQQw3zTLuWJiYjaUlJToS5Ys6fjkk080kwDEeAmADcA9GzZsIElGRUW9CyAWwLApU6Y0kOSKFSsog9QICGdERMTGsrIyZmVlEcC9AB4IDw/fTpLbtm0jgN94CUAnAJmVlZVcs2aNZ/LkyRdJcvbs2b4EwAkgZfPmzTxw4AABFAN4BkC6vFeUSewcAO5duXIlSTIhIaEawGMAxgKYAmAGgCS73e5vrKVk/yGythANYEhCQsIhkly+fDkBpKqqGmL6DgIALDKN/3yZpVWQZGVlJQE8aPI3KiMjo5okV61aRQAjAPQBMPfIkSN0u90EUCBtsPiFEwpgbn19PdetW2fM5N4zQ9ekpKQqkty0aRMBpMjiWM6JEydIkoqirJUFJ6iq6pAPVy8A6cZMehMBUACEuVyuFwG8HBwcPEIWx367ZMkSjSQXLVrUJouTRorrkAHdA8BdQogsAOsKCwtJkmPGjDkvMw2bDDo/ADEjRoz4XylyFbm5uY0mAbjLyyZ/AOOrq6tZVlbWsWDBgo69e/eyoqKCgwcPPg4gSQaoIRbp27dvN7KF+tLSUr28vJwFBQXtMpvpYRIM7+wrAkDeqVOnePbsWQIoNKfzpiXPg8uXLydJJicnNwF4f+nSpW6STEtLq5fjYwhk1wkTJtSQ5Ouvv04AqTKj+N2xY8dIkgEBAW/Ie1v8wncRegwZMmQvSfbr12+3Ua33WqPfOWbMmP0kWVpaSgCDZAqcfejQIWNZsEGKgvnh9gfQb9myZd8nAEJVVZtMkUNk8CcNHTq0liR1XWdYWNhmH1mJIme80OnTp18x1rp5eXkEsNJms92Fb7e/IgEsvHz5Mp999tkmAI/l5uZeMC0B7vEqqAYAyL106RJJsra2lpWVld+sucePH38ZQG+5NncBeOrgwYMkqbe3t/Po0aOsra011wAWyl0H7x0JJ4DE+fPnu0kyPT29DsDdUrBuyNKEEAkAdpw/f/6GeoEM8GUmfwEgPCIiopwkGxsbabPZPgOw6L777vvm4p49e26VGYjFLxUhhD+ApLKyMp44ccIoVnXybgbgzkcfffRzklyzZg0BDJYCMMmoCwQFBXkLgLGWvvcWAgBToSsKwNPTp09vMR7UuLi4rwH0lgU8c/Db5ezbeeTIkRWzZ8++aMxu+fn5BPCADBwHgP4LFy701NXVEUAJgAnPP/98kyxMNgHo53A4zH77BQQETMvPz7+Um5vbBuAlAFMSExPPmdbVL0qh8Acw8fDhw5SCchVAEYAVb775JknyhRdeaJYztHfxMwLAaqNwCGC2FArv8x0hAHKNLGPKlCme5OTk/Zs3bzb7O0wKiiG8KXl5ed8IxenTp0mSR48e1UmyW7duWywBuD2xyQcgFECgoih+8H1gyJgZV5Lkyy+/3CbTRIePtl2HDBmyw1QBHyGDdXZdXR1JUghRKkXBjOMHCoBdpr0L3nvvPZLkF198wejo6O0A4lVVDTb74HQ6AwD8Wq7Jh8rgGgDgQ13XjVR8qaxJuADMbmlpYXl5uV5UVNRWUFDgfv/993Vj/ZydnU1c37eHXML4S3viAcQqitJD2l104cIFY8lTKsXSBWBMVVWVcd9yed2A1NTUQ6Zl00CvLMMOoHdubm6zFIlWOf5+PsY/Kj09vdrU11QAwwGsv3jxIk21m2DZr10I0RXAuAcffPBgaWkpV69eTYfDcdiwUxY0w6xw+flX8L1xApjevXv3lREREaW6rofB93aPDUDQpEmTMgHgtddeqwBwEd/utZvpqK6uPgEAcXFxkA94NwB9unfvjrNnz4LklwDcf08iIqv66Zs2bXrl4YcfxooVKxAbG7uqrq5uAYA2TdOEqqpGYIi2tjbl6aeffu/YsWPv5uTk7JaC1wHg4Pnz542MwoVvTx+21dbWYvjw4WLixIl+2dnZ9lGjRgmSTE1NRUpKCkwFTGiaxtTU1OXTpk3707Bhw/6g67pDipnT4biuj7qut+Lbk3Vf1tTUXI9qu91Pjq1QFEUBgJaWFgBo8yGOQ8eNGxcAAOvXr/8QwBUfYygAKL169eoCABcuXACAWtn2hOGv0+kMNO1KiPDw8F4A4rZv3/7R1KlTR0+bNu1ht9u9r1+/fqitrQXJgwDarRC6/QjPzs4+QJIffPCB9/aQmSAA43ft2mW0e1QGoi8CAPyLsZccExNTC2BlRkbGRdOyYJCP2csBIN6UAZzCd7cBbQCijYp/dXU1ExMTz6SmptaMHj36f9LS0vYlJCRsl6mxIWSdu3fv/g5J7t+/nwC2AShMTk6+SJKff/45AWRLYbD7+fndAeDf5BJnLoCCyZMnt5JkdnZ2C4B/F0KEm1Pu+Pj4rST55ZdfEsBWAK+mpaVdMo3raDn7KwDuSEpK+m+S3LBhAwG8DuCtHTt2UBbpjgC408vvcFVV15HkuXPnjMp+p5uMf0RcXNyHJNnQ0EBVVfcCWBQXF3fG+Jv0yxABPwB5LS0tRmFxN4BlTzzxxGWSXLx4sS5F3GGFy+1Hp5SUlJq6ujoWFxdTpsZ2H+0iIyMj/0iSWVlZX5mr5jfJFroPGzasxlhTnjp1iiTZ3NxMl8tlrCd9pfa9SkpKSJI5OTmnZOageLUZZqxvfVFWVkZcPwdgNwnSCKPqb17jkmR8fPzfZMDZ5CRsFBmNI7h95s2b1yhT7/MAYmStwCx4vy0uLqa3v5qmEcCfvSr1QQAeXb16NY3Cm3HQ55133iGAp+SxZTNhKSkpfzUddkrFjYevzAQCeGjp0qXfsYckY2NjTwD4leGDLCL2HTdunNtoY+zWSHFcIHdsFCtcfuZ1vO9Eqs3m7/F47sb1k2qX/f3997W2tl7BjWfpBYDOzzzzzIVJkyZh0KBBCwEsB3AJvl9AETabLcDj8dwRFRW1ctasWb8JCgpSzp07d62wsPC/Wltb8xRFadR1/ZqPXYbgAQMGbI2Pjw/+6quv9ldVVT0r01ezuPRJSUn5Y9euXXVd11WzDaqq6kePHm3+7LPPRgO4KlNuxWazhXo8nuTk5OSXMjIyEl0uFxoaGtqKior+dPXq1VdUVT0jj7r68ieoT58+vx8yZMjdx48fP1JVVTVF9m20VW02WyfZf97YsWPjXS4X6urqWvPy8jYCWCyEuEDS8FdVFKWzruv//OSTTy5OTk7uqWkaPv3007qysrJ8RVH+LI8ym8/rB3Tu3HnRI488knLo0KG2ffv2ZQI4C98vP6mqqoZqmpaclpa2cOTIkX39/f3R0NDQUVxc/G5TU9PLqqrWa5rWLH1QVFUN0TStX1JSUvH48eP7BwYG4uDBg1cKCgpeBbBe2u+2Qug2EwD5N5sMPuNtMe8XP4TT6Qxoa2sbIGeXvUKIK7d4IISiKC5d1wPljOfA9bPwzYqiXNV13dd6Uqiq6qdpml2mpe02m63d4/G4vcTF5fF47LJf71nJA6BZVVW3pmntuPHlmAD5wk6Q9NnbHp9vHaqq6tA0zU/64PZhk1FfCZB9G/23ALiqKEqzD39tpvbGUqoFwFUhRLP3yzpCCDtJpxyXDulfG27+pqRR3DXsUWVd4Yq0x/taVQjhIhksC8L+ABpM9ljBf5sKwI8pIBr75L5E4vvu+UNeG/a+hv+AL7yFH8qPtOfHjtOP6V/Bja8D6z/B2Nys/1u9Xv33tLf4GfF/LC4GCJwByWIAAAAASUVORK5CYII\x3d";
cc.Camera = cc.Class.extend({
    _eyeX: null,
    _eyeY: null,
    _eyeZ: null,
    _centerX: null,
    _centerY: null,
    _centerZ: null,
    _upX: null,
    _upY: null,
    _upZ: null,
    _dirty: null,
    _lookupMatrix: null,
    ctor: function () {
        this._lookupMatrix = new cc.kmMat4;
        this.restore()
    },
    description: function () {
        return "\x3cCCCamera | center \x3d(" + this._centerX + "," + this._centerY + "," + this._centerZ + ")\x3e"
    },
    setDirty: function (a) {
        this._dirty = a
    },
    isDirty: function () {
        return this._dirty
    },
    restore: function () {
        this._eyeX = this._eyeY = 0;
        this._eyeZ = cc.Camera.getZEye();
        this._upX =
            this._centerX = this._centerY = this._centerZ = 0;
        this._upY = 1;
        this._upZ = 0;
        cc.kmMat4Identity(this._lookupMatrix);
        this._dirty = !1
    },
    locate: function () {
        if (this._dirty) {
            var a = new cc.kmVec3,
                b = new cc.kmVec3,
                c = new cc.kmVec3;
            cc.kmVec3Fill(a, this._eyeX, this._eyeY, this._eyeZ);
            cc.kmVec3Fill(b, this._centerX, this._centerY, this._centerZ);
            cc.kmVec3Fill(c, this._upX, this._upY, this._upZ);
            cc.kmMat4LookAt(this._lookupMatrix, a, b, c);
            this._dirty = !1
        }
        cc.kmGLMultMatrix(this._lookupMatrix)
    },
    setEyeXYZ: function (a, b, c) {
        this.setEye(a, b,
            c)
    },
    setEye: function (a, b, c) {
        this._eyeX = a;
        this._eyeY = b;
        this._eyeZ = c;
        this._dirty = !0
    },
    setCenterXYZ: function (a, b, c) {
        this.setCenter(a, b, c)
    },
    setCenter: function (a, b, c) {
        this._centerX = a;
        this._centerY = b;
        this._centerZ = c;
        this._dirty = !0
    },
    setUpXYZ: function (a, b, c) {
        this.setUp(a, b, c)
    },
    setUp: function (a, b, c) {
        this._upX = a;
        this._upY = b;
        this._upZ = c;
        this._dirty = !0
    },
    getEyeXYZ: function (a, b, c) {
        return {
            x: this._eyeX,
            y: this._eyeY,
            z: this._eyeZ
        }
    },
    getEye: function () {
        return {
            x: this._eyeX,
            y: this._eyeY,
            z: this._eyeZ
        }
    },
    getCenterXYZ: function (a,
        b, c) {
        return {
            x: this._centerX,
            y: this._centerY,
            z: this._centerZ
        }
    },
    getCenter: function () {
        return {
            x: this._centerX,
            y: this._centerY,
            z: this._centerZ
        }
    },
    getUpXYZ: function (a, b, c) {
        return {
            x: this._upX,
            y: this._upY,
            z: this._upZ
        }
    },
    getUp: function () {
        return {
            x: this._upX,
            y: this._upY,
            z: this._upZ
        }
    },
    _DISALLOW_COPY_AND_ASSIGN: function (a) {}
});
cc.Camera.getZEye = function () {
    return cc.FLT_EPSILON
};
cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1;
cc.arrayVerifyType = function (a, b) {
    if (a && 0 < a.length)
        for (var c = 0; c < a.length; c++)
            if (!(a[c] instanceof b)) return cc.log("element type is wrong!"), !1;
    return !0
};
cc.arrayRemoveObject = function (a, b) {
    for (var c = 0, d = a.length; c < d; c++)
        if (a[c] == b) {
            a.splice(c, 1);
            break
        }
};
cc.arrayRemoveArray = function (a, b) {
    for (var c = 0, d = b.length; c < d; c++) cc.arrayRemoveObject(a, b[c])
};
cc.arrayAppendObjectsToIndex = function (a, b, c) {
    a.splice.apply(a, [c, 0].concat(b));
    return a
};
cc.ListEntry = function (a, b, c, d, e, f) {
    this.prev = a;
    this.next = b;
    this.target = c;
    this.priority = d;
    this.paused = e;
    this.markedForDeletion = f
};
cc.HashUpdateEntry = function (a, b, c, d) {
    this.list = a;
    this.entry = b;
    this.target = c;
    this.hh = d
};
cc.HashTimerEntry = function (a, b, c, d, e, f, g) {
    this.timers = a;
    this.target = b;
    this.timerIndex = c;
    this.currentTimer = d;
    this.currentTimerSalvaged = e;
    this.paused = f;
    this.hh = g
};
cc.Timer = cc.Class.extend({
    _interval: 0,
    _callback: null,
    _target: null,
    _elapsed: 0,
    _runForever: !1,
    _useDelay: !1,
    _timesExecuted: 0,
    _repeat: 0,
    _delay: 0,
    getInterval: function () {
        return this._interval
    },
    setInterval: function (a) {
        this._interval = a
    },
    getCallback: function () {
        return this._callback
    },
    ctor: function (a, b, c, d, e) {
        this._target = a;
        this._callback = b;
        this._elapsed = -1;
        this._interval = c || 0;
        this._delay = e || 0;
        this._useDelay = 0 < this._delay;
        this._repeat = null == d ? cc.REPEAT_FOREVER : d;
        this._runForever = this._repeat == cc.REPEAT_FOREVER
    },
    _doCallback: function () {
        if ("string" == typeof this._callback) this._target[this._callback](this._elapsed);
        else this._callback.call(this._target, this._elapsed)
    },
    update: function (a) {
        if (-1 == this._elapsed) this._timesExecuted = this._elapsed = 0;
        else {
            var b = this._target,
                c = this._callback;
            this._elapsed += a;
            this._runForever && !this._useDelay ? this._elapsed >= this._interval && (b && c && this._doCallback(), this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (b && c && this._doCallback(), this._elapsed -= this._delay, this._timesExecuted +=
                1, this._useDelay = !1) : this._elapsed >= this._interval && (b && c && this._doCallback(), this._elapsed = 0, this._timesExecuted += 1), this._timesExecuted > this._repeat && cc.director.getScheduler().unscheduleCallbackForTarget(b, c))
        }
    }
});
cc.Scheduler = cc.Class.extend({
    _timeScale: 1,
    _updates: null,
    _hashForUpdates: null,
    _arrayForUpdates: null,
    _hashForTimers: null,
    _arrayForTimes: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _updateHashLocked: !1,
    ctor: function () {
        this._timeScale = 1;
        this._updates = [
            [],
            [],
            []
        ];
        this._hashForUpdates = {};
        this._arrayForUpdates = [];
        this._hashForTimers = {};
        this._arrayForTimers = [];
        this._currentTarget = null;
        this._updateHashLocked = this._currentTargetSalvaged = !1
    },
    _removeHashElement: function (a) {
        delete this._hashForTimers[a.target.__instanceId];
        cc.arrayRemoveObject(this._arrayForTimers, a);
        a.Timer = null;
        a.target = null
    },
    _removeUpdateFromHash: function (a) {
        if (a = this._hashForUpdates[a.target.__instanceId]) cc.arrayRemoveObject(a.list, a.entry), delete this._hashForUpdates[a.target.__instanceId], cc.arrayRemoveObject(this._arrayForUpdates, a), a.entry = null, a.target = null
    },
    _priorityIn: function (a, b, c, d) {
        d = new cc.ListEntry(null, null, b, c, d, !1);
        if (a) {
            for (var e = a.length - 1, f = 0; f <= e && !(c < a[f].priority); f++);
            a.splice(f, 0, d)
        } else a = [], a.push(d);
        c = new cc.HashUpdateEntry(a,
            d, b, null);
        this._arrayForUpdates.push(c);
        this._hashForUpdates[b.__instanceId] = c;
        return a
    },
    _appendIn: function (a, b, c) {
        c = new cc.ListEntry(null, null, b, 0, c, !1);
        a.push(c);
        a = new cc.HashUpdateEntry(a, c, b, null);
        this._arrayForUpdates.push(a);
        this._hashForUpdates[b.__instanceId] = a
    },
    setTimeScale: function (a) {
        this._timeScale = a
    },
    getTimeScale: function () {
        return this._timeScale
    },
    update: function (a) {
        var b = this._updates,
            c = this._arrayForTimers,
            d;
        this._updateHashLocked = !0;
        1 != this._timeScale && (a *= this._timeScale);
        for (var e =
            0, f = b.length; e < f && 0 <= e; e++)
            for (var g = this._updates[e], h = 0, k = g.length; h < k; h++) d = g[h], d.paused || d.markedForDeletion || d.target.update(a);
        e = 0;
        for (f = c.length; e < f; e++) {
            d = c[e];
            if (!d) break;
            this._currentTarget = d;
            this._currentTargetSalvaged = !1;
            if (!d.paused)
                for (d.timerIndex = 0; d.timerIndex < d.timers.length; d.timerIndex++) d.currentTimer = d.timers[d.timerIndex], d.currentTimerSalvaged = !1, d.currentTimer.update(a), d.currentTimer = null;
            this._currentTargetSalvaged && 0 == d.timers.length && (this._removeHashElement(d), e--)
        }
        e =
            0;
        for (f = b.length; e < f; e++)
            for (g = this._updates[e], h = 0, k = g.length; h < k;) {
                d = g[h];
                if (!d) break;
                d.markedForDeletion ? this._removeUpdateFromHash(d) : h++
            }
        this._updateHashLocked = !1;
        this._currentTarget = null
    },
    scheduleCallbackForTarget: function (a, b, c, d, e, f) {
        if (!b) throw "cc.scheduler.scheduleCallbackForTarget(): callback_fn should be non-null.";
        if (!a) throw "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.";
        c = c || 0;
        d = null == d ? cc.REPEAT_FOREVER : d;
        e = e || 0;
        f = f || !1;
        var g = this._hashForTimers[a.__instanceId];
        g || (g = new cc.HashTimerEntry(null, a, 0, null, null, f, null), this._arrayForTimers.push(g), this._hashForTimers[a.__instanceId] = g);
        if (null == g.timers) g.timers = [];
        else
            for (var h = 0; h < g.timers.length; h++)
                if (f = g.timers[h], b == f._callback) {
                    cc.log("CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:" + f.getInterval().toFixed(4) + " to " + c.toFixed(4));
                    f._interval = c;
                    return
                }
        f = new cc.Timer(a, b, c, d, e);
        g.timers.push(f)
    },
    scheduleUpdateForTarget: function (a, b, c) {
        var d = this._updates,
            e = this._hashForUpdates[a.__instanceId];
        e ? e.entry.markedForDeletion = !1 : 0 == b ? this._appendIn(d[1], a, c) : 0 > b ? d[0] = this._priorityIn(d[0], a, b, c) : d[2] = this._priorityIn(d[2], a, b, c)
    },
    unscheduleCallbackForTarget: function (a, b) {
        if (null != a && null != b) {
            var c = this._hashForTimers[a.__instanceId];
            if (c)
                for (var d = c.timers, e = 0, f = d.length; e < f; e++) {
                    var g = d[e];
                    if (b == g._callback) {
                        g != c.currentTimer || c.currentTimerSalvaged || (c.currentTimerSalvaged = !0);
                        d.splice(e, 1);
                        c.timerIndex >= e && c.timerIndex--;
                        0 == d.length && (this._currentTarget == c ? this._currentTargetSalvaged = !0 :
                            this._removeHashElement(c));
                        break
                    }
                }
        }
    },
    unscheduleUpdateForTarget: function (a) {
        null != a && (a = this._hashForUpdates[a.__instanceId], null != a && (this._updateHashLocked ? a.entry.markedForDeletion = !0 : this._removeUpdateFromHash(a.entry)))
    },
    unscheduleAllCallbacksForTarget: function (a) {
        if (null != a) {
            var b = this._hashForTimers[a.__instanceId];
            if (b) {
                var c = b.timers;
                !b.currentTimerSalvaged && 0 <= c.indexOf(b.currentTimer) && (b.currentTimerSalvaged = !0);
                c.length = 0;
                this._currentTarget == b ? this._currentTargetSalvaged = !0 : this._removeHashElement(b)
            }
            this.unscheduleUpdateForTarget(a)
        }
    },
    unscheduleAllCallbacks: function () {
        this.unscheduleAllCallbacksWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    unscheduleAllCallbacksWithMinPriority: function (a) {
        for (var b = this._arrayForTimers, c = this._updates, d = 0, e = b.length; d < e; d++) this.unscheduleAllCallbacksForTarget(b[d].target);
        for (d = 2; 0 <= d; d--)
            if (!(1 == d && 0 < a || 0 == d && 0 <= a))
                for (var b = c[d], e = 0, f = b.length; e < f; e++) this.unscheduleUpdateForTarget(b[e].target)
    },
    pauseAllTargets: function () {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    pauseAllTargetsWithMinPriority: function (a) {
        a = [];
        for (var b, c = this._arrayForTimers, d = this._updates, e = 0, f = c.length; e < f; e++)
            if (b = c[e]) b.paused = !0, a.push(b.target);
        e = 0;
        for (f = d.length; e < f; e++)
            for (var c = d[e], g = 0, h = c.length; g < h; g++)
                if (b = c[g]) b.paused = !0, a.push(b.target);
        return a
    },
    resumeTargets: function (a) {
        if (a)
            for (var b = 0; b < a.length; b++) this.resumeTarget(a[b])
    },
    pauseTarget: function (a) {
        if (!a) throw "cc.Scheduler.pauseTarget():target should be non-null";
        var b = this._hashForTimers[a.__instanceId];
        b && (b.paused = !0);
        if (a = this._hashForUpdates[a.__instanceId]) a.entry.paused = !0
    },
    resumeTarget: function (a) {
        if (!a) throw "cc.Scheduler.resumeTarget():target should be non-null";
        var b = this._hashForTimers[a.__instanceId];
        b && (b.paused = !1);
        if (a = this._hashForUpdates[a.__instanceId]) a.entry.paused = !1
    },
    isTargetPaused: function (a) {
        if (!a) throw "cc.Scheduler.isTargetPaused():target should be non-null";
        return (a = this._hashForTimers[a.__instanceId]) ? a.paused : !1
    }
});
cc.Scheduler.PRIORITY_SYSTEM = -2147483648;
cc.DrawingPrimitive = cc.Class.extend({
    _renderContext: null,
    setRenderContext: function (a) {
        this._renderContext = a
    },
    getRenderContext: function () {
        return this._renderContext
    },
    ctor: function (a) {
        this._renderContext = a
    },
    drawPoint: function (a) {
        cc.log("DrawingPrimitive.drawPoint() not implement!")
    },
    drawPoints: function (a, b) {
        cc.log("DrawingPrimitive.drawPoints() not implement!")
    },
    drawLine: function (a, b) {
        cc.log("DrawingPrimitive.drawLine() not implement!")
    },
    drawRect: function (a, b) {
        cc.log("DrawingPrimitive.drawRect() not implement!")
    },
    drawSolidRect: function (a, b, c) {
        cc.log("DrawingPrimitive.drawSolidRect() not implement!")
    },
    drawPoly: function (a, b, c, d) {
        cc.log("DrawingPrimitive.drawPoly() not implement!")
    },
    drawSolidPoly: function (a, b, c) {
        cc.log("DrawingPrimitive.drawSolidPoly() not implement!")
    },
    drawCircle: function (a, b, c, d, e) {
        cc.log("DrawingPrimitive.drawCircle() not implement!")
    },
    drawQuadBezier: function (a, b, c, d) {
        cc.log("DrawingPrimitive.drawQuadBezier() not implement!")
    },
    drawCubicBezier: function (a, b, c, d, e) {
        cc.log("DrawingPrimitive.drawCubicBezier() not implement!")
    },
    drawCatmullRom: function (a, b) {
        cc.log("DrawingPrimitive.drawCardinalSpline() not implement!")
    },
    drawCardinalSpline: function (a, b, c) {
        cc.log("DrawingPrimitive.drawCardinalSpline() not implement!")
    }
});
cc.DrawingPrimitiveCanvas = cc.DrawingPrimitive.extend({
    _cacheArray: [],
    drawPoint: function (a, b) {
        b || (b = 1);
        var c = cc.view.getScaleX(),
            d = cc.view.getScaleY(),
            d = cc.p(a.x * c, a.y * d);
        this._renderContext.beginPath();
        this._renderContext.arc(d.x, -d.y, b * c, 0, 2 * Math.PI, !1);
        this._renderContext.closePath();
        this._renderContext.fill()
    },
    drawPoints: function (a, b, c) {
        if (null != a) {
            c || (c = 1);
            b = this._renderContext;
            var d = cc.view.getScaleX(),
                e = cc.view.getScaleY();
            b.beginPath();
            for (var f = 0, g = a.length; f < g; f++) b.arc(a[f].x * d, -a[f].y *
                e, c * d, 0, 2 * Math.PI, !1);
            b.closePath();
            b.fill()
        }
    },
    drawLine: function (a, b) {
        var c = this._renderContext,
            d = cc.view.getScaleX(),
            e = cc.view.getScaleY();
        c.beginPath();
        c.moveTo(a.x * d, -a.y * e);
        c.lineTo(b.x * d, -b.y * e);
        c.closePath();
        c.stroke()
    },
    drawRect: function (a, b) {
        this.drawLine(cc.p(a.x, a.y), cc.p(b.x, a.y));
        this.drawLine(cc.p(b.x, a.y), cc.p(b.x, b.y));
        this.drawLine(cc.p(b.x, b.y), cc.p(a.x, b.y));
        this.drawLine(cc.p(a.x, b.y), cc.p(a.x, a.y))
    },
    drawSolidRect: function (a, b, c) {
        a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
        this.drawSolidPoly(a,
            4, c)
    },
    drawPoly: function (a, b, c, d) {
        d = d || !1;
        if (null != a) {
            if (3 > a.length) throw Error("Polygon's point must greater than 2");
            var e = a[0];
            b = this._renderContext;
            var f = cc.view.getScaleX(),
                g = cc.view.getScaleY();
            b.beginPath();
            b.moveTo(e.x * f, -e.y * g);
            for (var e = 1, h = a.length; e < h; e++) b.lineTo(a[e].x * f, -a[e].y * g);
            c && b.closePath();
            d ? b.fill() : b.stroke()
        }
    },
    drawSolidPoly: function (a, b, c) {
        this.setDrawColor(c.r, c.g, c.b, c.a);
        this.drawPoly(a, b, !0, !0)
    },
    drawCircle: function (a, b, c, d, e) {
        e = e || !1;
        d = this._renderContext;
        var f = cc.view.getScaleX(),
            g = cc.view.getScaleY();
        d.beginPath();
        d.arc(0 | a.x * f, 0 | -(a.y * g), b * f, -c, -(c - 2 * Math.PI), !1);
        e && d.lineTo(0 | a.x * f, 0 | -(a.y * g));
        d.stroke()
    },
    drawQuadBezier: function (a, b, c, d) {
        for (var e = this._cacheArray, f = e.length = 0, g = 0; g < d; g++) {
            var h = Math.pow(1 - f, 2) * a.x + 2 * (1 - f) * f * b.x + f * f * c.x,
                k = Math.pow(1 - f, 2) * a.y + 2 * (1 - f) * f * b.y + f * f * c.y;
            e.push(cc.p(h, k));
            f += 1 / d
        }
        e.push(cc.p(c.x, c.y));
        this.drawPoly(e, d + 1, !1, !1)
    },
    drawCubicBezier: function (a, b, c, d, e) {
        for (var f = this._cacheArray, g = f.length = 0, h = 0; h < e; h++) {
            var k = Math.pow(1 - g, 3) * a.x + 3 *
                Math.pow(1 - g, 2) * g * b.x + 3 * (1 - g) * g * g * c.x + g * g * g * d.x,
                m = Math.pow(1 - g, 3) * a.y + 3 * Math.pow(1 - g, 2) * g * b.y + 3 * (1 - g) * g * g * c.y + g * g * g * d.y;
            f.push(cc.p(k, m));
            g += 1 / e
        }
        f.push(cc.p(d.x, d.y));
        this.drawPoly(f, e + 1, !1, !1)
    },
    drawCatmullRom: function (a, b) {
        this.drawCardinalSpline(a, 0.5, b)
    },
    drawCardinalSpline: function (a, b, c) {
        cc._renderContext.strokeStyle = "rgba(255,255,255,1)";
        var d = this._cacheArray;
        d.length = 0;
        for (var e, f, g = 1 / a.length, h = 0; h < c + 1; h++) f = h / c, 1 == f ? (e = a.length - 1, f = 1) : (e = 0 | f / g, f = (f - g * e) / g), e = cc.CardinalSplineAt(cc.getControlPointAt(a,
            e - 1), cc.getControlPointAt(a, e - 0), cc.getControlPointAt(a, e + 1), cc.getControlPointAt(a, e + 2), b, f), d.push(e);
        this.drawPoly(d, c + 1, !1, !1)
    },
    drawImage: function (a, b, c, d, e) {
        switch (arguments.length) {
        case 2:
            this._renderContext.drawImage(a, b.x, -(b.y + a.height));
            break;
        case 3:
            this._renderContext.drawImage(a, b.x, -(b.y + c.height), c.width, c.height);
            break;
        case 5:
            this._renderContext.drawImage(a, b.x, b.y, c.width, c.height, d.x, -(d.y + e.height), e.width, e.height);
            break;
        default:
            throw Error("Argument must be non-nil");
        }
    },
    drawStar: function (a,
        b, c) {
        a = a || this._renderContext;
        b *= cc.view.getScaleX();
        c = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b);
        a.fillStyle = c + ",1)";
        var d = b / 10;
        a.beginPath();
        a.moveTo(-b, b);
        a.lineTo(0, d);
        a.lineTo(b, b);
        a.lineTo(d, 0);
        a.lineTo(b, -b);
        a.lineTo(0, -d);
        a.lineTo(-b, -b);
        a.lineTo(-d, 0);
        a.lineTo(-b, b);
        a.closePath();
        a.fill();
        var e = a.createRadialGradient(0, 0, d, 0, 0, b);
        e.addColorStop(0, c + ", 1)");
        e.addColorStop(0.3, c + ", 0.8)");
        e.addColorStop(1, c + ", 0.0)");
        a.fillStyle = e;
        a.beginPath();
        a.arc(0, 0, b - d, 0, cc.PI2, !1);
        a.closePath();
        a.fill()
    },
    drawColorBall: function (a, b, c) {
        a = a || this._renderContext;
        b *= cc.view.getScaleX();
        c = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b);
        var d = a.createRadialGradient(0, 0, b / 10, 0, 0, b);
        d.addColorStop(0, c + ", 1)");
        d.addColorStop(0.3, c + ", 0.8)");
        d.addColorStop(0.6, c + ", 0.4)");
        d.addColorStop(1, c + ", 0.0)");
        a.fillStyle = d;
        a.beginPath();
        a.arc(0, 0, b, 0, cc.PI2, !1);
        a.closePath();
        a.fill()
    },
    fillText: function (a, b, c) {
        this._renderContext.fillText(a, b, -c)
    },
    setDrawColor: function (a, b, c, d) {
        this._renderContext.fillStyle = "rgba(" + a + "," + b + "," +
            c + "," + d / 255 + ")";
        this._renderContext.strokeStyle = "rgba(" + a + "," + b + "," + c + "," + d / 255 + ")"
    },
    setPointSize: function (a) {},
    setLineWidth: function (a) {
        this._renderContext.lineWidth = a * cc.view.getScaleX()
    }
});
cc.DrawingPrimitiveWebGL = cc.DrawingPrimitive.extend({
    _initialized: !1,
    _shader: null,
    _colorLocation: -1,
    _colorArray: null,
    _pointSizeLocation: -1,
    _pointSize: -1,
    ctor: function (a) {
        null == a && (a = cc._renderContext);
        if (!a instanceof WebGLRenderingContext) throw "Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext";
        cc.DrawingPrimitive.prototype.ctor.call(this, a);
        this._colorArray = new Float32Array([1, 1, 1, 1])
    },
    lazy_init: function () {
        this._initialized || (this._shader = cc.shaderCache.programForKey(cc.SHADER_POSITION_UCOLOR),
            this._colorLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_color"), this._pointSizeLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_pointSize"), this._initialized = !0)
    },
    drawInit: function () {
        this._initialized = !1
    },
    drawPoint: function (a) {
        this.lazy_init();
        var b = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        b.uniform4fv(this._colorLocation,
            this._colorArray);
        this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
        var c = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, c);
        b.bufferData(b.ARRAY_BUFFER, new Float32Array([a.x, a.y]), b.STATIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
        b.drawArrays(b.POINTS, 0, 1);
        b.deleteBuffer(c);
        cc.INCREMENT_GL_DRAWS(1)
    },
    drawPoints: function (a, b) {
        if (a && 0 != a.length) {
            this.lazy_init();
            var c = this._renderContext;
            this._shader.use();
            this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
            c.uniform4fv(this._colorLocation, this._colorArray);
            this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
            var d = c.createBuffer();
            c.bindBuffer(c.ARRAY_BUFFER, d);
            c.bufferData(c.ARRAY_BUFFER, this._pointsToTypeArray(a), c.STATIC_DRAW);
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, 0);
            c.drawArrays(c.POINTS, 0, a.length);
            c.deleteBuffer(d);
            cc.INCREMENT_GL_DRAWS(1)
        }
    },
    _pointsToTypeArray: function (a) {
        for (var b = new Float32Array(2 *
            a.length), c = 0; c < a.length; c++) b[2 * c] = a[c].x, b[2 * c + 1] = a[c].y;
        return b
    },
    drawLine: function (a, b) {
        this.lazy_init();
        var c = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        c.uniform4fv(this._colorLocation, this._colorArray);
        var d = c.createBuffer();
        c.bindBuffer(c.ARRAY_BUFFER, d);
        c.bufferData(c.ARRAY_BUFFER, this._pointsToTypeArray([a, b]), c.STATIC_DRAW);
        c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION,
            2, c.FLOAT, !1, 0, 0);
        c.drawArrays(c.LINES, 0, 2);
        c.deleteBuffer(d);
        cc.INCREMENT_GL_DRAWS(1)
    },
    drawRect: function (a, b) {
        this.drawLine(cc.p(a.x, a.y), cc.p(b.x, a.y));
        this.drawLine(cc.p(b.x, a.y), cc.p(b.x, b.y));
        this.drawLine(cc.p(b.x, b.y), cc.p(a.x, b.y));
        this.drawLine(cc.p(a.x, b.y), cc.p(a.x, a.y))
    },
    drawSolidRect: function (a, b, c) {
        a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
        this.drawSolidPoly(a, 4, c)
    },
    drawPoly: function (a, b, c) {
        this.lazy_init();
        b = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        b.uniform4fv(this._colorLocation, this._colorArray);
        var d = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, d);
        b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
        c ? b.drawArrays(b.LINE_LOOP, 0, a.length) : b.drawArrays(b.LINE_STRIP, 0, a.length);
        b.deleteBuffer(d);
        cc.INCREMENT_GL_DRAWS(1)
    },
    drawSolidPoly: function (a, b, c) {
        this.lazy_init();
        c && this.setDrawColor(c.r, c.g, c.b, c.a);
        b = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        b.uniform4fv(this._colorLocation, this._colorArray);
        c = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, c);
        b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
        b.drawArrays(b.TRIANGLE_FAN, 0, a.length);
        b.deleteBuffer(c);
        cc.INCREMENT_GL_DRAWS(1)
    },
    drawCircle: function (a,
        b, c, d, e) {
        this.lazy_init();
        var f = 1;
        e && f++;
        var g = 2 * Math.PI / d;
        if (e = new Float32Array(2 * (d + 2))) {
            for (var h = 0; h <= d; h++) {
                var k = h * g,
                    m = b * Math.cos(k + c) + a.x,
                    k = b * Math.sin(k + c) + a.y;
                e[2 * h] = m;
                e[2 * h + 1] = k
            }
            e[2 * (d + 1)] = a.x;
            e[2 * (d + 1) + 1] = a.y;
            a = this._renderContext;
            this._shader.use();
            this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
            a.uniform4fv(this._colorLocation, this._colorArray);
            b = a.createBuffer();
            a.bindBuffer(a.ARRAY_BUFFER, b);
            a.bufferData(a.ARRAY_BUFFER,
                e, a.STATIC_DRAW);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
            a.drawArrays(a.LINE_STRIP, 0, d + f);
            a.deleteBuffer(b);
            cc.INCREMENT_GL_DRAWS(1)
        }
    },
    drawQuadBezier: function (a, b, c, d) {
        this.lazy_init();
        for (var e = new Float32Array(2 * (d + 1)), f = 0, g = 0; g < d; g++) e[2 * g] = Math.pow(1 - f, 2) * a.x + 2 * (1 - f) * f * b.x + f * f * c.x, e[2 * g + 1] = Math.pow(1 - f, 2) * a.y + 2 * (1 - f) * f * b.y + f * f * c.y, f += 1 / d;
        e[2 * d] = c.x;
        e[2 * d + 1] = c.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        a.uniform4fv(this._colorLocation, this._colorArray);
        b = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, b);
        a.bufferData(a.ARRAY_BUFFER, e, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, d + 1);
        a.deleteBuffer(b);
        cc.INCREMENT_GL_DRAWS(1)
    },
    drawCubicBezier: function (a, b, c, d, e) {
        this.lazy_init();
        for (var f = new Float32Array(2 * (e + 1)), g = 0, h = 0; h < e; h++) f[2 * h] = Math.pow(1 - g, 3) * a.x + 3 * Math.pow(1 - g, 2) * g * b.x + 3 * (1 - g) * g * g * c.x + g * g * g * d.x, f[2 * h + 1] = Math.pow(1 - g, 3) * a.y + 3 *
            Math.pow(1 - g, 2) * g * b.y + 3 * (1 - g) * g * g * c.y + g * g * g * d.y, g += 1 / e;
        f[2 * e] = d.x;
        f[2 * e + 1] = d.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        a.uniform4fv(this._colorLocation, this._colorArray);
        b = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, b);
        a.bufferData(a.ARRAY_BUFFER, f, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, e + 1);
        a.deleteBuffer(b);
        cc.INCREMENT_GL_DRAWS(1)
    },
    drawCatmullRom: function (a, b) {
        this.drawCardinalSpline(a, 0.5, b)
    },
    drawCardinalSpline: function (a, b, c) {
        this.lazy_init();
        for (var d = new Float32Array(2 * (c + 1)), e, f, g = 1 / a.length, h = 0; h < c + 1; h++) f = h / c, 1 == f ? (e = a.length - 1, f = 1) : (e = 0 | f / g, f = (f - g * e) / g), e = cc.CardinalSplineAt(cc.getControlPointAt(a, e - 1), cc.getControlPointAt(a, e), cc.getControlPointAt(a, e + 1), cc.getControlPointAt(a, e + 2), b, f), d[2 * h] = e.x, d[2 * h + 1] = e.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        a.uniform4fv(this._colorLocation, this._colorArray);
        b = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, b);
        a.bufferData(a.ARRAY_BUFFER, d, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, c + 1);
        a.deleteBuffer(b);
        cc.INCREMENT_GL_DRAWS(1)
    },
    setDrawColor: function (a, b, c, d) {
        this._colorArray[0] = a / 255;
        this._colorArray[1] = b / 255;
        this._colorArray[2] = c / 255;
        this._colorArray[3] = d / 255
    },
    setPointSize: function (a) {
        this._pointSize =
            a * cc.CONTENT_SCALE_FACTOR()
    },
    setLineWidth: function (a) {
        this._renderContext.lineWidth && this._renderContext.lineWidth(a)
    }
});
cc.PI2 = 2 * Math.PI;
cc.LabelTTF = cc.Sprite.extend({
    _dimensions: null,
    _hAlignment: cc.TEXT_ALIGNMENT_CENTER,
    _vAlignment: cc.VERTICAL_TEXT_ALIGNMENT_TOP,
    _fontName: null,
    _fontSize: 0,
    _string: "",
    _originalText: null,
    _isMultiLine: !1,
    _fontStyleStr: null,
    _shadowEnabled: !1,
    _shadowOffset: null,
    _shadowOpacity: 0,
    _shadowBlur: 0,
    _shadowColorStr: null,
    _strokeEnabled: !1,
    _strokeColor: null,
    _strokeSize: 0,
    _strokeColorStr: null,
    _textFillColor: null,
    _fillColorStr: null,
    _strokeShadowOffsetX: 0,
    _strokeShadowOffsetY: 0,
    _needUpdateTexture: !1,
    _labelCanvas: null,
    _labelContext: null,
    _lineWidths: null,
    _className: "LabelTTF",
    ctor: function () {
        cc.Sprite.prototype.ctor.call(this);
        this._dimensions = cc.size(0, 0);
        this._hAlignment = cc.TEXT_ALIGNMENT_LEFT;
        this._vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        this._opacityModifyRGB = !1;
        this._fontStyleStr = "";
        this._fontName = "Arial";
        this._shadowEnabled = this._isMultiLine = !1;
        this._shadowOffset = cc.p(0, 0);
        this._shadowBlur = this._shadowOpacity = 0;
        this._shadowColorStr = "rgba(128, 128, 128, 0.5)";
        this._strokeEnabled = !1;
        this._strokeColor = cc.color(255,
            255, 255, 255);
        this._strokeSize = 0;
        this._strokeColorStr = "";
        this._textFillColor = cc.color(255, 255, 255, 255);
        this._fillColorStr = "rgba(255,255,255,1)";
        this._strokeShadowOffsetY = this._strokeShadowOffsetX = 0;
        this._needUpdateTexture = !1;
        this._lineWidths = [];
        this._setColorsString()
    },
    init: function () {
        return this.initWithString(" ", this._fontName, this._fontSize)
    },
    _measureConfig: function () {
        this._getLabelContext().font = this._fontStyleStr
    },
    _measure: function (a) {
        return this._getLabelContext().measureText(a).width
    },
    _checkNextline: function (a,
        b) {
        var c = this._measure(a),
            d = Math.floor(a.length * b / c),
            e = a.indexOf("\n");
        if (0.8 * d >= e && 0 < e) return e + 1;
        if (c < b) return a.length;
        for (var c = !1, f = b + 1, e = -1, g = d, h, k = cc.LabelTTF._checkRegEx, m = cc.LabelTTF._reverseCheckRegEx, n = cc.LabelTTF._checkEnRegEx, p = a.substr(d); h = k.exec(p);) {
            g += h[0].length;
            f = a.substr(0, g);
            f = this._measure(f);
            if ("\n" == h[2] && f < b) {
                c = !0;
                e = g;
                break
            }
            if (f > b) {
                -1 != e && (c = !0);
                break
            }
            e = g;
            p = a.substr(g)
        }
        if (c) return e;
        p = a.substr(0, d);
        for (e = d; h = m.exec(p);)
            if (e = h[1].length, p = h[1], f = this._measure(p), f < b) {
                n.test(h[2]) &&
                    e++;
                break
            }
        return e || 1
    },
    description: function () {
        return "\x3ccc.LabelTTF | FontName \x3d" + this._fontName + " FontSize \x3d " + this._fontSize.toFixed(1) + "\x3e"
    },
    setColor: null,
    _setColorForCanvas: function (a) {
        cc.NodeRGBA.prototype.setColor.call(this, a);
        this._setColorsStringForCanvas()
    },
    _setColorsString: null,
    _setColorsStringForCanvas: function () {
        this._needUpdateTexture = !0;
        var a = this._displayedColor,
            b = this._displayedOpacity,
            c = this._strokeColor,
            d = this._textFillColor;
        this._shadowColorStr = "rgba(" + (0 | 0.5 * a.r) + "," +
            (0 | 0.5 * a.g) + "," + (0 | 0.5 * a.b) + "," + this._shadowOpacity + ")";
        this._fillColorStr = "rgba(" + (0 | a.r / 255 * d.r) + "," + (0 | a.g / 255 * d.g) + "," + (0 | a.b / 255 * d.b) + ", " + b / 255 + ")";
        this._strokeColorStr = "rgba(" + (0 | a.r / 255 * c.r) + "," + (0 | a.g / 255 * c.g) + "," + (0 | a.b / 255 * c.b) + ", " + b / 255 + ")"
    },
    _setColorsStringForWebGL: function () {
        this._needUpdateTexture = !0;
        var a = this._strokeColor,
            b = this._textFillColor;
        this._shadowColorStr = "rgba(128,128,128," + this._shadowOpacity + ")";
        this._fillColorStr = "rgba(" + (0 | b.r) + "," + (0 | b.g) + "," + (0 | b.b) + ", 1)";
        this._strokeColorStr =
            "rgba(" + (0 | a.r) + "," + (0 | a.g) + "," + (0 | a.b) + ", 1)"
    },
    updateDisplayedColor: null,
    _updateDisplayedColorForCanvas: function (a) {
        cc.NodeRGBA.prototype.updateDisplayedColor.call(this, a);
        this._setColorsString()
    },
    setOpacity: null,
    _setOpacityForCanvas: function (a) {
        this._opacity !== a && (cc.Sprite.prototype.setOpacity.call(this, a), this._setColorsString(), this._needUpdateTexture = !0)
    },
    updateDisplayedOpacity: null,
    updateDisplayedOpacityForCanvas: function (a) {
        cc.NodeRGBA.prototype.updateDisplayedOpacity.call(this, a);
        this._setColorsString()
    },
    getString: function () {
        return this._string
    },
    getHorizontalAlignment: function () {
        return this._hAlignment
    },
    getVerticalAlignment: function () {
        return this._vAlignment
    },
    getDimensions: function () {
        return cc.size(this._dimensions.width, this._dimensions.height)
    },
    getFontSize: function () {
        return this._fontSize
    },
    getFontName: function () {
        return this._fontName
    },
    initWithString: function (a, b, c, d, e, f) {
        a = a ? a + "" : "";
        c = c || 16;
        d = d || cc.size(0, c);
        e = e || cc.TEXT_ALIGNMENT_LEFT;
        f = f || cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        return cc.Sprite.prototype.init.call(this) ?
            (this._opacityModifyRGB = !1, this._dimensions = cc.size(d.width, d.height), this._fontName = b || "Arial", this._hAlignment = e, this._vAlignment = f, this._fontSize = c, this._fontStyleStr = this._fontSize + "px '" + b + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(b, this._fontSize), this.string = a, this._setColorsString(), this._updateTexture(), this._needUpdateTexture = !1, !0) : !1
    },
    initWithStringAndTextDefinition: null,
    _initWithStringAndTextDefinitionForCanvas: function (a, b) {
        if (!cc.Sprite.prototype.init.call(this)) return !1;
        this._updateWithTextDefinition(b, !1);
        this.string = a;
        return !0
    },
    _initWithStringAndTextDefinitionForWebGL: function (a, b) {
        if (!cc.Sprite.prototype.init.call(this)) return !1;
        this.shaderProgram = cc.shaderCache.programForKey(cc.LabelTTF._SHADER_PROGRAM);
        this._updateWithTextDefinition(b, !1);
        this.string = a;
        return !0
    },
    setTextDefinition: function (a) {
        a && this._updateWithTextDefinition(a, !0)
    },
    getTextDefinition: function () {
        return this._prepareTextDefinition(!1)
    },
    enableShadow: function (a, b, c, d) {
        c = c || 0.5;
        !1 === this._shadowEnabled &&
            (this._shadowEnabled = !0);
        var e = this._shadowOffset;
        if (e && e.x != a || e._y != b) e.x = a, e.y = b;
        this._shadowOpacity != c && (this._shadowOpacity = c);
        this._setColorsString();
        this._shadowBlur != d && (this._shadowBlur = d);
        this._needUpdateTexture = !0
    },
    _getShadowOffsetX: function () {
        return this._shadowOffset.x
    },
    _setShadowOffsetX: function (a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOffset.x != a && (this._shadowOffset.x = a, this._needUpdateTexture = !0)
    },
    _getShadowOffsetY: function () {
        return this._shadowOffset._y
    },
    _setShadowOffsetY: function (a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOffset._y != a && (this._shadowOffset._y = a, this._needUpdateTexture = !0)
    },
    _getShadowOffset: function () {
        return cc.p(this._shadowOffset.x, this._shadowOffset.y)
    },
    _setShadowOffset: function (a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        if (this._shadowOffset.x != a.x || this._shadowOffset.y != a.y) this._shadowOffset.x = a.x, this._shadowOffset.y = a.y, this._needUpdateTexture = !0
    },
    _getShadowOpacity: function () {
        return this._shadowOpacity
    },
    _setShadowOpacity: function (a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOpacity != a && (this._shadowOpacity = a, this._setColorsString(), this._needUpdateTexture = !0)
    },
    _getShadowBlur: function () {
        return this._shadowBlur
    },
    _setShadowBlur: function (a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowBlur != a && (this._shadowBlur = a, this._needUpdateTexture = !0)
    },
    disableShadow: function () {
        this._shadowEnabled && (this._shadowEnabled = !1, this._needUpdateTexture = !0)
    },
    enableStroke: function (a,
        b) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var c = this._strokeColor;
        if (c.r !== a.r || c.g !== a.g || c.b !== a.b) c.r = a.r, c.g = a.g, c.b = a.b, this._setColorsString();
        this._strokeSize !== b && (this._strokeSize = b || 0);
        this._needUpdateTexture = !0
    },
    _getStrokeStyle: function () {
        return this._strokeColor
    },
    _setStrokeStyle: function (a) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var b = this._strokeColor;
        if (b.r !== a.r || b.g !== a.g || b.b !== a.b) b.r = a.r, b.g = a.g, b.b = a.b, this._setColorsString(), this._needUpdateTexture = !0
    },
    _getLineWidth: function () {
        return this._strokeSize
    },
    _setLineWidth: function (a) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        this._strokeSize !== a && (this._strokeSize = a || 0, this._needUpdateTexture = !0)
    },
    disableStroke: function () {
        this._strokeEnabled && (this._strokeEnabled = !1, this._needUpdateTexture = !0)
    },
    setFontFillColor: null,
    _setFontFillColorForCanvas: function (a) {
        var b = this._textFillColor;
        if (b.r != a.r || b.g != a.g || b.b != a.b) b.r = a.r, b.g = a.g, b.b = a.b, this._setColorsString(), this._needUpdateTexture = !0
    },
    _setFontFillColorForWebGL: function (a) {
        var b =
            this._textFillColor;
        if (b.r != a.r || b.g != a.g || b.b != a.b) b.r = a.r, b.g = a.g, b.b = a.b, this._setColorsString(), this._needUpdateTexture = !0
    },
    _getFillStyle: function () {
        return this._textFillColor
    },
    _updateWithTextDefinition: function (a, b) {
        a.fontDimensions ? (this._dimensions.width = a.boundingWidth, this._dimensions.height = a.boundingHeight) : (this._dimensions.width = 0, this._dimensions.height = 0);
        this._hAlignment = a.textAlign;
        this._vAlignment = a.verticalAlign;
        this._fontName = a.fontName;
        this._fontSize = a.fontSize || 12;
        this._fontStyleStr =
            this._fontSize + "px '" + this._fontName + "'";
        this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize);
        a.shadowEnabled && this.enableShadow(a.shadowOffsetX, a.shadowOffsetY, a.shadowOpacity, a.shadowBlur);
        a.strokeEnabled && this.enableStroke(a.strokeStyle, a.lineWidth);
        this.setFontFillColor(a.fillStyle);
        b && this._updateTexture()
    },
    _prepareTextDefinition: function (a) {
        var b = new cc.FontDefinition;
        a ? (b.fontSize = this._fontSize, b.boundingWidth = cc.CONTENT_SCALE_FACTOR() * this._dimensions.width,
            b.boundingHeight = cc.CONTENT_SCALE_FACTOR() * this._dimensions.height) : (b.fontSize = this._fontSize, b.boundingWidth = this._dimensions.width, b.boundingHeight = this._dimensions.height);
        b.fontName = this._fontName;
        b.textAlign = this._hAlignment;
        b.verticalAlign = this._vAlignment;
        if (this._strokeEnabled) {
            b.strokeEnabled = !0;
            var c = this._strokeColor;
            b.strokeStyle = cc.color(c.r, c.g, c.b);
            b.lineWidth = this._strokeSize
        } else b.strokeEnabled = !1;
        this._shadowEnabled ? (b.shadowEnabled = !0, b.shadowBlur = this._shadowBlur, b.shadowOpacity =
            this._shadowOpacity, b.shadowOffsetX = (a ? cc.CONTENT_SCALE_FACTOR() : 1) * this._shadowOffset.x, b.shadowOffsetY = (a ? cc.CONTENT_SCALE_FACTOR() : 1) * this._shadowOffset.y) : b._shadowEnabled = !1;
        a = this._textFillColor;
        b.fillStyle = cc.color(a.r, a.g, a.b);
        return b
    },
    _fontClientHeight: 18,
    setString: function (a) {
        a = String(a);
        this._originalText != a && (this._originalText = a + "", this._updateString(), this._needUpdateTexture = !0)
    },
    _updateString: function () {
        this._string = this._originalText
    },
    setHorizontalAlignment: function (a) {
        a !== this._hAlignment &&
            (this._hAlignment = a, this._needUpdateTexture = !0)
    },
    setVerticalAlignment: function (a) {
        a != this._vAlignment && (this._vAlignment = a, this._needUpdateTexture = !0)
    },
    setDimensions: function (a) {
        if (a.width != this._dimensions.width || a.height != this._dimensions.height) this._dimensions = a, this._updateString(), this._needUpdateTexture = !0
    },
    _getBoundingWidth: function () {
        return this._dimensions.width
    },
    _setBoundingWidth: function (a) {
        a != this._dimensions.width && (this._dimensions.width = a, this._updateString(), this._needUpdateTexture = !0)
    },
    _getBoundingHeight: function () {
        return this._dimensions.height
    },
    _setBoundingHeight: function (a) {
        a != this._dimensions.height && (this._dimensions.height = a, this._updateString(), this._needUpdateTexture = !0)
    },
    setFontSize: function (a) {
        this._fontSize !== a && (this._fontSize = a, this._fontStyleStr = a + "px '" + this._fontName + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, a), this._needUpdateTexture = !0)
    },
    setFontName: function (a) {
        this._fontName && this._fontName != a && (this._fontName = a, this._fontStyleStr =
            this._fontSize + "px '" + a + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(a, this._fontSize), this._needUpdateTexture = !0)
    },
    _getFont: function () {
        return this._fontStyleStr
    },
    _setFont: function (a) {
        var b = cc.LabelTTF._fontStyleRE.exec(a);
        b && (this._fontSize = parseInt(b[1]), this._fontName = b[2], this._fontStyleStr = a, this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize), this._needUpdateTexture = !0)
    },
    _drawTTFInCanvas: function (a) {
        if (a) {
            var b = this._strokeShadowOffsetX,
                c = this._strokeShadowOffsetY,
                d = this._contentSize.height - c,
                e = this._vAlignment,
                f = this._hAlignment,
                g = this._fontClientHeight,
                h = this._strokeSize;
            a.setTransform(1, 0, 0, 1, 0 + 0.5 * b, d + 0.5 * c);
            a.font != this._fontStyleStr && (a.font = this._fontStyleStr);
            a.fillStyle = this._fillColorStr;
            var k = c = 0,
                m = this._strokeEnabled;
            m && (a.lineWidth = 2 * h, a.strokeStyle = this._strokeColorStr);
            this._shadowEnabled && (h = this._shadowOffset, a.shadowColor = this._shadowColorStr, a.shadowOffsetX = h.x, a.shadowOffsetY = -h.y, a.shadowBlur = this._shadowBlur);
            a.textBaseline = cc.LabelTTF._textBaseline[e];
            a.textAlign = cc.LabelTTF._textAlign[f];
            b = this._contentSize.width - b;
            c = f === cc.TEXT_ALIGNMENT_RIGHT ? c + b : f === cc.TEXT_ALIGNMENT_CENTER ? c + b / 2 : c + 0;
            if (this._isMultiLine)
                for (f = this._strings.length, e === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? k = g + d - g * f : e === cc.VERTICAL_TEXT_ALIGNMENT_CENTER && (k = g / 2 + (d - g * f) / 2), e = 0; e < f; e++) b = this._strings[e], h = -d + g * e + k, m && a.strokeText(b, c, h), a.fillText(b, c, h);
            else e !== cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM && (k = e === cc.VERTICAL_TEXT_ALIGNMENT_TOP ? k - d : k - 0.5 * d), m && a.strokeText(this._string, c,
                k), a.fillText(this._string, c, k)
        }
    },
    _getLabelContext: function () {
        if (this._labelContext) return this._labelContext;
        if (!this._labelCanvas) {
            var a = document.createElement("canvas"),
                b = new cc.Texture2D;
            b.initWithElement(a);
            this.texture = b;
            this._labelCanvas = a
        }
        return this._labelContext = this._labelCanvas.getContext("2d")
    },
    _updateTTF: function () {
        var a = this._dimensions.width,
            b, c, d = this._lineWidths;
        d.length = 0;
        this._isMultiLine = !1;
        this._measureConfig();
        if (0 !== a) {
            var e = this._string;
            this._strings = [];
            b = 0;
            for (c = this._string.length; b <
                c;) {
                var f = this._checkNextline(e.substr(b), a),
                    g = e.substr(b, f);
                this._strings.push(g);
                b += f
            }
        } else
            for (this._strings = this._string.split("\n"), b = 0, c = this._strings.length; b < c; b++) d.push(this._measure(this._strings[b]));
        0 < this._strings.length && (this._isMultiLine = !0);
        c = b = 0;
        this._strokeEnabled && (b = c = 2 * this._strokeSize);
        this._shadowEnabled && (e = this._shadowOffset, b += 2 * Math.abs(e.x), c += 2 * Math.abs(e.y));
        a = 0 === a ? this._isMultiLine ? cc.size(0 | Math.max.apply(Math, d) + b, 0 | this._fontClientHeight * this._strings.length + c) :
            cc.size(0 | this._measure(this._string) + b, 0 | this._fontClientHeight + c) : 0 === this._dimensions.height ? this._isMultiLine ? cc.size(0 | a + b, 0 | this._fontClientHeight * this._strings.length + c) : cc.size(0 | a + b, 0 | this._fontClientHeight + c) : cc.size(0 | a + b, 0 | this._dimensions.height + c);
        this.setContentSize(a);
        this._strokeShadowOffsetX = b;
        this._strokeShadowOffsetY = c;
        d = this._anchorPoint;
        this._anchorPointInPoints.x = 0.5 * b + (a.width - b) * d.x;
        this._anchorPointInPoints.y = 0.5 * c + (a.height - c) * d.y
    },
    getContentSize: function () {
        this._needUpdateTexture &&
            this._updateTTF();
        return cc.Sprite.prototype.getContentSize.call(this)
    },
    _getWidth: function () {
        this._needUpdateTexture && this._updateTTF();
        return cc.Sprite.prototype._getWidth.call(this)
    },
    _getHeight: function () {
        this._needUpdateTexture && this._updateTTF();
        return cc.Sprite.prototype._getHeight.call(this)
    },
    _updateTexture: function () {
        var a = this._getLabelContext(),
            b = this._labelCanvas,
            c = this._contentSize;
        if (0 === this._string.length) return b.width = 1, b.height = c.height, this.setTextureRect(cc.rect(0, 0, 1, c.height)), !0;
        a.font = this._fontStyleStr;
        this._updateTTF();
        var d = c.width,
            c = c.height,
            e = b.width == d && b.height == c;
        b.width = d;
        b.height = c;
        e && a.clearRect(0, 0, d, c);
        this._drawTTFInCanvas(a);
        this._texture.handleLoadedTexture();
        this.setTextureRect(cc.rect(0, 0, d, c));
        return !0
    },
    visit: function (a) {
        this._string && "" != this._string && (this._needUpdateTexture && (this._needUpdateTexture = !1, this._updateTexture()), cc.Sprite.prototype.visit.call(this, a || cc._renderContext))
    },
    draw: null,
    _drawForWebGL: function (a) {
        if (this._string && "" != this._string) {
            a =
                a || cc._renderContext;
            var b = this._texture;
            b && b._isLoaded && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2D(b), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (a.bufferData(a.ARRAY_BUFFER, this._quad.arrayBuffer, a.STATIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 24, 16), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.drawArrays(a.TRIANGLE_STRIP, 0, 4));
            if (1 === cc.SPRITE_DEBUG_DRAW) a = this._quad, a = [cc.p(a.tl.vertices.x, a.tl.vertices.y), cc.p(a.bl.vertices.x, a.bl.vertices.y), cc.p(a.br.vertices.x, a.br.vertices.y), cc.p(a.tr.vertices.x, a.tr.vertices.y)], cc._drawingUtil.drawPoly(a, 4, !0);
            else if (2 === cc.SPRITE_DEBUG_DRAW) {
                a = this.getTextureRect()._size;
                var b = this.offsetX,
                    c = this.offsetY;
                a = [cc.p(b, c), cc.p(b + a.width, c), cc.p(b + a.width, c + a.height), cc.p(b, c + a.height)];
                cc._drawingUtil.drawPoly(a, 4, !0)
            }
            cc.g_NumberOfDraws++
        }
    },
    _setTextureRectForCanvas: function (a, b, c) {
        this._rectRotated = b || !1;
        this.setContentSize(c || a);
        this.setVertexRect(a);
        b = this._textureRect_Canvas;
        b.x = a.x;
        b.y = a.y;
        b.width = a.width;
        b.height = a.height;
        b.validRect = !(0 === b.width || 0 === b.height || 0 > b.x || 0 > b.y);
        a = this._unflippedOffsetPositionFromCenter;
        this._flippedX && (a.x = -a.x);
        this._flippedY && (a.y = -a.y);
        this._offsetPosition.x =
            a.x + (this._contentSize.width - this._rect.width) / 2;
        this._offsetPosition.y = a.y + (this._contentSize.height - this._rect.height) / 2;
        this._batchNode && (this.dirty = !0)
    },
    _setTextureCoords: function (a) {
        var b = this._batchNode ? this.textureAtlas.texture : this._texture;
        if (b) {
            var c = b.pixelsWidth,
                d = b.pixelsHeight,
                e, f = this._quad;
            this._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (b = (2 * a.x + 1) / (2 * c), c = b + (2 * a.height - 2) / (2 * c), e = (2 * a.y + 1) / (2 * d), a = e + (2 * a.width - 2) / (2 * d)) : (b = a.x / c, c = (a.x + a.height) / c, e = a.y / d, a = (a.y + a.width) /
                d), this._flippedX && (d = e, e = a, a = d), this._flippedY && (d = b, b = c, c = d), f.bl.texCoords.u = b, f.bl.texCoords.v = e, f.br.texCoords.u = b, f.br.texCoords.v = a, f.tl.texCoords.u = c, f.tl.texCoords.v = e, f.tr.texCoords.u = c, f.tr.texCoords.v = a) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (b = (2 * a.x + 1) / (2 * c), c = b + (2 * a.width - 2) / (2 * c), e = (2 * a.y + 1) / (2 * d), a = e + (2 * a.height - 2) / (2 * d)) : (b = a.x / c, c = (a.x + a.width) / c, e = a.y / d, a = (a.y + a.height) / d), this._flippedX && (d = b, b = c, c = d), this._flippedY && (d = e, e = a, a = d), f.bl.texCoords.u = b, f.bl.texCoords.v = a, f.br.texCoords.u =
                c, f.br.texCoords.v = a, f.tl.texCoords.u = b, f.tl.texCoords.v = e, f.tr.texCoords.u = c, f.tr.texCoords.v = e);
            this._quadDirty = !0
        }
    }
});
window._p = cc.LabelTTF.prototype;
cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.setColor = cc.Sprite.prototype.setColor, _p._setColorsString = _p._setColorsStringForWebGL, _p.updateDisplayedColor = cc.Sprite.prototype.updateDisplayedColor, _p.setOpacity = cc.Sprite.prototype.setOpacity, _p.updateDisplayedOpacity = cc.Sprite.prototype.updateDisplayedOpacity, _p.initWithStringAndTextDefinition = _p._initWithStringAndTextDefinitionForWebGL, _p.setFontFillColor = _p._setFontFillColorForWebGL, _p.draw = _p._drawForWebGL, _p.setTextureRect = cc.Sprite.prototype._setTextureRectForWebGL) :
    (_p.setColor = _p._setColorForCanvas, _p._setColorsString = _p._setColorsStringForCanvas, _p.updateDisplayedColor = _p._updateDisplayedColorForCanvas, _p.setOpacity = _p._setOpacityForCanvas, _p.updateDisplayedOpacity = _p._updateDisplayedOpacityForCanvas, _p.initWithStringAndTextDefinition = _p._initWithStringAndTextDefinitionForCanvas, _p.setFontFillColor = _p._setFontFillColorForCanvas, _p.draw = cc.Sprite.prototype.draw, _p.setTextureRect = _p._setTextureRectForCanvas);
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "textAlign", _p.getHorizontalAlignment, _p.setHorizontalAlignment);
cc.defineGetterSetter(_p, "verticalAlign", _p.getVerticalAlignment, _p.setVerticalAlignment);
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont);
cc.defineGetterSetter(_p, "boundingWidth", _p._getBoundingWidth, _p._setBoundingWidth);
cc.defineGetterSetter(_p, "boundingHeight", _p._getBoundingHeight, _p._setBoundingHeight);
cc.defineGetterSetter(_p, "fillStyle", _p._getFillStyle, _p.setFontFillColor);
cc.defineGetterSetter(_p, "strokeStyle", _p._getStrokeStyle, _p._setStrokeStyle);
cc.defineGetterSetter(_p, "lineWidth", _p._getLineWidth, _p._setLineWidth);
cc.defineGetterSetter(_p, "shadowOffsetX", _p._getShadowOffsetX, _p._setShadowOffsetX);
cc.defineGetterSetter(_p, "shadowOffsetY", _p._getShadowOffsetY, _p._setShadowOffsetY);
cc.defineGetterSetter(_p, "shadowOpacity", _p._getShadowOpacity, _p._setShadowOpacity);
cc.defineGetterSetter(_p, "shadowBlur", _p._getShadowBlur, _p._setShadowBlur);
delete window._p;
cc.LabelTTF._textAlign = ["left", "center", "right"];
cc.LabelTTF._textBaseline = ["top", "middle", "bottom"];
cc.LabelTTF._checkRegEx = /(.+?)([\s\n\r\-\/\\\:]|[\u4E00-\u9FA5]|[\uFE30-\uFFA0])/;
cc.LabelTTF._reverseCheckRegEx = /(.*)([\s\n\r\-\/\\\:]|[\u4E00-\u9FA5]|[\uFE30-\uFFA0])/;
cc.LabelTTF._checkEnRegEx = /[\s\-\/\\\:]/;
cc.LabelTTF._fontStyleRE = /^(\d+)px\s+['"]?([\w\s\d]+)['"]?$/;
cc.LabelTTF.create = function (a, b, c, d, e, f) {
    var g = new cc.LabelTTF;
    return b && b instanceof cc.FontDefinition && g.initWithStringAndTextDefinition(a, b) || g.initWithString(a, b, c, d, e, f) ? g : null
};
cc.LabelTTF._SHADER_PROGRAM = cc.USE_LA88_LABELS ? cc.SHADER_POSITION_TEXTURECOLOR : cc.SHADER_POSITION_TEXTUREA8COLOR;
cc.LabelTTF.__labelHeightDiv = document.createElement("div");
cc.LabelTTF.__labelHeightDiv.style.fontFamily = "Arial";
cc.LabelTTF.__labelHeightDiv.style.position = "absolute";
cc.LabelTTF.__labelHeightDiv.style.left = "-100px";
cc.LabelTTF.__labelHeightDiv.style.top = "-100px";
cc.LabelTTF.__labelHeightDiv.style.lineHeight = "normal";
document.body.appendChild(cc.LabelTTF.__labelHeightDiv);
cc.LabelTTF.__getFontHeightByDiv = function (a, b) {
    var c = cc.LabelTTF.__fontHeightCache[a + "." + b];
    if (0 < c) return c;
    var d = cc.LabelTTF.__labelHeightDiv;
    d.innerHTML = "ajghl~!";
    d.style.fontFamily = a;
    d.style.fontSize = b + "px";
    c = d.clientHeight;
    cc.LabelTTF.__fontHeightCache[a + "." + b] = c;
    d.innerHTML = "";
    return c
};
cc.LabelTTF.__fontHeightCache = {};
cc.HashElement = cc.Class.extend({
    actions: null,
    target: null,
    actionIndex: 0,
    currentAction: null,
    currentActionSalvaged: !1,
    paused: !1,
    hh: null,
    ctor: function () {
        this.actions = [];
        this.target = null;
        this.actionIndex = 0;
        this.currentAction = null;
        this.paused = this.currentActionSalvaged = !1;
        this.hh = null
    }
});
cc.ActionManager = cc.Class.extend({
    _hashTargets: null,
    _arrayTargets: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _searchElementByTarget: function (a, b) {
        for (var c = 0; c < a.length; c++)
            if (b == a[c].target) return a[c];
        return null
    },
    ctor: function () {
        this._hashTargets = {};
        this._arrayTargets = [];
        this._currentTarget = null;
        this._currentTargetSalvaged = !1
    },
    addAction: function (a, b, c) {
        if (!a) throw "cc.ActionManager.addAction(): action must be non-null";
        if (!b) throw "cc.ActionManager.addAction(): action must be non-null";
        var d =
            this._hashTargets[b.__instanceId];
        d || (d = new cc.HashElement, d.paused = c, d.target = b, this._hashTargets[b.__instanceId] = d, this._arrayTargets.push(d));
        this._actionAllocWithHashElement(d);
        d.actions.push(a);
        a.startWithTarget(b)
    },
    removeAllActions: function () {
        for (var a = this._arrayTargets, b = 0; b < a.length; b++) {
            var c = a[b];
            c && this.removeAllActionsFromTarget(c.target, !0)
        }
    },
    removeAllActionsFromTarget: function (a, b) {
        if (null != a) {
            var c = this._hashTargets[a.__instanceId];
            c && (-1 === c.actions.indexOf(c.currentAction) || c.currentActionSalvaged ||
                (c.currentActionSalvaged = !0), c.actions.length = 0, this._currentTarget != c || b ? this._deleteHashElement(c) : this._currentTargetSalvaged = !0)
        }
    },
    removeAction: function (a) {
        if (null != a) {
            var b = a.getOriginalTarget();
            if (b = this._hashTargets[b.__instanceId])
                for (var c = 0; c < b.actions.length; c++) {
                    if (b.actions[c] == a) {
                        b.actions.splice(c, 1);
                        break
                    }
                } else cc.log("cocos2d: removeAction: Target not found")
        }
    },
    removeActionByTag: function (a, b) {
        a == cc.ACTION_TAG_INVALID && cc.log("cc.ActionManager.removeActionByTag(): an invalid tag");
        if (!b) throw "cc.ActionManager.removeActionByTag(): target must be non-null";
        var c = this._hashTargets[b.__instanceId];
        if (c)
            for (var d = c.actions.length, e = 0; e < d; ++e) {
                var f = c.actions[e];
                if (f && f.getTag() === a && f.getOriginalTarget() == b) {
                    this._removeActionAtIndex(e, c);
                    break
                }
            }
    },
    getActionByTag: function (a, b) {
        a == cc.ACTION_TAG_INVALID && cc.log("cc.ActionManager.getActionByTag(): an invalid tag");
        var c = this._hashTargets[b.__instanceId];
        if (c) {
            if (null != c.actions)
                for (var d = 0; d < c.actions.length; ++d) {
                    var e = c.actions[d];
                    if (e && e.getTag() === a) return e
                }
            cc.log("cocos2d : getActionByTag(tag \x3d" + a + "): Action not found")
        }
        return null
    },
    numberOfRunningActionsInTarget: function (a) {
        return (a = this._hashTargets[a.__instanceId]) ? a.actions ? a.actions.length : 0 : 0
    },
    pauseTarget: function (a) {
        if (a = this._hashTargets[a.__instanceId]) a.paused = !0
    },
    resumeTarget: function (a) {
        if (a = this._hashTargets[a.__instanceId]) a.paused = !1
    },
    pauseAllRunningActions: function () {
        for (var a = [], b = this._arrayTargets, c = 0; c < b.length; c++) {
            var d = b[c];
            d && !d.paused && (d.paused = !0, a.push(d.target))
        }
        return a
    },
    resumeTargets: function (a) {
        if (a)
            for (var b = 0; b < a.length; b++) a[b] && this.resumeTarget(a[b])
    },
    purgeSharedManager: function () {
        cc.director.getScheduler().unscheduleUpdateForTarget(this)
    },
    _removeActionAtIndex: function (a, b) {
        b.actions[a] != b.currentAction || b.currentActionSalvaged || (b.currentActionSalvaged = !0);
        b.actions.splice(a, 1);
        b.actionIndex >= a && b.actionIndex--;
        0 == b.actions.length && (this._currentTarget == b ? this._currentTargetSalvaged = !0 : this._deleteHashElement(b))
    },
    _deleteHashElement: function (a) {
        a &&
            (delete this._hashTargets[a.target.__instanceId], cc.arrayRemoveObject(this._arrayTargets, a), a.actions = null, a.target = null)
    },
    _actionAllocWithHashElement: function (a) {
        null == a.actions && (a.actions = [])
    },
    update: function (a) {
        for (var b = this._arrayTargets, c, d = 0; d < b.length; d++) {
            c = this._currentTarget = b[d];
            if (!c.paused)
                for (c.actionIndex = 0; c.actionIndex < c.actions.length; c.actionIndex++)
                    if (c.currentAction = c.actions[c.actionIndex], c.currentAction) {
                        c.currentActionSalvaged = !1;
                        c.currentAction.step(a);
                        if (c.currentActionSalvaged) c.currentAction =
                            null;
                        else if (c.currentAction.isDone()) {
                            c.currentAction.stop();
                            var e = c.currentAction;
                            c.currentAction = null;
                            this.removeAction(e)
                        }
                        c.currentAction = null
                    }
            this._currentTargetSalvaged && 0 === c.actions.length && this._deleteHashElement(c)
        }
    }
});
cc.kmScalar = Number;
cc.kmBool = Number;
cc.kmEnum = Number;
cc.KM_FALSE = 0;
cc.KM_TRUE = 1;
cc.kmPI = 3.141592;
cc.kmPIOver180 = 0.017453;
cc.kmPIUnder180 = 57.295779;
cc.kmEpsilon = 0.015625;
cc.kmSQR = function (a) {
    return a * a
};
cc.kmDegreesToRadians = function (a) {
    return a * cc.kmPIOver180
};
cc.kmRadiansToDegrees = function (a) {
    return a * cc.kmPIUnder180
};
cc.kmMin = function (a, b) {
    return a < b ? a : b
};
cc.kmMax = function (a, b) {
    return a > b ? a : b
};
cc.kmAlmostEqual = function (a, b) {
    return a + cc.kmEpsilon > b && a - cc.kmEpsilon < b
};
cc.kmVec2 = function (a, b) {
    this.x = a || 0;
    this.y = b || 0
};
cc.kmVec2Fill = function (a, b, c) {
    a.x = b;
    a.y = c;
    return a
};
cc.kmVec2Length = function (a) {
    return Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y))
};
cc.kmVec2LengthSq = function (a) {
    return cc.kmSQR(a.x) + cc.kmSQR(a.y)
};
cc.kmVec2Normalize = function (a, b) {
    var c = 1 / cc.kmVec2Length(b),
        d = new cc.kmVec2;
    d.x = b.x * c;
    d.y = b.y * c;
    a.x = d.x;
    a.y = d.y;
    return a
};
cc.kmVec2Add = function (a, b, c) {
    a.x = b.x + c.x;
    a.y = b.y + c.y;
    return a
};
cc.kmVec2Dot = function (a, b) {
    return a.x * b.x + a.y * b.y
};
cc.kmVec2Subtract = function (a, b, c) {
    a.x = b.x - c.x;
    a.y = b.y - c.y;
    return a
};
cc.kmVec2Transform = function (a, b, c) {
    var d = new cc.kmVec2;
    d.x = b.x * c.mat[0] + b.y * c.mat[3] + c.mat[6];
    d.y = b.x * c.mat[1] + b.y * c.mat[4] + c.mat[7];
    a.x = d.x;
    a.y = d.y;
    return a
};
cc.kmVec2TransformCoord = function (a, b, c) {
    return null
};
cc.kmVec2Scale = function (a, b, c) {
    a.x = b.x * c;
    a.y = b.y * c;
    return a
};
cc.kmVec2AreEqual = function (a, b) {
    return a.x < b.x + cc.kmEpsilon && a.x > b.x - cc.kmEpsilon && a.y < b.y + cc.kmEpsilon && a.y > b.y - cc.kmEpsilon
};
cc.kmVec3 = function (a, b, c) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0
};
cc.kmVec3Fill = function (a, b, c, d) {
    if (!a) return new cc.kmVec3(b, c, d);
    a.x = b;
    a.y = c;
    a.z = d;
    return a
};
cc.kmVec3Length = function (a) {
    return Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z))
};
cc.kmVec3LengthSq = function (a) {
    return cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z)
};
cc.kmVec3Normalize = function (a, b) {
    var c = 1 / cc.kmVec3Length(b);
    a.x = b.x * c;
    a.y = b.y * c;
    a.z = b.z * c;
    return a
};
cc.kmVec3Cross = function (a, b, c) {
    a.x = b.y * c.z - b.z * c.y;
    a.y = b.z * c.x - b.x * c.z;
    a.z = b.x * c.y - b.y * c.x;
    return a
};
cc.kmVec3Dot = function (a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z
};
cc.kmVec3Add = function (a, b, c) {
    a.x = b.x + c.x;
    a.y = b.y + c.y;
    a.z = b.z + c.z;
    return a
};
cc.kmVec3Subtract = function (a, b, c) {
    a.x = b.x - c.x;
    a.y = b.y - c.y;
    a.z = b.z - c.z;
    return a
};
cc.kmVec3Transform = function (a, b, c) {
    a.x = b.x * c.mat[0] + b.y * c.mat[4] + b.z * c.mat[8] + c.mat[12];
    a.y = b.x * c.mat[1] + b.y * c.mat[5] + b.z * c.mat[9] + c.mat[13];
    a.z = b.x * c.mat[2] + b.y * c.mat[6] + b.z * c.mat[10] + c.mat[14];
    return a
};
cc.kmVec3TransformNormal = function (a, b, c) {
    a.x = b.x * c.mat[0] + b.y * c.mat[4] + b.z * c.mat[8];
    a.y = b.x * c.mat[1] + b.y * c.mat[5] + b.z * c.mat[9];
    a.z = b.x * c.mat[2] + b.y * c.mat[6] + b.z * c.mat[10];
    return a
};
cc.kmVec3TransformCoord = function (a, b, c) {
    var d = new cc.kmVec4,
        e = new cc.kmVec4;
    cc.kmVec4Fill(e, b.x, b.y, b.z, 1);
    cc.kmVec4Transform(d, e, c);
    a.x = d.x / d.w;
    a.y = d.y / d.w;
    a.z = d.z / d.w;
    return a
};
cc.kmVec3Scale = function (a, b, c) {
    a.x = b.x * c;
    a.y = b.y * c;
    a.z = b.z * c;
    return a
};
cc.kmVec3AreEqual = function (a, b) {
    return a.x < b.x + cc.kmEpsilon && a.x > b.x - cc.kmEpsilon && a.y < b.y + cc.kmEpsilon && a.y > b.y - cc.kmEpsilon && a.z < b.z + cc.kmEpsilon && a.z > b.z - cc.kmEpsilon ? 1 : 0
};
cc.kmVec3InverseTransform = function (a, b, c) {
    b = new cc.kmVec3(b.x - c.mat[12], b.y - c.mat[13], b.z - c.mat[14]);
    a.x = b.x * c.mat[0] + b.y * c.mat[1] + b.z * c.mat[2];
    a.y = b.x * c.mat[4] + b.y * c.mat[5] + b.z * c.mat[6];
    a.z = b.x * c.mat[8] + b.y * c.mat[9] + b.z * c.mat[10];
    return a
};
cc.kmVec3InverseTransformNormal = function (a, b, c) {
    a.x = b.x * c.mat[0] + b.y * c.mat[1] + b.z * c.mat[2];
    a.y = b.x * c.mat[4] + b.y * c.mat[5] + b.z * c.mat[6];
    a.z = b.x * c.mat[8] + b.y * c.mat[9] + b.z * c.mat[10];
    return a
};
cc.kmVec3Assign = function (a, b) {
    if (a == b) return a;
    a.x = b.x;
    a.y = b.y;
    a.z = b.z;
    return a
};
cc.kmVec3Zero = function (a) {
    a.x = 0;
    a.y = 0;
    a.z = 0;
    return a
};
cc.kmVec3ToTypeArray = function (a) {
    if (!a) return null;
    var b = new Float32Array(3);
    b[0] = a.x;
    b[1] = a.y;
    b[2] = a.z;
    return b
};
cc.kmVec4 = function (a, b, c, d) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0;
    this.w = d || 0
};
cc.kmVec4Fill = function (a, b, c, d, e) {
    a.x = b;
    a.y = c;
    a.z = d;
    a.w = e;
    return a
};
cc.kmVec4Add = function (a, b, c) {
    a.x = b.x + c.x;
    a.y = b.y + c.y;
    a.z = b.z + c.z;
    a.w = b.w + c.w;
    return a
};
cc.kmVec4Dot = function (a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
};
cc.kmVec4Length = function (a) {
    return Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z) + cc.kmSQR(a.w))
};
cc.kmVec4LengthSq = function (a) {
    return cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z) + cc.kmSQR(a.w)
};
cc.kmVec4Lerp = function (a, b, c, d) {
    return a
};
cc.kmVec4Normalize = function (a, b) {
    var c = 1 / cc.kmVec4Length(b);
    a.x *= c;
    a.y *= c;
    a.z *= c;
    a.w *= c;
    return a
};
cc.kmVec4Scale = function (a, b, c) {
    cc.kmVec4Normalize(a, b);
    a.x *= c;
    a.y *= c;
    a.z *= c;
    a.w *= c;
    return a
};
cc.kmVec4Subtract = function (a, b, c) {
    a.x = b.x - c.x;
    a.y = b.y - c.y;
    a.z = b.z - c.z;
    a.w = b.w - c.w;
    return a
};
cc.kmVec4Transform = function (a, b, c) {
    a.x = b.x * c.mat[0] + b.y * c.mat[4] + b.z * c.mat[8] + b.w * c.mat[12];
    a.y = b.x * c.mat[1] + b.y * c.mat[5] + b.z * c.mat[9] + b.w * c.mat[13];
    a.z = b.x * c.mat[2] + b.y * c.mat[6] + b.z * c.mat[10] + b.w * c.mat[14];
    a.w = b.x * c.mat[3] + b.y * c.mat[7] + b.z * c.mat[11] + b.w * c.mat[15];
    return a
};
cc.kmVec4TransformArray = function (a, b, c, d, e, f) {
    for (var g = 0; g < f;) cc.kmVec4Transform(a + g * b, c + g * d, e), ++g;
    return a
};
cc.kmVec4AreEqual = function (a, b) {
    return a.x < b.x + cc.kmEpsilon && a.x > b.x - cc.kmEpsilon && a.y < b.y + cc.kmEpsilon && a.y > b.y - cc.kmEpsilon && a.z < b.z + cc.kmEpsilon && a.z > b.z - cc.kmEpsilon && a.w < b.w + cc.kmEpsilon && a.w > b.w - cc.kmEpsilon
};
cc.kmVec4Assign = function (a, b) {
    if (a == b) return cc.log("destVec and srcVec are same object"), a;
    a.x = b.x;
    a.y = b.y;
    a.z = b.z;
    a.w = b.w;
    return a
};
cc.kmVec4ToTypeArray = function (a) {
    if (!a) return null;
    var b = new Float32Array(4);
    b[0] = a.x;
    b[1] = a.y;
    b[2] = a.z;
    b[3] = a.w;
    return b
};
cc.kmRay2 = function (a, b) {
    this.start = a || new cc.kmVec2;
    this.start = a || new cc.kmVec2
};
cc.kmRay2Fill = function (a, b, c, d, e) {
    a.start.x = b;
    a.start.y = c;
    a.dir.x = d;
    a.dir.y = e
};
cc.kmRay2IntersectLineSegment = function (a, b, c, d) {
    var e = a.start.x,
        f = a.start.y,
        g = a.start.x + a.dir.x;
    a = a.start.y + a.dir.y;
    var h = b.x,
        k = b.y,
        m = c.x,
        n = c.y,
        p = (n - k) * (g - e) - (m - h) * (a - f);
    if (p > -cc.kmEpsilon && p < cc.kmEpsilon) return cc.KM_FALSE;
    k = ((m - h) * (f - k) - (n - k) * (e - h)) / p;
    h = e + k * (g - e);
    k = f + k * (a - f);
    if (h < cc.kmMin(b.x, c.x) - cc.kmEpsilon || h > cc.kmMax(b.x, c.x) + cc.kmEpsilon || k < cc.kmMin(b.y, c.y) - cc.kmEpsilon || k > cc.kmMax(b.y, c.y) + cc.kmEpsilon || h < cc.kmMin(e, g) - cc.kmEpsilon || h > cc.kmMax(e, g) + cc.kmEpsilon || k < cc.kmMin(f, a) - cc.kmEpsilon ||
        k > cc.kmMax(f, a) + cc.kmEpsilon) return cc.KM_FALSE;
    d.x = h;
    d.y = k;
    return cc.KM_TRUE
};
cc.calculate_line_normal = function (a, b, c) {
    var d = new cc.kmVec2;
    cc.kmVec2Subtract(d, b, a);
    c.x = -d.y;
    c.y = d.x;
    cc.kmVec2Normalize(c, c)
};
cc.kmRay2IntersectTriangle = function (a, b, c, d, e, f) {
    var g = new cc.kmVec2,
        h = new cc.kmVec2,
        k = new cc.kmVec2,
        m = 1E4,
        n = cc.KM_FALSE,
        p;
    cc.kmRay2IntersectLineSegment(a, b, c, g) && (p = new cc.kmVec2, n = cc.KM_TRUE, p = cc.kmVec2Length(cc.kmVec2Subtract(p, g, a.start)), p < m && (h.x = g.x, h.y = g.y, m = p, cc.calculate_line_normal(b, c, k)));
    cc.kmRay2IntersectLineSegment(a, c, d, g) && (p = new cc.kmVec2, n = cc.KM_TRUE, p = cc.kmVec2Length(cc.kmVec2Subtract(p, g, a.start)), p < m && (h.x = g.x, h.y = g.y, m = p, cc.calculate_line_normal(c, d, k)));
    cc.kmRay2IntersectLineSegment(a,
        d, b, g) && (p = new cc.kmVec2, n = cc.KM_TRUE, p = cc.kmVec2Length(cc.kmVec2Subtract(p, g, a.start)), p < m && (h.x = g.x, h.y = g.y, cc.calculate_line_normal(d, b, k)));
    n && (e.x = h.x, e.y = h.y, f && (f.x = k.x, f.y = k.y));
    return n
};
cc.kmRay2IntersectCircle = function (a, b, c, d) {
    cc.log("cc.kmRay2IntersectCircle() has not been implemented.")
};
var Float32Array = Float32Array || Array;
cc.kmMat3 = function () {
    this.mat = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0])
};
cc.kmMat3Fill = function (a, b) {
    for (var c = 0; 9 > c; c++) a.mat[c] = b;
    return a
};
cc.kmMat3Adjugate = function (a, b) {
    a.mat[0] = b.mat[4] * b.mat[8] - b.mat[5] * b.mat[7];
    a.mat[1] = b.mat[2] * b.mat[7] - b.mat[1] * b.mat[8];
    a.mat[2] = b.mat[1] * b.mat[5] - b.mat[2] * b.mat[4];
    a.mat[3] = b.mat[5] * b.mat[6] - b.mat[3] * b.mat[8];
    a.mat[4] = b.mat[0] * b.mat[8] - b.mat[2] * b.mat[6];
    a.mat[5] = b.mat[2] * b.mat[3] - b.mat[0] * b.mat[5];
    a.mat[6] = b.mat[3] * b.mat[7] - b.mat[4] * b.mat[6];
    a.mat[8] = b.mat[0] * b.mat[4] - b.mat[1] * b.mat[3];
    return a
};
cc.kmMat3Identity = function (a) {
    a.mat[1] = a.mat[2] = a.mat[3] = a.mat[5] = a.mat[6] = a.mat[7] = 0;
    a.mat[0] = a.mat[4] = a.mat[8] = 1;
    return a
};
cc.kmMat3Inverse = function (a, b, c) {
    var d = new cc.kmMat3;
    if (0 === b) return null;
    b = 1 / b;
    cc.kmMat3Adjugate(d, c);
    cc.kmMat3ScalarMultiply(a, d, b);
    return a
};
cc.kmMat3._identity = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
cc.kmMat3IsIdentity = function (a) {
    for (var b = 0; 9 > b; b++)
        if (cc.kmMat3._identity[b] !== a.mat[b]) return !1;
    return !0
};
cc.kmMat3Transpose = function (a, b) {
    var c, d;
    for (c = 0; 3 > c; ++c)
        for (d = 0; 3 > d; ++d) a.mat[3 * c + d] = b.mat[3 * d + c];
    return a
};
cc.kmMat3Determinant = function (a) {
    var b;
    b = a.mat[0] * a.mat[4] * a.mat[8] + a.mat[1] * a.mat[5] * a.mat[6] + a.mat[2] * a.mat[3] * a.mat[7];
    return b -= a.mat[2] * a.mat[4] * a.mat[6] + a.mat[0] * a.mat[5] * a.mat[7] + a.mat[1] * a.mat[3] * a.mat[8]
};
cc.kmMat3Multiply = function (a, b, c) {
    b = b.mat;
    c = c.mat;
    a.mat[0] = b[0] * c[0] + b[3] * c[1] + b[6] * c[2];
    a.mat[1] = b[1] * c[0] + b[4] * c[1] + b[7] * c[2];
    a.mat[2] = b[2] * c[0] + b[5] * c[1] + b[8] * c[2];
    a.mat[3] = b[0] * c[3] + b[3] * c[4] + b[6] * c[5];
    a.mat[4] = b[1] * c[3] + b[4] * c[4] + b[7] * c[5];
    a.mat[5] = b[2] * c[3] + b[5] * c[4] + b[8] * c[5];
    a.mat[6] = b[0] * c[6] + b[3] * c[7] + b[6] * c[8];
    a.mat[7] = b[1] * c[6] + b[4] * c[7] + b[7] * c[8];
    a.mat[8] = b[2] * c[6] + b[5] * c[7] + b[8] * c[8];
    return a
};
cc.kmMat3ScalarMultiply = function (a, b, c) {
    for (var d = 0; 9 > d; d++) a.mat[d] = b.mat[d] * c;
    return a
};
cc.kmMat3RotationAxisAngle = function (a, b, c) {
    var d = Math.cos(c);
    c = Math.sin(c);
    a.mat[0] = d + b.x * b.x * (1 - d);
    a.mat[1] = b.z * c + b.y * b.x * (1 - d);
    a.mat[2] = -b.y * c + b.z * b.x * (1 - d);
    a.mat[3] = -b.z * c + b.x * b.y * (1 - d);
    a.mat[4] = d + b.y * b.y * (1 - d);
    a.mat[5] = b.x * c + b.z * b.y * (1 - d);
    a.mat[6] = b.y * c + b.x * b.z * (1 - d);
    a.mat[7] = -b.x * c + b.y * b.z * (1 - d);
    a.mat[8] = d + b.z * b.z * (1 - d);
    return a
};
cc.kmMat3Assign = function (a, b) {
    if (a == b) return cc.log("cc.kmMat3Assign(): pOut equals pIn"), a;
    for (var c = 0; 9 > c; c++) a.mat[c] = b.mat[c];
    return a
};
cc.kmMat3AreEqual = function (a, b) {
    if (a == b) return !0;
    for (var c = 0; 9 > c; ++c)
        if (!(a.mat[c] + cc.kmEpsilon > b.mat[c] && a.mat[c] - cc.kmEpsilon < b.mat[c])) return !1;
    return !0
};
cc.kmMat3RotationX = function (a, b) {
    a.mat[0] = 1;
    a.mat[1] = 0;
    a.mat[2] = 0;
    a.mat[3] = 0;
    a.mat[4] = Math.cos(b);
    a.mat[5] = Math.sin(b);
    a.mat[6] = 0;
    a.mat[7] = -Math.sin(b);
    a.mat[8] = Math.cos(b);
    return a
};
cc.kmMat3RotationY = function (a, b) {
    a.mat[0] = Math.cos(b);
    a.mat[1] = 0;
    a.mat[2] = -Math.sin(b);
    a.mat[3] = 0;
    a.mat[4] = 1;
    a.mat[5] = 0;
    a.mat[6] = Math.sin(b);
    a.mat[7] = 0;
    a.mat[8] = Math.cos(b);
    return a
};
cc.kmMat3RotationZ = function (a, b) {
    a.mat[0] = Math.cos(b);
    a.mat[1] = -Math.sin(b);
    a.mat[2] = 0;
    a.mat[3] = Math.sin(b);
    a.mat[4] = Math.cos(b);
    a.mat[5] = 0;
    a.mat[6] = 0;
    a.mat[7] = 0;
    a.mat[8] = 1;
    return a
};
cc.kmMat3Rotation = function (a, b) {
    a.mat[0] = Math.cos(b);
    a.mat[1] = Math.sin(b);
    a.mat[2] = 0;
    a.mat[3] = -Math.sin(b);
    a.mat[4] = Math.cos(b);
    a.mat[5] = 0;
    a.mat[6] = 0;
    a.mat[7] = 0;
    a.mat[8] = 1;
    return a
};
cc.kmMat3Scaling = function (a, b, c) {
    cc.kmMat3Identity(a);
    a.mat[0] = b;
    a.mat[4] = c;
    return a
};
cc.kmMat3Translation = function (a, b, c) {
    cc.kmMat3Identity(a);
    a.mat[6] = b;
    a.mat[7] = c;
    return a
};
cc.kmMat3RotationQuaternion = function (a, b) {
    if (!b || !a) return null;
    a.mat[0] = 1 - 2 * (b.y * b.y + b.z * b.z);
    a.mat[1] = 2 * (b.x * b.y - b.w * b.z);
    a.mat[2] = 2 * (b.x * b.z + b.w * b.y);
    a.mat[3] = 2 * (b.x * b.y + b.w * b.z);
    a.mat[4] = 1 - 2 * (b.x * b.x + b.z * b.z);
    a.mat[5] = 2 * (b.y * b.z - b.w * b.x);
    a.mat[6] = 2 * (b.x * b.z - b.w * b.y);
    a.mat[7] = 2 * (b.y * b.z + b.w * b.x);
    a.mat[8] = 1 - 2 * (b.x * b.x + b.y * b.y);
    return a
};
cc.kmMat3RotationToAxisAngle = function (a, b, c) {
    cc.kmQuaternionRotationMatrix(void 0, c);
    cc.kmQuaternionToAxisAngle(void 0, a, b);
    return a
};
cc.kmMat4 = function () {
    this.mat = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
};
cc.kmMat4Fill = function (a, b) {
    a.mat[0] = a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[5] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[10] = a.mat[11] = a.mat[12] = a.mat[13] = a.mat[14] = a.mat[15] = b
};
cc.kmMat4Identity = function (a) {
    a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = a.mat[12] = a.mat[13] = a.mat[14] = 0;
    a.mat[0] = a.mat[5] = a.mat[10] = a.mat[15] = 1;
    return a
};
cc.kmMat4._get = function (a, b, c) {
    return a.mat[b + 4 * c]
};
cc.kmMat4._set = function (a, b, c, d) {
    a.mat[b + 4 * c] = d
};
cc.kmMat4._swap = function (a, b, c, d, e) {
    var f = cc.kmMat4._get(a, b, c);
    cc.kmMat4._set(a, b, c, cc.kmMat4._get(a, d, e));
    cc.kmMat4._set(a, d, e, f)
};
cc.kmMat4._gaussj = function (a, b) {
    var c, d = 0,
        e = 0,
        f, g, h, k = [0, 0, 0, 0],
        m = [0, 0, 0, 0],
        n = [0, 0, 0, 0];
    for (c = 0; 4 > c; c++) {
        for (f = h = 0; 4 > f; f++)
            if (1 != n[f])
                for (g = 0; 4 > g; g++) 0 == n[g] && Math.abs(cc.kmMat4._get(a, f, g)) >= h && (h = Math.abs(cc.kmMat4._get(a, f, g)), e = f, d = g);
            ++n[d];
        if (e != d) {
            for (f = 0; 4 > f; f++) cc.kmMat4._swap(a, e, f, d, f);
            for (f = 0; 4 > f; f++) cc.kmMat4._swap(b, e, f, d, f)
        }
        m[c] = e;
        k[c] = d;
        if (0 == cc.kmMat4._get(a, d, d)) return cc.KM_FALSE;
        g = 1 / cc.kmMat4._get(a, d, d);
        cc.kmMat4._set(a, d, d, 1);
        for (f = 0; 4 > f; f++) cc.kmMat4._set(a, d, f, cc.kmMat4._get(a,
            d, f) * g);
        for (f = 0; 4 > f; f++) cc.kmMat4._set(b, d, f, cc.kmMat4._get(b, d, f) * g);
        for (g = 0; 4 > g; g++)
            if (g != d) {
                h = cc.kmMat4._get(a, g, d);
                cc.kmMat4._set(a, g, d, 0);
                for (f = 0; 4 > f; f++) cc.kmMat4._set(a, g, f, cc.kmMat4._get(a, g, f) - cc.kmMat4._get(a, d, f) * h);
                for (f = 0; 4 > f; f++) cc.kmMat4._set(b, g, f, cc.kmMat4._get(a, g, f) - cc.kmMat4._get(b, d, f) * h)
            }
    }
    for (f = 3; 0 <= f; f--)
        if (m[f] != k[f])
            for (g = 0; 4 > g; g++) cc.kmMat4._swap(a, g, m[f], g, k[f]);
    return cc.KM_TRUE
};
cc.kmMat4._identity = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
cc.kmMat4Inverse = function (a, b) {
    var c = new cc.kmMat4,
        d = new cc.kmMat4;
    cc.kmMat4Assign(c, b);
    cc.kmMat4Identity(d);
    if (cc.kmMat4._gaussj(c, d) == cc.KM_FALSE) return null;
    cc.kmMat4Assign(a, c);
    return a
};
cc.kmMat4IsIdentity = function (a) {
    for (var b = 0; 16 > b; b++)
        if (cc.kmMat4._identity[b] != a.mat[b]) return !1;
    return !0
};
cc.kmMat4Transpose = function (a, b) {
    var c, d, e = a.mat,
        f = b.mat;
    for (d = 0; 4 > d; ++d)
        for (c = 0; 4 > c; ++c) e[4 * d + c] = f[4 * c + d];
    return a
};
cc.kmMat4Multiply = function (a, b, c) {
    var d = a.mat,
        e = b.mat[0],
        f = b.mat[1],
        g = b.mat[2],
        h = b.mat[3],
        k = b.mat[4],
        m = b.mat[5],
        n = b.mat[6],
        p = b.mat[7],
        r = b.mat[8],
        q = b.mat[9],
        s = b.mat[10],
        t = b.mat[11],
        x = b.mat[12],
        y = b.mat[13],
        B = b.mat[14];
    b = b.mat[15];
    var D = c.mat[0],
        z = c.mat[1],
        w = c.mat[2],
        v = c.mat[3],
        u = c.mat[4],
        A = c.mat[5],
        E = c.mat[6],
        F = c.mat[7],
        G = c.mat[8],
        I = c.mat[9],
        K = c.mat[10],
        J = c.mat[11],
        L = c.mat[12],
        H = c.mat[13],
        M = c.mat[14];
    c = c.mat[15];
    d[0] = D * e + z * k + w * r + v * x;
    d[1] = D * f + z * m + w * q + v * y;
    d[2] = D * g + z * n + w * s + v * B;
    d[3] = D * h + z * p + w * t + v * b;
    d[4] =
        u * e + A * k + E * r + F * x;
    d[5] = u * f + A * m + E * q + F * y;
    d[6] = u * g + A * n + E * s + F * B;
    d[7] = u * h + A * p + E * t + F * b;
    d[8] = G * e + I * k + K * r + J * x;
    d[9] = G * f + I * m + K * q + J * y;
    d[10] = G * g + I * n + K * s + J * B;
    d[11] = G * h + I * p + K * t + J * b;
    d[12] = L * e + H * k + M * r + c * x;
    d[13] = L * f + H * m + M * q + c * y;
    d[14] = L * g + H * n + M * s + c * B;
    d[15] = L * h + H * p + M * t + c * b;
    return a
};
cc.getMat4MultiplyValue = function (a, b) {
    var c = a.mat,
        d = b.mat,
        e = new Float32Array(16);
    e[0] = c[0] * d[0] + c[4] * d[1] + c[8] * d[2] + c[12] * d[3];
    e[1] = c[1] * d[0] + c[5] * d[1] + c[9] * d[2] + c[13] * d[3];
    e[2] = c[2] * d[0] + c[6] * d[1] + c[10] * d[2] + c[14] * d[3];
    e[3] = c[3] * d[0] + c[7] * d[1] + c[11] * d[2] + c[15] * d[3];
    e[4] = c[0] * d[4] + c[4] * d[5] + c[8] * d[6] + c[12] * d[7];
    e[5] = c[1] * d[4] + c[5] * d[5] + c[9] * d[6] + c[13] * d[7];
    e[6] = c[2] * d[4] + c[6] * d[5] + c[10] * d[6] + c[14] * d[7];
    e[7] = c[3] * d[4] + c[7] * d[5] + c[11] * d[6] + c[15] * d[7];
    e[8] = c[0] * d[8] + c[4] * d[9] + c[8] * d[10] + c[12] * d[11];
    e[9] = c[1] * d[8] + c[5] * d[9] + c[9] * d[10] + c[13] * d[11];
    e[10] = c[2] * d[8] + c[6] * d[9] + c[10] * d[10] + c[14] * d[11];
    e[11] = c[3] * d[8] + c[7] * d[9] + c[11] * d[10] + c[15] * d[11];
    e[12] = c[0] * d[12] + c[4] * d[13] + c[8] * d[14] + c[12] * d[15];
    e[13] = c[1] * d[12] + c[5] * d[13] + c[9] * d[14] + c[13] * d[15];
    e[14] = c[2] * d[12] + c[6] * d[13] + c[10] * d[14] + c[14] * d[15];
    e[15] = c[3] * d[12] + c[7] * d[13] + c[11] * d[14] + c[15] * d[15];
    return e
};
cc.getMat4MultiplyWithMat4 = function (a, b, c) {
    a = a.mat;
    b = b.mat;
    var d = c.mat;
    d[0] = a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3];
    d[1] = a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3];
    d[2] = a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3];
    d[3] = a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3];
    d[4] = a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7];
    d[5] = a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7];
    d[6] = a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7];
    d[7] = a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7];
    d[8] = a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11];
    d[9] = a[1] *
        b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11];
    d[10] = a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11];
    d[11] = a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11];
    d[12] = a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15];
    d[13] = a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15];
    d[14] = a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15];
    d[15] = a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15];
    return c.mat
};
cc.kmMat4Assign = function (a, b) {
    if (a == b) return cc.log("cc.kmMat4Assign(): pOut equals pIn"), a;
    var c = a.mat,
        d = b.mat;
    c[0] = d[0];
    c[1] = d[1];
    c[2] = d[2];
    c[3] = d[3];
    c[4] = d[4];
    c[5] = d[5];
    c[6] = d[6];
    c[7] = d[7];
    c[8] = d[8];
    c[9] = d[9];
    c[10] = d[10];
    c[11] = d[11];
    c[12] = d[12];
    c[13] = d[13];
    c[14] = d[14];
    c[15] = d[15];
    return a
};
cc.kmMat4AreEqual = function (a, b) {
    if (a == b) return cc.log("cc.kmMat4AreEqual(): pMat1 and pMat2 are same object."), !0;
    for (var c = 0; 16 > c; c++)
        if (!(a.mat[c] + cc.kmEpsilon > b.mat[c] && a.mat[c] - cc.kmEpsilon < b.mat[c])) return !1;
    return !0
};
cc.kmMat4RotationX = function (a, b) {
    a.mat[0] = 1;
    a.mat[1] = 0;
    a.mat[2] = 0;
    a.mat[3] = 0;
    a.mat[4] = 0;
    a.mat[5] = Math.cos(b);
    a.mat[6] = Math.sin(b);
    a.mat[7] = 0;
    a.mat[8] = 0;
    a.mat[9] = -Math.sin(b);
    a.mat[10] = Math.cos(b);
    a.mat[11] = 0;
    a.mat[12] = 0;
    a.mat[13] = 0;
    a.mat[14] = 0;
    a.mat[15] = 1;
    return a
};
cc.kmMat4RotationY = function (a, b) {
    a.mat[0] = Math.cos(b);
    a.mat[1] = 0;
    a.mat[2] = -Math.sin(b);
    a.mat[3] = 0;
    a.mat[4] = 0;
    a.mat[5] = 1;
    a.mat[6] = 0;
    a.mat[7] = 0;
    a.mat[8] = Math.sin(b);
    a.mat[9] = 0;
    a.mat[10] = Math.cos(b);
    a.mat[11] = 0;
    a.mat[12] = 0;
    a.mat[13] = 0;
    a.mat[14] = 0;
    a.mat[15] = 1;
    return a
};
cc.kmMat4RotationZ = function (a, b) {
    a.mat[0] = Math.cos(b);
    a.mat[1] = Math.sin(b);
    a.mat[2] = 0;
    a.mat[3] = 0;
    a.mat[4] = -Math.sin(b);
    a.mat[5] = Math.cos(b);
    a.mat[6] = 0;
    a.mat[7] = 0;
    a.mat[8] = 0;
    a.mat[9] = 0;
    a.mat[10] = 1;
    a.mat[11] = 0;
    a.mat[12] = 0;
    a.mat[13] = 0;
    a.mat[14] = 0;
    a.mat[15] = 1;
    return a
};
cc.kmMat4RotationPitchYawRoll = function (a, b, c, d) {
    var e = Math.cos(b);
    b = Math.sin(b);
    var f = Math.cos(c);
    c = Math.sin(c);
    var g = Math.cos(d);
    d = Math.sin(d);
    var h = b * c,
        k = e * c;
    a.mat[0] = f * g;
    a.mat[4] = f * d;
    a.mat[8] = -c;
    a.mat[1] = h * g - e * d;
    a.mat[5] = h * d + e * g;
    a.mat[9] = b * f;
    a.mat[2] = k * g + b * d;
    a.mat[6] = k * d - b * g;
    a.mat[10] = e * f;
    a.mat[3] = a.mat[7] = a.mat[11] = 0;
    a.mat[15] = 1;
    return a
};
cc.kmMat4RotationQuaternion = function (a, b) {
    a.mat[0] = 1 - 2 * (b.y * b.y + b.z * b.z);
    a.mat[1] = 2 * (b.x * b.y + b.z * b.w);
    a.mat[2] = 2 * (b.x * b.z - b.y * b.w);
    a.mat[3] = 0;
    a.mat[4] = 2 * (b.x * b.y - b.z * b.w);
    a.mat[5] = 1 - 2 * (b.x * b.x + b.z * b.z);
    a.mat[6] = 2 * (b.z * b.y + b.x * b.w);
    a.mat[7] = 0;
    a.mat[8] = 2 * (b.x * b.z + b.y * b.w);
    a.mat[9] = 2 * (b.y * b.z - b.x * b.w);
    a.mat[10] = 1 - 2 * (b.x * b.x + b.y * b.y);
    a.mat[11] = 0;
    a.mat[12] = 0;
    a.mat[13] = 0;
    a.mat[14] = 0;
    a.mat[15] = 1;
    return a
};
cc.kmMat4RotationTranslation = function (a, b, c) {
    a.mat[0] = b.mat[0];
    a.mat[1] = b.mat[1];
    a.mat[2] = b.mat[2];
    a.mat[3] = 0;
    a.mat[4] = b.mat[3];
    a.mat[5] = b.mat[4];
    a.mat[6] = b.mat[5];
    a.mat[7] = 0;
    a.mat[8] = b.mat[6];
    a.mat[9] = b.mat[7];
    a.mat[10] = b.mat[8];
    a.mat[11] = 0;
    a.mat[12] = c.x;
    a.mat[13] = c.y;
    a.mat[14] = c.z;
    a.mat[15] = 1;
    return a
};
cc.kmMat4Scaling = function (a, b, c, d) {
    a.mat[0] = b;
    a.mat[5] = c;
    a.mat[10] = d;
    a.mat[15] = 1;
    a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = a.mat[12] = a.mat[13] = a.mat[14] = 0;
    return a
};
cc.kmMat4Translation = function (a, b, c, d) {
    a.mat[0] = a.mat[5] = a.mat[10] = a.mat[15] = 1;
    a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = 0;
    a.mat[12] = b;
    a.mat[13] = c;
    a.mat[14] = d;
    return a
};
cc.kmMat4GetUpVec3 = function (a, b) {
    a.x = b.mat[4];
    a.y = b.mat[5];
    a.z = b.mat[6];
    cc.kmVec3Normalize(a, a);
    return a
};
cc.kmMat4GetRightVec3 = function (a, b) {
    a.x = b.mat[0];
    a.y = b.mat[1];
    a.z = b.mat[2];
    cc.kmVec3Normalize(a, a);
    return a
};
cc.kmMat4GetForwardVec3 = function (a, b) {
    a.x = b.mat[8];
    a.y = b.mat[9];
    a.z = b.mat[10];
    cc.kmVec3Normalize(a, a);
    return a
};
cc.kmMat4PerspectiveProjection = function (a, b, c, d, e) {
    var f = cc.kmDegreesToRadians(b / 2);
    b = e - d;
    var g = Math.sin(f);
    if (0 == b || 0 == g || 0 == c) return null;
    f = Math.cos(f) / g;
    cc.kmMat4Identity(a);
    a.mat[0] = f / c;
    a.mat[5] = f;
    a.mat[10] = -(e + d) / b;
    a.mat[11] = -1;
    a.mat[14] = -2 * d * e / b;
    a.mat[15] = 0;
    return a
};
cc.kmMat4OrthographicProjection = function (a, b, c, d, e, f, g) {
    cc.kmMat4Identity(a);
    a.mat[0] = 2 / (c - b);
    a.mat[5] = 2 / (e - d);
    a.mat[10] = -2 / (g - f);
    a.mat[12] = -((c + b) / (c - b));
    a.mat[13] = -((e + d) / (e - d));
    a.mat[14] = -((g + f) / (g - f));
    return a
};
cc.kmMat4LookAt = function (a, b, c, d) {
    var e = new cc.kmVec3,
        f = new cc.kmVec3,
        g = new cc.kmVec3,
        h = new cc.kmVec3,
        k = new cc.kmMat4;
    cc.kmVec3Subtract(e, c, b);
    cc.kmVec3Normalize(e, e);
    cc.kmVec3Assign(f, d);
    cc.kmVec3Normalize(f, f);
    cc.kmVec3Cross(g, e, f);
    cc.kmVec3Normalize(g, g);
    cc.kmVec3Cross(h, g, e);
    cc.kmVec3Normalize(g, g);
    cc.kmMat4Identity(a);
    a.mat[0] = g.x;
    a.mat[4] = g.y;
    a.mat[8] = g.z;
    a.mat[1] = h.x;
    a.mat[5] = h.y;
    a.mat[9] = h.z;
    a.mat[2] = -e.x;
    a.mat[6] = -e.y;
    a.mat[10] = -e.z;
    cc.kmMat4Translation(k, -b.x, -b.y, -b.z);
    cc.kmMat4Multiply(a,
        a, k);
    return a
};
cc.kmMat4RotationAxisAngle = function (a, b, c) {
    var d = Math.cos(c);
    c = Math.sin(c);
    var e = new cc.kmVec3;
    cc.kmVec3Normalize(e, b);
    a.mat[0] = d + e.x * e.x * (1 - d);
    a.mat[1] = e.z * c + e.y * e.x * (1 - d);
    a.mat[2] = -e.y * c + e.z * e.x * (1 - d);
    a.mat[3] = 0;
    a.mat[4] = -e.z * c + e.x * e.y * (1 - d);
    a.mat[5] = d + e.y * e.y * (1 - d);
    a.mat[6] = e.x * c + e.z * e.y * (1 - d);
    a.mat[7] = 0;
    a.mat[8] = e.y * c + e.x * e.z * (1 - d);
    a.mat[9] = -e.x * c + e.y * e.z * (1 - d);
    a.mat[10] = d + e.z * e.z * (1 - d);
    a.mat[11] = 0;
    a.mat[12] = 0;
    a.mat[13] = 0;
    a.mat[14] = 0;
    a.mat[15] = 1;
    return a
};
cc.kmMat4ExtractRotation = function (a, b) {
    a.mat[0] = b.mat[0];
    a.mat[1] = b.mat[1];
    a.mat[2] = b.mat[2];
    a.mat[3] = b.mat[4];
    a.mat[4] = b.mat[5];
    a.mat[5] = b.mat[6];
    a.mat[6] = b.mat[8];
    a.mat[7] = b.mat[9];
    a.mat[8] = b.mat[10];
    return a
};
cc.kmMat4ExtractPlane = function (a, b, c) {
    switch (c) {
    case cc.KM_PLANE_RIGHT:
        a.a = b.mat[3] - b.mat[0];
        a.b = b.mat[7] - b.mat[4];
        a.c = b.mat[11] - b.mat[8];
        a.d = b.mat[15] - b.mat[12];
        break;
    case cc.KM_PLANE_LEFT:
        a.a = b.mat[3] + b.mat[0];
        a.b = b.mat[7] + b.mat[4];
        a.c = b.mat[11] + b.mat[8];
        a.d = b.mat[15] + b.mat[12];
        break;
    case cc.KM_PLANE_BOTTOM:
        a.a = b.mat[3] + b.mat[1];
        a.b = b.mat[7] + b.mat[5];
        a.c = b.mat[11] + b.mat[9];
        a.d = b.mat[15] + b.mat[13];
        break;
    case cc.KM_PLANE_TOP:
        a.a = b.mat[3] - b.mat[1];
        a.b = b.mat[7] - b.mat[5];
        a.c = b.mat[11] - b.mat[9];
        a.d = b.mat[15] -
            b.mat[13];
        break;
    case cc.KM_PLANE_FAR:
        a.a = b.mat[3] - b.mat[2];
        a.b = b.mat[7] - b.mat[6];
        a.c = b.mat[11] - b.mat[10];
        a.d = b.mat[15] - b.mat[14];
        break;
    case cc.KM_PLANE_NEAR:
        a.a = b.mat[3] + b.mat[2];
        a.b = b.mat[7] + b.mat[6];
        a.c = b.mat[11] + b.mat[10];
        a.d = b.mat[15] + b.mat[14];
        break;
    default:
        cc.log("cc.kmMat4ExtractPlane(): Invalid plane index")
    }
    b = Math.sqrt(a.a * a.a + a.b * a.b + a.c * a.c);
    a.a /= b;
    a.b /= b;
    a.c /= b;
    a.d /= b;
    return a
};
cc.kmMat4RotationToAxisAngle = function (a, b, c) {
    var d = new cc.kmQuaternion,
        e = new cc.kmMat3;
    cc.kmMat4ExtractRotation(e, c);
    cc.kmQuaternionRotationMatrix(d, e);
    cc.kmQuaternionToAxisAngle(d, a, b);
    return a
};
cc.KM_PLANE_LEFT = 0;
cc.KM_PLANE_RIGHT = 1;
cc.KM_PLANE_BOTTOM = 2;
cc.KM_PLANE_TOP = 3;
cc.KM_PLANE_NEAR = 4;
cc.KM_PLANE_FAR = 5;
cc.kmPlane = function (a, b, c, d) {
    this.a = a || 0;
    this.b = b || 0;
    this.c = c || 0;
    this.d = d || 0
};
cc.POINT_INFRONT_OF_PLANE = 0;
cc.POINT_BEHIND_PLANE = 1;
cc.POINT_ON_PLANE = 2;
cc.kmPlaneDot = function (a, b) {
    return a.a * b.x + a.b * b.y + a.c * b.z + a.d * b.w
};
cc.kmPlaneDotCoord = function (a, b) {
    return a.a * b.x + a.b * b.y + a.c * b.z + a.d
};
cc.kmPlaneDotNormal = function (a, b) {
    return a.a * b.x + a.b * b.y + a.c * b.z
};
cc.kmPlaneFromPointNormal = function (a, b, c) {
    a.a = c.x;
    a.b = c.y;
    a.c = c.z;
    a.d = -cc.kmVec3Dot(c, b);
    return a
};
cc.kmPlaneFromPoints = function (a, b, c, d) {
    var e = new cc.kmVec3,
        f = new cc.kmVec3,
        g = new cc.kmVec3;
    cc.kmVec3Subtract(f, c, b);
    cc.kmVec3Subtract(g, d, b);
    cc.kmVec3Cross(e, f, g);
    cc.kmVec3Normalize(e, e);
    a.a = e.x;
    a.b = e.y;
    a.c = e.z;
    a.d = cc.kmVec3Dot(cc.kmVec3Scale(e, e, -1), b);
    return a
};
cc.kmPlaneIntersectLine = function (a, b, c, d) {
    throw "cc.kmPlaneIntersectLine() hasn't been implemented.";
};
cc.kmPlaneNormalize = function (a, b) {
    var c = new cc.kmVec3;
    c.x = b.a;
    c.y = b.b;
    c.z = b.c;
    var d = 1 / cc.kmVec3Length(c);
    cc.kmVec3Normalize(c, c);
    a.a = c.x;
    a.b = c.y;
    a.c = c.z;
    a.d = b.d * d;
    return a
};
cc.kmPlaneScale = function (a, b, c) {
    cc.log("cc.kmPlaneScale() has not been implemented.")
};
cc.kmPlaneClassifyPoint = function (a, b) {
    var c = a.a * b.x + a.b * b.y + a.c * b.z + a.d;
    return 0.001 < c ? cc.POINT_INFRONT_OF_PLANE : -0.001 > c ? cc.POINT_BEHIND_PLANE : cc.POINT_ON_PLANE
};
cc.kmQuaternion = function (a, b, c, d) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0;
    this.w = d || 0
};
cc.kmQuaternionConjugate = function (a, b) {
    a.x = -b.x;
    a.y = -b.y;
    a.z = -b.z;
    a.w = b.w;
    return a
};
cc.kmQuaternionDot = function (a, b) {
    return a.w * b.w + a.x * b.x + a.y * b.y + a.z * b.z
};
cc.kmQuaternionExp = function (a, b) {
    return a
};
cc.kmQuaternionIdentity = function (a) {
    a.x = 0;
    a.y = 0;
    a.z = 0;
    a.w = 1;
    return a
};
cc.kmQuaternionInverse = function (a, b) {
    var c = cc.kmQuaternionLength(b),
        d = new cc.kmQuaternion;
    if (Math.abs(c) > cc.kmEpsilon) return a.x = 0, a.y = 0, a.z = 0, a.w = 0, a;
    cc.kmQuaternionScale(a, cc.kmQuaternionConjugate(d, b), 1 / c);
    return a
};
cc.kmQuaternionIsIdentity = function (a) {
    return 0 == a.x && 0 == a.y && 0 == a.z && 1 == a.w
};
cc.kmQuaternionLength = function (a) {
    return Math.sqrt(cc.kmQuaternionLengthSq(a))
};
cc.kmQuaternionLengthSq = function (a) {
    return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w
};
cc.kmQuaternionLn = function (a, b) {
    return a
};
cc.kmQuaternionMultiply = function (a, b, c) {
    a.w = b.w * c.w - b.x * c.x - b.y * c.y - b.z * c.z;
    a.x = b.w * c.x + b.x * c.w + b.y * c.z - b.z * c.y;
    a.y = b.w * c.y + b.y * c.w + b.z * c.x - b.x * c.z;
    a.z = b.w * c.z + b.z * c.w + b.x * c.y - b.y * c.x;
    return a
};
cc.kmQuaternionNormalize = function (a, b) {
    var c = cc.kmQuaternionLength(b);
    if (Math.abs(c) <= cc.kmEpsilon) throw "cc.kmQuaternionNormalize(): pIn is an invalid value";
    cc.kmQuaternionScale(a, b, 1 / c);
    return a
};
cc.kmQuaternionRotationAxis = function (a, b, c) {
    c *= 0.5;
    var d = Math.sin(c);
    a.w = Math.cos(c);
    a.x = b.x * d;
    a.y = b.y * d;
    a.z = b.z * d;
    return a
};
cc.kmQuaternionRotationMatrix = function (a, b) {
    var c, d, e, f;
    c = [];
    d = f = 0;
    if (!b) return null;
    c[0] = b.mat[0];
    c[1] = b.mat[3];
    c[2] = b.mat[6];
    c[4] = b.mat[1];
    c[5] = b.mat[4];
    c[6] = b.mat[7];
    c[8] = b.mat[2];
    c[9] = b.mat[5];
    c[10] = b.mat[8];
    c[15] = 1;
    var g = c[0];
    d = g[0] + g[5] + g[10] + 1;
    d > cc.kmEpsilon ? (f = 2 * Math.sqrt(d), c = (g[9] - g[6]) / f, d = (g[2] - g[8]) / f, e = (g[4] - g[1]) / f, f *= 0.25) : g[0] > g[5] && g[0] > g[10] ? (f = 2 * Math.sqrt(1 + g[0] - g[5] - g[10]), c = 0.25 * f, d = (g[4] + g[1]) / f, e = (g[2] + g[8]) / f, f = (g[9] - g[6]) / f) : g[5] > g[10] ? (f = 2 * Math.sqrt(1 + g[5] - g[0] - g[10]), c =
        (g[4] + g[1]) / f, d = 0.25 * f, e = (g[9] + g[6]) / f, f = (g[2] - g[8]) / f) : (f = 2 * Math.sqrt(1 + g[10] - g[0] - g[5]), c = (g[2] + g[8]) / f, d = (g[9] + g[6]) / f, e = 0.25 * f, f = (g[4] - g[1]) / f);
    a.x = c;
    a.y = d;
    a.z = e;
    a.w = f;
    return a
};
cc.kmQuaternionRotationYawPitchRoll = function (a, b, c, d) {
    var e, f, g, h, k;
    e = cc.kmDegreesToRadians(c) / 2;
    f = cc.kmDegreesToRadians(b) / 2;
    g = cc.kmDegreesToRadians(d) / 2;
    d = Math.cos(e);
    b = Math.cos(f);
    c = Math.cos(g);
    e = Math.sin(e);
    f = Math.sin(f);
    g = Math.sin(g);
    h = b * c;
    k = f * g;
    a.w = d * h + e * k;
    a.x = e * h - d * k;
    a.y = d * f * c + e * b * g;
    a.z = d * b * g - e * f * c;
    cc.kmQuaternionNormalize(a, a);
    return a
};
cc.kmQuaternionSlerp = function (a, b, c, d) {
    if (b.x == c.x && b.y == c.y && b.z == c.z && b.w == c.w) return a.x = b.x, a.y = b.y, a.z = b.z, a.w = b.w, a;
    var e = cc.kmQuaternionDot(b, c),
        f = Math.acos(e),
        g = Math.sqrt(1 - cc.kmSQR(e)),
        e = Math.sin(d * f) / g;
    d = Math.sin((1 - d) * f) / g;
    f = new cc.kmQuaternion;
    g = new cc.kmQuaternion;
    cc.kmQuaternionScale(f, b, d);
    cc.kmQuaternionScale(g, c, e);
    cc.kmQuaternionAdd(a, f, g);
    return a
};
cc.kmQuaternionToAxisAngle = function (a, b, c) {
    Math.acos(a.w);
    c = Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z));
    c > -cc.kmEpsilon && c < cc.kmEpsilon || c < 2 * cc.kmPI + cc.kmEpsilon && c > 2 * cc.kmPI - cc.kmEpsilon ? (b.x = 0, b.y = 0, b.z = 1) : (b.x = a.x / c, b.y = a.y / c, b.z = a.z / c, cc.kmVec3Normalize(b, b))
};
cc.kmQuaternionScale = function (a, b, c) {
    a.x = b.x * c;
    a.y = b.y * c;
    a.z = b.z * c;
    a.w = b.w * c;
    return a
};
cc.kmQuaternionAssign = function (a, b) {
    a.x = b.x;
    a.y = b.y;
    a.z = b.z;
    a.w = b.w;
    return a
};
cc.kmQuaternionAdd = function (a, b, c) {
    a.x = b.x + c.x;
    a.y = b.y + c.y;
    a.z = b.z + c.z;
    a.w = b.w + c.w;
    return a
};
cc.kmQuaternionRotationBetweenVec3 = function (a, b, c, d) {
    var e = new cc.kmVec3,
        f = new cc.kmVec3;
    cc.kmVec3Assign(e, b);
    cc.kmVec3Assign(f, c);
    cc.kmVec3Normalize(e, e);
    cc.kmVec3Normalize(f, f);
    c = cc.kmVec3Dot(e, f);
    if (1 <= c) return cc.kmQuaternionIdentity(a), a; - 0.999999 > c ? Math.abs(cc.kmVec3LengthSq(d)) < cc.kmEpsilon ? cc.kmQuaternionRotationAxis(a, d, cc.kmPI) : (e = new cc.kmVec3, f = new cc.kmVec3, f.x = 1, f.y = 0, f.z = 0, cc.kmVec3Cross(e, f, b), Math.abs(cc.kmVec3LengthSq(e)) < cc.kmEpsilon && (f = new cc.kmVec3, f.x = 0, f.y = 1, f.z = 0, cc.kmVec3Cross(e,
        f, b)), cc.kmVec3Normalize(e, e), cc.kmQuaternionRotationAxis(a, e, cc.kmPI)) : (b = Math.sqrt(2 * (1 + c)), d = 1 / b, c = new cc.kmVec3, cc.kmVec3Cross(c, e, f), a.x = c.x * d, a.y = c.y * d, a.z = c.z * d, a.w = 0.5 * b, cc.kmQuaternionNormalize(a, a));
    return a
};
cc.kmQuaternionMultiplyVec3 = function (a, b, c) {
    var d = new cc.kmVec3,
        e = new cc.kmVec3,
        f = new cc.kmVec3;
    f.x = b.x;
    f.y = b.y;
    f.z = b.z;
    cc.kmVec3Cross(d, f, c);
    cc.kmVec3Cross(e, f, d);
    cc.kmVec3Scale(d, d, 2 * b.w);
    cc.kmVec3Scale(e, e, 2);
    cc.kmVec3Add(a, c, d);
    cc.kmVec3Add(a, a, e);
    return a
};
cc.kmAABB = function (a, b) {
    this.min = a || new cc.kmVec3;
    this.max = b || new cc.kmVec3
};
cc.kmAABBContainsPoint = function (a, b) {
    return a.x >= b.min.x && a.x <= b.max.x && a.y >= b.min.y && a.y <= b.max.y && a.z >= b.min.z && a.z <= b.max.z ? cc.KM_TRUE : cc.KM_FALSE
};
cc.kmAABBAssign = function (a, b) {
    cc.kmVec3Assign(a.min, b.min);
    cc.kmVec3Assign(a.max, b.max);
    return a
};
cc.kmAABBScale = function (a, b, c) {
    cc.log("cc.kmAABBScale hasn't been supported.")
};
cc.km_mat4_stack = function (a, b, c, d) {
    this.top = c;
    this.stack = d
};
cc.km_mat4_stack.INITIAL_SIZE = 30;
cc.km_mat4_stack_initialize = function (a) {
    a.stack = [];
    a.top = null
};
cc.km_mat4_stack_push = function (a, b) {
    a.stack.push(a.top);
    a.top = new cc.kmMat4;
    cc.kmMat4Assign(a.top, b)
};
cc.km_mat4_stack_pop = function (a, b) {
    a.top = a.stack.pop()
};
cc.km_mat4_stack_release = function (a) {
    a.stack = null;
    a.top = null
};
cc.KM_GL_MODELVIEW = 5888;
cc.KM_GL_PROJECTION = 5889;
cc.KM_GL_TEXTURE = 5890;
cc.modelview_matrix_stack = new cc.km_mat4_stack;
cc.projection_matrix_stack = new cc.km_mat4_stack;
cc.texture_matrix_stack = new cc.km_mat4_stack;
cc.current_stack = null;
cc.initialized = !1;
cc.lazyInitialize = function () {
    if (!cc.initialized) {
        var a = new cc.kmMat4;
        cc.km_mat4_stack_initialize(cc.modelview_matrix_stack);
        cc.km_mat4_stack_initialize(cc.projection_matrix_stack);
        cc.km_mat4_stack_initialize(cc.texture_matrix_stack);
        cc.current_stack = cc.modelview_matrix_stack;
        cc.initialized = !0;
        cc.kmMat4Identity(a);
        cc.km_mat4_stack_push(cc.modelview_matrix_stack, a);
        cc.km_mat4_stack_push(cc.projection_matrix_stack, a);
        cc.km_mat4_stack_push(cc.texture_matrix_stack, a)
    }
};
cc.lazyInitialize();
cc.kmGLFreeAll = function () {
    cc.km_mat4_stack_release(cc.modelview_matrix_stack);
    cc.km_mat4_stack_release(cc.projection_matrix_stack);
    cc.km_mat4_stack_release(cc.texture_matrix_stack);
    cc.initialized = !1;
    cc.current_stack = null
};
cc.kmGLPushMatrix = function () {
    cc.km_mat4_stack_push(cc.current_stack, cc.current_stack.top)
};
cc.kmGLPushMatrixWitMat4 = function (a) {
    cc.current_stack.stack.push(cc.current_stack.top);
    cc.kmMat4Assign(a, cc.current_stack.top);
    cc.current_stack.top = a
};
cc.kmGLPopMatrix = function () {
    cc.current_stack.top = cc.current_stack.stack.pop()
};
cc.kmGLMatrixMode = function (a) {
    switch (a) {
    case cc.KM_GL_MODELVIEW:
        cc.current_stack = cc.modelview_matrix_stack;
        break;
    case cc.KM_GL_PROJECTION:
        cc.current_stack = cc.projection_matrix_stack;
        break;
    case cc.KM_GL_TEXTURE:
        cc.current_stack = cc.texture_matrix_stack;
        break;
    default:
        throw "Invalid matrix mode specified";
    }
};
cc.kmGLLoadIdentity = function () {
    cc.kmMat4Identity(cc.current_stack.top)
};
cc.kmGLLoadMatrix = function (a) {
    cc.kmMat4Assign(cc.current_stack.top, a)
};
cc.kmGLMultMatrix = function (a) {
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, a)
};
cc.kmGLTranslatef = function (a, b, c) {
    var d = new cc.kmMat4;
    cc.kmMat4Translation(d, a, b, c);
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, d)
};
cc.kmGLRotatef = function (a, b, c, d) {
    b = new cc.kmVec3(b, c, d);
    c = new cc.kmMat4;
    cc.kmMat4RotationAxisAngle(c, b, cc.kmDegreesToRadians(a));
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, c)
};
cc.kmGLScalef = function (a, b, c) {
    var d = new cc.kmMat4;
    cc.kmMat4Scaling(d, a, b, c);
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, d)
};
cc.kmGLGetMatrix = function (a, b) {
    switch (a) {
    case cc.KM_GL_MODELVIEW:
        cc.kmMat4Assign(b, cc.modelview_matrix_stack.top);
        break;
    case cc.KM_GL_PROJECTION:
        cc.kmMat4Assign(b, cc.projection_matrix_stack.top);
        break;
    case cc.KM_GL_TEXTURE:
        cc.kmMat4Assign(b, cc.texture_matrix_stack.top);
        break;
    default:
        throw "Invalid matrix mode specified";
    }
};
cc.SHADER_POSITION_UCOLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor;\nvoid main()                              \n{ \n    gl_FragColor \x3d v_fragmentColor;      \n}\n";
cc.SHADER_POSITION_UCOLOR_VERT = "attribute vec4 a_position;\nuniform    vec4 u_color;\nuniform float u_pointSize;\nvarying lowp vec4 v_fragmentColor; \nvoid main(void)   \n{\n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    gl_PointSize \x3d u_pointSize;          \n    v_fragmentColor \x3d u_color;           \n}";
cc.SHADER_POSITION_COLOR_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvoid main() \n{ \n     gl_FragColor \x3d v_fragmentColor; \n} ";
cc.SHADER_POSITION_COLOR_VERT = "attribute vec4 a_position;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvoid main()\n{\n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color;             \n}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG = "// #extension GL_OES_standard_derivatives : enable\nvarying mediump vec4 v_color;\nvarying mediump vec2 v_texcoord;\nvoid main()\t\n{ \n// #if defined GL_OES_standard_derivatives\t\n// gl_FragColor \x3d v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0 - length(v_texcoord)); \n// #else\t\ngl_FragColor \x3d v_color * step(0.0, 1.0 - length(v_texcoord)); \n// #endif \n}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT = "attribute mediump vec4 a_position; \nattribute mediump vec2 a_texcoord; \nattribute mediump vec4 a_color;\t\nvarying mediump vec4 v_color; \nvarying mediump vec2 v_texcoord;\t\nvoid main() \n{ \n     v_color \x3d a_color;//vec4(a_color.rgb * a_color.a, a_color.a); \n     v_texcoord \x3d a_texcoord; \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n}";
cc.SHADER_POSITION_TEXTURE_FRAG = "precision lowp float;   \nvarying vec2 v_texCoord;  \nuniform sampler2D CC_Texture0; \nvoid main() \n{  \n    gl_FragColor \x3d  texture2D(CC_Texture0, v_texCoord);   \n}";
cc.SHADER_POSITION_TEXTURE_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord \x3d a_texCoord;               \n}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG = "precision lowp float;  \nuniform vec4 u_color; \nvarying vec2 v_texCoord; \nuniform sampler2D CC_Texture0;  \nvoid main() \n{  \n    gl_FragColor \x3d  texture2D(CC_Texture0, v_texCoord) * u_color;    \n}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT = "attribute vec4 a_position;\nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord \x3d a_texCoord;                 \n}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG = "precision lowp float;  \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D CC_Texture0; \nvoid main() \n{ \n    gl_FragColor \x3d vec4( v_fragmentColor.rgb,         \n        v_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a   \n    ); \n}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color; \n    v_texCoord \x3d a_texCoord; \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D CC_Texture0; \nvoid main() \n{ \n    gl_FragColor \x3d v_fragmentColor * texture2D(CC_Texture0, v_texCoord); \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color; \n    v_texCoord \x3d a_texCoord; \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG = "precision lowp float;   \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord;   \nuniform sampler2D CC_Texture0; \nuniform float CC_alpha_value; \nvoid main() \n{  \n    vec4 texColor \x3d texture2D(CC_Texture0, v_texCoord);  \n    // mimic: glAlphaFunc(GL_GREATER)           \n    //pass if ( incoming_pixel \x3e\x3d CC_alpha_value ) \x3d\x3e fail if incoming_pixel \x3c CC_alpha_value   \n    if ( texColor.a \x3c\x3d CC_alpha_value )          \n        discard; \n    gl_FragColor \x3d texColor * v_fragmentColor;  \n}";
cc.SHADEREX_SWITCHMASK_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D u_texture;  \nuniform sampler2D   u_mask;   \nvoid main()  \n{  \n    vec4 texColor   \x3d texture2D(u_texture, v_texCoord);  \n    vec4 maskColor  \x3d texture2D(u_mask, v_texCoord); \n    vec4 finalColor \x3d vec4(texColor.r, texColor.g, texColor.b, maskColor.a * texColor.a);        \n    gl_FragColor    \x3d v_fragmentColor * finalColor; \n}";
cc.shaderCache = {
    TYPE_POSITION_TEXTURECOLOR: 0,
    TYPE_POSITION_TEXTURECOLOR_ALPHATEST: 1,
    TYPE_POSITION_COLOR: 2,
    TYPE_POSITION_TEXTURE: 3,
    TYPE_POSITION_TEXTURE_UCOLOR: 4,
    TYPE_POSITION_TEXTURE_A8COLOR: 5,
    TYPE_POSITION_UCOLOR: 6,
    TYPE_POSITION_LENGTH_TEXTURECOLOR: 7,
    TYPE_MAX: 8,
    _programs: {},
    _init: function () {
        this.loadDefaultShaders();
        return !0
    },
    _loadDefaultShader: function (a, b) {
        switch (b) {
        case this.TYPE_POSITION_TEXTURECOLOR:
            a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_FRAG);
            a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
            a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST:
            a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG);
            a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
            a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_COLOR:
            a.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_VERT, cc.SHADER_POSITION_COLOR_FRAG);
            a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
            break;
        case this.TYPE_POSITION_TEXTURE:
            a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_VERT, cc.SHADER_POSITION_TEXTURE_FRAG);
            a.addAttribute(cc.ATTRIBUTE_NAME_POSITION,
                cc.VERTEX_ATTRIB_POSITION);
            a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_TEXTURE_UCOLOR:
            a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT, cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG);
            a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_TEXTURE_A8COLOR:
            a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT,
                cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG);
            a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
            a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_UCOLOR:
            a.initWithVertexShaderByteArray(cc.SHADER_POSITION_UCOLOR_VERT, cc.SHADER_POSITION_UCOLOR_FRAG);
            a.addAttribute("aVertex", cc.VERTEX_ATTRIB_POSITION);
            break;
        case this.TYPE_POSITION_LENGTH_TEXTURECOLOR:
            a.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT,
                cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG);
            a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
            break;
        default:
            cc.log("cocos2d: cc.shaderCache._loadDefaultShader, error shader type");
            return
        }
        a.link();
        a.updateUniforms()
    },
    loadDefaultShaders: function () {
        var a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR);
        this._programs[cc.SHADER_POSITION_TEXTURECOLOR] =
            a;
        this._programs.ShaderPositionTextureColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
        this._programs[cc.SHADER_POSITION_TEXTURECOLORALPHATEST] = a;
        this._programs.ShaderPositionTextureColorAlphaTest = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_COLOR);
        this._programs[cc.SHADER_POSITION_COLOR] = a;
        this._programs.ShaderPositionColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE);
        this._programs[cc.SHADER_POSITION_TEXTURE] =
            a;
        this._programs.ShaderPositionTexture = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_UCOLOR);
        this._programs[cc.SHADER_POSITION_TEXTURE_UCOLOR] = a;
        this._programs.ShaderPositionTextureUColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_A8COLOR);
        this._programs[cc.SHADER_POSITION_TEXTUREA8COLOR] = a;
        this._programs.ShaderPositionTextureA8Color = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_UCOLOR);
        this._programs[cc.SHADER_POSITION_UCOLOR] =
            a;
        this._programs.ShaderPositionUColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_LENGTH_TEXTURECOLOR);
        this._programs[cc.SHADER_POSITION_LENGTHTEXTURECOLOR] = a;
        this._programs.ShaderPositionLengthTextureColor = a
    },
    reloadDefaultShaders: function () {
        var a = this.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR);
        a = this.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
        a = this.programForKey(cc.SHADER_POSITION_COLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_COLOR);
        a = this.programForKey(cc.SHADER_POSITION_TEXTURE);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE);
        a = this.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_UCOLOR);
        a = this.programForKey(cc.SHADER_POSITION_TEXTUREA8COLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_A8COLOR);
        a = this.programForKey(cc.SHADER_POSITION_UCOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_UCOLOR)
    },
    programForKey: function (a) {
        return this._programs[a]
    },
    getProgram: function (a) {
        return this._programs[a]
    },
    addProgram: function (a, b) {
        this._programs[b] = a
    }
};
cc.VERTEX_ATTRIB_POSITION = 0;
cc.VERTEX_ATTRIB_COLOR = 1;
cc.VERTEX_ATTRIB_TEX_COORDS = 2;
cc.VERTEX_ATTRIB_MAX = 3;
cc.UNIFORM_PMATRIX = 0;
cc.UNIFORM_MVMATRIX = 1;
cc.UNIFORM_MVPMATRIX = 2;
cc.UNIFORM_TIME = 3;
cc.UNIFORM_SINTIME = 4;
cc.UNIFORM_COSTIME = 5;
cc.UNIFORM_RANDOM01 = 6;
cc.UNIFORM_SAMPLER = 7;
cc.UNIFORM_MAX = 8;
cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor";
cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest";
cc.SHADER_POSITION_COLOR = "ShaderPositionColor";
cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture";
cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor";
cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color";
cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor";
cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor";
cc.UNIFORM_PMATRIX_S = "CC_PMatrix";
cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix";
cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix";
cc.UNIFORM_TIME_S = "CC_Time";
cc.UNIFORM_SINTIME_S = "CC_SinTime";
cc.UNIFORM_COSTIME_S = "CC_CosTime";
cc.UNIFORM_RANDOM01_S = "CC_Random01";
cc.UNIFORM_SAMPLER_S = "CC_Texture0";
cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value";
cc.ATTRIBUTE_NAME_COLOR = "a_color";
cc.ATTRIBUTE_NAME_POSITION = "a_position";
cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord";
cc.HashUniformEntry = function (a, b, c) {
    this.value = a;
    this.location = b;
    this.hh = c || {}
};
cc.GLProgram = cc.Class.extend({
    _glContext: null,
    _programObj: null,
    _vertShader: null,
    _fragShader: null,
    _uniforms: null,
    _hashForUniforms: null,
    _usesTime: !1,
    _updateUniformLocation: function (a, b, c) {
        if (null == a) return !1;
        c = !0;
        for (var d = null, e = 0; e < this._hashForUniforms.length; e++) this._hashForUniforms[e].location == a && (d = this._hashForUniforms[e]);
        d ? d.value == b ? c = !1 : d.value = b : (d = new cc.HashUniformEntry, d.location = a, d.value = b, this._hashForUniforms.push(d));
        return c
    },
    _description: function () {
        return "\x3cCCGLProgram \x3d " +
            this.toString() + " | Program \x3d " + this._programObj.toString() + ", VertexShader \x3d " + this._vertShader.toString() + ", FragmentShader \x3d " + this._fragShader.toString() + "\x3e"
    },
    _compileShader: function (a, b, c) {
        if (!c || !a) return !1;
        this._glContext.shaderSource(a, "precision highp float;        \nuniform mat4 CC_PMatrix;         \nuniform mat4 CC_MVMatrix;        \nuniform mat4 CC_MVPMatrix;       \nuniform vec4 CC_Time;            \nuniform vec4 CC_SinTime;         \nuniform vec4 CC_CosTime;         \nuniform vec4 CC_Random01;        \n//CC INCLUDES END                \n" +
            c);
        this._glContext.compileShader(a);
        c = this._glContext.getShaderParameter(a, this._glContext.COMPILE_STATUS);
        c || (cc.log("cocos2d: ERROR: Failed to compile shader:\n" + this._glContext.getShaderSource(a)), b == this._glContext.VERTEX_SHADER ? cc.log("cocos2d: \n" + this.vertexShaderLog()) : cc.log("cocos2d: \n" + this.fragmentShaderLog()));
        return 1 == c
    },
    ctor: function (a) {
        this._fragShader = this._vertShader = this._programObj = null;
        this._uniforms = [];
        this._hashForUniforms = [];
        this._glContext = a || cc._renderContext
    },
    destroyProgram: function () {
        this._hashForUniforms =
            this._uniforms = this._fragShader = this._vertShader = null;
        this._glContext.deleteProgram(this._programObj)
    },
    initWithVertexShaderByteArray: function (a, b) {
        var c = this._glContext;
        this._programObj = c.createProgram();
        this._fragShader = this._vertShader = null;
        a && (this._vertShader = c.createShader(c.VERTEX_SHADER), this._compileShader(this._vertShader, c.VERTEX_SHADER, a) || cc.log("cocos2d: ERROR: Failed to compile vertex shader"));
        b && (this._fragShader = c.createShader(c.FRAGMENT_SHADER), this._compileShader(this._fragShader,
            c.FRAGMENT_SHADER, b) || cc.log("cocos2d: ERROR: Failed to compile fragment shader"));
        this._vertShader && c.attachShader(this._programObj, this._vertShader);
        cc.CHECK_GL_ERROR_DEBUG();
        this._fragShader && c.attachShader(this._programObj, this._fragShader);
        this._hashForUniforms.length = 0;
        cc.CHECK_GL_ERROR_DEBUG();
        return !0
    },
    initWithString: function (a, b) {
        return this.initWithVertexShaderByteArray(a, b)
    },
    initWithVertexShaderFilename: function (a, b) {
        var c = cc.loader.getRes(a);
        if (!c) throw "Please load the resource firset : " +
            a;
        var d = cc.loader.getRes(b);
        if (!d) throw "Please load the resource firset : " + b;
        return this.initWithVertexShaderByteArray(c, d)
    },
    init: function (a, b) {
        return this.initWithVertexShaderFilename(a, b)
    },
    addAttribute: function (a, b) {
        this._glContext.bindAttribLocation(this._programObj, b, a)
    },
    link: function () {
        if (!this._programObj) return cc.log("cc.GLProgram.link(): Cannot link invalid program"), !1;
        this._glContext.linkProgram(this._programObj);
        this._vertShader && this._glContext.deleteShader(this._vertShader);
        this._fragShader &&
            this._glContext.deleteShader(this._fragShader);
        this._fragShader = this._vertShader = null;
        return cc.game.config[cc.game.CONFIG_KEY.debugMode] && !this._glContext.getProgramParameter(this._programObj, this._glContext.LINK_STATUS) ? (cc.log("cocos2d: ERROR: Failed to link program: " + this._glContext.getProgramInfoLog(this._programObj)), cc.glDeleteProgram(this._programObj), this._programObj = null, !1) : !0
    },
    use: function () {
        cc.glUseProgram(this._programObj)
    },
    updateUniforms: function () {
        this._uniforms[cc.UNIFORM_PMATRIX] =
            this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_PMATRIX_S);
        this._uniforms[cc.UNIFORM_MVMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVMATRIX_S);
        this._uniforms[cc.UNIFORM_MVPMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVPMATRIX_S);
        this._uniforms[cc.UNIFORM_TIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_TIME_S);
        this._uniforms[cc.UNIFORM_SINTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SINTIME_S);
        this._uniforms[cc.UNIFORM_COSTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_COSTIME_S);
        this._usesTime = null != this._uniforms[cc.UNIFORM_TIME] || null != this._uniforms[cc.UNIFORM_SINTIME] || null != this._uniforms[cc.UNIFORM_COSTIME];
        this._uniforms[cc.UNIFORM_RANDOM01] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_RANDOM01_S);
        this._uniforms[cc.UNIFORM_SAMPLER] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SAMPLER_S);
        this.use();
        this.setUniformLocationWith1i(this._uniforms[cc.UNIFORM_SAMPLER],
            0)
    },
    getUniformLocationForName: function (a) {
        if (!a) throw "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null";
        if (!this._programObj) throw "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized";
        return this._glContext.getUniformLocation(this._programObj, a)
    },
    getUniformMVPMatrix: function () {
        return this._uniforms[cc.UNIFORM_MVPMATRIX]
    },
    getUniformSampler: function () {
        return this._uniforms[cc.UNIFORM_SAMPLER]
    },
    setUniformLocationWith1i: function (a,
        b) {
        this._updateUniformLocation(a, b) && this._glContext.uniform1i(a, b)
    },
    setUniformLocationWith2i: function (a, b, c) {
        this._updateUniformLocation(a, [b, c]) && this._glContext.uniform2i(a, b, c)
    },
    setUniformLocationWith3i: function (a, b, c, d) {
        this._updateUniformLocation(a, [b, c, d]) && this._glContext.uniform3i(a, b, c, d)
    },
    setUniformLocationWith4i: function (a, b, c, d, e) {
        this._updateUniformLocation(a, [b, c, d, e]) && this._glContext.uniform4i(a, b, c, d, e)
    },
    setUniformLocationWith2iv: function (a, b, c) {
        this._updateUniformLocation(a, b) &&
            this._glContext.uniform2iv(a, b)
    },
    setUniformLocationWith3iv: function (a, b, c) {
        this._updateUniformLocation(a, b) && this._glContext.uniform3iv(a, b)
    },
    setUniformLocationWith4iv: function (a, b, c) {
        this._updateUniformLocation(a, b) && this._glContext.uniform4iv(a, b)
    },
    setUniformLocationI32: function (a, b) {
        this.setUniformLocationWith1i(a, b)
    },
    setUniformLocationWith1f: function (a, b) {
        this._updateUniformLocation(a, b) && this._glContext.uniform1f(a, b)
    },
    setUniformLocationWith2f: function (a, b, c) {
        this._updateUniformLocation(a, [b,
            c
        ]) && this._glContext.uniform2f(a, b, c)
    },
    setUniformLocationWith3f: function (a, b, c, d) {
        this._updateUniformLocation(a, [b, c, d]) && this._glContext.uniform3f(a, b, c, d)
    },
    setUniformLocationWith4f: function (a, b, c, d, e) {
        this._updateUniformLocation(a, [b, c, d, e]) && this._glContext.uniform4f(a, b, c, d, e)
    },
    setUniformLocationWith2fv: function (a, b, c) {
        this._updateUniformLocation(a, b) && this._glContext.uniform2fv(a, b)
    },
    setUniformLocationWith3fv: function (a, b, c) {
        this._updateUniformLocation(a, b) && this._glContext.uniform3fv(a, b)
    },
    setUniformLocationWith4fv: function (a, b, c) {
        this._updateUniformLocation(a, b) && this._glContext.uniform4fv(a, b)
    },
    setUniformLocationWithMatrix4fv: function (a, b, c) {
        this._updateUniformLocation(a, b) && this._glContext.uniformMatrix4fv(a, !1, b)
    },
    setUniformLocationF32: function () {
        if (!(2 > arguments.length)) switch (arguments.length) {
        case 2:
            this.setUniformLocationWith1f(arguments[0], arguments[1]);
            break;
        case 3:
            this.setUniformLocationWith2f(arguments[0], arguments[1], arguments[2]);
            break;
        case 4:
            this.setUniformLocationWith3f(arguments[0],
                arguments[1], arguments[2], arguments[3]);
            break;
        case 5:
            this.setUniformLocationWith4f(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4])
        }
    },
    setUniformsForBuiltins: function () {
        var a = new cc.kmMat4,
            b = new cc.kmMat4,
            c = new cc.kmMat4;
        cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, a);
        cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, b);
        cc.kmMat4Multiply(c, a, b);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], a.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], b.mat,
            1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], c.mat, 1);
        this._usesTime && (a = cc.director, a = a.getTotalFrames() * a.getAnimationInterval(), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], a / 10, a, 2 * a, 4 * a), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], a / 8, a / 4, a / 2, Math.sin(a)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], a / 8, a / 4, a / 2, Math.cos(a))); - 1 != this._uniforms[cc.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01],
            Math.random(), Math.random(), Math.random(), Math.random())
    },
    setUniformForModelViewProjectionMatrix: function () {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, cc.getMat4MultiplyValue(cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top))
    },
    setUniformForModelViewProjectionMatrixWithMat4: function (a) {
        cc.kmMat4Multiply(a, cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, a.mat)
    },
    setUniformForModelViewAndProjectionMatrixWithMat4: function () {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], !1, cc.modelview_matrix_stack.top.mat);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], !1, cc.projection_matrix_stack.top.mat)
    },
    vertexShaderLog: function () {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    getVertexShaderLog: function () {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    getFragmentShaderLog: function () {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    fragmentShaderLog: function () {
        return this._glContext.getShaderInfoLog(this._fragShader)
    },
    programLog: function () {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    getProgramLog: function () {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    reset: function () {
        this._fragShader = this._vertShader = null;
        this._uniforms.length = 0;
        this._glContext.deleteProgram(this._programObj);
        this._programObj = null;
        for (var a = 0; a < this._hashForUniforms.length; a++) this._hashForUniforms[a].value = null, this._hashForUniforms[a] = null;
        this._hashForUniforms.length = 0
    },
    getProgram: function () {
        return this._programObj
    },
    retain: function () {},
    release: function () {}
});
cc.GLProgram.create = function (a, b) {
    var c = new cc.GLProgram;
    return c.init(a, b) ? c : null
};
cc.VERTEX_ATTRIB_FLAG_NONE = 0;
cc.VERTEX_ATTRIB_FLAG_POSITION = 1;
cc.VERTEX_ATTRIB_FLAG_COLOR = 2;
cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = 4;
cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
cc.GL_ALL = 0;
cc._currentProjectionMatrix = -1;
cc._vertexAttribPosition = !1;
cc._vertexAttribColor = !1;
cc._vertexAttribTexCoords = !1;
cc.ENABLE_GL_STATE_CACHE && (cc.MAX_ACTIVETEXTURE = 16, cc._currentShaderProgram = -1, cc._currentBoundTexture = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], cc._blendingSource = -1, cc._blendingDest = -1, cc._GLServerState = 0, cc.TEXTURE_ATLAS_USE_VAO && (cc._uVAO = 0));
cc.glInvalidateStateCache = function () {
    cc.kmGLFreeAll();
    cc._currentProjectionMatrix = -1;
    cc._vertexAttribPosition = !1;
    cc._vertexAttribColor = !1;
    cc._vertexAttribTexCoords = !1;
    if (cc.ENABLE_GL_STATE_CACHE) {
        cc._currentShaderProgram = -1;
        for (var a = 0; a < cc.MAX_ACTIVETEXTURE; a++) cc._currentBoundTexture[a] = -1;
        cc._blendingSource = -1;
        cc._blendingDest = -1;
        cc._GLServerState = 0
    }
};
cc.glUseProgram = function (a) {
    a !== cc._currentShaderProgram && (cc._currentShaderProgram = a, cc._renderContext.useProgram(a))
};
cc.ENABLE_GL_STATE_CACHE || (cc.glUseProgram = function (a) {
    cc._renderContext.useProgram(a)
});
cc.glDeleteProgram = function (a) {
    cc.ENABLE_GL_STATE_CACHE && a === cc._currentShaderProgram && (cc._currentShaderProgram = -1);
    gl.deleteProgram(a)
};
cc.glBlendFunc = function (a, b) {
    if (a !== cc._blendingSource || b !== cc._blendingDest) cc._blendingSource = a, cc._blendingDest = b, cc.setBlending(a, b)
};
cc.setBlending = function (a, b) {
    var c = cc._renderContext;
    a === c.ONE && b === c.ZERO ? c.disable(c.BLEND) : (c.enable(c.BLEND), cc._renderContext.blendFunc(a, b))
};
cc.glBlendFuncForParticle = function (a, b) {
    if (a !== cc._blendingSource || b !== cc._blendingDest) {
        cc._blendingSource = a;
        cc._blendingDest = b;
        var c = cc._renderContext;
        a === c.ONE && b === c.ZERO ? c.disable(c.BLEND) : (c.enable(c.BLEND), c.blendFuncSeparate(c.SRC_ALPHA, b, a, b))
    }
};
cc.ENABLE_GL_STATE_CACHE || (cc.glBlendFunc = cc.setBlending);
cc.glBlendResetToCache = function () {
    var a = cc._renderContext;
    a.blendEquation(a.FUNC_ADD);
    cc.ENABLE_GL_STATE_CACHE ? cc.setBlending(cc._blendingSource, cc._blendingDest) : cc.setBlending(a.BLEND_SRC, a.BLEND_DST)
};
cc.setProjectionMatrixDirty = function () {
    cc._currentProjectionMatrix = -1
};
cc.glEnableVertexAttribs = function (a) {
    var b = cc._renderContext,
        c = a & cc.VERTEX_ATTRIB_FLAG_POSITION;
    c !== cc._vertexAttribPosition && (c ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), cc._vertexAttribPosition = c);
    c = a & cc.VERTEX_ATTRIB_FLAG_COLOR;
    c !== cc._vertexAttribColor && (c ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), cc._vertexAttribColor = c);
    a &= cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
    a !== cc._vertexAttribTexCoords &&
        (a ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), cc._vertexAttribTexCoords = a)
};
cc.glBindTexture2D = function (a) {
    cc.glBindTexture2DN(0, a)
};
cc.glBindTexture2DN = function (a, b) {
    if (cc._currentBoundTexture[a] != b) {
        cc._currentBoundTexture[a] = b;
        var c = cc._renderContext;
        c.activeTexture(c.TEXTURE0 + a);
        b ? c.bindTexture(c.TEXTURE_2D, b._webTextureObj) : c.bindTexture(c.TEXTURE_2D, null)
    }
};
cc.ENABLE_GL_STATE_CACHE || (cc.glBindTexture2DN = function (a, b) {
    var c = cc._renderContext;
    c.activeTexture(c.TEXTURE0 + a);
    b ? c.bindTexture(c.TEXTURE_2D, b._webTextureObj) : c.bindTexture(c.TEXTURE_2D, null)
});
cc.glDeleteTexture = function (a) {
    cc.glDeleteTextureN(0, a)
};
cc.glDeleteTextureN = function (a, b) {
    cc.ENABLE_GL_STATE_CACHE && b == cc._currentBoundTexture[a] && (cc._currentBoundTexture[a] = -1);
    cc._renderContext.deleteTexture(b)
};
cc.glBindVAO = function (a) {
    cc.TEXTURE_ATLAS_USE_VAO && cc.ENABLE_GL_STATE_CACHE && cc._uVAO != a && (cc._uVAO = a)
};
cc.glEnable = function (a) {};
cc.IMAGE_FORMAT_JPEG = 0;
cc.IMAGE_FORMAT_PNG = 1;
cc.IMAGE_FORMAT_RAWDATA = 2;
cc.NextPOT = function (a) {
    a -= 1;
    a |= a >> 1;
    a |= a >> 2;
    a |= a >> 4;
    a |= a >> 8;
    return (a | a >> 16) + 1
};
cc.RenderTexture = cc.Node.extend({
    sprite: null,
    clearFlags: 0,
    clearDepthVal: 0,
    autoDraw: !1,
    _cacheCanvas: null,
    _cacheContext: null,
    _fBO: 0,
    _depthRenderBuffer: 0,
    _oldFBO: 0,
    _texture: null,
    _textureCopy: null,
    _uITextureImage: null,
    _pixelFormat: cc.Texture2D.PIXEL_FORMAT_RGBA8888,
    _clearColor: null,
    clearStencilVal: 0,
    _clearColorStr: null,
    _className: "RenderTexture",
    ctor: null,
    _ctorForCanvas: function () {
        cc.Node.prototype.ctor.call(this);
        this._clearColor = cc.color(255, 255, 255, 255);
        this._clearColorStr = "rgba(255,255,255,1)";
        this._cacheCanvas =
            document.createElement("canvas");
        this._cacheContext = this._cacheCanvas.getContext("2d");
        this.anchorY = this.anchorX = 0
    },
    _ctorForWebGL: function () {
        cc.Node.prototype.ctor.call(this);
        this._clearColor = cc.color(0, 0, 0, 0)
    },
    cleanup: null,
    _cleanupForCanvas: function () {
        cc.Node.prototype.onExit.call(this);
        this._cacheCanvas = this._cacheContext = null
    },
    _cleanupForWebGL: function () {
        cc.Node.prototype.onExit.call(this);
        this._textureCopy = null;
        var a = cc._renderContext;
        a.deleteFramebuffer(this._fBO);
        this._depthRenderBuffer && a.deleteRenderbuffer(this._depthRenderBuffer);
        this._uITextureImage = null
    },
    getSprite: function () {
        return this.sprite
    },
    setSprite: function (a) {
        this.sprite = a
    },
    initWithWidthAndHeight: null,
    _initWithWidthAndHeightForCanvas: function (a, b, c, d) {
        c = this._cacheCanvas;
        d = cc.CONTENT_SCALE_FACTOR();
        c.width = 0 | a * d;
        c.height = 0 | b * d;
        this._cacheContext.translate(0, c.height);
        a = new cc.Texture2D;
        a.initWithElement(c);
        a.handleLoadedTexture();
        this.sprite = cc.Sprite.create(a);
        return !0
    },
    _initWithWidthAndHeightForWebGL: function (a, b, c, d) {
        c == cc.Texture2D.PIXEL_FORMAT_A8 && cc.log("cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;");
        var e = cc._renderContext,
            f = cc.CONTENT_SCALE_FACTOR();
        a = 0 | a * f;
        b = 0 | b * f;
        this._oldFBO = e.getParameter(e.FRAMEBUFFER_BINDING);
        var g;
        cc.configuration.supportsNPOT() ? (f = a, g = b) : (f = cc.NextPOT(a), g = cc.NextPOT(b));
        for (var h = new Uint8Array(f * g * 4), k = 0; k < f * g * 4; k++) h[k] = 0;
        this._pixelFormat = c;
        this._texture = new cc.Texture2D;
        if (!this._texture) return !1;
        k = this._texture;
        k.initWithData(h, this._pixelFormat, f, g, cc.size(a, b));
        c = e.getParameter(e.RENDERBUFFER_BINDING);
        if (cc.configuration.checkForGLExtension("GL_QCOM")) {
            this._textureCopy =
                new cc.Texture2D;
            if (!this._textureCopy) return !1;
            this._textureCopy.initWithData(h, this._pixelFormat, f, g, cc.size(a, b))
        }
        this._fBO = e.createFramebuffer();
        e.bindFramebuffer(e.FRAMEBUFFER, this._fBO);
        e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, k._webTextureObj, 0);
        0 != d && (this._depthRenderBuffer = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, this._depthRenderBuffer), e.renderbufferStorage(e.RENDERBUFFER, d, f, g), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER,
            this._depthRenderBuffer));
        e.checkFramebufferStatus(e.FRAMEBUFFER) !== e.FRAMEBUFFER_COMPLETE && cc.log("Could not attach texture to the framebuffer");
        k.setAliasTexParameters();
        a = this.sprite = cc.Sprite.create(k);
        a.scaleY = -1;
        a.setBlendFunc(e.ONE, e.ONE_MINUS_SRC_ALPHA);
        e.bindRenderbuffer(e.RENDERBUFFER, c);
        e.bindFramebuffer(e.FRAMEBUFFER, this._oldFBO);
        this.autoDraw = !1;
        this.addChild(a);
        return !0
    },
    begin: null,
    _beginForCanvas: function () {
        cc._renderContext = this._cacheContext;
        cc.view._setScaleXYForRenderTexture()
    },
    _beginForWebGL: function () {
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLPushMatrix();
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLPushMatrix();
        var a = cc.director;
        a.setProjection(a.getProjection());
        var b = this._texture.getContentSizeInPixels(),
            c = cc.director.getWinSizeInPixels(),
            a = c.width / b.width,
            c = c.height / b.height,
            d = cc._renderContext;
        d.viewport(0, 0, b.width, b.height);
        b = new cc.kmMat4;
        cc.kmMat4OrthographicProjection(b, -1 / a, 1 / a, -1 / c, 1 / c, -1, 1);
        cc.kmGLMultMatrix(b);
        this._oldFBO = d.getParameter(d.FRAMEBUFFER_BINDING);
        d.bindFramebuffer(d.FRAMEBUFFER, this._fBO);
        cc.configuration.checkForGLExtension("GL_QCOM") && (d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, this._textureCopy._webTextureObj, 0), d.clear(d.COLOR_BUFFER_BIT | d.DEPTH_BUFFER_BIT), d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, this._texture._webTextureObj, 0))
    },
    beginWithClear: function (a, b, c, d, e, f) {
        var g = cc._renderContext;
        e = e || g.COLOR_BUFFER_BIT;
        f = f || g.COLOR_BUFFER_BIT | g.DEPTH_BUFFER_BIT;
        this._beginWithClear(a,
            b, c, d, e, f, g.COLOR_BUFFER_BIT | g.DEPTH_BUFFER_BIT | g.STENCIL_BUFFER_BIT)
    },
    _beginWithClear: null,
    _beginWithClearForCanvas: function (a, b, c, d, e, f, g) {
        this.begin();
        a = a || 0;
        b = b || 0;
        c = c || 0;
        d = isNaN(d) ? 1 : d;
        e = this._cacheContext;
        f = this._cacheCanvas;
        e.save();
        e.fillStyle = "rgba(" + (0 | a) + "," + (0 | b) + "," + (0 | c) + "," + d / 255 + ")";
        e.clearRect(0, 0, f.width, -f.height);
        e.fillRect(0, 0, f.width, -f.height);
        e.restore()
    },
    _beginWithClearForWebGL: function (a, b, c, d, e, f, g) {
        this.begin();
        var h = cc._renderContext,
            k = [0, 0, 0, 0],
            m = 0,
            n = 0;
        g & h.COLOR_BUFFER_BIT &&
            (k = h.getParameter(h.COLOR_CLEAR_VALUE), h.clearColor(a, b, c, d));
        g & h.DEPTH_BUFFER_BIT && (m = h.getParameter(h.DEPTH_CLEAR_VALUE), h.clearDepth(e));
        g & h.STENCIL_BUFFER_BIT && (n = h.getParameter(h.STENCIL_CLEAR_VALUE), h.clearStencil(f));
        h.clear(g);
        g & h.COLOR_BUFFER_BIT && h.clearColor(k[0], k[1], k[2], k[3]);
        g & h.DEPTH_BUFFER_BIT && h.clearDepth(m);
        g & h.STENCIL_BUFFER_BIT && h.clearStencil(n)
    },
    end: null,
    _endForCanvas: function () {
        cc._renderContext = cc._mainRenderContextBackup;
        cc.view._resetScale()
    },
    _endForWebGL: function () {
        var a =
            cc._renderContext,
            b = cc.director;
        a.bindFramebuffer(a.FRAMEBUFFER, this._oldFBO);
        b.setViewport();
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLPopMatrix();
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLPopMatrix()
    },
    clear: function (a, b, c, d) {
        this.beginWithClear(a, b, c, d);
        this.end()
    },
    clearRect: null,
    _clearRectForCanvas: function (a, b, c, d) {
        this._cacheContext.clearRect(a, b, c, -d)
    },
    _clearRectForWebGL: function (a, b, c, d) {},
    clearDepth: null,
    _clearDepthForCanvas: function (a) {
        cc.log("clearDepth isn't supported on Cocos2d-Html5")
    },
    _clearDepthForWebGL: function (a) {
        this.begin();
        var b = cc._renderContext,
            c = b.getParameter(b.DEPTH_CLEAR_VALUE);
        b.clearDepth(a);
        b.clear(b.DEPTH_BUFFER_BIT);
        b.clearDepth(c);
        this.end()
    },
    clearStencil: null,
    _clearStencilForCanvas: function (a) {
        cc.log("clearDepth isn't supported on Cocos2d-Html5")
    },
    _clearStencilForWebGL: function (a) {
        var b = cc._renderContext,
            c = b.getParameter(b.STENCIL_CLEAR_VALUE);
        b.clearStencil(a);
        b.clear(b.STENCIL_BUFFER_BIT);
        b.clearStencil(c)
    },
    visit: null,
    _visitForCanvas: function (a) {
        this._visible &&
            (a = a || cc._renderContext, a.save(), this.draw(a), this.transform(a), this.sprite.visit(), a.restore(), this.arrivalOrder = 0)
    },
    _visitForWebGL: function (a) {
        if (this._visible) {
            cc.kmGLPushMatrix();
            var b = this.grid;
            b && b.isActive() && (b.beforeDraw(), this.transformAncestors());
            this.transform(a);
            this.sprite.visit();
            this.draw(a);
            b && b.isActive() && b.afterDraw(this);
            cc.kmGLPopMatrix();
            this.arrivalOrder = 0
        }
    },
    draw: null,
    _drawForCanvas: function (a) {
        a = a || cc._renderContext;
        if (this.autoDraw) {
            this.begin();
            if (this.clearFlags) {
                var b =
                    this._cacheCanvas;
                a.save();
                a.fillStyle = this._clearColorStr;
                a.clearRect(0, 0, b.width, -b.height);
                a.fillRect(0, 0, b.width, -b.height);
                a.restore()
            }
            this.sortAllChildren();
            a = this._children;
            for (var b = a.length, c = this.sprite, d = 0; d < b; d++) {
                var e = a[d];
                e != c && e.visit()
            }
            this.end()
        }
    },
    _drawForWebGL: function (a) {
        a = cc._renderContext;
        if (this.autoDraw) {
            this.begin();
            var b = this.clearFlags;
            if (b) {
                var c = [0, 0, 0, 0],
                    d = 0,
                    e = 0;
                b & a.COLOR_BUFFER_BIT && (c = a.getParameter(a.COLOR_CLEAR_VALUE), a.clearColor(this._clearColor.r / 255, this._clearColor.g /
                    255, this._clearColor.b / 255, this._clearColor.a / 255));
                b & a.DEPTH_BUFFER_BIT && (d = a.getParameter(a.DEPTH_CLEAR_VALUE), a.clearDepth(this.clearDepthVal));
                b & a.STENCIL_BUFFER_BIT && (e = a.getParameter(a.STENCIL_CLEAR_VALUE), a.clearStencil(this.clearStencilVal));
                a.clear(b);
                b & a.COLOR_BUFFER_BIT && a.clearColor(c[0], c[1], c[2], c[3]);
                b & a.DEPTH_BUFFER_BIT && a.clearDepth(d);
                b & a.STENCIL_BUFFER_BIT && a.clearStencil(e)
            }
            this.sortAllChildren();
            a = this._children;
            for (b = 0; b < a.length; b++) c = a[b], c != this.sprite && c.visit();
            this.end()
        }
    },
    newCCImage: function (a) {
        cc.log("saveToFile isn't supported on cocos2d-html5");
        return null
    },
    _memcpy: function (a, b, c, d, e) {
        for (var f = 0; f < e; f++) a[b + f] = c[d + f]
    },
    saveToFile: function (a, b) {
        cc.log("saveToFile isn't supported on Cocos2d-Html5")
    },
    listenToBackground: function (a) {
        cc.log("listenToBackground isn't supported on Cocos2d-Html5")
    },
    listenToForeground: function (a) {
        cc.log("listenToForeground isn't supported on Cocos2d-Html5")
    },
    getClearFlags: function () {
        return this.clearFlags
    },
    setClearFlags: function (a) {
        this.clearFlags =
            a
    },
    getClearColor: function () {
        return this._clearColor
    },
    setClearColor: null,
    _setClearColorForCanvas: function (a) {
        var b = this._clearColor;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        b.a = a.a;
        this._clearColorStr = "rgba(" + (0 | a.r) + "," + (0 | a.g) + "," + (0 | a.b) + "," + a.a / 255 + ")"
    },
    _setClearColorForWebGL: function (a) {
        var b = this._clearColor;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        b.a = a.a
    },
    getClearDepth: function () {
        return this.clearDepthVal
    },
    setClearDepth: function (a) {
        this.clearDepthVal = a
    },
    getClearStencil: function () {
        return this.clearStencilVal
    },
    setClearStencil: function (a) {
        this.clearStencilVal =
            a
    },
    isAutoDraw: function () {
        return this.autoDraw
    },
    setAutoDraw: function (a) {
        this.autoDraw = a
    }
});
window._p = cc.RenderTexture.prototype;
cc._renderType == cc._RENDER_TYPE_WEBGL ? (_p.ctor = _p._ctorForWebGL, _p.cleanup = _p._cleanupForWebGL, _p.initWithWidthAndHeight = _p._initWithWidthAndHeightForWebGL, _p.begin = _p._beginForWebGL, _p._beginWithClear = _p._beginWithClearForWebGL, _p.end = _p._endForWebGL, _p.clearRect = _p._clearRectForWebGL, _p.clearDepth = _p._clearDepthForWebGL, _p.clearStencil = _p._clearStencilForWebGL, _p.visit = _p._visitForWebGL, _p.draw = _p._drawForWebGL, _p.setClearColor = _p._setClearColorForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.cleanup = _p._cleanupForCanvas,
    _p.initWithWidthAndHeight = _p._initWithWidthAndHeightForCanvas, _p.begin = _p._beginForCanvas, _p._beginWithClear = _p._beginWithClearForCanvas, _p.end = _p._endForCanvas, _p.clearRect = _p._clearRectForCanvas, _p.clearDepth = _p._clearDepthForCanvas, _p.clearStencil = _p._clearStencilForCanvas, _p.visit = _p._visitForCanvas, _p.draw = _p._drawForCanvas, _p.setClearColor = _p._setClearColorForCanvas);
cc.defineGetterSetter(_p, "clearColorVal", _p.getClearColor, _p.setClearColor);
delete window._p;
cc.RenderTexture.create = function (a, b, c, d) {
    c = c || cc.Texture2D.PIXEL_FORMAT_RGBA8888;
    d = d || 0;
    var e = new cc.RenderTexture;
    return e && e.initWithWidthAndHeight(a, b, c, d) ? e : null
};
cc.LabelAtlas = cc.AtlasNode.extend({
    _string: null,
    _mapStartChar: null,
    _textureLoaded: !1,
    _loadedEventListeners: null,
    _className: "LabelAtlas",
    ctor: function () {
        cc.AtlasNode.prototype.ctor.call(this)
    },
    textureLoaded: function () {
        return this._textureLoaded
    },
    addLoadedEventListener: function (a, b) {
        this._loadedEventListeners || (this._loadedEventListeners = []);
        this._loadedEventListeners.push({
            eventCallback: a,
            eventTarget: b
        })
    },
    _callLoadedEventCallbacks: function () {
        if (this._loadedEventListeners) {
            this._textureLoaded = !0;
            for (var a =
                this._loadedEventListeners, b = 0, c = a.length; b < c; b++) {
                var d = a[b];
                d.eventCallback.call(d.eventTarget, this)
            }
            a.length = 0
        }
    },
    initWithString: function (a, b, c, d, e) {
        var f = a + "",
            g, h, k, m;
        if (2 === arguments.length) {
            m = cc.loader.getRes(b);
            if (1 !== parseInt(m.version, 10)) return cc.log("cc.LabelAtlas.initWithString(): Unsupported version. Upgrade cocos2d version"), !1;
            g = cc.path.changeBasename(b, m.textureFilename);
            var n = cc.CONTENT_SCALE_FACTOR();
            h = parseInt(m.itemWidth, 10) / n;
            k = parseInt(m.itemHeight, 10) / n;
            m = String.fromCharCode(parseInt(m.firstChar,
                10))
        } else g = b, h = c || 0, k = d || 0, m = e || " ";
        var p = null,
            p = g instanceof cc.Texture2D ? g : cc.textureCache.addImage(g);
        (this._textureLoaded = g = p.isLoaded()) || p.addLoadedEventListener(function (a) {
            this.initWithTexture(p, h, k, f.length);
            this.string = f;
            this._callLoadedEventCallbacks()
        }, this);
        return this.initWithTexture(p, h, k, f.length) ? (this._mapStartChar = m, this.string = f, !0) : !1
    },
    setColor: function (a) {
        cc.AtlasNode.prototype.setColor.call(this, a);
        this.updateAtlasValues()
    },
    getString: function () {
        return this._string
    },
    draw: function (a) {
        cc.AtlasNode.prototype.draw.call(this,
            a);
        cc.LABELATLAS_DEBUG_DRAW && (a = this.size, a = [cc.p(0, 0), cc.p(a.width, 0), cc.p(a.width, a.height), cc.p(0, a.height)], cc._drawingUtil.drawPoly(a, 4, !0))
    },
    updateAtlasValues: null,
    _updateAtlasValuesForCanvas: function () {
        for (var a = this._string, b = a.length, c = this.texture, d = this._itemWidth, e = this._itemHeight, f = 0; f < b; f++) {
            var g = a.charCodeAt(f) - this._mapStartChar.charCodeAt(0),
                h = parseInt(g % this._itemsPerRow, 10),
                g = parseInt(g / this._itemsPerRow, 10),
                h = cc.rect(h * d, g * e, d, e),
                g = a.charCodeAt(f),
                k = this.getChildByTag(f);
            k ? 32 ==
                g ? (k.init(), k.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : (k.initWithTexture(c, h), k.visible = !0, k.opacity = this._displayedOpacity) : (k = new cc.Sprite, 32 == g ? (k.init(), k.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : k.initWithTexture(c, h), this.addChild(k, 0, f));
            k.setPosition(f * d + d / 2, e / 2)
        }
    },
    _updateAtlasValuesForWebGL: function () {
        var a = this._string,
            b = a.length,
            c = this.textureAtlas,
            d = c.texture,
            e = d.pixelsWidth,
            d = d.pixelsHeight,
            f = this._itemWidth,
            g = this._itemHeight;
        this._ignoreContentScaleFactor || (f =
            this._itemWidth * cc.CONTENT_SCALE_FACTOR(), g = this._itemHeight * cc.CONTENT_SCALE_FACTOR());
        b > c.getCapacity() && cc.log("cc.LabelAtlas._updateAtlasValues(): Invalid String length");
        for (var h = c.quads, k = this._displayedColor, k = {
            r: k.r,
            g: k.g,
            b: k.b,
            a: this._displayedOpacity
        }, m = this._itemWidth, n = 0; n < b; n++) {
            var p = a.charCodeAt(n) - this._mapStartChar.charCodeAt(0),
                r = p % this._itemsPerRow,
                q = 0 | p / this._itemsPerRow,
                s;
            cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (r = (2 * r * f + 1) / (2 * e), p = r + (2 * f - 2) / (2 * e), q = (2 * q * g + 1) / (2 * d), s = q + (2 * g - 2) / (2 *
                d)) : (r = r * f / e, p = r + f / e, q = q * g / d, s = q + g / d);
            var t = h[n],
                x = t.tl,
                y = t.tr,
                B = t.bl,
                t = t.br;
            x.texCoords.u = r;
            x.texCoords.v = q;
            y.texCoords.u = p;
            y.texCoords.v = q;
            B.texCoords.u = r;
            B.texCoords.v = s;
            t.texCoords.u = p;
            t.texCoords.v = s;
            B.vertices.x = n * m;
            B.vertices.y = 0;
            B.vertices.z = 0;
            t.vertices.x = n * m + m;
            t.vertices.y = 0;
            t.vertices.z = 0;
            x.vertices.x = n * m;
            x.vertices.y = this._itemHeight;
            x.vertices.z = 0;
            y.vertices.x = n * m + m;
            y.vertices.y = this._itemHeight;
            y.vertices.z = 0;
            x.colors = k;
            y.colors = k;
            B.colors = k;
            t.colors = k
        }
        0 < b && (c.dirty = !0, a = c.totalQuads,
            b > a && c.increaseTotalQuadsWith(b - a))
    },
    setString: null,
    _setStringForCanvas: function (a) {
        a = String(a);
        var b = a.length;
        this._string = a;
        this.width = b * this._itemWidth;
        this.height = this._itemHeight;
        if (this._children) {
            a = this._children;
            for (var b = a.length, c = 0; c < b; c++) {
                var d = a[c];
                d && (d.visible = !1)
            }
        }
        this.updateAtlasValues();
        this.quadsToDraw = b
    },
    _setStringForWebGL: function (a) {
        a = String(a);
        var b = a.length;
        b > this.textureAtlas.totalQuads && this.textureAtlas.resizeCapacity(b);
        this._string = a;
        this.width = b * this._itemWidth;
        this.height =
            this._itemHeight;
        this.updateAtlasValues();
        this.quadsToDraw = b
    },
    setOpacity: null,
    _setOpacityForCanvas: function (a) {
        if (this._displayedOpacity !== a) {
            cc.AtlasNode.prototype.setOpacity.call(this, a);
            for (var b = this._children, c = 0, d = b.length; c < d; c++) b[c] && (b[c].opacity = a)
        }
    },
    _setOpacityForWebGL: function (a) {
        this._opacity !== a && cc.AtlasNode.prototype.setOpacity.call(this, a)
    }
});
window._p = cc.LabelAtlas.prototype;
cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.updateAtlasValues = _p._updateAtlasValuesForWebGL, _p.setString = _p._setStringForWebGL, _p.setOpacity = _p._setOpacityForWebGL) : (_p.updateAtlasValues = _p._updateAtlasValuesForCanvas, _p.setString = _p._setStringForCanvas, _p.setOpacity = _p._setOpacityForCanvas);
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
delete window._p;
cc.LabelAtlas.create = function (a, b, c, d, e) {
    var f = new cc.LabelAtlas;
    return f && cc.LabelAtlas.prototype.initWithString.apply(f, arguments) ? f : null
};
cc.LABEL_AUTOMATIC_WIDTH = -1;
cc.LabelBMFont = cc.SpriteBatchNode.extend({
    RGBAProtocol: !0,
    _opacityModifyRGB: !1,
    _string: "",
    _config: null,
    _fntFile: "",
    _initialString: "",
    _alignment: cc.TEXT_ALIGNMENT_CENTER,
    _width: -1,
    _lineBreakWithoutSpaces: !1,
    _imageOffset: null,
    _reusedChar: null,
    _displayedOpacity: 255,
    _realOpacity: 255,
    _displayedColor: null,
    _realColor: null,
    _cascadeColorEnabled: !0,
    _cascadeOpacityEnabled: !0,
    _textureLoaded: !1,
    _loadedEventListeners: null,
    _className: "LabelBMFont",
    _setString: function (a, b) {
        b ? this._initialString = a : this._string = a;
        var c = this._children;
        if (c)
            for (var d = 0; d < c.length; d++) {
                var e = c[d];
                e && e.setVisible(!1)
            }
        this._textureLoaded && (this.createFontChars(), b && this.updateLabel())
    },
    ctor: function () {
        cc.SpriteBatchNode.prototype.ctor.call(this);
        this._imageOffset = cc.p(0, 0);
        this._displayedColor = cc.color(255, 255, 255, 255);
        this._realColor = cc.color(255, 255, 255, 255);
        this._reusedChar = []
    },
    textureLoaded: function () {
        return this._textureLoaded
    },
    addLoadedEventListener: function (a, b) {
        this._loadedEventListeners || (this._loadedEventListeners = []);
        this._loadedEventListeners.push({
            eventCallback: a,
            eventTarget: b
        })
    },
    _callLoadedEventCallbacks: function () {
        if (this._loadedEventListeners) {
            for (var a = this._loadedEventListeners, b = 0, c = a.length; b < c; b++) {
                var d = a[b];
                d.eventCallback.call(d.eventTarget, this)
            }
            a.length = 0
        }
    },
    draw: function (a) {
        cc.SpriteBatchNode.prototype.draw.call(this, a);
        if (cc.LABELBMFONT_DEBUG_DRAW) {
            a = this.getContentSize();
            var b = cc.p(0 | -this._anchorPointInPoints.x, 0 | -this._anchorPointInPoints.y);
            a = [cc.p(b.x, b.y), cc.p(b.x + a.width, b.y), cc.p(b.x + a.width,
                b.y + a.height), cc.p(b.x, b.y + a.height)];
            cc._drawingUtil.setDrawColor(0, 255, 0, 255);
            cc._drawingUtil.drawPoly(a, 4, !0)
        }
    },
    setColor: function (a) {
        var b = this._displayedColor,
            c = this._realColor;
        if (c.r != a.r || c.g != a.g || c.b != a.b || c.a != a.a) b.r = c.r = a.r, b.g = c.g = a.g, b.b = c.b = a.b, this._textureLoaded && this._cascadeColorEnabled && (b = cc.color.WHITE, (c = this._parent) && c.RGBAProtocol && c.cascadeColor && (b = c.getDisplayedColor()), this.updateDisplayedColor(b)), void 0 === a.a || a.a_undefined || this.setOpacity(a.a)
    },
    isOpacityModifyRGB: function () {
        return this._opacityModifyRGB
    },
    setOpacityModifyRGB: function (a) {
        this._opacityModifyRGB = a;
        if (a = this._children)
            for (var b = 0; b < a.length; b++) {
                var c = a[b];
                c && c.RGBAProtocol && (c.opacityModifyRGB = this._opacityModifyRGB)
            }
    },
    getOpacity: function () {
        return this._realOpacity
    },
    getDisplayedOpacity: function () {
        return this._displayedOpacity
    },
    setOpacity: function (a) {
        this._displayedOpacity = this._realOpacity = a;
        if (this._cascadeOpacityEnabled) {
            var b = 255,
                c = this._parent;
            c && c.RGBAProtocol && c.cascadeOpacity && (b = c.getDisplayedOpacity());
            this.updateDisplayedOpacity(b)
        }
        this._displayedColor.a =
            this._realColor.a = a
    },
    updateDisplayedOpacity: function (a) {
        this._displayedOpacity = this._realOpacity * a / 255;
        a = this._children;
        for (var b = 0; b < a.length; b++) {
            var c = a[b];
            cc._renderType == cc._RENDER_TYPE_WEBGL ? c.updateDisplayedOpacity(this._displayedOpacity) : (cc.NodeRGBA.prototype.updateDisplayedOpacity.call(c, this._displayedOpacity), c.setNodeDirty())
        }
        this._changeTextureColor()
    },
    isCascadeOpacityEnabled: function () {
        return !1
    },
    setCascadeOpacityEnabled: function (a) {
        this._cascadeOpacityEnabled = a
    },
    getColor: function () {
        var a =
            this._realColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getDisplayedColor: function () {
        return this._displayedColor
    },
    updateDisplayedColor: function (a) {
        var b = this._displayedColor,
            c = this._realColor;
        b.r = c.r * a.r / 255;
        b.g = c.g * a.g / 255;
        b.b = c.b * a.b / 255;
        a = this._children;
        for (b = 0; b < a.length; b++) c = a[b], cc._renderType == cc._RENDER_TYPE_WEBGL ? c.updateDisplayedColor(this._displayedColor) : (cc.NodeRGBA.prototype.updateDisplayedColor.call(c, this._displayedColor), c.setNodeDirty());
        this._changeTextureColor()
    },
    _changeTextureColor: function () {
        if (cc._renderType !=
            cc._RENDER_TYPE_WEBGL) {
            var a, b = this.texture;
            b && 0 < b.width && (a = b.getHtmlElementObj()) && (b = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj())) && (a instanceof HTMLCanvasElement && !this._rectRotated ? cc.generateTintImage(a, b, this._displayedColor, null, a) : (a = cc.generateTintImage(a, b, this._displayedColor), b = new cc.Texture2D, b.initWithElement(a), b.handleLoadedTexture(), this.texture = b))
        }
    },
    isCascadeColorEnabled: function () {
        return !1
    },
    setCascadeColorEnabled: function (a) {
        this._cascadeColorEnabled =
            a
    },
    init: function () {
        return this.initWithString(null, null, null, null, null)
    },
    initWithString: function (a, b, c, d, e) {
        a = a || "";
        this._config && cc.log("cc.LabelBMFont.initWithString(): re-init is no longer supported");
        if (b) {
            var f = cc.loader.getRes(b);
            if (!f) return cc.log("cc.LabelBMFont.initWithString(): Impossible to create font. Please check file"), !1;
            this._config = f;
            this._fntFile = b;
            b = cc.textureCache.addImage(f.atlasName);
            (this._textureLoaded = f = b.isLoaded()) || b.addLoadedEventListener(function (a) {
                this._textureLoaded = !0;
                this.initWithTexture(a, this._initialString.length);
                this.setString(this._initialString, !0);
                this._callLoadedEventCallbacks()
            }, this)
        } else b = new cc.Texture2D, f = new Image, b.initWithElement(f), this._textureLoaded = !1;
        return this.initWithTexture(b, a.length) ? (this._alignment = d || cc.TEXT_ALIGNMENT_LEFT, this._imageOffset = e || cc.p(0, 0), this._width = null == c ? -1 : c, this._displayedOpacity = this._realOpacity = 255, this._displayedColor = cc.color(255, 255, 255, 255), this._realColor = cc.color(255, 255, 255, 255), this._cascadeColorEnabled =
            this._cascadeOpacityEnabled = !0, this._contentSize.width = 0, this._contentSize.height = 0, this.setAnchorPoint(0.5, 0.5), cc._renderType === cc._RENDER_TYPE_WEBGL && (c = this.textureAtlas.texture, this._opacityModifyRGB = c.hasPremultipliedAlpha(), d = this._reusedChar = new cc.Sprite, d.initWithTexture(c, cc.rect(0, 0, 0, 0), !1), d.batchNode = this), this.setString(a, !0), !0) : !1
    },
    createFontChars: function () {
        var a = cc._renderType,
            b = a === cc._RENDER_TYPE_CANVAS ? this.texture : this.textureAtlas.texture,
            c = 0,
            d = cc.size(0, 0),
            e = 0,
            f = 1,
            g = this._string,
            h = g ? g.length : 0;
        if (0 !== h) {
            var k, m = this._config,
                n = m.kerningDict,
                p = m.commonHeight,
                r = m.fontDefDictionary;
            for (k = 0; k < h - 1; k++) 10 == g.charCodeAt(k) && f++;
            var q = p * f,
                f = -(p - p * f),
                s = -1;
            for (k = 0; k < h; k++)
                if (p = g.charCodeAt(k), 0 != p)
                    if (10 === p) c = 0, f -= m.commonHeight;
                    else {
                        var t = n[s << 16 | p & 65535] || 0,
                            x = r[p];
                        if (x) {
                            var y = cc.rect(x.rect.x, x.rect.y, x.rect.width, x.rect.height),
                                y = cc.RECT_PIXELS_TO_POINTS(y);
                            y.x += this._imageOffset.x;
                            y.y += this._imageOffset.y;
                            (s = this.getChildByTag(k)) ? 32 === p && a === cc._RENDER_TYPE_CANVAS ? s.setTextureRect(y, !1, cc.size(0, 0)) : (s.setTextureRect(y, !1), s.visible = !0): (s = new cc.Sprite, 32 === p && a === cc._RENDER_TYPE_CANVAS && (y = cc.rect(0, 0, 0, 0)), s.initWithTexture(b, y, !1), s._newTextureWhenChangeColor = !0, this.addChild(s, 0, k));
                            s.opacityModifyRGB = this._opacityModifyRGB;
                            cc._renderType == cc._RENDER_TYPE_WEBGL ? (s.updateDisplayedColor(this._displayedColor), s.updateDisplayedOpacity(this._displayedOpacity)) : (cc.NodeRGBA.prototype.updateDisplayedColor.call(s, this._displayedColor), cc.NodeRGBA.prototype.updateDisplayedOpacity.call(s,
                                this._displayedOpacity), s.setNodeDirty());
                            y = cc.p(c + x.xOffset + 0.5 * x.rect.width + t, f + (m.commonHeight - x.yOffset) - 0.5 * y.height * cc.CONTENT_SCALE_FACTOR());
                            s.setPosition(cc.POINT_PIXELS_TO_POINTS(y));
                            c += x.xAdvance + t;
                            s = p;
                            e < c && (e = c)
                        } else cc.log("cocos2d: LabelBMFont: character not found " + g[k])
                    }
            d.width = e;
            d.height = q;
            this.setContentSize(cc.SIZE_PIXELS_TO_POINTS(d))
        }
    },
    updateString: function (a) {
        var b = this._children;
        if (b)
            for (var c = 0, d = b.length; c < d; c++) {
                var e = b[c];
                e && (e.visible = !1)
            }
        this._config && this.createFontChars();
        a || this.updateLabel()
    },
    getString: function () {
        return this._initialString
    },
    setString: function (a, b) {
        a = String(a);
        null == b && (b = !0);
        if (null == a || "string" != typeof a) a += "";
        this._initialString = a;
        this._setString(a, b)
    },
    _setStringForSetter: function (a) {
        this.setString(a, !1)
    },
    setCString: function (a) {
        this.setString(a, !0)
    },
    updateLabel: function () {
        this.string = this._initialString;
        if (0 < this._width) {
            for (var a = this._string.length, b = [], c = [], d = 1, e = 0, f = !1, g = !1, h = -1, k = -1, m = 0, n, p = 0, r = this._children.length; p < r; p++) {
                for (var q = 0; !(n =
                    this.getChildByTag(p + m + q));) q++;
                m += q;
                if (e >= a) break;
                var s = this._string[e];
                g || (k = this._getLetterPosXLeft(n), g = !0);
                f || (h = k, f = !0);
                if (10 == s.charCodeAt(0)) {
                    c.push("\n");
                    b = b.concat(c);
                    c.length = 0;
                    f = g = !1;
                    h = k = -1;
                    e += q;
                    d++;
                    if (e >= a) break;
                    k || (k = this._getLetterPosXLeft(n), g = !0);
                    h || (h = k, f = !0);
                    e++
                } else if (cc.isspace_unicode(s)) c.push(s), b = b.concat(c), c.length = 0, g = !1, k = -1, e++;
                else if (this._getLetterPosXRight(n) - h > this._width)
                    if (this._lineBreakWithoutSpaces) {
                        cc.utf8_trim_ws(c);
                        c.push("\n");
                        b = b.concat(c);
                        c.length = 0;
                        f = g = !1;
                        h = k = -1;
                        d++;
                        if (e >= a) break;
                        k || (k = this._getLetterPosXLeft(n), g = !0);
                        h || (h = k, f = !0);
                        p--
                    } else c.push(s), -1 != b.lastIndexOf(" ") ? cc.utf8_trim_ws(b) : b = [], 0 < b.length && b.push("\n"), d++, f = !1, h = -1, e++;
                else c.push(s), e++
            }
            b = b.concat(c);
            p = b.length;
            n = "";
            for (e = 0; e < p; ++e) n += b[e];
            n += String.fromCharCode(0);
            this._setString(n, !1)
        }
        if (this._alignment != cc.TEXT_ALIGNMENT_LEFT)
            for (b = e = 0, a = this._string.length, c = [], d = 0; d < a; d++)
                if (10 == this._string[d].charCodeAt(0) || 0 == this._string[d].charCodeAt(0)) {
                    if (p = 0, f = c.length, n = e +
                        f - 1 + b, !(0 > n) && (p = this.getChildByTag(n), null != p)) {
                        p = p.getPositionX() + p._getWidth() / 2;
                        g = 0;
                        switch (this._alignment) {
                        case cc.TEXT_ALIGNMENT_CENTER:
                            g = this.width / 2 - p / 2;
                            break;
                        case cc.TEXT_ALIGNMENT_RIGHT:
                            g = this.width - p
                        }
                        if (0 != g)
                            for (p = 0; p < f; p++)(n = e + p + b, 0 > n || !(n = this.getChildByTag(n))) || (n.x += g);
                        e += f;
                        b++;
                        c.length = 0
                    }
                } else c.push(this._string[e])
    },
    setAlignment: function (a) {
        this._alignment = a;
        this.updateLabel()
    },
    _getAlignment: function () {
        return this._alignment
    },
    setBoundingWidth: function (a) {
        this._width = a;
        this.updateLabel()
    },
    _getBoundingWidth: function () {
        return this._width
    },
    setLineBreakWithoutSpace: function (a) {
        this._lineBreakWithoutSpaces = a;
        this.updateLabel()
    },
    setScale: function (a, b) {
        cc.Node.prototype.setScale.call(this, a, b);
        this.updateLabel()
    },
    setScaleX: function (a) {
        cc.Node.prototype.setScaleX.call(this, a);
        this.updateLabel()
    },
    setScaleY: function (a) {
        cc.Node.prototype.setScaleY.call(this, a);
        this.updateLabel()
    },
    setFntFile: function (a) {
        if (null != a && a != this._fntFile) {
            var b = cc.loader.getRes(a);
            b ? (this._fntFile = a, this._config = b,
                a = cc.textureCache.addImage(b.atlasName), this._textureLoaded = b = a.isLoaded(), this.texture = a, cc._renderType === cc._RENDER_TYPE_CANVAS && (this._originalTexture = this.texture), b ? this.createFontChars() : a.addLoadedEventListener(function (a) {
                    this._textureLoaded = !0;
                    this.texture = a;
                    this.createFontChars();
                    this._changeTextureColor();
                    this.updateLabel();
                    this._callLoadedEventCallbacks()
                }, this)) : cc.log("cc.LabelBMFont.setFntFile() : Impossible to create font. Please check file")
        }
    },
    getFntFile: function () {
        return this._fntFile
    },
    setAnchorPoint: function (a, b) {
        cc.Node.prototype.setAnchorPoint.call(this, a, b);
        this.updateLabel()
    },
    _setAnchor: function (a) {
        cc.Node.prototype._setAnchor.call(this, a);
        this.updateLabel()
    },
    _setAnchorX: function (a) {
        cc.Node.prototype._setAnchorX.call(this, a);
        this.updateLabel()
    },
    _setAnchorY: function (a) {
        cc.Node.prototype._setAnchorY.call(this, a);
        this.updateLabel()
    },
    _atlasNameFromFntFile: function (a) {},
    _kerningAmountForFirst: function (a, b) {
        var c = 0;
        if (this._configuration.kerningDictionary) {
            var d = this._configuration.kerningDictionary[(a <<
                16 | b & 65535).toString()];
            d && (c = d.amount)
        }
        return c
    },
    _getLetterPosXLeft: function (a) {
        return a.getPositionX() * this._scaleX + a._getWidth() * this._scaleX * a._getAnchorX()
    },
    _getLetterPosXRight: function (a) {
        return a.getPositionX() * this._scaleX - a._getWidth() * this._scaleX * a._getAnchorX()
    }
});
window._p = cc.LabelBMFont.prototype;
cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "cascadeOpacity", _p.isCascadeOpacityEnabled, _p.setCascadeOpacityEnabled);
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, "cascadeColor", _p.isCascadeColorEnabled, _p.setCascadeColorEnabled);
cc.defineGetterSetter(_p, "string", _p.getString, _p._setStringForSetter);
cc.defineGetterSetter(_p, "boundingWidth", _p._getBoundingWidth, _p.setBoundingWidth);
cc.defineGetterSetter(_p, "textAlign", _p._getAlignment, _p.setAlignment);
delete window._p;
cc.LabelBMFont.create = function (a, b, c, d, e) {
    var f = new cc.LabelBMFont;
    return void 0 === a ? f && f.init() ? f : null : f && f.initWithString(a, b, c, d, e) ? f : null
};
cc.isspace_unicode = function (a) {
    a = a.charCodeAt(0);
    return 9 <= a && 13 >= a || 32 == a || 133 == a || 160 == a || 5760 == a || 8192 <= a && 8202 >= a || 8232 == a || 8233 == a || 8239 == a || 8287 == a || 12288 == a
};
cc.utf8_trim_ws = function (a) {
    var b = a.length;
    if (!(0 >= b) && (b -= 1, cc.isspace_unicode(a[b]))) {
        for (var c = b - 1; 0 <= c; --c)
            if (cc.isspace_unicode(a[c])) b = c;
            else break;
        cc.utf8_trim_from(a, b)
    }
};
cc.utf8_trim_from = function (a, b) {
    var c = a.length;
    b >= c || 0 > b || a.splice(b, c)
};
cc._fntLoader = {
    INFO_EXP: /info [^\n]*(\n|$)/gi,
    COMMON_EXP: /common [^\n]*(\n|$)/gi,
    PAGE_EXP: /page [^\n]*(\n|$)/gi,
    CHAR_EXP: /char [^\n]*(\n|$)/gi,
    KERNING_EXP: /kerning [^\n]*(\n|$)/gi,
    ITEM_EXP: /\w+=[^ \r\n]+/gi,
    INT_EXP: /^[\-]?\d+$/,
    _parseStrToObj: function (a) {
        a = a.match(this.ITEM_EXP);
        var b = {};
        if (a)
            for (var c = 0, d = a.length; c < d; c++) {
                var e = a[c],
                    f = e.indexOf("\x3d"),
                    g = e.substring(0, f),
                    e = e.substring(f + 1);
                e.match(this.INT_EXP) ? e = parseInt(e) : '"' == e[0] && (e = e.substring(1, e.length - 1));
                b[g] = e
            }
        return b
    },
    parseFnt: function (a,
        b) {
        var c = {},
            d = this._parseStrToObj(a.match(this.INFO_EXP)[0]).padding.split(",");
        parseInt(d[0]);
        parseInt(d[1]);
        parseInt(d[2]);
        parseInt(d[3]);
        d = this._parseStrToObj(a.match(this.COMMON_EXP)[0]);
        c.commonHeight = d.lineHeight;
        if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
            var e = cc.configuration.getMaxTextureSize();
            (d.scaleW > e.width || d.scaleH > e.height) && cc.log("cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported")
        }
        1 !== d.pages && cc.log("cc.LabelBMFont._parseCommonArguments(): only supports 1 page");
        d = this._parseStrToObj(a.match(this.PAGE_EXP)[0]);
        0 !== d.id && cc.log("cc.LabelBMFont._parseImageFileName() : file could not be found");
        c.atlasName = cc.path.changeBasename(b, d.file);
        for (var f = a.match(this.CHAR_EXP), g = c.fontDefDictionary = {}, d = 0, e = f.length; d < e; d++) {
            var h = this._parseStrToObj(f[d]);
            g[h.id] = {
                rect: {
                    x: h.x,
                    y: h.y,
                    width: h.width,
                    height: h.height
                },
                xOffset: h.xoffset,
                yOffset: h.yoffset,
                xAdvance: h.xadvance
            }
        }
        f = c.kerningDict = {};
        if (g = a.match(this.KERNING_EXP))
            for (d = 0, e = g.length; d < e; d++) h = this._parseStrToObj(g[d]),
                f[h.first << 16 | h.second & 65535] = h.amount;
        return c
    },
    load: function (a, b, c, d) {
        var e = this;
        cc.loader.loadTxt(a, function (a, c) {
            if (a) return d(a);
            d(null, e.parseFnt(c, b))
        })
    }
};
cc.loader.register(["fnt"], cc._fntLoader);
cc.MotionStreak = cc.NodeRGBA.extend({
    texture: null,
    fastMode: !1,
    startingPositionInitialized: !1,
    _blendFunc: null,
    _stroke: 0,
    _fadeDelta: 0,
    _minSeg: 0,
    _maxPoints: 0,
    _nuPoints: 0,
    _previousNuPoints: 0,
    _pointVertexes: null,
    _pointState: null,
    _vertices: null,
    _colorPointer: null,
    _texCoords: null,
    _verticesBuffer: null,
    _colorPointerBuffer: null,
    _texCoordsBuffer: null,
    _className: "MotionStreak",
    ctor: function () {
        cc.NodeRGBA.prototype.ctor.call(this);
        this._positionR = cc.p(0, 0);
        this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
        this._vertexWebGLBuffer = cc._renderContext.createBuffer();
        this.startingPositionInitialized = this.fastMode = !1;
        this.texture = null;
        this._previousNuPoints = this._nuPoints = this._maxPoints = this._minSeg = this._fadeDelta = this._stroke = 0;
        this._texCoordsBuffer = this._colorPointerBuffer = this._verticesBuffer = this._texCoords = this._colorPointer = this._vertices = this._pointState = this._pointVertexes = null
    },
    getTexture: function () {
        return this.texture
    },
    setTexture: function (a) {
        this.texture != a && (this.texture = a)
    },
    getBlendFunc: function () {
        return this._blendFunc
    },
    setBlendFunc: function (a, b) {
        void 0 === b ? this._blendFunc = a : (this._blendFunc.src = a, this._blendFunc.dst = b)
    },
    getOpacity: function () {
        cc.log("cc.MotionStreak.getOpacity has not been supported.");
        return 0
    },
    setOpacity: function (a) {
        cc.log("cc.MotionStreak.setOpacity has not been supported.")
    },
    setOpacityModifyRGB: function (a) {},
    isOpacityModifyRGB: function () {
        return !1
    },
    onExit: function () {
        cc.Node.prototype.onExit.call(this);
        this._verticesBuffer && cc._renderContext.deleteBuffer(this._verticesBuffer);
        this._texCoordsBuffer &&
            cc._renderContext.deleteBuffer(this._texCoordsBuffer);
        this._colorPointerBuffer && cc._renderContext.deleteBuffer(this._colorPointerBuffer)
    },
    isFastMode: function () {
        return this.fastMode
    },
    setFastMode: function (a) {
        this.fastMode = a
    },
    isStartingPositionInitialized: function () {
        return this.startingPositionInitialized
    },
    setStartingPositionInitialized: function (a) {
        this.startingPositionInitialized = a
    },
    initWithFade: function (a, b, c, d, e) {
        if (!e) throw "cc.MotionStreak.initWithFade(): Invalid filename or texture";
        "string" ===
        typeof e && (e = cc.textureCache.addImage(e));
        cc.Node.prototype.setPosition.call(this, cc.p(0, 0));
        this.anchorY = this.anchorX = 0;
        this.ignoreAnchor = !0;
        this.startingPositionInitialized = !1;
        this.fastMode = !0;
        this._minSeg = -1 == b ? c / 5 : b;
        this._minSeg *= this._minSeg;
        this._stroke = c;
        this._fadeDelta = 1 / a;
        a = (0 | 60 * a) + 2;
        this._nuPoints = 0;
        this._pointState = new Float32Array(a);
        this._pointVertexes = new Float32Array(2 * a);
        this._vertices = new Float32Array(4 * a);
        this._texCoords = new Float32Array(4 * a);
        this._colorPointer = new Uint8Array(8 *
            a);
        this._maxPoints = a;
        a = cc._renderContext;
        this._verticesBuffer = a.createBuffer();
        this._texCoordsBuffer = a.createBuffer();
        this._colorPointerBuffer = a.createBuffer();
        this._blendFunc.src = a.SRC_ALPHA;
        this._blendFunc.dst = a.ONE_MINUS_SRC_ALPHA;
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        this.texture = e;
        this.color = d;
        this.scheduleUpdate();
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._vertices, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ARRAY_BUFFER,
            this._texCoordsBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._texCoords, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ARRAY_BUFFER, this._colorPointerBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._colorPointer, a.DYNAMIC_DRAW);
        return !0
    },
    tintWithColor: function (a) {
        this.color = a;
        for (var b = this._colorPointer, c = 0, d = 2 * this._nuPoints; c < d; c++) b[4 * c] = a.r, b[4 * c + 1] = a.g, b[4 * c + 2] = a.b
    },
    reset: function () {
        this._nuPoints = 0
    },
    setPosition: function (a, b) {
        this.startingPositionInitialized = !0;
        void 0 === b ? (this._positionR.x = a.x, this._positionR.y = a.y) :
            (this._positionR.x = a, this._positionR.y = b)
    },
    getPositionX: function () {
        return this._positionR.x
    },
    setPositionX: function (a) {
        this._positionR.x = a;
        this.startingPositionInitialized || (this.startingPositionInitialized = !0)
    },
    getPositionY: function () {
        return this._positionR.y
    },
    setPositionY: function (a) {
        this._positionR.y = a;
        this.startingPositionInitialized || (this.startingPositionInitialized = !0)
    },
    draw: function (a) {
        1 >= this._nuPoints || !this.texture || !this.texture.isLoaded() || (a = a || cc._renderContext, cc.NODE_DRAW_SETUP(this),
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2D(this.texture), a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer), a.bufferData(a.ARRAY_BUFFER, this._vertices, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, this._texCoordsBuffer), a.bufferData(a.ARRAY_BUFFER, this._texCoords, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 0,
                0), a.bindBuffer(a.ARRAY_BUFFER, this._colorPointerBuffer), a.bufferData(a.ARRAY_BUFFER, this._colorPointer, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0), a.drawArrays(a.TRIANGLE_STRIP, 0, 2 * this._nuPoints), cc.g_NumberOfDraws++)
    },
    update: function (a) {
        if (this.startingPositionInitialized) {
            a *= this._fadeDelta;
            var b, c, d, e, f = 0,
                g = this._nuPoints,
                h = this._pointState,
                k = this._pointVertexes,
                m = this._vertices,
                n = this._colorPointer;
            for (d = 0; d < g; d++) h[d] -= a, 0 >= h[d] ? f++ : (b = d - f, 0 < f ? (h[b] =
                h[d], k[2 * b] = k[2 * d], k[2 * b + 1] = k[2 * d + 1], e = 2 * d, c = 2 * b, m[2 * c] = m[2 * e], m[2 * c + 1] = m[2 * e + 1], m[2 * (c + 1)] = m[2 * (e + 1)], m[2 * (c + 1) + 1] = m[2 * (e + 1) + 1], e *= 4, c *= 4, n[c + 0] = n[e + 0], n[c + 1] = n[e + 1], n[c + 2] = n[e + 2], n[c + 4] = n[e + 4], n[c + 5] = n[e + 5], n[c + 6] = n[e + 6]) : c = 8 * b, b = 255 * h[b], n[c + 3] = b, n[c + 7] = b);
            g -= f;
            d = !0;
            g >= this._maxPoints ? d = !1 : 0 < g && (a = cc.pDistanceSQ(cc.p(k[2 * (g - 1)], k[2 * (g - 1) + 1]), this._positionR) < this._minSeg, c = 1 == g ? !1 : cc.pDistanceSQ(cc.p(k[2 * (g - 2)], k[2 * (g - 2) + 1]), this._positionR) < 2 * this._minSeg, a || c) && (d = !1);
            d && (k[2 * g] = this._positionR.x,
                k[2 * g + 1] = this._positionR.y, h[g] = 1, h = 8 * g, d = this._displayedColor, n[h] = d.r, n[h + 1] = d.g, n[h + 2] = d.b, n[h + 4] = d.r, n[h + 5] = d.g, n[h + 6] = d.b, n[h + 3] = 255, n[h + 7] = 255, 0 < g && this.fastMode && (1 < g ? cc.vertexLineToPolygon(k, this._stroke, this._vertices, g, 1) : cc.vertexLineToPolygon(k, this._stroke, this._vertices, 0, 2)), g++);
            this.fastMode || cc.vertexLineToPolygon(k, this._stroke, this._vertices, 0, g);
            if (g && this._previousNuPoints != g) {
                k = 1 / g;
                n = this._texCoords;
                for (d = 0; d < g; d++) n[4 * d] = 0, n[4 * d + 1] = k * d, n[2 * (2 * d + 1)] = 1, n[2 * (2 * d + 1) + 1] = k * d;
                this._previousNuPoints =
                    g
            }
            this._nuPoints = g
        }
    }
});
cc.MotionStreak.create = function (a, b, c, d, e) {
    var f = new cc.MotionStreak;
    return f && f.initWithFade(a, b, c, d, e) ? f : null
};
cc.NodeGrid = cc.Node.extend({
    grid: null,
    _target: null,
    getGrid: function () {
        return this.grid
    },
    setGrid: function (a) {
        this.grid = a
    },
    setTarget: function (a) {
        this._target = a
    },
    addChild: function (a, b, c) {
        cc.Node.prototype.addChild.call(this, a, b, c);
        a && !this._target && (this._target = a)
    },
    visit: function () {
        if (this._visible) {
            var a = cc._renderType == cc._RENDER_TYPE_WEBGL,
                b = this.grid;
            a && b && b._active && b.beforeDraw();
            this.transform();
            var c = this._children;
            if (c && 0 < c.length) {
                var d = c.length;
                this.sortAllChildren();
                for (i = 0; i < d; i++) {
                    var e =
                        c[i];
                    e && e.visit()
                }
            }
            a && b && b._active && b.afterDraw(this._target)
        }
    },
    _transformForWebGL: function () {
        var a = this._transform4x4,
            b = cc.current_stack.top,
            c = this.nodeToParentTransform(),
            d = a.mat;
        d[0] = c.a;
        d[4] = c.c;
        d[12] = c.tx;
        d[1] = c.b;
        d[5] = c.d;
        d[13] = c.ty;
        d[14] = this._vertexZ;
        cc.kmMat4Multiply(b, b, a);
        null == this._camera || this.grid && this.grid.isActive() || (a = this._anchorPointInPoints.x, b = this._anchorPointInPoints.y, 0 !== a || 0 !== b ? (cc.kmGLTranslatef(cc.RENDER_IN_SUBPIXEL(a), cc.RENDER_IN_SUBPIXEL(b), 0), this._camera.locate(),
            cc.kmGLTranslatef(cc.RENDER_IN_SUBPIXEL(-a), cc.RENDER_IN_SUBPIXEL(-b), 0)) : this._camera.locate())
    }
});
window._p = cc.NodeGrid.prototype;
_p.transform = cc._renderType === cc._RENDER_TYPE_WEBGL ? _p._transformForWebGL : _p._transformForCanvas;
cc.defineGetterSetter(_p, "target", null, _p.setTarget);
delete window._p;
cc.NodeGrid.create = function () {
    return new cc.NodeGrid
};
cc.v2fzero = function () {
    return {
        x: 0,
        y: 0
    }
};
cc.v2f = function (a, b) {
    return {
        x: a,
        y: b
    }
};
cc.v2fadd = function (a, b) {
    return cc.v2f(a.x + b.x, a.y + b.y)
};
cc.v2fsub = function (a, b) {
    return cc.v2f(a.x - b.x, a.y - b.y)
};
cc.v2fmult = function (a, b) {
    return cc.v2f(a.x * b, a.y * b)
};
cc.v2fperp = function (a) {
    return cc.v2f(-a.y, a.x)
};
cc.v2fneg = function (a) {
    return cc.v2f(-a.x, -a.y)
};
cc.v2fdot = function (a, b) {
    return a.x * b.x + a.y * b.y
};
cc.v2fforangle = function (a) {
    return cc.v2f(Math.cos(a), Math.sin(a))
};
cc.v2fnormalize = function (a) {
    a = cc.pNormalize(cc.p(a.x, a.y));
    return cc.v2f(a.x, a.y)
};
cc.__v2f = function (a) {
    return cc.v2f(a.x, a.y)
};
cc.__t = function (a) {
    return {
        u: a.x,
        v: a.y
    }
};
cc.DrawNodeCanvas = cc.Node.extend({
    _buffer: null,
    _blendFunc: null,
    _lineWidth: 0,
    _drawColor: null,
    _className: "DrawNodeCanvas",
    ctor: function () {
        cc.Node.prototype.ctor.call(this);
        this._buffer = [];
        this._lineWidth = 1;
        this._drawColor = cc.color(255, 255, 255, 255);
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST)
    },
    getBlendFunc: function () {
        return this._blendFunc
    },
    setBlendFunc: function (a) {
        this._blendFunc = a
    },
    setLineWidth: function (a) {
        this._lineWidth = a
    },
    getLineWidth: function () {
        return this._lineWidth
    },
    setDrawColor: function (a) {
        this._drawColor.r =
            a.r;
        this._drawColor.g = a.g;
        this._drawColor.b = a.b;
        this._drawColor.a = a.a
    },
    getDrawColor: function () {
        return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a)
    },
    drawRect: function (a, b, c, d, e) {
        d = d || this._lineWidth;
        e = e || this.getDrawColor();
        a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
        b = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        b.verts = a;
        b.lineWidth = d;
        b.lineColor = e;
        b.isClosePolygon = !0;
        b.isStroke = !0;
        b.lineCap = "butt";
        if (b.fillColor = c) b.isFill = !0;
        this._buffer.push(b)
    },
    drawCircle: function (a,
        b, c, d, e, f, g) {
        f = f || this._lineWidth;
        g = g || this.getDrawColor();
        for (var h = 2 * Math.PI / d, k = [], m = 0; m <= d; m++) {
            var n = m * h,
                p = b * Math.cos(n + c) + a.x,
                n = b * Math.sin(n + c) + a.y;
            k.push(cc.p(p, n))
        }
        e && k.push(cc.p(a.x, a.y));
        a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        a.verts = k;
        a.lineWidth = f;
        a.lineColor = g;
        a.isClosePolygon = !0;
        a.isStroke = !0;
        this._buffer.push(a)
    },
    drawQuadBezier: function (a, b, c, d, e, f) {
        e = e || this._lineWidth;
        f = f || this.getDrawColor();
        for (var g = [], h = 0, k = 0; k < d; k++) {
            var m = Math.pow(1 - h, 2) * a.x + 2 * (1 - h) * h * b.x + h * h * c.x,
                n = Math.pow(1 - h, 2) * a.y + 2 * (1 - h) * h * b.y + h * h * c.y;
            g.push(cc.p(m, n));
            h += 1 / d
        }
        g.push(cc.p(c.x, c.y));
        a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        a.verts = g;
        a.lineWidth = e;
        a.lineColor = f;
        a.isStroke = !0;
        a.lineCap = "round";
        this._buffer.push(a)
    },
    drawCubicBezier: function (a, b, c, d, e, f, g) {
        f = f || this._lineWidth;
        g = g || this.getDrawColor();
        for (var h = [], k = 0, m = 0; m < e; m++) {
            var n = Math.pow(1 - k, 3) * a.x + 3 * Math.pow(1 - k, 2) * k * b.x + 3 * (1 - k) * k * k * c.x + k * k * k * d.x,
                p = Math.pow(1 - k, 3) * a.y + 3 * Math.pow(1 - k, 2) * k * b.y + 3 * (1 - k) * k * k * c.y + k * k * k * d.y;
            h.push(cc.p(n,
                p));
            k += 1 / e
        }
        h.push(cc.p(d.x, d.y));
        a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        a.verts = h;
        a.lineWidth = f;
        a.lineColor = g;
        a.isStroke = !0;
        a.lineCap = "round";
        this._buffer.push(a)
    },
    drawCatmullRom: function (a, b, c, d) {
        this.drawCardinalSpline(a, 0.5, b, c, d)
    },
    drawCardinalSpline: function (a, b, c, d, e) {
        d = d || this._lineWidth;
        e = e || this.getDrawColor();
        for (var f = [], g, h, k = 1 / a.length, m = 0; m < c + 1; m++) h = m / c, 1 == h ? (g = a.length - 1, h = 1) : (g = 0 | h / k, h = (h - k * g) / k), g = cc.CardinalSplineAt(cc.getControlPointAt(a, g - 1), cc.getControlPointAt(a, g -
            0), cc.getControlPointAt(a, g + 1), cc.getControlPointAt(a, g + 2), b, h), f.push(g);
        a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        a.verts = f;
        a.lineWidth = d;
        a.lineColor = e;
        a.isStroke = !0;
        a.lineCap = "round";
        this._buffer.push(a)
    },
    drawDot: function (a, b, c) {
        c = c || this.getDrawColor();
        var d = new cc._DrawNodeElement(cc.DrawNode.TYPE_DOT);
        d.verts = [a];
        d.lineWidth = b;
        d.fillColor = c;
        this._buffer.push(d)
    },
    drawSegment: function (a, b, c, d) {
        c = c || this._lineWidth;
        d = d || this.getDrawColor();
        var e = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        e.verts = [a, b];
        e.lineWidth = c;
        e.lineColor = d;
        e.isStroke = !0;
        e.lineCap = "round";
        this._buffer.push(e)
    },
    drawPoly_: function (a, b, c, d) {
        c = c || this._lineWidth;
        d = d || this.getDrawColor();
        var e = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        e.verts = a;
        e.fillColor = b;
        e.lineWidth = c;
        e.lineColor = d;
        e.isClosePolygon = !0;
        e.isStroke = !0;
        e.lineCap = "round";
        b && (e.isFill = !0);
        this._buffer.push(e)
    },
    drawPoly: function (a, b, c, d) {
        for (var e = [], f = 0; f < a.length; f++) e.push(cc.p(a[f].x, a[f].y));
        return this.drawPoly_(e, b, c, d)
    },
    draw: function (a) {
        a =
            a || cc._renderContext;
        this._blendFunc && this._blendFunc.src == cc.SRC_ALPHA && this._blendFunc.dst == cc.ONE && (a.globalCompositeOperation = "lighter");
        for (var b = 0; b < this._buffer.length; b++) {
            var c = this._buffer[b];
            switch (c.type) {
            case cc.DrawNode.TYPE_DOT:
                this._drawDot(a, c);
                break;
            case cc.DrawNode.TYPE_SEGMENT:
                this._drawSegment(a, c);
                break;
            case cc.DrawNode.TYPE_POLY:
                this._drawPoly(a, c)
            }
        }
    },
    _drawDot: function (a, b) {
        var c = b.fillColor,
            d = b.verts[0],
            e = b.lineWidth,
            f = cc.view.getScaleX(),
            g = cc.view.getScaleY();
        a.fillStyle =
            "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b) + "," + c.a / 255 + ")";
        a.beginPath();
        a.arc(d.x * f, -d.y * g, e * f, 0, 2 * Math.PI, !1);
        a.closePath();
        a.fill()
    },
    _drawSegment: function (a, b) {
        var c = b.lineColor,
            d = b.verts[0],
            e = b.verts[1],
            f = b.lineWidth,
            g = b.lineCap,
            h = cc.view.getScaleX(),
            k = cc.view.getScaleY();
        a.strokeStyle = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b) + "," + c.a / 255 + ")";
        a.lineWidth = f * h;
        a.beginPath();
        a.lineCap = g;
        a.moveTo(d.x * h, -d.y * k);
        a.lineTo(e.x * h, -e.y * k);
        a.stroke()
    },
    _drawPoly: function (a, b) {
        var c = b.verts,
            d = b.lineCap,
            e = b.fillColor,
            f = b.lineWidth,
            g = b.lineColor,
            h = b.isClosePolygon,
            k = b.isFill,
            m = b.isStroke;
        if (null != c) {
            var n = c[0],
                p = cc.view.getScaleX(),
                r = cc.view.getScaleY();
            a.lineCap = d;
            e && (a.fillStyle = "rgba(" + (0 | e.r) + "," + (0 | e.g) + "," + (0 | e.b) + "," + e.a / 255 + ")");
            f && (a.lineWidth = f * p);
            g && (a.strokeStyle = "rgba(" + (0 | g.r) + "," + (0 | g.g) + "," + (0 | g.b) + "," + g.a / 255 + ")");
            a.beginPath();
            a.moveTo(n.x * p, -n.y * r);
            d = 1;
            for (e = c.length; d < e; d++) a.lineTo(c[d].x * p, -c[d].y * r);
            h && a.closePath();
            k && a.fill();
            m && a.stroke()
        }
    },
    clear: function () {
        this._buffer.length = 0
    }
});
cc.DrawNodeWebGL = cc.Node.extend({
    _bufferCapacity: 0,
    _buffer: null,
    _trianglesArrayBuffer: null,
    _trianglesWebBuffer: null,
    _trianglesReader: null,
    _blendFunc: null,
    _dirty: !1,
    _className: "DrawNodeWebGL",
    getBlendFunc: function () {
        return this._blendFunc
    },
    setBlendFunc: function (a) {
        this._blendFunc = a
    },
    ctor: function () {
        cc.Node.prototype.ctor.call(this);
        this._buffer = [];
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST)
    },
    init: function () {
        return cc.Node.prototype.init.call(this) ? (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_LENGTHTEXTURECOLOR),
            this._ensureCapacity(512), this._trianglesWebBuffer = cc._renderContext.createBuffer(), this._dirty = !0) : !1
    },
    _render: function () {
        var a = cc._renderContext;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
        a.bindBuffer(a.ARRAY_BUFFER, this._trianglesWebBuffer);
        this._dirty && (a.bufferData(a.ARRAY_BUFFER, this._trianglesArrayBuffer, a.STREAM_DRAW), this._dirty = !1);
        var b = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, b, 0);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR,
            4, a.UNSIGNED_BYTE, !0, b, 8);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, b, 12);
        a.drawArrays(a.TRIANGLES, 0, 3 * this._buffer.length);
        cc.INCREMENT_GL_DRAWS(1)
    },
    _ensureCapacity: function (a) {
        if (this._buffer.length + a > this._bufferCapacity) {
            var b = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
            this._bufferCapacity += Math.max(this._bufferCapacity, a);
            if (null == this._buffer || 0 === this._buffer.length) this._buffer = [], this._trianglesArrayBuffer = new ArrayBuffer(b * this._bufferCapacity), this._trianglesReader =
                new Uint8Array(this._trianglesArrayBuffer);
            else {
                a = this._buffer;
                a.length = 0;
                for (var c = new ArrayBuffer(b * this._bufferCapacity), d = 0; d < this._buffer.length; d++) a[d] = new cc.V2F_C4B_T2F_Triangle(this._buffer[d].a, this._buffer[d].b, this._buffer[d].c, c, d * b);
                this._trianglesReader = new Uint8Array(c);
                this._trianglesArrayBuffer = c
            }
        }
    },
    draw: function () {
        cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
        this._shaderProgram.use();
        this._shaderProgram.setUniformsForBuiltins();
        this._render()
    },
    drawDot: function (a, b, c) {
        c = {
            r: 0 | c.r,
            g: 0 | c.g,
            b: 0 | c.b,
            a: 0 | c.a
        };
        var d = {
                vertices: {
                    x: a.x - b,
                    y: a.y - b
                },
                colors: c,
                texCoords: {
                    u: -1,
                    v: -1
                }
            },
            e = {
                vertices: {
                    x: a.x + b,
                    y: a.y + b
                },
                colors: c,
                texCoords: {
                    u: 1,
                    v: 1
                }
            },
            f = {
                vertices: {
                    x: a.x + b,
                    y: a.y - b
                },
                colors: c,
                texCoords: {
                    u: 1,
                    v: -1
                }
            };
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle(d, {
            vertices: {
                x: a.x - b,
                y: a.y + b
            },
            colors: c,
            texCoords: {
                u: -1,
                v: 1
            }
        }, e, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle(d, e, f, this._trianglesArrayBuffer, this._buffer.length *
            cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
        this._dirty = !0
    },
    drawSegment: function (a, b, c, d) {
        this._ensureCapacity(18);
        d = {
            r: 0 | d.r,
            g: 0 | d.g,
            b: 0 | d.b,
            a: 0 | d.a
        };
        var e = cc.__v2f(a),
            f = cc.__v2f(b);
        b = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(f, e)));
        a = cc.v2fperp(b);
        var g = cc.v2fmult(b, c),
            h = cc.v2fmult(a, c);
        c = cc.v2fsub(f, cc.v2fadd(g, h));
        var k = cc.v2fadd(f, cc.v2fsub(g, h)),
            m = cc.v2fsub(f, g),
            f = cc.v2fadd(f, g),
            n = cc.v2fsub(e, g),
            p = cc.v2fadd(e, g),
            r = cc.v2fsub(e, cc.v2fsub(g, h)),
            e = cc.v2fadd(e, cc.v2fadd(g, h)),
            g = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
            h = this._trianglesArrayBuffer;
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: c,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(cc.v2fadd(b, a)))
        }, {
            vertices: k,
            colors: d,
            texCoords: cc.__t(cc.v2fsub(b, a))
        }, {
            vertices: m,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(b))
        }, h, this._buffer.length * g));
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: f,
            colors: d,
            texCoords: cc.__t(b)
        }, {
            vertices: k,
            colors: d,
            texCoords: cc.__t(cc.v2fsub(b, a))
        }, {
            vertices: m,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(b))
        }, h, this._buffer.length * g));
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: f,
            colors: d,
            texCoords: cc.__t(b)
        }, {
            vertices: n,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(b))
        }, {
            vertices: m,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(b))
        }, h, this._buffer.length * g));
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: f,
            colors: d,
            texCoords: cc.__t(b)
        }, {
            vertices: n,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(b))
        }, {
            vertices: p,
            colors: d,
            texCoords: cc.__t(b)
        }, h, this._buffer.length * g));
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: r,
            colors: d,
            texCoords: cc.__t(cc.v2fsub(a, b))
        }, {
            vertices: n,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(b))
        }, {
            vertices: p,
            colors: d,
            texCoords: cc.__t(b)
        }, h, this._buffer.length * g));
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: r,
            colors: d,
            texCoords: cc.__t(cc.v2fsub(a, b))
        }, {
            vertices: e,
            colors: d,
            texCoords: cc.__t(cc.v2fadd(b, a))
        }, {
            vertices: p,
            colors: d,
            texCoords: cc.__t(b)
        }, h, this._buffer.length * g));
        this._dirty = !0
    },
    drawPoly: function (a, b, c, d) {
        b = {
            r: 0 | b.r,
            g: 0 | b.g,
            b: 0 | b.b,
            a: 0 | b.a
        };
        d = {
            r: 0 | d.r,
            g: 0 | d.g,
            b: 0 | d.b,
            a: 0 | d.a
        };
        var e = [],
            f, g, h, k, m = a.length;
        for (f = 0; f < m; f++) {
            g = cc.__v2f(a[(f - 1 + m) % m]);
            h = cc.__v2f(a[f]);
            k = cc.__v2f(a[(f +
                1) % m]);
            var n = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(h, g)));
            h = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(k, h)));
            n = cc.v2fmult(cc.v2fadd(n, h), 1 / (cc.v2fdot(n, h) + 1));
            e[f] = {
                offset: n,
                n: h
            }
        }
        n = 0 < c;
        this._ensureCapacity(3 * (3 * m - 2));
        var p = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
            r = this._trianglesArrayBuffer,
            q = this._buffer,
            s = !1 == n ? 0.5 : 0;
        for (f = 0; f < m - 2; f++) g = cc.v2fsub(cc.__v2f(a[0]), cc.v2fmult(e[0].offset, s)), h = cc.v2fsub(cc.__v2f(a[f + 1]), cc.v2fmult(e[f + 1].offset, s)), k = cc.v2fsub(cc.__v2f(a[f + 2]), cc.v2fmult(e[f + 2].offset,
            s)), q.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: g,
            colors: b,
            texCoords: cc.__t(cc.v2fzero())
        }, {
            vertices: h,
            colors: b,
            texCoords: cc.__t(cc.v2fzero())
        }, {
            vertices: k,
            colors: b,
            texCoords: cc.__t(cc.v2fzero())
        }, r, q.length * p));
        for (f = 0; f < m; f++) {
            s = (f + 1) % m;
            g = cc.__v2f(a[f]);
            h = cc.__v2f(a[s]);
            k = e[f].n;
            var t = e[f].offset,
                x = e[s].offset,
                s = n ? cc.v2fsub(g, cc.v2fmult(t, c)) : cc.v2fsub(g, cc.v2fmult(t, 0.5)),
                y = n ? cc.v2fsub(h, cc.v2fmult(x, c)) : cc.v2fsub(h, cc.v2fmult(x, 0.5));
            g = n ? cc.v2fadd(g, cc.v2fmult(t, c)) : cc.v2fadd(g, cc.v2fmult(t,
                0.5));
            h = n ? cc.v2fadd(h, cc.v2fmult(x, c)) : cc.v2fadd(h, cc.v2fmult(x, 0.5));
            n ? (q.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: s,
                colors: d,
                texCoords: cc.__t(cc.v2fneg(k))
            }, {
                vertices: y,
                colors: d,
                texCoords: cc.__t(cc.v2fneg(k))
            }, {
                vertices: h,
                colors: d,
                texCoords: cc.__t(k)
            }, r, q.length * p)), q.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: s,
                colors: d,
                texCoords: cc.__t(cc.v2fneg(k))
            }, {
                vertices: g,
                colors: d,
                texCoords: cc.__t(k)
            }, {
                vertices: h,
                colors: d,
                texCoords: cc.__t(k)
            }, r, q.length * p))) : (q.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: s,
                colors: b,
                texCoords: cc.__t(cc.v2fzero())
            }, {
                vertices: y,
                colors: b,
                texCoords: cc.__t(cc.v2fzero())
            }, {
                vertices: h,
                colors: b,
                texCoords: cc.__t(k)
            }, r, q.length * p)), q.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: s,
                colors: b,
                texCoords: cc.__t(cc.v2fzero())
            }, {
                vertices: g,
                colors: b,
                texCoords: cc.__t(k)
            }, {
                vertices: h,
                colors: b,
                texCoords: cc.__t(k)
            }, r, q.length * p)))
        }
        this._dirty = !0
    },
    clear: function () {
        this._buffer.length = 0;
        this._dirty = !0
    }
});
cc.DrawNode = cc._renderType == cc._RENDER_TYPE_WEBGL ? cc.DrawNodeWebGL : cc.DrawNodeCanvas;
cc.DrawNode.create = function () {
    var a = new cc.DrawNode;
    return a && a.init() ? a : null
};
cc._DrawNodeElement = function (a, b, c, d, e, f, g, h, k) {
    this.type = a;
    this.verts = b || null;
    this.fillColor = c || null;
    this.lineWidth = d || 0;
    this.lineColor = e || null;
    this.lineCap = f || "butt";
    this.isClosePolygon = g || !1;
    this.isFill = h || !1;
    this.isStroke = k || !1
};
cc.DrawNode.TYPE_DOT = 0;
cc.DrawNode.TYPE_SEGMENT = 1;
cc.DrawNode.TYPE_POLY = 2;
cc.stencilBits = -1;
cc.setProgram = function (a, b) {
    a.shaderProgram = b;
    var c = a.children;
    if (c)
        for (var d = 0; d < c.length; d++) cc.setProgram(c[d], b)
};
cc.ClippingNode = cc.Node.extend({
    alphaThreshold: 0,
    inverted: !1,
    _stencil: null,
    _godhelpme: !1,
    ctor: function () {
        cc.Node.prototype.ctor.call(this);
        this._stencil = null;
        this.alphaThreshold = 0;
        this.inverted = !1
    },
    init: null,
    _className: "ClippingNode",
    _initForWebGL: function (a) {
        this._stencil = a;
        this.alphaThreshold = 1;
        this.inverted = !1;
        cc.ClippingNode._init_once = !0;
        cc.ClippingNode._init_once && (cc.stencilBits = cc._renderContext.getParameter(cc._renderContext.STENCIL_BITS), 0 >= cc.stencilBits && cc.log("Stencil buffer is not enabled."),
            cc.ClippingNode._init_once = !1);
        return !0
    },
    _initForCanvas: function (a) {
        this._stencil = a;
        this.alphaThreshold = 1;
        this.inverted = !1
    },
    onEnter: function () {
        cc.Node.prototype.onEnter.call(this);
        this._stencil.onEnter()
    },
    onEnterTransitionDidFinish: function () {
        cc.Node.prototype.onEnterTransitionDidFinish.call(this);
        this._stencil.onEnterTransitionDidFinish()
    },
    onExitTransitionDidStart: function () {
        this._stencil.onExitTransitionDidStart();
        cc.Node.prototype.onExitTransitionDidStart.call(this)
    },
    onExit: function () {
        this._stencil.onExit();
        cc.Node.prototype.onExit.call(this)
    },
    visit: null,
    _visitForWebGL: function (a) {
        var b = a || cc._renderContext;
        if (1 > cc.stencilBits) cc.Node.prototype.visit.call(this, a);
        else if (this._stencil && this._stencil.visible)
            if (cc.ClippingNode._layer = -1, cc.ClippingNode._layer + 1 == cc.stencilBits) cc.ClippingNode._visit_once = !0, cc.ClippingNode._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its childs."), cc.ClippingNode._visit_once = !1), cc.Node.prototype.visit.call(this, a);
            else {
                cc.ClippingNode._layer++;
                var c = 1 << cc.ClippingNode._layer,
                    d = c | c - 1,
                    e = b.isEnabled(b.STENCIL_TEST),
                    f = b.getParameter(b.STENCIL_WRITEMASK),
                    g = b.getParameter(b.STENCIL_FUNC),
                    h = b.getParameter(b.STENCIL_REF),
                    k = b.getParameter(b.STENCIL_VALUE_MASK),
                    m = b.getParameter(b.STENCIL_FAIL),
                    n = b.getParameter(b.STENCIL_PASS_DEPTH_FAIL),
                    p = b.getParameter(b.STENCIL_PASS_DEPTH_PASS);
                b.enable(b.STENCIL_TEST);
                b.stencilMask(c);
                var r = b.getParameter(b.DEPTH_WRITEMASK);
                b.depthMask(!1);
                b.stencilFunc(b.NEVER, c, c);
                b.stencilOp(this.inverted ? b.REPLACE : b.ZERO, b.KEEP, b.KEEP);
                cc._drawingUtil.drawSolidRect(cc.p(0, 0), cc.pFromSize(cc.director.getWinSize()), cc.color(255, 255, 255, 255));
                b.stencilFunc(b.NEVER, c, c);
                b.stencilOp(this.inverted ? b.ZERO : b.REPLACE, b.KEEP, b.KEEP);
                if (1 > this.alphaThreshold) {
                    var c = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST),
                        q = b.getUniformLocation(c.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S);
                    cc.glUseProgram(c.getProgram());
                    c.setUniformLocationWith1f(q,
                        this.alphaThreshold);
                    cc.setProgram(this._stencil, c)
                }
                cc.kmGLPushMatrix();
                this.transform();
                this._stencil.visit();
                cc.kmGLPopMatrix();
                b.depthMask(r);
                b.stencilFunc(b.EQUAL, d, d);
                b.stencilOp(b.KEEP, b.KEEP, b.KEEP);
                cc.Node.prototype.visit.call(this, a);
                b.stencilFunc(g, h, k);
                b.stencilOp(m, n, p);
                b.stencilMask(f);
                e || b.disable(b.STENCIL_TEST);
                cc.ClippingNode._layer--
            } else this.inverted && cc.Node.prototype.visit.call(this, a)
    },
    _visitForCanvas: function (a) {
        if (this._stencil && this._stencil.visible) {
            a = a || cc._renderContext;
            if (this._cangodhelpme() || this._stencil instanceof cc.Sprite) {
                var b = a.canvas,
                    c = cc.ClippingNode._getSharedCache();
                c.width = b.width;
                c.height = b.height;
                c.getContext("2d").drawImage(b, 0, 0);
                a.save();
                this._super(a);
                a.globalCompositeOperation = this.inverted ? "destination-out" : "destination-in";
                this.transform(a);
                this._stencil.visit();
                a.restore();
                a.save();
                a.setTransform(1, 0, 0, 1, 0, 0);
                a.globalCompositeOperation = "destination-over";
                a.drawImage(c, 0, 0)
            } else {
                var c = this._children,
                    d;
                a.save();
                this.transform(a);
                this._stencil.visit(a);
                a.clip();
                this._cangodhelpme(!0);
                var e = c.length;
                if (0 < e) {
                    this.sortAllChildren();
                    for (b = 0; b < e; b++)
                        if (d = c[b], 0 > d._localZOrder) d.visit(a);
                        else break;
                    for (this.draw(a); b < e; b++) c[b].visit(a)
                } else this.draw(a);
                this._cangodhelpme(!1)
            }
            a.restore()
        } else this.inverted && cc.Node.prototype.visit.call(this, a)
    },
    getStencil: function () {
        return this._stencil
    },
    setStencil: null,
    _setStencilForWebGL: function (a) {
        this._stencil = a
    },
    _setStencilForCanvas: function (a) {
        this._stencil = a;
        var b = cc.view.getScaleX(),
            c = cc.view.getScaleY(),
            d =
            cc._renderContext;
        !(a instanceof cc.Sprite) && a instanceof cc.DrawNode && (a.draw = function () {
            for (var e = 0; e < a._buffer.length; e++) {
                var f = a._buffer[e].verts,
                    g = f[0];
                d.beginPath();
                d.moveTo(g.x * b, -g.y * c);
                for (var g = 1, h = f.length; g < h; g++) d.lineTo(f[g].x * b, -f[g].y * c)
            }
        })
    },
    getAlphaThreshold: function () {
        return this.alphaThreshold
    },
    setAlphaThreshold: function (a) {
        this.alphaThreshold = a
    },
    isInverted: function () {
        return this.inverted
    },
    setInverted: function (a) {
        this.inverted = a
    },
    _cangodhelpme: function (a) {
        if (!0 === a || !1 === a) cc.ClippingNode.prototype._godhelpme =
            a;
        return cc.ClippingNode.prototype._godhelpme
    }
});
window._p = cc.ClippingNode.prototype;
cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.init = _p._initForWebGL, _p.visit = _p._visitForWebGL, _p.setStencil = _p._setStencilForWebGL) : (_p.init = _p._initForCanvas, _p.visit = _p._visitForCanvas, _p.setStencil = _p._setStencilForCanvas);
cc.defineGetterSetter(_p, "stencil", _p.getStencil, _p.setStencil);
delete window._p;
cc.ClippingNode._init_once = null;
cc.ClippingNode._visit_once = null;
cc.ClippingNode._layer = null;
cc.ClippingNode._sharedCache = null;
cc.ClippingNode._getSharedCache = function () {
    return cc.ClippingNode._sharedCache || (cc.ClippingNode._sharedCache = document.createElement("canvas"))
};
cc.ClippingNode.create = function (a) {
    var b = new cc.ClippingNode;
    b.init(a);
    return b
};
cc.GridBase = cc.Class.extend({
    _active: !1,
    _reuseGrid: 0,
    _gridSize: null,
    _texture: null,
    _step: null,
    _grabber: null,
    _isTextureFlipped: !1,
    _shaderProgram: null,
    _directorProjection: 0,
    _dirty: !1,
    ctor: function () {
        this._active = !1;
        this._reuseGrid = 0;
        this._texture = this._gridSize = null;
        this._step = cc.p(0, 0);
        this._grabber = null;
        this._isTextureFlipped = !1;
        this._shaderProgram = null;
        this._directorProjection = 0;
        this._dirty = !1
    },
    isActive: function () {
        return this._active
    },
    setActive: function (a) {
        this._active = a;
        if (!a) {
            a = cc.director;
            var b =
                a.getProjection();
            a.setProjection(b)
        }
    },
    getReuseGrid: function () {
        return this._reuseGrid
    },
    setReuseGrid: function (a) {
        this._reuseGrid = a
    },
    getGridSize: function () {
        return cc.size(this._gridSize.width, this._gridSize.height)
    },
    setGridSize: function (a) {
        this._gridSize.width = parseInt(a.width);
        this._gridSize.height = parseInt(a.height)
    },
    getStep: function () {
        return cc.p(this._step.x, this._step.y)
    },
    setStep: function (a) {
        this._step.x = a.x;
        this._step.y = a.y
    },
    isTextureFlipped: function () {
        return this._isTextureFlipped
    },
    setTextureFlipped: function (a) {
        this._isTextureFlipped !=
            a && (this._isTextureFlipped = a, this.calculateVertexPoints())
    },
    initWithSize: function (a, b, c) {
        if (!b) {
            var d = cc.director.getWinSizeInPixels(),
                e = cc.NextPOT(d.width),
                f = cc.NextPOT(d.height),
                g = new Uint8Array(e * f * 4);
            if (!g) return cc.log("cocos2d: CCGrid: not enough memory."), !1;
            b = new cc.Texture2D;
            b.initWithData(g, cc.Texture2D.PIXEL_FORMAT_RGBA8888, e, f, d);
            if (!b) return cc.log("cocos2d: CCGrid: error creating texture"), !1
        }
        this._active = !1;
        this._reuseGrid = 0;
        this._gridSize = a;
        this._texture = b;
        this._isTextureFlipped = c ||
            !1;
        this._step.x = this._texture.width / a.width;
        this._step.y = this._texture.height / a.height;
        this._grabber = new cc.Grabber;
        if (!this._grabber) return !1;
        this._grabber.grab(this._texture);
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
        this.calculateVertexPoints();
        return !0
    },
    beforeDraw: function () {
        this._directorProjection = cc.director.getProjection();
        this.set2DProjection();
        this._grabber.beforeRender(this._texture)
    },
    afterDraw: function (a) {
        this._grabber.afterRender(this._texture);
        cc.director.setProjection(this._directorProjection);
        if (a.getCamera().isDirty()) {
            var b = a.getAnchorPointInPoints();
            cc.kmGLTranslatef(b.x, b.y, 0);
            a.getCamera().locate();
            cc.kmGLTranslatef(-b.x, -b.y, 0)
        }
        cc.glBindTexture2D(this._texture);
        this.blit()
    },
    blit: function () {
        cc.log("cc.GridBase.blit(): Shall be overridden in subclass.")
    },
    reuse: function () {
        cc.log("cc.GridBase.reuse(): Shall be overridden in subclass.")
    },
    calculateVertexPoints: function () {
        cc.log("cc.GridBase.calculateVertexPoints(): Shall be overridden in subclass.")
    },
    set2DProjection: function () {
        var a = cc.director.getWinSizeInPixels();
        cc._renderContext.viewport(0, 0, a.width, a.height);
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLLoadIdentity();
        var b = new cc.kmMat4;
        cc.kmMat4OrthographicProjection(b, 0, a.width, 0, a.height, -1, 1);
        cc.kmGLMultMatrix(b);
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLLoadIdentity();
        cc.setProjectionMatrixDirty()
    }
});
cc.GridBase.create = function (a, b, c) {
    var d = new cc.GridBase;
    return d && d.initWithSize(a, b, c) ? d : null
};
cc.Grid3D = cc.GridBase.extend({
    _texCoordinates: null,
    _vertices: null,
    _originalVertices: null,
    _indices: null,
    _texCoordinateBuffer: null,
    _verticesBuffer: null,
    _indicesBuffer: null,
    ctor: function () {
        cc.GridBase.prototype.ctor.call(this);
        this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null
    },
    vertex: function (a) {
        a.x === (0 | a.x) && a.y === (0 | a.y) || cc.log("cc.Grid3D.vertex() : Numbers must be integers");
        a = 0 | 3 * (a.x * (this._gridSize.height +
            1) + a.y);
        var b = this._vertices;
        return new cc.Vertex3F(b[a], b[a + 1], b[a + 2])
    },
    originalVertex: function (a) {
        a.x === (0 | a.x) && a.y === (0 | a.y) || cc.log("cc.Grid3D.originalVertex() : Numbers must be integers");
        a = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y);
        var b = this._originalVertices;
        return new cc.Vertex3F(b[a], b[a + 1], b[a + 2])
    },
    setVertex: function (a, b) {
        a.x === (0 | a.x) && a.y === (0 | a.y) || cc.log("cc.Grid3D.setVertex() : Numbers must be integers");
        var c = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y),
            d = this._vertices;
        d[c] = b.x;
        d[c + 1] =
            b.y;
        d[c + 2] = b.z;
        this._dirty = !0
    },
    blit: function () {
        var a = this._gridSize.width * this._gridSize.height;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
        this._shaderProgram.use();
        this._shaderProgram.setUniformsForBuiltins();
        var b = cc._renderContext,
            c = this._dirty;
        b.bindBuffer(b.ARRAY_BUFFER, this._verticesBuffer);
        c && b.bufferData(b.ARRAY_BUFFER, this._vertices, b.DYNAMIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, b.FLOAT, !1, 0, 0);
        b.bindBuffer(b.ARRAY_BUFFER,
            this._texCoordinateBuffer);
        c && b.bufferData(b.ARRAY_BUFFER, this._texCoordinates, b.DYNAMIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, b.FLOAT, !1, 0, 0);
        b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        c && b.bufferData(b.ELEMENT_ARRAY_BUFFER, this._indices, b.STATIC_DRAW);
        b.drawElements(b.TRIANGLES, 6 * a, b.UNSIGNED_SHORT, 0);
        c && (this._dirty = !1);
        cc.INCREMENT_GL_DRAWS(1)
    },
    reuse: function () {
        if (0 < this._reuseGrid) {
            for (var a = this._originalVertices, b = this._vertices, c = 0, d = this._vertices.length; c <
                d; c++) a[c] = b[c];
            --this._reuseGrid
        }
    },
    calculateVertexPoints: function () {
        var a = cc._renderContext,
            b = this._texture.pixelsWidth,
            c = this._texture.pixelsHeight,
            d = this._texture.getContentSizeInPixels().height,
            e = this._gridSize,
            f = (e.width + 1) * (e.height + 1);
        this._vertices = new Float32Array(3 * f);
        this._texCoordinates = new Float32Array(2 * f);
        this._indices = new Uint16Array(e.width * e.height * 6);
        this._verticesBuffer && a.deleteBuffer(this._verticesBuffer);
        this._verticesBuffer = a.createBuffer();
        this._texCoordinateBuffer && a.deleteBuffer(this._texCoordinateBuffer);
        this._texCoordinateBuffer = a.createBuffer();
        this._indicesBuffer && a.deleteBuffer(this._indicesBuffer);
        this._indicesBuffer = a.createBuffer();
        for (var g, h, k = this._indices, m = this._texCoordinates, n = this._isTextureFlipped, p = this._vertices, f = 0; f < e.width; ++f)
            for (g = 0; g < e.height; ++g) {
                var r = g * e.width + f;
                h = f * this._step.x;
                var q = h + this._step.x,
                    s = g * this._step.y,
                    t = s + this._step.y,
                    x = f * (e.height + 1) + g,
                    y = (f + 1) * (e.height + 1) + g,
                    B = (f + 1) * (e.height + 1) + (g + 1),
                    D = f * (e.height + 1) + (g + 1);
                k[6 * r] = x;
                k[6 * r + 1] = y;
                k[6 * r + 2] = D;
                k[6 * r + 3] = y;
                k[6 * r +
                    4] = B;
                k[6 * r + 5] = D;
                var r = [3 * x, 3 * y, 3 * B, 3 * D],
                    z = [{
                        x: h,
                        y: s,
                        z: 0
                    }, {
                        x: q,
                        y: s,
                        z: 0
                    }, {
                        x: q,
                        y: t,
                        z: 0
                    }, {
                        x: h,
                        y: t,
                        z: 0
                    }],
                    x = [2 * x, 2 * y, 2 * B, 2 * D],
                    q = [cc.p(h, s), cc.p(q, s), cc.p(q, t), cc.p(h, t)];
                for (h = 0; 4 > h; ++h) p[r[h]] = z[h].x, p[r[h] + 1] = z[h].y, p[r[h] + 2] = z[h].z, m[x[h]] = q[h].x / b, m[x[h] + 1] = n ? (d - q[h].y) / c : q[h].y / c
            }
        this._originalVertices = new Float32Array(this._vertices);
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._vertices, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ARRAY_BUFFER, this._texCoordinateBuffer);
        a.bufferData(a.ARRAY_BUFFER,
            this._texCoordinates, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW);
        this._dirty = !0
    }
});
cc.Grid3D.create = function (a, b, c) {
    var d = new cc.Grid3D;
    return d && d.initWithSize(a, b, c) ? d : null
};
cc.TiledGrid3D = cc.GridBase.extend({
    _texCoordinates: null,
    _vertices: null,
    _originalVertices: null,
    _indices: null,
    _texCoordinateBuffer: null,
    _verticesBuffer: null,
    _indicesBuffer: null,
    ctor: function () {
        cc.GridBase.prototype.ctor.call(this);
        this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null
    },
    tile: function (a) {
        a.x === (0 | a.x) && a.y === (0 | a.y) || cc.log("cc.TiledGrid3D.tile() : Numbers must be integers");
        a = 12 * (this._gridSize.height *
            a.x + a.y);
        var b = this._vertices;
        return new cc.Quad3(new cc.Vertex3F(b[a], b[a + 1], b[a + 2]), new cc.Vertex3F(b[a + 3], b[a + 4], b[a + 5]), new cc.Vertex3F(b[a + 6], b[a + 7], b[a + 8]), new cc.Vertex3F(b[a + 9], b[a + 10], b[a + 11]))
    },
    originalTile: function (a) {
        a.x === (0 | a.x) && a.y === (0 | a.y) || cc.log("cc.TiledGrid3D.originalTile() : Numbers must be integers");
        a = 12 * (this._gridSize.height * a.x + a.y);
        var b = this._originalVertices;
        return new cc.Quad3(new cc.Vertex3F(b[a], b[a + 1], b[a + 2]), new cc.Vertex3F(b[a + 3], b[a + 4], b[a + 5]), new cc.Vertex3F(b[a +
            6], b[a + 7], b[a + 8]), new cc.Vertex3F(b[a + 9], b[a + 10], b[a + 11]))
    },
    setTile: function (a, b) {
        a.x === (0 | a.x) && a.y === (0 | a.y) || cc.log("cc.TiledGrid3D.setTile() : Numbers must be integers");
        var c = 12 * (this._gridSize.height * a.x + a.y),
            d = this._vertices;
        d[c] = b.bl.x;
        d[c + 1] = b.bl.y;
        d[c + 2] = b.bl.z;
        d[c + 3] = b.br.x;
        d[c + 4] = b.br.y;
        d[c + 5] = b.br.z;
        d[c + 6] = b.tl.x;
        d[c + 7] = b.tl.y;
        d[c + 8] = b.tl.z;
        d[c + 9] = b.tr.x;
        d[c + 10] = b.tr.y;
        d[c + 11] = b.tr.z;
        this._dirty = !0
    },
    blit: function () {
        var a = this._gridSize.width * this._gridSize.height;
        this._shaderProgram.use();
        this._shaderProgram.setUniformsForBuiltins();
        var b = cc._renderContext,
            c = this._dirty;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
        b.bindBuffer(b.ARRAY_BUFFER, this._verticesBuffer);
        c && b.bufferData(b.ARRAY_BUFFER, this._vertices, b.DYNAMIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, b.FLOAT, !1, 0, this._vertices);
        b.bindBuffer(b.ARRAY_BUFFER, this._texCoordinateBuffer);
        c && b.bufferData(b.ARRAY_BUFFER, this._texCoordinates, b.DYNAMIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
            2, b.FLOAT, !1, 0, this._texCoordinates);
        b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        c && b.bufferData(b.ELEMENT_ARRAY_BUFFER, this._indices, b.STATIC_DRAW);
        b.drawElements(b.TRIANGLES, 6 * a, b.UNSIGNED_SHORT, 0);
        c && (this._dirty = !1);
        cc.INCREMENT_GL_DRAWS(1)
    },
    reuse: function () {
        if (0 < this._reuseGrid) {
            for (var a = this._vertices, b = this._originalVertices, c = 0; c < a.length; c++) b[c] = a[c];
            --this._reuseGrid
        }
    },
    calculateVertexPoints: function () {
        var a = this._texture.pixelsWidth,
            b = this._texture.pixelsHeight,
            c = this._texture.getContentSizeInPixels().height,
            d = this._gridSize,
            e = d.width * d.height;
        this._vertices = new Float32Array(12 * e);
        this._texCoordinates = new Float32Array(8 * e);
        this._indices = new Uint16Array(6 * e);
        var f = cc._renderContext;
        this._verticesBuffer && f.deleteBuffer(this._verticesBuffer);
        this._verticesBuffer = f.createBuffer();
        this._texCoordinateBuffer && f.deleteBuffer(this._texCoordinateBuffer);
        this._texCoordinateBuffer = f.createBuffer();
        this._indicesBuffer && f.deleteBuffer(this._indicesBuffer);
        this._indicesBuffer = f.createBuffer();
        var g, h, k = 0,
            m = this._step,
            n = this._vertices,
            p = this._texCoordinates,
            r = this._isTextureFlipped;
        for (g = 0; g < d.width; g++)
            for (h = 0; h < d.height; h++) {
                var q = g * m.x,
                    s = q + m.x,
                    t = h * m.y,
                    x = t + m.y;
                n[12 * k] = q;
                n[12 * k + 1] = t;
                n[12 * k + 2] = 0;
                n[12 * k + 3] = s;
                n[12 * k + 4] = t;
                n[12 * k + 5] = 0;
                n[12 * k + 6] = q;
                n[12 * k + 7] = x;
                n[12 * k + 8] = 0;
                n[12 * k + 9] = s;
                n[12 * k + 10] = x;
                n[12 * k + 11] = 0;
                var y = t,
                    B = x;
                r && (y = c - t, B = c - x);
                p[8 * k] = q / a;
                p[8 * k + 1] = y / b;
                p[8 * k + 2] = s / a;
                p[8 * k + 3] = y / b;
                p[8 * k + 4] = q / a;
                p[8 * k + 5] = B / b;
                p[8 * k + 6] = s / a;
                p[8 * k + 7] = B / b;
                k++
            }
        a = this._indices;
        for (g = 0; g < e; g++) a[6 * g + 0] = 4 * g + 0, a[6 * g + 1] = 4 * g + 1, a[6 * g + 2] = 4 * g +
            2, a[6 * g + 3] = 4 * g + 1, a[6 * g + 4] = 4 * g + 2, a[6 * g + 5] = 4 * g + 3;
        this._originalVertices = new Float32Array(this._vertices);
        f.bindBuffer(f.ARRAY_BUFFER, this._verticesBuffer);
        f.bufferData(f.ARRAY_BUFFER, this._vertices, f.DYNAMIC_DRAW);
        f.bindBuffer(f.ARRAY_BUFFER, this._texCoordinateBuffer);
        f.bufferData(f.ARRAY_BUFFER, this._texCoordinates, f.DYNAMIC_DRAW);
        f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        f.bufferData(f.ELEMENT_ARRAY_BUFFER, this._indices, f.DYNAMIC_DRAW);
        this._dirty = !0
    }
});
cc.TiledGrid3D.create = function (a, b, c) {
    var d = new cc.TiledGrid3D;
    d.initWithSize(a, b, c);
    return d
};
cc.Grabber = cc.Class.extend({
    _FBO: null,
    _oldFBO: null,
    _oldClearColor: null,
    _gl: null,
    ctor: function () {
        this._gl = cc._renderContext;
        this._oldClearColor = [0, 0, 0, 0];
        this._oldFBO = null;
        this._FBO = this._gl.createFramebuffer()
    },
    grab: function (a) {
        var b = this._gl;
        this._oldFBO = b.getParameter(b.FRAMEBUFFER_BINDING);
        b.bindFramebuffer(b.FRAMEBUFFER, this._FBO);
        b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, a._webTextureObj, 0);
        b.checkFramebufferStatus(b.FRAMEBUFFER) != b.FRAMEBUFFER_COMPLETE && cc.log("Frame Grabber: could not attach texture to frmaebuffer");
        b.bindFramebuffer(b.FRAMEBUFFER, this._oldFBO)
    },
    beforeRender: function (a) {
        a = this._gl;
        this._oldFBO = a.getParameter(a.FRAMEBUFFER_BINDING);
        a.bindFramebuffer(a.FRAMEBUFFER, this._FBO);
        this._oldClearColor = a.getParameter(a.COLOR_CLEAR_VALUE);
        a.clearColor(0, 0, 0, 0);
        a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
    },
    afterRender: function (a) {
        a = this._gl;
        a.bindFramebuffer(a.FRAMEBUFFER, this._oldFBO);
        a.colorMask(!0, !0, !0, !0)
    },
    destroy: function () {
        this._gl.deleteFramebuffer(this._FBO)
    }
});
cc.ACTION_TAG_INVALID = -1;
cc.Action = cc.Class.extend({
    originalTarget: null,
    target: null,
    tag: cc.ACTION_TAG_INVALID,
    ctor: function () {
        this.target = this.originalTarget = null;
        this.tag = cc.ACTION_TAG_INVALID
    },
    copy: function () {
        return this.clone()
    },
    clone: function () {
        var a = new cc.Action;
        a.originalTarget = null;
        a.target = null;
        a.tag = this.tag;
        return a
    },
    isDone: function () {
        return !0
    },
    startWithTarget: function (a) {
        this.target = this.originalTarget = a
    },
    stop: function () {
        this.target = null
    },
    step: function (a) {
        cc.log("[Action step]. override me")
    },
    update: function (a) {
        cc.log("[Action update]. override me")
    },
    getTarget: function () {
        return this.target
    },
    setTarget: function (a) {
        this.target = a
    },
    getOriginalTarget: function () {
        return this.originalTarget
    },
    setOriginalTarget: function (a) {
        this.originalTarget = a
    },
    getTag: function () {
        return this.tag
    },
    setTag: function (a) {
        this.tag = a
    },
    retain: function () {},
    release: function () {}
});
cc.Action.create = function () {
    return new cc.Action
};
cc.FiniteTimeAction = cc.Action.extend({
    _duration: 0,
    ctor: function () {
        cc.Action.prototype.ctor.call(this);
        this._duration = 0
    },
    getDuration: function () {
        return this._duration
    },
    setDuration: function (a) {
        this._duration = a
    },
    reverse: function () {
        cc.log("cocos2d: FiniteTimeAction#reverse: Implement me");
        return null
    },
    clone: function () {
        return new cc.FiniteTimeAction
    }
});
cc.Speed = cc.Action.extend({
    _speed: 0,
    _innerAction: null,
    ctor: function () {
        cc.Action.prototype.ctor.call(this);
        this._speed = 0;
        this._innerAction = null
    },
    getSpeed: function () {
        return this._speed
    },
    setSpeed: function (a) {
        this._speed = a
    },
    initWithAction: function (a, b) {
        if (!a) throw "cc.Speed.initWithAction(): action must be non nil";
        this._innerAction = a;
        this._speed = b;
        return !0
    },
    clone: function () {
        var a = new cc.Speed;
        a.initWithAction(this._innerAction.clone(), this._speed);
        return a
    },
    startWithTarget: function (a) {
        cc.Action.prototype.startWithTarget.call(this,
            a);
        this._innerAction.startWithTarget(a)
    },
    stop: function () {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this)
    },
    step: function (a) {
        this._innerAction.step(a * this._speed)
    },
    isDone: function () {
        return this._innerAction.isDone()
    },
    reverse: function () {
        return cc.Speed.create(this._innerAction.reverse(), this._speed)
    },
    setInnerAction: function (a) {
        this._innerAction != a && (this._innerAction = a)
    },
    getInnerAction: function () {
        return this._innerAction
    }
});
cc.Speed.create = function (a, b) {
    var c = new cc.Speed;
    return c && c.initWithAction(a, b) ? c : null
};
cc.Follow = cc.Action.extend({
    _followedNode: null,
    _boundarySet: !1,
    _boundaryFullyCovered: !1,
    _halfScreenSize: null,
    _fullScreenSize: null,
    leftBoundary: 0,
    rightBoundary: 0,
    topBoundary: 0,
    bottomBoundary: 0,
    _worldRect: null,
    ctor: function () {
        cc.Action.prototype.ctor.call(this);
        this._followedNode = null;
        this._boundaryFullyCovered = this._boundarySet = !1;
        this._fullScreenSize = this._halfScreenSize = null;
        this.bottomBoundary = this.topBoundary = this.rightBoundary = this.leftBoundary = 0;
        this._worldRect = cc.rect(0, 0, 0, 0)
    },
    clone: function () {
        var a =
            new cc.Follow,
            b = this._worldRect,
            b = new cc.Rect(b.x, b.y, b.width, b.height);
        a.initWithTarget(this._followedNode, b);
        return a
    },
    isBoundarySet: function () {
        return this._boundarySet
    },
    setBoudarySet: function (a) {
        this._boundarySet = a
    },
    initWithTarget: function (a, b) {
        if (!a) throw "cc.Follow.initWithAction(): followedNode must be non nil";
        b = b || cc.rect(0, 0, 0, 0);
        this._followedNode = a;
        this._worldRect = b;
        this._boundarySet = !cc._rectEqualToZero(b);
        this._boundaryFullyCovered = !1;
        var c = cc.director.getWinSize();
        this._fullScreenSize =
            cc.p(c.width, c.height);
        this._halfScreenSize = cc.pMult(this._fullScreenSize, 0.5);
        this._boundarySet && (this.leftBoundary = -(b.x + b.width - this._fullScreenSize.x), this.rightBoundary = -b.x, this.topBoundary = -b.y, this.bottomBoundary = -(b.y + b.height - this._fullScreenSize.y), this.rightBoundary < this.leftBoundary && (this.rightBoundary = this.leftBoundary = (this.leftBoundary + this.rightBoundary) / 2), this.topBoundary < this.bottomBoundary && (this.topBoundary = this.bottomBoundary = (this.topBoundary + this.bottomBoundary) / 2), this.topBoundary ==
            this.bottomBoundary && this.leftBoundary == this.rightBoundary && (this._boundaryFullyCovered = !0));
        return !0
    },
    step: function (a) {
        a = this._followedNode.x;
        var b = this._followedNode.y;
        a = this._halfScreenSize.x - a;
        b = this._halfScreenSize.y - b;
        this._boundarySet ? this._boundaryFullyCovered || this.target.setPosition(cc.clampf(a, this.leftBoundary, this.rightBoundary), cc.clampf(b, this.bottomBoundary, this.topBoundary)) : this.target.setPosition(a, b)
    },
    isDone: function () {
        return !this._followedNode.running
    },
    stop: function () {
        this.target =
            null;
        cc.Action.prototype.stop.call(this)
    }
});
cc.Follow.create = function (a, b) {
    b = b || cc.rect(0, 0, 0, 0);
    var c = new cc.Follow;
    return null != b && c && c.initWithTarget(a, b) || c && c.initWithTarget(a) ? c : null
};
cc.ActionInterval = cc.FiniteTimeAction.extend({
    _elapsed: 0,
    _firstTick: !1,
    ctor: function () {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._elapsed = 0;
        this._firstTick = !1
    },
    getElapsed: function () {
        return this._elapsed
    },
    initWithDuration: function (a) {
        this._duration = 0 === a ? cc.FLT_EPSILON : a;
        this._elapsed = 0;
        return this._firstTick = !0
    },
    isDone: function () {
        return this._elapsed >= this._duration
    },
    clone: function () {
        var a = new cc.ActionInterval;
        a.initWithDuration(this._duration);
        return a
    },
    step: function (a) {
        this._firstTick ?
            (this._firstTick = !1, this._elapsed = 0) : this._elapsed += a;
        a = this._elapsed / (1.192092896E-7 < this._duration ? this._duration : 1.192092896E-7);
        a = 1 > a ? a : 1;
        this.update(0 < a ? a : 0)
    },
    startWithTarget: function (a) {
        cc.Action.prototype.startWithTarget.call(this, a);
        this._elapsed = 0;
        this._firstTick = !0
    },
    reverse: function () {
        cc.log("cc.IntervalAction: reverse not implemented.");
        return null
    },
    setAmplitudeRate: function (a) {
        cc.log("cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.")
    },
    getAmplitudeRate: function () {
        cc.log("cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.")
    }
});
cc.ActionInterval.create = function (a) {
    var b = new cc.ActionInterval;
    b.initWithDuration(a);
    return b
};
cc.Sequence = cc.ActionInterval.extend({
    _actions: null,
    _split: null,
    _last: 0,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._actions = [];
        this._split = null;
        this._last = 0
    },
    initWithTwoActions: function (a, b) {
        if (!a || !b) throw "cc.Sequence.initWithTwoActions(): arguments must all be non nil";
        var c = a.getDuration() + b.getDuration();
        this.initWithDuration(c);
        this._actions[0] = a;
        this._actions[1] = b;
        return !0
    },
    clone: function () {
        var a = new cc.Sequence;
        a.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._split = this._actions[0].getDuration() / this._duration;
        this._last = -1
    },
    stop: function () {
        -1 !== this._last && this._actions[this._last].stop();
        cc.Action.prototype.stop.call(this)
    },
    update: function (a) {
        var b = 0,
            c = this._split,
            d = this._actions,
            e = this._last;
        a < c ? (a = 0 !== c ? a / c : 1, 0 === b && 1 === e && (d[1].update(0), d[1].stop())) : (b = 1, a = 1 === c ? 1 : (a - c) / (1 - c), -1 === e && (d[0].startWithTarget(this.target), d[0].update(1), d[0].stop()),
            e || (d[0].update(1), d[0].stop()));
        e === b && d[b].isDone() || (e !== b && d[b].startWithTarget(this.target), d[b].update(a), this._last = b)
    },
    reverse: function () {
        return cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse())
    },
    copy: function () {
        return this.clone()
    }
});
cc.Sequence.create = function (a) {
    var b = a instanceof Array ? a : arguments;
    0 < b.length && null == b[b.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    for (var c = b[0], d = 1; d < b.length; d++) b[d] && (c = cc.Sequence._actionOneTwo(c, b[d]));
    return c
};
cc.Sequence._actionOneTwo = function (a, b) {
    var c = new cc.Sequence;
    c.initWithTwoActions(a, b);
    return c
};
cc.Repeat = cc.ActionInterval.extend({
    _times: 0,
    _total: 0,
    _nextDt: 0,
    _actionInstant: !1,
    _innerAction: null,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._nextDt = this._total = this._times = 0;
        this._actionInstant = !1;
        this._innerAction = null
    },
    initWithAction: function (a, b) {
        var c = a.getDuration() * b;
        return this.initWithDuration(c) ? (this._times = b, this._innerAction = a, a instanceof cc.ActionInstant && (this._times -= 1), this._total = 0, !0) : !1
    },
    clone: function () {
        var a = new cc.Repeat;
        a.initWithAction(this._innerAction.clone(),
            this._times);
        return a
    },
    startWithTarget: function (a) {
        this._total = 0;
        this._nextDt = this._innerAction.getDuration() / this._duration;
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._innerAction.startWithTarget(a)
    },
    stop: function () {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this)
    },
    update: function (a) {
        var b = this._innerAction,
            c = this._duration,
            d = this._times,
            e = this._nextDt;
        if (a >= e) {
            for (; a > e && this._total < d;) b.update(1), this._total++, b.stop(), b.startWithTarget(this.target), this._nextDt = e +=
                b.getDuration() / c;
            1 <= a && this._total < d && this._total++;
            this._actionInstant && (this._total == d ? (b.update(1), b.stop()) : b.update(a - (e - b.getDuration() / c)))
        } else b.update(a * d % 1)
    },
    isDone: function () {
        return this._total == this._times
    },
    reverse: function () {
        return cc.Repeat.create(this._innerAction.reverse(), this._times)
    },
    setInnerAction: function (a) {
        this._innerAction != a && (this._innerAction = a)
    },
    getInnerAction: function () {
        return this._innerAction
    }
});
cc.Repeat.create = function (a, b) {
    var c = new cc.Repeat;
    c.initWithAction(a, b);
    return c
};
cc.RepeatForever = cc.ActionInterval.extend({
    _innerAction: null,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._innerAction = null
    },
    initWithAction: function (a) {
        if (!a) throw "cc.RepeatForever.initWithAction(): action must be non null";
        this._innerAction = a;
        return !0
    },
    clone: function () {
        var a = new cc.RepeatForever;
        a.initWithAction(this._innerAction.clone());
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._innerAction.startWithTarget(a)
    },
    step: function (a) {
        var b =
            this._innerAction;
        b.step(a);
        b.isDone() && (b.startWithTarget(this.target), b.step(b.getElapsed() - b.getDuration()))
    },
    isDone: function () {
        return !1
    },
    reverse: function () {
        return cc.RepeatForever.create(this._innerAction.reverse())
    },
    setInnerAction: function (a) {
        this._innerAction != a && (this._innerAction = a)
    },
    getInnerAction: function () {
        return this._innerAction
    }
});
cc.RepeatForever.create = function (a) {
    var b = new cc.RepeatForever;
    return b && b.initWithAction(a) ? b : null
};
cc.Spawn = cc.ActionInterval.extend({
    _one: null,
    _two: null,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._two = this._one = null
    },
    initWithTwoActions: function (a, b) {
        if (!a || !b) throw "cc.Spawn.initWithTwoActions(): arguments must all be non null";
        var c = !1,
            d = a.getDuration(),
            e = b.getDuration();
        this.initWithDuration(Math.max(d, e)) && (this._one = a, this._two = b, d > e ? this._two = cc.Sequence._actionOneTwo(b, cc.DelayTime.create(d - e)) : d < e && (this._one = cc.Sequence._actionOneTwo(a, cc.DelayTime.create(e - d))), c = !0);
        return c
    },
    clone: function () {
        var a = new cc.Spawn;
        a.initWithTwoActions(this._one.clone(), this._two.clone());
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._one.startWithTarget(a);
        this._two.startWithTarget(a)
    },
    stop: function () {
        this._one.stop();
        this._two.stop();
        cc.Action.prototype.stop.call(this)
    },
    update: function (a) {
        this._one && this._one.update(a);
        this._two && this._two.update(a)
    },
    reverse: function () {
        return cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse())
    }
});
cc.Spawn.create = function (a) {
    var b = a instanceof Array ? a : arguments;
    0 < b.length && null == b[b.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    for (var c = b[0], d = 1; d < b.length; d++) null != b[d] && (c = this._actionOneTwo(c, b[d]));
    return c
};
cc.Spawn._actionOneTwo = function (a, b) {
    var c = new cc.Spawn;
    c.initWithTwoActions(a, b);
    return c
};
cc.RotateTo = cc.ActionInterval.extend({
    _dstAngleX: 0,
    _startAngleX: 0,
    _diffAngleX: 0,
    _dstAngleY: 0,
    _startAngleY: 0,
    _diffAngleY: 0,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._diffAngleY = this._startAngleY = this._dstAngleY = this._diffAngleX = this._startAngleX = this._dstAngleX = 0
    },
    initWithDuration: function (a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._dstAngleX = b || 0, this._dstAngleY = c || this._dstAngleX, !0) : !1
    },
    clone: function () {
        var a = new cc.RotateTo;
        a.initWithDuration(this._duration,
            this._dstAngleX, this._dstAngleY);
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.rotationX % 360,
            c = this._dstAngleX - b;
        180 < c && (c -= 360); - 180 > c && (c += 360);
        this._startAngleX = b;
        this._diffAngleX = c;
        this._startAngleY = a.rotationY % 360;
        a = this._dstAngleY - this._startAngleY;
        180 < a && (a -= 360); - 180 > a && (a += 360);
        this._diffAngleY = a
    },
    reverse: function () {
        cc.log("cc.RotateTo.reverse(): it should be overridden in subclass.")
    },
    update: function (a) {
        this.target && (this.target.rotationX =
            this._startAngleX + this._diffAngleX * a, this.target.rotationY = this._startAngleY + this._diffAngleY * a)
    }
});
cc.RotateTo.create = function (a, b, c) {
    var d = new cc.RotateTo;
    d.initWithDuration(a, b, c);
    return d
};
cc.RotateBy = cc.ActionInterval.extend({
    _angleX: 0,
    _startAngleX: 0,
    _angleY: 0,
    _startAngleY: 0,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._startAngleY = this._angleY = this._startAngleX = this._angleX = 0
    },
    initWithDuration: function (a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._angleX = b || 0, this._angleY = c || this._angleX, !0) : !1
    },
    clone: function () {
        var a = new cc.RotateBy;
        a.initWithDuration(this._duration, this._angleX, this._angleY);
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._startAngleX = a.rotationX;
        this._startAngleY = a.rotationY
    },
    update: function (a) {
        this.target && (this.target.rotationX = this._startAngleX + this._angleX * a, this.target.rotationY = this._startAngleY + this._angleY * a)
    },
    reverse: function () {
        return cc.RotateBy.create(this._duration, -this._angleX, -this._angleY)
    }
});
cc.RotateBy.create = function (a, b, c) {
    var d = new cc.RotateBy;
    d.initWithDuration(a, b, c);
    return d
};
cc.MoveBy = cc.ActionInterval.extend({
    _positionDelta: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._positionDelta = cc.p(0, 0);
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0)
    },
    initWithDuration: function (a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._positionDelta.x = b.x, this._positionDelta.y = b.y, !0) : !1
    },
    clone: function () {
        var a = new cc.MoveBy;
        a.initWithDuration(this._duration, this._positionDelta);
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX();
        a = a.getPositionY();
        this._previousPosition.x = b;
        this._previousPosition.y = a;
        this._startPosition.x = b;
        this._startPosition.y = a
    },
    update: function (a) {
        if (this.target) {
            var b = this._positionDelta.x * a;
            a *= this._positionDelta.y;
            var c = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var d = this.target.getPositionX(),
                    e = this.target.getPositionY(),
                    f = this._previousPosition;
                c.x = c.x + d - f.x;
                c.y = c.y + e - f.y;
                b += c.x;
                a += c.y;
                f.x = b;
                f.y = a;
                this.target.setPosition(b, a)
            } else this.target.setPosition(c.x + b, c.y + a)
        }
    },
    reverse: function () {
        return cc.MoveBy.create(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y))
    }
});
cc.MoveBy.create = function (a, b) {
    var c = new cc.MoveBy;
    c.initWithDuration(a, b);
    return c
};
cc.MoveTo = cc.MoveBy.extend({
    _endPosition: null,
    ctor: function () {
        cc.MoveBy.prototype.ctor.call(this);
        this._endPosition = cc.p(0, 0)
    },
    initWithDuration: function (a, b) {
        return cc.MoveBy.prototype.initWithDuration.call(this, a, b) ? (this._endPosition.x = b.x, this._endPosition.y = b.y, !0) : !1
    },
    clone: function () {
        var a = new cc.MoveTo;
        a.initWithDuration(this._duration, this._endPosition);
        return a
    },
    startWithTarget: function (a) {
        cc.MoveBy.prototype.startWithTarget.call(this, a);
        this._positionDelta.x = this._endPosition.x - a.getPositionX();
        this._positionDelta.y = this._endPosition.y - a.getPositionY()
    }
});
cc.MoveTo.create = function (a, b) {
    var c = new cc.MoveTo;
    c.initWithDuration(a, b);
    return c
};
cc.SkewTo = cc.ActionInterval.extend({
    _skewX: 0,
    _skewY: 0,
    _startSkewX: 0,
    _startSkewY: 0,
    _endSkewX: 0,
    _endSkewY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._deltaY = this._deltaX = this._endSkewY = this._endSkewX = this._startSkewY = this._startSkewX = this._skewY = this._skewX = 0
    },
    initWithDuration: function (a, b, c) {
        var d = !1;
        cc.ActionInterval.prototype.initWithDuration.call(this, a) && (this._endSkewX = b, this._endSkewY = c, d = !0);
        return d
    },
    clone: function () {
        var a = new cc.SkewTo;
        a.initWithDuration(this._duration,
            this._endSkewX, this._endSkewY);
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._startSkewX = a.skewX % 180;
        this._deltaX = this._endSkewX - this._startSkewX;
        180 < this._deltaX && (this._deltaX -= 360); - 180 > this._deltaX && (this._deltaX += 360);
        this._startSkewY = a.skewY % 360;
        this._deltaY = this._endSkewY - this._startSkewY;
        180 < this._deltaY && (this._deltaY -= 360); - 180 > this._deltaY && (this._deltaY += 360)
    },
    update: function (a) {
        this.target.skewX = this._startSkewX + this._deltaX * a;
        this.target.skewY =
            this._startSkewY + this._deltaY * a
    }
});
cc.SkewTo.create = function (a, b, c) {
    var d = new cc.SkewTo;
    d && d.initWithDuration(a, b, c);
    return d
};
cc.SkewBy = cc.SkewTo.extend({
    initWithDuration: function (a, b, c) {
        var d = !1;
        cc.SkewTo.prototype.initWithDuration.call(this, a, b, c) && (this._skewX = b, this._skewY = c, d = !0);
        return d
    },
    clone: function () {
        var a = new cc.SkewBy;
        a.initWithDuration(this._duration, this._skewX, this._skewY);
        return a
    },
    startWithTarget: function (a) {
        cc.SkewTo.prototype.startWithTarget.call(this, a);
        this._deltaX = this._skewX;
        this._deltaY = this._skewY;
        this._endSkewX = this._startSkewX + this._deltaX;
        this._endSkewY = this._startSkewY + this._deltaY
    },
    reverse: function () {
        return cc.SkewBy.create(this._duration, -this._skewX, -this._skewY)
    }
});
cc.SkewBy.create = function (a, b, c) {
    var d = new cc.SkewBy;
    d && d.initWithDuration(a, b, c);
    return d
};
cc.JumpBy = cc.ActionInterval.extend({
    _startPosition: null,
    _delta: null,
    _height: 0,
    _jumps: 0,
    _previousPosition: null,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        this._delta = cc.p(0, 0);
        this._jumps = this._height = 0
    },
    initWithDuration: function (a, b, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._delta.x = b.x, this._delta.y = b.y, this._height = c, this._jumps = d, !0) : !1
    },
    clone: function () {
        var a = new cc.JumpBy;
        a.initWithDuration(this._duration,
            this._delta, this._height, this._jumps);
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX();
        a = a.getPositionY();
        this._previousPosition.x = b;
        this._previousPosition.y = a;
        this._startPosition.x = b;
        this._startPosition.y = a
    },
    update: function (a) {
        if (this.target) {
            var b = a * this._jumps % 1,
                b = 4 * this._height * b * (1 - b),
                b = b + this._delta.y * a;
            a *= this._delta.x;
            var c = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var d = this.target.getPositionX(),
                    e = this.target.getPositionY(),
                    f = this._previousPosition;
                c.x = c.x + d - f.x;
                c.y = c.y + e - f.y;
                a += c.x;
                b += c.y;
                f.x = a;
                f.y = b;
                this.target.setPosition(a, b)
            } else this.target.setPosition(c.x + a, c.y + b)
        }
    },
    reverse: function () {
        return cc.JumpBy.create(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps)
    }
});
cc.JumpBy.create = function (a, b, c, d) {
    var e = new cc.JumpBy;
    e.initWithDuration(a, b, c, d);
    return e
};
cc.JumpTo = cc.JumpBy.extend({
    startWithTarget: function (a) {
        cc.JumpBy.prototype.startWithTarget.call(this, a);
        this._delta.x -= this._startPosition.x;
        this._delta.y -= this._startPosition.y
    },
    clone: function () {
        var a = new cc.JumpTo;
        a.initWithDuration(this._duration, this._delta, this._height, this._jumps);
        return a
    }
});
cc.JumpTo.create = function (a, b, c, d) {
    var e = new cc.JumpTo;
    e.initWithDuration(a, b, c, d);
    return e
};
cc.bezierAt = function (a, b, c, d, e) {
    return Math.pow(1 - e, 3) * a + 3 * e * Math.pow(1 - e, 2) * b + 3 * Math.pow(e, 2) * (1 - e) * c + Math.pow(e, 3) * d
};
cc.BezierBy = cc.ActionInterval.extend({
    _config: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._config = [];
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0)
    },
    initWithDuration: function (a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._config = b, !0) : !1
    },
    clone: function () {
        for (var a = new cc.BezierBy, b = [], c = 0; c < this._config.length; c++) {
            var d = this._config[c];
            b.push(cc.p(d.x, d.y))
        }
        a.initWithDuration(this._duration,
            b);
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX();
        a = a.getPositionY();
        this._previousPosition.x = b;
        this._previousPosition.y = a;
        this._startPosition.x = b;
        this._startPosition.y = a
    },
    update: function (a) {
        if (this.target) {
            var b = this._config,
                c = b[0].y,
                d = b[1].y,
                e = b[2].y,
                b = cc.bezierAt(0, b[0].x, b[1].x, b[2].x, a);
            a = cc.bezierAt(0, c, d, e, a);
            c = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var d = this.target.getPositionX(),
                    e = this.target.getPositionY(),
                    f = this._previousPosition;
                c.x = c.x + d - f.x;
                c.y = c.y + e - f.y;
                b += c.x;
                a += c.y;
                f.x = b;
                f.y = a;
                this.target.setPosition(b, a)
            } else this.target.setPosition(c.x + b, c.y + a)
        }
    },
    reverse: function () {
        var a = this._config,
            a = [cc.pAdd(a[1], cc.pNeg(a[2])), cc.pAdd(a[0], cc.pNeg(a[2])), cc.pNeg(a[2])];
        return cc.BezierBy.create(this._duration, a)
    }
});
cc.BezierBy.create = function (a, b) {
    var c = new cc.BezierBy;
    c.initWithDuration(a, b);
    return c
};
cc.BezierTo = cc.BezierBy.extend({
    _toConfig: null,
    ctor: function () {
        cc.BezierBy.prototype.ctor.call(this);
        this._toConfig = []
    },
    initWithDuration: function (a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toConfig = b, !0) : !1
    },
    clone: function () {
        var a = new cc.BezierTo;
        a.initWithDuration(this._duration, this._toConfig);
        return a
    },
    startWithTarget: function (a) {
        cc.BezierBy.prototype.startWithTarget.call(this, a);
        a = this._startPosition;
        var b = this._toConfig,
            c = this._config;
        c[0] = cc.pSub(b[0], a);
        c[1] =
            cc.pSub(b[1], a);
        c[2] = cc.pSub(b[2], a)
    }
});
cc.BezierTo.create = function (a, b) {
    var c = new cc.BezierTo;
    c.initWithDuration(a, b);
    return c
};
cc.ScaleTo = cc.ActionInterval.extend({
    _scaleX: 1,
    _scaleY: 1,
    _startScaleX: 1,
    _startScaleY: 1,
    _endScaleX: 0,
    _endScaleY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._startScaleY = this._startScaleX = this._scaleY = this._scaleX = 1;
        this._deltaY = this._deltaX = this._endScaleY = this._endScaleX = 0
    },
    initWithDuration: function (a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._endScaleX = b, this._endScaleY = null != c ? c : b, !0) : !1
    },
    clone: function () {
        var a = new cc.ScaleTo;
        a.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._startScaleX = a.scaleX;
        this._startScaleY = a.scaleY;
        this._deltaX = this._endScaleX - this._startScaleX;
        this._deltaY = this._endScaleY - this._startScaleY
    },
    update: function (a) {
        this.target && (this.target.scaleX = this._startScaleX + this._deltaX * a, this.target.scaleY = this._startScaleY + this._deltaY * a)
    }
});
cc.ScaleTo.create = function (a, b, c) {
    var d = new cc.ScaleTo;
    d.initWithDuration(a, b, c);
    return d
};
cc.ScaleBy = cc.ScaleTo.extend({
    startWithTarget: function (a) {
        cc.ScaleTo.prototype.startWithTarget.call(this, a);
        this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
        this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY
    },
    reverse: function () {
        return cc.ScaleBy.create(this._duration, 1 / this._endScaleX, 1 / this._endScaleY)
    },
    clone: function () {
        var a = new cc.ScaleBy;
        a.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
        return a
    }
});
cc.ScaleBy.create = function (a, b, c) {
    var d = new cc.ScaleBy;
    d.initWithDuration(a, b, c);
    return d
};
cc.Blink = cc.ActionInterval.extend({
    _times: 0,
    _originalState: !1,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._times = 0;
        this._originalState = !1
    },
    initWithDuration: function (a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._times = b, !0) : !1
    },
    clone: function () {
        var a = new cc.Blink;
        a.initWithDuration(this._duration, this._times);
        return a
    },
    update: function (a) {
        if (this.target && !this.isDone()) {
            var b = 1 / this._times;
            this.target.visible = a % b > b / 2
        }
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._originalState = a.visible
    },
    stop: function () {
        this.target.visible = this._originalState;
        cc.ActionInterval.prototype.stop.call(this)
    },
    reverse: function () {
        return cc.Blink.create(this._duration, this._times)
    }
});
cc.Blink.create = function (a, b) {
    var c = new cc.Blink;
    c.initWithDuration(a, b);
    return c
};
cc.FadeTo = cc.ActionInterval.extend({
    _toOpacity: null,
    _fromOpacity: null,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._fromOpacity = this._toOpacity = 0
    },
    initWithDuration: function (a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toOpacity = b, !0) : !1
    },
    clone: function () {
        var a = new cc.FadeTo;
        a.initWithDuration(this._duration, this._toOpacity);
        return a
    },
    update: function (a) {
        if (this.target.RGBAProtocol) {
            var b = this._fromOpacity;
            this.target.opacity = b + (this._toOpacity - b) *
                a
        }
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this.target.RGBAProtocol && (this._fromOpacity = a.opacity)
    }
});
cc.FadeTo.create = function (a, b) {
    var c = new cc.FadeTo;
    c.initWithDuration(a, b);
    return c
};
cc.FadeIn = cc.FadeTo.extend({
    _reverseAction: null,
    reverse: function () {
        var a = new cc.FadeOut;
        a.initWithDuration(this._duration, 0);
        return a
    },
    clone: function () {
        var a = new cc.FadeIn;
        a.initWithDuration(this._duration, this._toOpacity);
        return a
    },
    startWithTarget: function (a) {
        this._reverseAction && (this._toOpacity = this._reverseAction._fromOpacity);
        cc.FadeTo.prototype.startWithTarget.call(this, a)
    }
});
cc.FadeIn.create = function (a, b) {
    null == b && (b = 255);
    var c = new cc.FadeIn;
    c.initWithDuration(a, b);
    return c
};
cc.FadeOut = cc.FadeTo.extend({
    reverse: function () {
        var a = new cc.FadeIn;
        a._reverseAction = this;
        a.initWithDuration(this._duration, 255);
        return a
    },
    clone: function () {
        var a = new cc.FadeOut;
        a.initWithDuration(this._duration, this._toOpacity);
        return a
    }
});
cc.FadeOut.create = function (a) {
    var b = new cc.FadeOut;
    b.initWithDuration(a, 0);
    return b
};
cc.TintTo = cc.ActionInterval.extend({
    _to: null,
    _from: null,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._to = cc.color(0, 0, 0);
        this._from = cc.color(0, 0, 0)
    },
    initWithDuration: function (a, b, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = cc.color(b, c, d), !0) : !1
    },
    clone: function () {
        var a = new cc.TintTo,
            b = this._to;
        a.initWithDuration(this._duration, b.r, b.g, b.b);
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this.target.RGBAProtocol &&
            (this._from = this.target.color)
    },
    update: function (a) {
        var b = this._from,
            c = this._to;
        this.target.RGBAProtocol && (this.target.color = cc.color(b.r + (c.r - b.r) * a, b.g + (c.g - b.g) * a, b.b + (c.b - b.b) * a))
    }
});
cc.TintTo.create = function (a, b, c, d) {
    var e = new cc.TintTo;
    e.initWithDuration(a, b, c, d);
    return e
};
cc.TintBy = cc.ActionInterval.extend({
    _deltaR: 0,
    _deltaG: 0,
    _deltaB: 0,
    _fromR: 0,
    _fromG: 0,
    _fromB: 0,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._fromB = this._fromG = this._fromR = this._deltaB = this._deltaG = this._deltaR = 0
    },
    initWithDuration: function (a, b, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._deltaR = b, this._deltaG = c, this._deltaB = d, !0) : !1
    },
    clone: function () {
        var a = new cc.TintBy;
        a.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB);
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        a.RGBAProtocol && (a = a.color, this._fromR = a.r, this._fromG = a.g, this._fromB = a.b)
    },
    update: function (a) {
        this.target.RGBAProtocol && (this.target.color = cc.color(this._fromR + this._deltaR * a, this._fromG + this._deltaG * a, this._fromB + this._deltaB * a))
    },
    reverse: function () {
        return cc.TintBy.create(this._duration, -this._deltaR, -this._deltaG, -this._deltaB)
    }
});
cc.TintBy.create = function (a, b, c, d) {
    var e = new cc.TintBy;
    e.initWithDuration(a, b, c, d);
    return e
};
cc.DelayTime = cc.ActionInterval.extend({
    update: function (a) {},
    reverse: function () {
        return cc.DelayTime.create(this._duration)
    },
    clone: function () {
        var a = new cc.DelayTime;
        a.initWithDuration(this._duration);
        return a
    }
});
cc.DelayTime.create = function (a) {
    var b = new cc.DelayTime;
    b.initWithDuration(a);
    return b
};
cc.ReverseTime = cc.ActionInterval.extend({
    _other: null,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._other = null
    },
    initWithAction: function (a) {
        if (!a) throw "cc.ReverseTime.initWithAction(): action must be non null";
        if (a == this._other) throw "cc.ReverseTime.initWithAction(): the action was already passed in.";
        return cc.ActionInterval.prototype.initWithDuration.call(this, a.getDuration()) ? (this._other = a, !0) : !1
    },
    clone: function () {
        var a = new cc.ReverseTime;
        a.initWithAction(this._other.clone());
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._other.startWithTarget(a)
    },
    update: function (a) {
        this._other && this._other.update(1 - a)
    },
    reverse: function () {
        return this._other.clone()
    },
    stop: function () {
        this._other.stop();
        cc.Action.prototype.stop.call(this)
    }
});
cc.ReverseTime.create = function (a) {
    var b = new cc.ReverseTime;
    b.initWithAction(a);
    return b
};
cc.Animate = cc.ActionInterval.extend({
    _animation: null,
    _nextFrame: 0,
    _origFrame: null,
    _executedLoops: 0,
    _splitTimes: null,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._animation = null;
        this._nextFrame = 0;
        this._origFrame = null;
        this._executedLoops = 0;
        this._splitTimes = []
    },
    getAnimation: function () {
        return this._animation
    },
    setAnimation: function (a) {
        this._animation = a
    },
    initWithAnimation: function (a) {
        if (!a) throw "cc.Animate.initWithAnimation(): animation must be non-NULL";
        var b = a.getDuration();
        if (this.initWithDuration(b *
            a.getLoops())) {
            this._nextFrame = 0;
            this.setAnimation(a);
            this._origFrame = null;
            this._executedLoops = 0;
            var c = this._splitTimes,
                d = c.length = 0,
                e = b / a.getTotalDelayUnits();
            a = a.getFrames();
            cc.arrayVerifyType(a, cc.AnimationFrame);
            for (var f = 0; f < a.length; f++) {
                var g = d * e / b,
                    d = d + a[f].getDelayUnits();
                c.push(g)
            }
            return !0
        }
        return !1
    },
    clone: function () {
        var a = new cc.Animate;
        a.initWithAnimation(this._animation.clone());
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._animation.getRestoreOriginalFrame() &&
            (this._origFrame = a.displayFrame());
        this._executedLoops = this._nextFrame = 0
    },
    update: function (a) {
        1 > a && (a *= this._animation.getLoops(), (0 | a) > this._executedLoops && (this._nextFrame = 0, this._executedLoops++), a %= 1);
        for (var b = this._animation.getFrames(), c = b.length, d = this._splitTimes, e = this._nextFrame; e < c; e++)
            if (d[e] <= a) this.target.setSpriteFrame(b[e].getSpriteFrame()), this._nextFrame = e + 1;
            else break
    },
    reverse: function () {
        var a = this._animation,
            b = a.getFrames(),
            c = [];
        cc.arrayVerifyType(b, cc.AnimationFrame);
        if (0 < b.length)
            for (var d =
                b.length - 1; 0 <= d; d--) {
                var e = b[d];
                if (!e) break;
                c.push(e.clone())
            }
        b = cc.Animation.create(c, a.getDelayPerUnit(), a.getLoops());
        b.setRestoreOriginalFrame(a.getRestoreOriginalFrame());
        return cc.Animate.create(b)
    },
    stop: function () {
        this._animation.getRestoreOriginalFrame() && this.target && this.target.setSpriteFrame(this._origFrame);
        cc.Action.prototype.stop.call(this)
    }
});
cc.Animate.create = function (a) {
    var b = new cc.Animate;
    b.initWithAnimation(a);
    return b
};
cc.TargetedAction = cc.ActionInterval.extend({
    _action: null,
    _forcedTarget: null,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._forcedTarget = this._action = null
    },
    initWithTarget: function (a, b) {
        return this.initWithDuration(b.getDuration()) ? (this._forcedTarget = a, this._action = b, !0) : !1
    },
    clone: function () {
        var a = new cc.TargetedAction;
        a.initWithTarget(this._forcedTarget, this._action.clone());
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._action.startWithTarget(this._forcedTarget)
    },
    stop: function () {
        this._action.stop()
    },
    update: function (a) {
        this._action.update(a)
    },
    getForcedTarget: function () {
        return this._forcedTarget
    },
    setForcedTarget: function (a) {
        this._forcedTarget != a && (this._forcedTarget = a)
    }
});
cc.TargetedAction.create = function (a, b) {
    var c = new cc.TargetedAction;
    c.initWithTarget(a, b);
    return c
};
cc.ActionInstant = cc.FiniteTimeAction.extend({
    isDone: function () {
        return !0
    },
    step: function (a) {
        this.update(1)
    },
    update: function (a) {},
    reverse: function () {
        return this.clone()
    },
    clone: function () {
        return new cc.ActionInstant
    }
});
cc.Show = cc.ActionInstant.extend({
    update: function (a) {
        this.target.visible = !0
    },
    reverse: function () {
        return cc.Hide.create()
    },
    clone: function () {
        return new cc.Show
    }
});
cc.Show.create = function () {
    return new cc.Show
};
cc.Hide = cc.ActionInstant.extend({
    update: function (a) {
        this.target.visible = !1
    },
    reverse: function () {
        return cc.Show.create()
    },
    clone: function () {
        return new cc.Hide
    }
});
cc.Hide.create = function () {
    return new cc.Hide
};
cc.ToggleVisibility = cc.ActionInstant.extend({
    update: function (a) {
        this.target.visible = !this.target.visible
    },
    reverse: function () {
        return new cc.ToggleVisibility
    },
    clone: function () {
        return new cc.ToggleVisibility
    }
});
cc.ToggleVisibility.create = function () {
    return new cc.ToggleVisibility
};
cc.RemoveSelf = cc.ActionInstant.extend({
    _isNeedCleanUp: !0,
    ctor: function () {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._isNeedCleanUp = !0
    },
    update: function (a) {
        this.target.removeFromParent(this._isNeedCleanUp)
    },
    init: function (a) {
        this._isNeedCleanUp = a;
        return !0
    },
    reverse: function () {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    },
    clone: function () {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    }
});
cc.RemoveSelf.create = function (a) {
    null == a && (a = !0);
    var b = new cc.RemoveSelf;
    b && b.init(a);
    return b
};
cc.FlipX = cc.ActionInstant.extend({
    _flippedX: !1,
    ctor: function () {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedX = !1
    },
    initWithFlipX: function (a) {
        this._flippedX = a;
        return !0
    },
    update: function (a) {
        this.target.flippedX = this._flippedX
    },
    reverse: function () {
        return cc.FlipX.create(!this._flippedX)
    },
    clone: function () {
        var a = new cc.FlipX;
        a.initWithFlipX(this._flippedX);
        return a
    }
});
cc.FlipX.create = function (a) {
    var b = new cc.FlipX;
    return b.initWithFlipX(a) ? b : null
};
cc.FlipY = cc.ActionInstant.extend({
    _flippedY: !1,
    ctor: function () {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedY = !1
    },
    initWithFlipY: function (a) {
        this._flippedY = a;
        return !0
    },
    update: function (a) {
        this.target.flippedY = this._flippedY
    },
    reverse: function () {
        return cc.FlipY.create(!this._flippedY)
    },
    clone: function () {
        var a = new cc.FlipY;
        a.initWithFlipY(this._flippedY);
        return a
    }
});
cc.FlipY.create = function (a) {
    var b = new cc.FlipY;
    return b.initWithFlipY(a) ? b : null
};
cc.Place = cc.ActionInstant.extend({
    _x: 0,
    _y: 0,
    ctor: function () {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._y = this._x = 0
    },
    initWithPosition: function (a, b) {
        this._x = a;
        this._y = b;
        return !0
    },
    update: function (a) {
        this.target.setPosition(this._x, this._y)
    },
    clone: function () {
        var a = new cc.Place;
        a.initWithPosition(this._x, this._y);
        return a
    }
});
cc.Place.create = function (a) {
    var b = new cc.Place;
    b.initWithPosition(a.x, a.y);
    return b
};
cc.CallFunc = cc.ActionInstant.extend({
    _selectorTarget: null,
    _callFunc: null,
    _function: null,
    _data: null,
    ctor: function () {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._data = this._function = this._callFunc = this._selectorTarget = null
    },
    initWithTarget: function (a, b, c) {
        this._data = c;
        this._callFunc = a;
        this._selectorTarget = b;
        return !0
    },
    initWithFunction: function (a) {
        this._function = a;
        return !0
    },
    execute: function () {
        null != this._callFunc ? this._callFunc.call(this._selectorTarget, this.target, this._data) : this._function && this._function.call(null,
            this.target)
    },
    update: function (a) {
        this.execute()
    },
    getTargetCallback: function () {
        return this._selectorTarget
    },
    setTargetCallback: function (a) {
        a != this._selectorTarget && (this._selectorTarget && (this._selectorTarget = null), this._selectorTarget = a)
    },
    copy: function () {
        var a = new cc.CallFunc;
        this._selectorTarget ? a.initWithTarget(this._callFunc, this._selectorTarget, this._data) : this._function && a.initWithFunction(this._function);
        return a
    },
    clone: function () {
        var a = new cc.CallFunc;
        this._selectorTarget ? a.initWithTarget(this._callFunc,
            this._selectorTarget, this._data) : this._function && a.initWithFunction(this._function);
        return a
    }
});
cc.CallFunc.create = function (a, b, c) {
    var d = new cc.CallFunc;
    if (void 0 === b) {
        if (d && d.initWithFunction(a)) return d
    } else if (d && d.initWithTarget(a, b, c)) return d._callFunc = a, d;
    return null
};
cc.ActionCamera = cc.ActionInterval.extend({
    _centerXOrig: 0,
    _centerYOrig: 0,
    _centerZOrig: 0,
    _eyeXOrig: 0,
    _eyeYOrig: 0,
    _eyeZOrig: 0,
    _upXOrig: 0,
    _upYOrig: 0,
    _upZOrig: 0,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._upZOrig = this._upYOrig = this._upXOrig = this._eyeZOrig = this._eyeYOrig = this._eyeXOrig = this._centerZOrig = this._centerYOrig = this._centerXOrig = 0
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        a = a.getCamera();
        var b = a.getCenter();
        this._centerXOrig = b.x;
        this._centerYOrig = b.y;
        this._centerZOrig = b.z;
        b = a.getEye();
        this._eyeXOrig = b.x;
        this._eyeYOrig = b.y;
        this._eyeZOrig = b.z;
        a = a.getUp();
        this._upXOrig = a.x;
        this._upYOrig = a.y;
        this._upZOrig = a.z
    },
    clone: function () {
        return new cc.ActionCamera
    },
    reverse: function () {
        return cc.ReverseTime.create(this)
    }
});
cc.OrbitCamera = cc.ActionCamera.extend({
    _radius: 0,
    _deltaRadius: 0,
    _angleZ: 0,
    _deltaAngleZ: 0,
    _angleX: 0,
    _deltaAngleX: 0,
    _radZ: 0,
    _radDeltaZ: 0,
    _radX: 0,
    _radDeltaX: 0,
    ctor: function () {
        cc.ActionCamera.prototype.ctor.call(this);
        this._radDeltaX = this._radX = this._radDeltaZ = this._radZ = this._deltaAngleX = this._angleX = this._deltaAngleZ = this._angleZ = this._deltaRadius = this._radius = 0
    },
    initWithDuration: function (a, b, c, d, e, f, g) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._radius = b, this._deltaRadius =
            c, this._angleZ = d, this._deltaAngleZ = e, this._angleX = f, this._deltaAngleX = g, this._radDeltaZ = cc.DEGREES_TO_RADIANS(e), this._radDeltaX = cc.DEGREES_TO_RADIANS(g), !0) : !1
    },
    sphericalRadius: function () {
        var a, b;
        b = this.target.getCamera();
        var c = b.getEye();
        a = b.getCenter();
        b = c.x - a.x;
        var d = c.y - a.y;
        a = c.z - a.z;
        var c = Math.sqrt(Math.pow(b, 2) + Math.pow(d, 2) + Math.pow(a, 2)),
            e = Math.sqrt(Math.pow(b, 2) + Math.pow(d, 2));
        0 === e && (e = cc.FLT_EPSILON);
        0 === c && (c = cc.FLT_EPSILON);
        a = Math.acos(a / c);
        b = 0 > b ? Math.PI - Math.asin(d / e) : Math.asin(d / e);
        return {
            newRadius: c / cc.Camera.getZEye(),
            zenith: a,
            azimuth: b
        }
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        a = this.sphericalRadius();
        isNaN(this._radius) && (this._radius = a.newRadius);
        isNaN(this._angleZ) && (this._angleZ = cc.RADIANS_TO_DEGREES(a.zenith));
        isNaN(this._angleX) && (this._angleX = cc.RADIANS_TO_DEGREES(a.azimuth));
        this._radZ = cc.DEGREES_TO_RADIANS(this._angleZ);
        this._radX = cc.DEGREES_TO_RADIANS(this._angleX)
    },
    clone: function () {
        var a = new cc.OrbitCamera;
        a.initWithDuration(this._duration,
            this._radius, this._deltaRadius, this._angleZ, this._deltaAngleZ, this._angleX, this._deltaAngleX);
        return a
    },
    update: function (a) {
        var b = (this._radius + this._deltaRadius * a) * cc.Camera.getZEye(),
            c = this._radZ + this._radDeltaZ * a,
            d = this._radX + this._radDeltaX * a;
        a = Math.sin(c) * Math.cos(d) * b + this._centerXOrig;
        d = Math.sin(c) * Math.sin(d) * b + this._centerYOrig;
        b = Math.cos(c) * b + this._centerZOrig;
        this.target.getCamera().setEye(a, d, b)
    }
});
cc.OrbitCamera.create = function (a, b, c, d, e, f, g) {
    var h = new cc.OrbitCamera;
    return h.initWithDuration(a, b, c, d, e, f, g) ? h : null
};
cc.ActionEase = cc.ActionInterval.extend({
    _inner: null,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._inner = null
    },
    initWithAction: function (a) {
        if (!a) throw "cc.ActionEase.initWithAction(): action must be non nil";
        return this.initWithDuration(a.getDuration()) ? (this._inner = a, !0) : !1
    },
    clone: function () {
        var a = new cc.ActionEase;
        a.initWithAction(this._inner.clone());
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._inner.startWithTarget(this.target)
    },
    stop: function () {
        this._inner.stop();
        cc.ActionInterval.prototype.stop.call(this)
    },
    update: function (a) {
        this._inner.update(a)
    },
    reverse: function () {
        return cc.ActionEase.create(this._inner.reverse())
    },
    getInnerAction: function () {
        return this._inner
    }
});
cc.ActionEase.create = function (a) {
    var b = new cc.ActionEase;
    b && b.initWithAction(a);
    return b
};
cc.EaseRateAction = cc.ActionEase.extend({
    _rate: 0,
    ctor: function () {
        cc.ActionEase.prototype.ctor.call(this);
        this._rate = 0
    },
    setRate: function (a) {
        this._rate = a
    },
    getRate: function () {
        return this._rate
    },
    initWithAction: function (a, b) {
        return cc.ActionEase.prototype.initWithAction.call(this, a) ? (this._rate = b, !0) : !1
    },
    clone: function () {
        var a = new cc.EaseRateAction;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    },
    reverse: function () {
        return cc.EaseRateAction.create(this._inner.reverse(), 1 / this._rate)
    }
});
cc.EaseRateAction.create = function (a, b) {
    var c = new cc.EaseRateAction;
    c && c.initWithAction(a, b);
    return c
};
cc.EaseIn = cc.EaseRateAction.extend({
    update: function (a) {
        this._inner.update(Math.pow(a, this._rate))
    },
    reverse: function () {
        return cc.EaseIn.create(this._inner.reverse(), 1 / this._rate)
    },
    clone: function () {
        var a = new cc.EaseIn;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    }
});
cc.EaseIn.create = function (a, b) {
    var c = new cc.EaseIn;
    c && c.initWithAction(a, b);
    return c
};
cc.EaseOut = cc.EaseRateAction.extend({
    update: function (a) {
        this._inner.update(Math.pow(a, 1 / this._rate))
    },
    reverse: function () {
        return cc.EaseOut.create(this._inner.reverse(), 1 / this._rate)
    },
    clone: function () {
        var a = new cc.EaseOut;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    }
});
cc.EaseOut.create = function (a, b) {
    var c = new cc.EaseOut;
    c && c.initWithAction(a, b);
    return c
};
cc.EaseInOut = cc.EaseRateAction.extend({
    update: function (a) {
        a *= 2;
        1 > a ? this._inner.update(0.5 * Math.pow(a, this._rate)) : this._inner.update(1 - 0.5 * Math.pow(2 - a, this._rate))
    },
    clone: function () {
        var a = new cc.EaseInOut;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    },
    reverse: function () {
        return cc.EaseInOut.create(this._inner.reverse(), this._rate)
    }
});
cc.EaseInOut.create = function (a, b) {
    var c = new cc.EaseInOut;
    c && c.initWithAction(a, b);
    return c
};
cc.EaseExponentialIn = cc.ActionEase.extend({
    update: function (a) {
        this._inner.update(0 === a ? 0 : Math.pow(2, 10 * (a - 1)))
    },
    reverse: function () {
        return cc.EaseExponentialOut.create(this._inner.reverse())
    },
    clone: function () {
        var a = new cc.EaseExponentialIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseExponentialIn.create = function (a) {
    var b = new cc.EaseExponentialIn;
    b && b.initWithAction(a);
    return b
};
cc.EaseExponentialOut = cc.ActionEase.extend({
    update: function (a) {
        this._inner.update(1 == a ? 1 : -Math.pow(2, -10 * a) + 1)
    },
    reverse: function () {
        return cc.EaseExponentialIn.create(this._inner.reverse())
    },
    clone: function () {
        var a = new cc.EaseExponentialOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseExponentialOut.create = function (a) {
    var b = new cc.EaseExponentialOut;
    b && b.initWithAction(a);
    return b
};
cc.EaseExponentialInOut = cc.ActionEase.extend({
    update: function (a) {
        1 != a && 0 !== a && (a *= 2, a = 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2));
        this._inner.update(a)
    },
    reverse: function () {
        return cc.EaseExponentialInOut.create(this._inner.reverse())
    },
    clone: function () {
        var a = new cc.EaseExponentialInOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseExponentialInOut.create = function (a) {
    var b = new cc.EaseExponentialInOut;
    b && b.initWithAction(a);
    return b
};
cc.EaseSineIn = cc.ActionEase.extend({
    update: function (a) {
        a = 0 === a || 1 == a ? a : -1 * Math.cos(a * Math.PI / 2) + 1;
        this._inner.update(a)
    },
    reverse: function () {
        return cc.EaseSineOut.create(this._inner.reverse())
    },
    clone: function () {
        var a = new cc.EaseSineIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseSineIn.create = function (a) {
    var b = new cc.EaseSineIn;
    b && b.initWithAction(a);
    return b
};
cc.EaseSineOut = cc.ActionEase.extend({
    update: function (a) {
        a = 0 === a || 1 == a ? a : Math.sin(a * Math.PI / 2);
        this._inner.update(a)
    },
    reverse: function () {
        return cc.EaseSineIn.create(this._inner.reverse())
    },
    clone: function () {
        var a = new cc.EaseSineOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseSineOut.create = function (a) {
    var b = new cc.EaseSineOut;
    b && b.initWithAction(a);
    return b
};
cc.EaseSineInOut = cc.ActionEase.extend({
    update: function (a) {
        a = 0 === a || 1 == a ? a : -0.5 * (Math.cos(Math.PI * a) - 1);
        this._inner.update(a)
    },
    clone: function () {
        var a = new cc.EaseSineInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function () {
        return cc.EaseSineInOut.create(this._inner.reverse())
    }
});
cc.EaseSineInOut.create = function (a) {
    var b = new cc.EaseSineInOut;
    b && b.initWithAction(a);
    return b
};
cc.EaseElastic = cc.ActionEase.extend({
    _period: null,
    ctor: function () {
        cc.ActionEase.prototype.ctor.call(this);
        this._period = 0.3
    },
    getPeriod: function () {
        return this._period
    },
    setPeriod: function (a) {
        this._period = a
    },
    initWithAction: function (a, b) {
        cc.ActionEase.prototype.initWithAction.call(this, a);
        this._period = null == b ? 0.3 : b;
        return !0
    },
    reverse: function () {
        cc.log("cc.EaseElastic.reverse(): it should be overridden in subclass.")
    },
    clone: function () {
        var a = new cc.EaseElastic;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElastic.create = function (a, b) {
    var c = new cc.EaseElastic;
    return c && c.initWithAction(a, b) ? c : null
};
cc.EaseElasticIn = cc.EaseElastic.extend({
    update: function (a) {
        var b = 0;
        0 === a || 1 === a ? b = a : (b = this._period / 4, a -= 1, b = -Math.pow(2, 10 * a) * Math.sin((a - b) * Math.PI * 2 / this._period));
        this._inner.update(b)
    },
    reverse: function () {
        return cc.EaseElasticOut.create(this._inner.reverse(), this._period)
    },
    clone: function () {
        var a = new cc.EaseElasticIn;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElasticIn.create = function (a, b) {
    var c = new cc.EaseElasticIn;
    return c && c.initWithAction(a, b) ? c : null
};
cc.EaseElasticOut = cc.EaseElastic.extend({
    update: function (a) {
        var b = 0;
        0 === a || 1 == a ? b = a : (b = this._period / 4, b = Math.pow(2, -10 * a) * Math.sin((a - b) * Math.PI * 2 / this._period) + 1);
        this._inner.update(b)
    },
    reverse: function () {
        return cc.EaseElasticIn.create(this._inner.reverse(), this._period)
    },
    clone: function () {
        var a = new cc.EaseElasticOut;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElasticOut.create = function (a, b) {
    var c = new cc.EaseElasticOut;
    c && c.initWithAction(a, b);
    return c
};
cc.EaseElasticInOut = cc.EaseElastic.extend({
    update: function (a) {
        var b = 0,
            b = this._period;
        if (0 === a || 1 == a) b = a;
        else {
            b || (b = this._period = 0.3 * 1.5);
            var c = b / 4;
            a = 2 * a - 1;
            b = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin((a - c) * Math.PI * 2 / b) : Math.pow(2, -10 * a) * Math.sin((a - c) * Math.PI * 2 / b) * 0.5 + 1
        }
        this._inner.update(b)
    },
    reverse: function () {
        return cc.EaseElasticInOut.create(this._inner.reverse(), this._period)
    },
    clone: function () {
        var a = new cc.EaseElasticInOut;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElasticInOut.create = function (a, b) {
    var c = new cc.EaseElasticInOut;
    c && c.initWithAction(a, b);
    return c
};
cc.EaseBounce = cc.ActionEase.extend({
    bounceTime: function (a) {
        if (a < 1 / 2.75) return 7.5625 * a * a;
        if (a < 2 / 2.75) return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
        if (a < 2.5 / 2.75) return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
        a -= 2.625 / 2.75;
        return 7.5625 * a * a + 0.984375
    },
    clone: function () {
        var a = new cc.EaseBounce;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function () {
        return cc.EaseBounce.create(this._inner.reverse())
    }
});
cc.EaseBounce.create = function (a) {
    var b = new cc.EaseBounce;
    b && b.initWithAction(a);
    return b
};
cc.EaseBounceIn = cc.EaseBounce.extend({
    update: function (a) {
        a = 1 - this.bounceTime(1 - a);
        this._inner.update(a)
    },
    reverse: function () {
        return cc.EaseBounceOut.create(this._inner.reverse())
    },
    clone: function () {
        var a = new cc.EaseBounceIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBounceIn.create = function (a) {
    var b = new cc.EaseBounceIn;
    b && b.initWithAction(a);
    return b
};
cc.EaseBounceOut = cc.EaseBounce.extend({
    update: function (a) {
        a = this.bounceTime(a);
        this._inner.update(a)
    },
    reverse: function () {
        return cc.EaseBounceIn.create(this._inner.reverse())
    },
    clone: function () {
        var a = new cc.EaseBounceOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBounceOut.create = function (a) {
    var b = new cc.EaseBounceOut;
    b && b.initWithAction(a);
    return b
};
cc.EaseBounceInOut = cc.EaseBounce.extend({
    update: function (a) {
        var b = 0,
            b = 0.5 > a ? 0.5 * (1 - this.bounceTime(1 - 2 * a)) : 0.5 * this.bounceTime(2 * a - 1) + 0.5;
        this._inner.update(b)
    },
    clone: function () {
        var a = new cc.EaseBounceInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function () {
        return cc.EaseBounceInOut.create(this._inner.reverse())
    }
});
cc.EaseBounceInOut.create = function (a) {
    var b = new cc.EaseBounceInOut;
    b && b.initWithAction(a);
    return b
};
cc.EaseBackIn = cc.ActionEase.extend({
    update: function (a) {
        this._inner.update(0 === a || 1 == a ? a : a * a * (2.70158 * a - 1.70158))
    },
    reverse: function () {
        return cc.EaseBackOut.create(this._inner.reverse())
    },
    clone: function () {
        var a = new cc.EaseBackIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBackIn.create = function (a) {
    var b = new cc.EaseBackIn;
    b && b.initWithAction(a);
    return b
};
cc.EaseBackOut = cc.ActionEase.extend({
    update: function (a) {
        a -= 1;
        this._inner.update(a * a * (2.70158 * a + 1.70158) + 1)
    },
    reverse: function () {
        return cc.EaseBackIn.create(this._inner.reverse())
    },
    clone: function () {
        var a = new cc.EaseBackOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBackOut.create = function (a) {
    var b = new cc.EaseBackOut;
    b && b.initWithAction(a);
    return b
};
cc.EaseBackInOut = cc.ActionEase.extend({
    update: function (a) {
        a *= 2;
        1 > a ? this._inner.update(a * a * (3.5949095 * a - 2.5949095) / 2) : (a -= 2, this._inner.update(a * a * (3.5949095 * a + 2.5949095) / 2 + 1))
    },
    clone: function () {
        var a = new cc.EaseBackInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function () {
        return cc.EaseBackInOut.create(this._inner.reverse())
    }
});
cc.EaseBackInOut.create = function (a) {
    var b = new cc.EaseBackInOut;
    b && b.initWithAction(a);
    return b
};
cc.CardinalSplineAt = function (a, b, c, d, e, f) {
    var g = f * f,
        h = g * f,
        k = (1 - e) / 2;
    e = k * (-h + 2 * g - f);
    var m = k * (-h + g) + (2 * h - 3 * g + 1);
    f = k * (h - 2 * g + f) + (-2 * h + 3 * g);
    g = k * (h - g);
    return cc.p(a.x * e + b.x * m + c.x * f + d.x * g, a.y * e + b.y * m + c.y * f + d.y * g)
};
cc.reverseControlPoints = function (a) {
    for (var b = [], c = a.length - 1; 0 <= c; c--) b.push(cc.p(a[c].x, a[c].y));
    return b
};
cc.copyControlPoints = function (a) {
    for (var b = [], c = 0; c < a.length; c++) b.push(cc.p(a[c].x, a[c].y));
    return b
};
cc.getControlPointAt = function (a, b) {
    var c = Math.min(a.length - 1, Math.max(b, 0));
    return a[c]
};
cc.reverseControlPointsInline = function (a) {
    for (var b = a.length, c = 0 | b / 2, d = 0; d < c; ++d) {
        var e = a[d];
        a[d] = a[b - d - 1];
        a[b - d - 1] = e
    }
};
cc.CardinalSplineTo = cc.ActionInterval.extend({
    _points: null,
    _deltaT: 0,
    _tension: 0,
    _previousPosition: null,
    _accumulatedDiff: null,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._points = [];
        this._tension = this._deltaT = 0;
        this._accumulatedDiff = this._previousPosition = null
    },
    initWithDuration: function (a, b, c) {
        if (!b || 0 == b.length) throw "Invalid configuration. It must at least have one control point";
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.setPoints(b), this._tension =
            c, !0) : !1
    },
    clone: function () {
        var a = new cc.CardinalSplineTo;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._deltaT = 1 / (this._points.length - 1);
        this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY());
        this._accumulatedDiff = cc.p(0, 0)
    },
    update: function (a) {
        var b, c = this._points;
        if (1 == a) b = c.length - 1, a = 1;
        else {
            var d = this._deltaT;
            b = 0 | a / d;
            a = (a - d * b) / d
        }
        b =
            cc.CardinalSplineAt(cc.getControlPointAt(c, b - 1), cc.getControlPointAt(c, b - 0), cc.getControlPointAt(c, b + 1), cc.getControlPointAt(c, b + 2), this._tension, a);
        cc.ENABLE_STACKABLE_ACTIONS && (c = this.target.getPositionX() - this._previousPosition.x, a = this.target.getPositionY() - this._previousPosition.y, 0 != c || 0 != a) && (d = this._accumulatedDiff, c = d.x + c, a = d.y + a, d.x = c, d.y = a, b.x += c, b.y += a);
        this.updatePosition(b)
    },
    reverse: function () {
        var a = cc.reverseControlPoints(this._points);
        return cc.CardinalSplineTo.create(this._duration,
            a, this._tension)
    },
    updatePosition: function (a) {
        this.target.setPosition(a);
        this._previousPosition = a
    },
    getPoints: function () {
        return this._points
    },
    setPoints: function (a) {
        this._points = a
    }
});
cc.CardinalSplineTo.create = function (a, b, c) {
    var d = new cc.CardinalSplineTo;
    return d.initWithDuration(a, b, c) ? d : null
};
cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
    _startPosition: null,
    ctor: function () {
        cc.CardinalSplineTo.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0)
    },
    startWithTarget: function (a) {
        cc.CardinalSplineTo.prototype.startWithTarget.call(this, a);
        this._startPosition.x = a.getPositionX();
        this._startPosition.y = a.getPositionY()
    },
    reverse: function () {
        for (var a = this._points.slice(), b, c = a[0], d = 1; d < a.length; ++d) b = a[d], a[d] = cc.pSub(b, c), c = b;
        a = cc.reverseControlPoints(a);
        c = a[a.length - 1];
        a.pop();
        c.x = -c.x;
        c.y = -c.y;
        a.unshift(c);
        for (d = 1; d < a.length; ++d) b = a[d], b.x = -b.x, b.y = -b.y, b.x += c.x, b.y += c.y, c = a[d] = b;
        return cc.CardinalSplineBy.create(this._duration, a, this._tension)
    },
    updatePosition: function (a) {
        var b = this._startPosition,
            c = a.x + b.x;
        a = a.y + b.y;
        this._previousPosition.x = c;
        this._previousPosition.y = a;
        this.target.setPosition(c, a)
    },
    clone: function () {
        var a = new cc.CardinalSplineBy;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
        return a
    }
});
cc.CardinalSplineBy.create = function (a, b, c) {
    var d = new cc.CardinalSplineBy;
    return d.initWithDuration(a, b, c) ? d : null
};
cc.CatmullRomTo = cc.CardinalSplineTo.extend({
    initWithDuration: function (a, b) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, b, 0.5)
    },
    clone: function () {
        var a = new cc.CatmullRomTo;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points));
        return a
    }
});
cc.CatmullRomTo.create = function (a, b) {
    var c = new cc.CatmullRomTo;
    return c.initWithDuration(a, b) ? c : null
};
cc.CatmullRomBy = cc.CardinalSplineBy.extend({
    initWithDuration: function (a, b) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, b, 0.5)
    },
    clone: function () {
        var a = new cc.CatmullRomBy;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points));
        return a
    }
});
cc.CatmullRomBy.create = function (a, b) {
    var c = new cc.CatmullRomBy;
    return c.initWithDuration(a, b) ? c : null
};
cc.ActionTweenDelegate = cc.Class.extend({
    updateTweenAction: function (a, b) {}
});
cc.ActionTween = cc.ActionInterval.extend({
    key: "",
    from: 0,
    to: 0,
    delta: 0,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this.key = "";
        this.delta = this.to = this.from = 0
    },
    initWithDuration: function (a, b, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.key = b, this.to = d, this.from = c, !0) : !1
    },
    startWithTarget: function (a) {
        if (!a || !a.updateTweenAction) throw "cc.ActionTween.startWithTarget(): target must be non-null, and target must implement updateTweenAction function";
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this.delta = this.to - this.from
    },
    update: function (a) {
        this.target.updateTweenAction(this.to - this.delta * (1 - a), this.key)
    },
    reverse: function () {
        return cc.ActionTween.create(this.duration, this.key, this.to, this.from)
    },
    clone: function () {
        var a = new cc.ActionTween;
        a.initWithDuration(this._duration, this.key, this.from, this.to);
        return a
    }
});
cc.ActionTween.create = function (a, b, c, d) {
    var e = new cc.ActionTween;
    return e.initWithDuration(a, b, c, d) ? e : null
};
cc.GridAction = cc.ActionInterval.extend({
    _gridSize: null,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._gridSize = cc.size(0, 0)
    },
    clone: function () {
        var a = new cc.GridAction,
            b = this._gridSize;
        a.initWithDuration(this._duration, cc.size(b.width, b.height));
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = this.getGrid(),
            c = this.target;
        (a = c.grid) && 0 < a.getReuseGrid() ? (b = a.getGridSize(), a.isActive() && b.width == this._gridSize.width && b.height == this._gridSize.height &&
            a.reuse()) : (a && a.isActive() && a.setActive(!1), c.grid = b, c.grid.setActive(!0))
    },
    reverse: function () {
        return cc.ReverseTime.create(this)
    },
    initWithDuration: function (a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._gridSize.width = b.width, this._gridSize.height = b.height, !0) : !1
    },
    getGrid: function () {
        cc.log("cc.GridAction.getGrid(): it should be overridden in subclass.")
    }
});
cc.GridAction.create = function (a, b) {
    var c = new cc.GridAction;
    c.initWithDuration(a, b);
    return c
};
cc.Grid3DAction = cc.GridAction.extend({
    getGrid: function () {
        return cc.Grid3D.create(this._gridSize)
    },
    vertex: function (a) {
        return this.target.grid.vertex(a)
    },
    originalVertex: function (a) {
        return this.target.grid.originalVertex(a)
    },
    setVertex: function (a, b) {
        this.target.grid.setVertex(a, b)
    }
});
cc.Grid3DAction.create = function (a, b) {
    var c = new cc.Grid3DAction;
    c.initWithDuration(a, b);
    return c
};
cc.TiledGrid3DAction = cc.GridAction.extend({
    tile: function (a) {
        return this.target.grid.tile(a)
    },
    originalTile: function (a) {
        return this.target.grid.originalTile(a)
    },
    setTile: function (a, b) {
        this.target.grid.setTile(a, b)
    },
    getGrid: function () {
        return cc.TiledGrid3D.create(this._gridSize)
    }
});
cc.TiledGrid3DAction.create = function (a, b) {
    var c = new cc.TiledGrid3DAction;
    c.initWithDuration(a, b);
    return c
};
cc.StopGrid = cc.ActionInstant.extend({
    startWithTarget: function (a) {
        cc.ActionInstant.prototype.startWithTarget.call(this, a);
        (a = this.target.grid) && a.isActive() && a.setActive(!1)
    }
});
cc.StopGrid.create = function () {
    return new cc.StopGrid
};
cc.ReuseGrid = cc.ActionInstant.extend({
    _times: null,
    initWithTimes: function (a) {
        this._times = a;
        return !0
    },
    startWithTarget: function (a) {
        cc.ActionInstant.prototype.startWithTarget.call(this, a);
        this.target.grid && this.target.grid.isActive() && this.target.grid.setReuseGrid(this.target.grid.getReuseGrid() + this._times)
    }
});
cc.ReuseGrid.create = function (a) {
    return new cc.ReuseGrid
};
cc.rand = function () {
    return 16777215 * Math.random()
};
cc.Waves3D = cc.Grid3DAction.extend({
    _waves: null,
    _amplitude: null,
    _amplitudeRate: null,
    ctor: function () {
        cc.GridAction.prototype.ctor.call(this);
        this._amplitudeRate = this._amplitude = this._waves = 0
    },
    getAmplitude: function () {
        return this._amplitude
    },
    setAmplitude: function (a) {
        this._amplitude = a
    },
    getAmplitudeRate: function () {
        return this._amplitudeRate
    },
    setAmplitudeRate: function (a) {
        this._amplitudeRate = a
    },
    initWithDuration: function (a, b, c, d) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves =
            c, this._amplitude = d, this._amplitudeRate = 1, !0) : !1
    },
    update: function (a) {
        for (var b = this._gridSize, c = this._amplitude, d = cc.p(0, 0), e = this._amplitudeRate, f = this._waves, g = 0; g < b.width + 1; ++g)
            for (var h = 0; h < b.height + 1; ++h) {
                d.x = g;
                d.y = h;
                var k = this.originalVertex(d);
                k.z += Math.sin(Math.PI * a * f * 2 + 0.01 * (k.y + k.x)) * c * e;
                this.setVertex(d, k)
            }
    }
});
cc.Waves3D.create = function (a, b, c, d) {
    var e = new cc.Waves3D;
    e.initWithDuration(a, b, c, d);
    return e
};
cc.FlipX3D = cc.Grid3DAction.extend({
    initWithDuration: function (a) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, cc.size(1, 1))
    },
    initWithSize: function (a, b) {
        return 1 != a.width || 1 != a.height ? (cc.log("Grid size must be (1,1)"), !1) : cc.Grid3DAction.prototype.initWithDuration.call(this, b, a)
    },
    update: function (a) {
        var b = Math.PI * a;
        a = Math.sin(b);
        var c = Math.cos(b / 2),
            b = new cc.Vertex3F,
            d = cc.p(0, 0);
        d.x = d.y = 1;
        var e = this.originalVertex(d);
        d.x = d.y = 0;
        var d = this.originalVertex(d),
            f = e.x,
            g = d.x,
            h, k;
        f > g ? (e = cc.p(0,
            0), d = cc.p(0, 1), h = cc.p(1, 0), k = cc.p(1, 1)) : (h = cc.p(0, 0), k = cc.p(0, 1), e = cc.p(1, 0), d = cc.p(1, 1), f = g);
        b.x = f - f * c;
        b.z = Math.abs(parseFloat(f * a / 4));
        a = this.originalVertex(e);
        a.x = b.x;
        a.z += b.z;
        this.setVertex(e, a);
        a = this.originalVertex(d);
        a.x = b.x;
        a.z += b.z;
        this.setVertex(d, a);
        a = this.originalVertex(h);
        a.x -= b.x;
        a.z -= b.z;
        this.setVertex(h, a);
        a = this.originalVertex(k);
        a.x -= b.x;
        a.z -= b.z;
        this.setVertex(k, a)
    }
});
cc.FlipX3D.create = function (a) {
    var b = new cc.FlipX3D;
    b.initWithDuration(a);
    return b
};
cc.FlipY3D = cc.FlipX3D.extend({
    update: function (a) {
        var b = Math.PI * a;
        a = Math.sin(b);
        var c = Math.cos(b / 2),
            b = new cc.Vertex3F,
            d = cc.p(0, 0);
        d.x = d.y = 1;
        var e = this.originalVertex(d);
        d.x = d.y = 0;
        var d = this.originalVertex(d),
            f = e.y,
            g = d.y,
            h, k;
        f > g ? (e = cc.p(0, 0), d = cc.p(0, 1), h = cc.p(1, 0), k = cc.p(1, 1)) : (d = cc.p(0, 0), e = cc.p(0, 1), k = cc.p(1, 0), h = cc.p(1, 1), f = g);
        b.y = f - f * c;
        b.z = Math.abs(parseFloat(f * a) / 4);
        a = this.originalVertex(e);
        a.y = b.y;
        a.z += b.z;
        this.setVertex(e, a);
        a = this.originalVertex(d);
        a.y -= b.y;
        a.z -= b.z;
        this.setVertex(d, a);
        a = this.originalVertex(h);
        a.y = b.y;
        a.z += b.z;
        this.setVertex(h, a);
        a = this.originalVertex(k);
        a.y -= b.y;
        a.z -= b.z;
        this.setVertex(k, a)
    }
});
cc.FlipY3D.create = function (a) {
    var b = new cc.FlipY3D;
    b.initWithDuration(a);
    return b
};
cc.Lens3D = cc.Grid3DAction.extend({
    _position: null,
    _radius: 0,
    _lensEffect: 0,
    _concave: !1,
    _dirty: !1,
    ctor: function () {
        cc.GridAction.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        this._lensEffect = this._radius = 0;
        this._dirty = this._concave = !1
    },
    getLensEffect: function () {
        return this._lensEffect
    },
    setLensEffect: function (a) {
        this._lensEffect = a
    },
    setConcave: function (a) {
        this._concave = a
    },
    getPosition: function () {
        return this._position
    },
    setPosition: function (a) {
        cc.pointEqualToPoint(a, this._position) || (this._position.x =
            a.x, this._position.y = a.y, this._dirty = !0)
    },
    initWithDuration: function (a, b, c, d) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this.setPosition(c), this._radius = d, this._lensEffect = 0.7, this._dirty = !0) : !1
    },
    update: function (a) {
        if (this._dirty) {
            a = this._gridSize.width;
            for (var b = this._gridSize.height, c = this._radius, d = this._lensEffect, e = cc.p(0, 0), f = cc.p(0, 0), g, h, k, m = 0; m < a + 1; ++m)
                for (var n = 0; n < b + 1; ++n) e.x = m, e.y = n, g = this.originalVertex(e), f.x = this._position.x - g.x, f.y = this._position.y - g.y, h = cc.pLength(f),
                    h < c && (h = c - h, h /= c, 0 == h && (h = 0.001), h = Math.log(h) * d, k = Math.exp(h) * c, h = cc.pLength(f), 0 < h && (f.x /= h, f.y /= h, f.x *= k, f.y *= k, g.z += cc.pLength(f) * d)), this.setVertex(e, g);
            this._dirty = !1
        }
    }
});
cc.Lens3D.create = function (a, b, c, d) {
    var e = new cc.Lens3D;
    e.initWithDuration(a, b, c, d);
    return e
};
cc.Ripple3D = cc.Grid3DAction.extend({
    _position: null,
    _radius: null,
    _waves: null,
    _amplitude: null,
    _amplitudeRate: null,
    ctor: function () {
        cc.GridAction.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        this._amplitudeRate = this._amplitude = this._waves = this._radius = 0
    },
    getPosition: function () {
        return this._position
    },
    setPosition: function (a) {
        this._position.x = a.x;
        this._position.y = a.y
    },
    getAmplitude: function () {
        return this._amplitude
    },
    setAmplitude: function (a) {
        this._amplitude = a
    },
    getAmplitudeRate: function () {
        return this._amplitudeRate
    },
    setAmplitudeRate: function (a) {
        this._amplitudeRate = a
    },
    initWithDuration: function (a, b, c, d, e, f) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this.setPosition(c), this._radius = d, this._waves = e, this._amplitude = f, this._amplitudeRate = 1, !0) : !1
    },
    update: function (a) {
        for (var b = this._gridSize.width, c = this._gridSize.height, d = cc.p(0, 0), e = this._radius, f = this._waves, g = this._amplitude, h = this._amplitudeRate, k, m, n = cc.p(0, 0), p = 0; p < b + 1; ++p)
            for (var r = 0; r < c + 1; ++r) {
                d.x = p;
                d.y = r;
                k = this.originalVertex(d);
                n.x =
                    this._position.x - k.x;
                n.y = this._position.y - k.y;
                m = cc.pLength(n);
                if (m < e) {
                    m = e - m;
                    var q = Math.pow(m / e, 2);
                    k.z += Math.sin(a * Math.PI * f * 2 + 0.1 * m) * g * h * q
                }
                this.setVertex(d, k)
            }
    }
});
cc.Ripple3D.create = function (a, b, c, d, e, f) {
    var g = new cc.Ripple3D;
    g.initWithDuration(a, b, c, d, e, f);
    return g
};
cc.Shaky3D = cc.Grid3DAction.extend({
    _randRange: null,
    _shakeZ: null,
    ctor: function () {
        cc.GridAction.prototype.ctor.call(this);
        this._randRange = 0;
        this._shakeZ = !1
    },
    initWithDuration: function (a, b, c, d) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._randRange = c, this._shakeZ = d, !0) : !1
    },
    update: function (a) {
        a = this._gridSize.width;
        for (var b = this._gridSize.height, c = this._randRange, d = this._shakeZ, e = cc.p(0, 0), f, g = 0; g < a + 1; ++g)
            for (var h = 0; h < b + 1; ++h) e.x = g, e.y = h, f = this.originalVertex(e), f.x += cc.rand() %
                (2 * c) - c, f.y += cc.rand() % (2 * c) - c, d && (f.z += cc.rand() % (2 * c) - c), this.setVertex(e, f)
    }
});
cc.Shaky3D.create = function (a, b, c, d) {
    var e = new cc.Shaky3D;
    e.initWithDuration(a, b, c, d);
    return e
};
cc.Liquid = cc.Grid3DAction.extend({
    _waves: null,
    _amplitude: null,
    _amplitudeRate: null,
    ctor: function () {
        cc.GridAction.prototype.ctor.call(this);
        this._amplitudeRate = this._amplitude = this._waves = 0
    },
    getAmplitude: function () {
        return this._amplitude
    },
    setAmplitude: function (a) {
        this._amplitude = a
    },
    getAmplitudeRate: function () {
        return this._amplitudeRate
    },
    setAmplitudeRate: function (a) {
        this._amplitudeRate = a
    },
    initWithDuration: function (a, b, c, d) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves =
            c, this._amplitude = d, this._amplitudeRate = 1, !0) : !1
    },
    update: function (a) {
        for (var b = this._gridSize.width, c = this._gridSize.height, d = cc.p(0, 0), e = this._waves, f = this._amplitude, g = this._amplitudeRate, h, k = 1; k < b; ++k)
            for (var m = 1; m < c; ++m) d.x = k, d.y = m, h = this.originalVertex(d), h.x += Math.sin(a * Math.PI * e * 2 + 0.01 * h.x) * f * g, h.y += Math.sin(a * Math.PI * e * 2 + 0.01 * h.y) * f * g, this.setVertex(d, h)
    }
});
cc.Liquid.create = function (a, b, c, d) {
    var e = new cc.Liquid;
    e.initWithDuration(a, b, c, d);
    return e
};
cc.Waves = cc.Grid3DAction.extend({
    _waves: null,
    _amplitude: null,
    _amplitudeRate: null,
    _vertical: null,
    _horizontal: null,
    ctor: function () {
        cc.GridAction.prototype.ctor.call(this);
        this._amplitudeRate = this._amplitude = this._waves = 0;
        this._horizontal = this._vertical = !1
    },
    getAmplitude: function () {
        return this._amplitude
    },
    setAmplitude: function (a) {
        this._amplitude = a
    },
    getAmplitudeRate: function () {
        return this._amplitudeRate
    },
    setAmplitudeRate: function (a) {
        this._amplitudeRate = a
    },
    initWithDuration: function (a, b, c, d, e, f) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this,
            a, b) ? (this._waves = c, this._amplitude = d, this._amplitudeRate = 1, this._horizontal = e, this._vertical = f, !0) : !1
    },
    update: function (a) {
        for (var b = this._gridSize.width, c = this._gridSize.height, d = cc.p(0, 0), e = this._vertical, f = this._horizontal, g = this._waves, h = this._amplitude, k = this._amplitudeRate, m, n = 0; n < b + 1; ++n)
            for (var p = 0; p < c + 1; ++p) d.x = n, d.y = p, m = this.originalVertex(d), e && (m.x += Math.sin(a * Math.PI * g * 2 + 0.01 * m.y) * h * k), f && (m.y += Math.sin(a * Math.PI * g * 2 + 0.01 * m.x) * h * k), this.setVertex(d, m)
    }
});
cc.Waves.create = function (a, b, c, d, e, f) {
    var g = new cc.Waves;
    g.initWithDuration(a, b, c, d, e, f);
    return g
};
cc.Twirl = cc.Grid3DAction.extend({
    _position: null,
    _twirls: null,
    _amplitude: null,
    _amplitudeRate: null,
    ctor: function () {
        cc.GridAction.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        this._amplitudeRate = this._amplitude = this._twirls = 0
    },
    getPosition: function () {
        return this._position
    },
    setPosition: function (a) {
        this._position.x = a.x;
        this._position.y = a.y
    },
    getAmplitude: function () {
        return this._amplitude
    },
    setAmplitude: function (a) {
        this._amplitude = a
    },
    getAmplitudeRate: function () {
        return this._amplitudeRate
    },
    setAmplitudeRate: function (a) {
        this._amplitudeRate =
            a
    },
    initWithDuration: function (a, b, c, d, e) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this.setPosition(c), this._twirls = d, this._amplitude = e, this._amplitudeRate = 1, !0) : !1
    },
    update: function (a) {
        for (var b = this._position, c = this._gridSize.width, d = this._gridSize.height, e = cc.p(0, 0), f = 0.1 * this._amplitude * this._amplitudeRate, g = this._twirls, h, k, m, n = cc.p(0, 0), p = 0; p < c + 1; ++p)
            for (var r = 0; r < d + 1; ++r) e.x = p, e.y = r, h = this.originalVertex(e), n.x = p - c / 2, n.y = r - d / 2, k = cc.pLength(n) * Math.cos(Math.PI / 2 + a * Math.PI *
                g * 2) * f, m = Math.sin(k) * (h.y - b.y) + Math.cos(k) * (h.x - b.x), k = Math.cos(k) * (h.y - b.y) - Math.sin(k) * (h.x - b.x), h.x = b.x + m, h.y = b.y + k, this.setVertex(e, h)
    }
});
cc.Twirl.create = function (a, b, c, d, e) {
    var f = new cc.Twirl;
    f.initWithDuration(a, b, c, d, e);
    return f
};
cc.ShakyTiles3D = cc.TiledGrid3DAction.extend({
    _randRange: 0,
    _shakeZ: !1,
    ctor: function () {
        cc.GridAction.prototype.ctor.call(this);
        this._randRange = 0;
        this._shakeZ = !1
    },
    initWithDuration: function (a, b, c, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._randRange = c, this._shakeZ = d, !0) : !1
    },
    update: function (a) {
        a = this._gridSize;
        for (var b = this._randRange, c = cc.p(0, 0), d = 0; d < a.width; ++d)
            for (var e = 0; e < a.height; ++e) {
                c.x = d;
                c.y = e;
                var f = this.originalTile(c);
                f.bl.x += cc.rand() % (2 * b) - b;
                f.br.x += cc.rand() %
                    (2 * b) - b;
                f.tl.x += cc.rand() % (2 * b) - b;
                f.tr.x += cc.rand() % (2 * b) - b;
                f.bl.y += cc.rand() % (2 * b) - b;
                f.br.y += cc.rand() % (2 * b) - b;
                f.tl.y += cc.rand() % (2 * b) - b;
                f.tr.y += cc.rand() % (2 * b) - b;
                this._shakeZ && (f.bl.z += cc.rand() % (2 * b) - b, f.br.z += cc.rand() % (2 * b) - b, f.tl.z += cc.rand() % (2 * b) - b, f.tr.z += cc.rand() % (2 * b) - b);
                this.setTile(c, f)
            }
    }
});
cc.ShakyTiles3D.create = function (a, b, c, d) {
    var e = new cc.ShakyTiles3D;
    e.initWithDuration(a, b, c, d);
    return e
};
cc.ShatteredTiles3D = cc.TiledGrid3DAction.extend({
    _randRange: 0,
    _once: !1,
    _shatterZ: !1,
    ctor: function () {
        cc.GridAction.prototype.ctor.call(this);
        this._randRange = 0;
        this._once = this._shakeZ = !1
    },
    initWithDuration: function (a, b, c, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._once = !1, this._randRange = c, this._shatterZ = d, !0) : !1
    },
    update: function (a) {
        if (!1 === this._once) {
            a = this._gridSize;
            for (var b = this._randRange, c, d = cc.p(0, 0), e = 0; e < a.width; ++e)
                for (var f = 0; f < a.height; ++f) d.x = e, d.y = f,
                    c = this.originalTile(d), c.bl.x += cc.rand() % (2 * b) - b, c.br.x += cc.rand() % (2 * b) - b, c.tl.x += cc.rand() % (2 * b) - b, c.tr.x += cc.rand() % (2 * b) - b, c.bl.y += cc.rand() % (2 * b) - b, c.br.y += cc.rand() % (2 * b) - b, c.tl.y += cc.rand() % (2 * b) - b, c.tr.y += cc.rand() % (2 * b) - b, this._shatterZ && (c.bl.z += cc.rand() % (2 * b) - b, c.br.z += cc.rand() % (2 * b) - b, c.tl.z += cc.rand() % (2 * b) - b, c.tr.z += cc.rand() % (2 * b) - b), this.setTile(d, c);
            this._once = !0
        }
    }
});
cc.ShatteredTiles3D.create = function (a, b, c, d) {
    var e = new cc.ShatteredTiles3D;
    e.initWithDuration(a, b, c, d);
    return e
};
cc.Tile = function (a, b, c) {
    this.position = a || cc.p(0, 0);
    this.startPosition = b || cc.p(0, 0);
    this.delta = c || cc.p(0, 0)
};
cc.ShuffleTiles = cc.TiledGrid3DAction.extend({
    _seed: 0,
    _tilesCount: 0,
    _tilesOrder: null,
    _tiles: null,
    ctor: function () {
        cc.GridAction.prototype.ctor.call(this);
        this._tilesOrder = [];
        this._tiles = [];
        this._tilesCount = this._seed = 0
    },
    initWithDuration: function (a, b, c) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._seed = c, this._tilesOrder.length = 0, this._tiles.length = 0, !0) : !1
    },
    shuffle: function (a, b) {
        for (var c = b - 1; 0 <= c; c--) {
            var d = 0 | cc.rand() % (c + 1),
                e = a[c];
            a[c] = a[d];
            a[d] = e
        }
    },
    getDelta: function (a) {
        var b =
            this._gridSize,
            c = a.width * b.height + a.height;
        return cc.size(this._tilesOrder[c] / b.height - a.width, this._tilesOrder[c] % b.height - a.height)
    },
    placeTile: function (a, b) {
        var c = this.originalTile(a),
            d = this.target.grid.getStep(),
            e = b.position;
        c.bl.x += e.x * d.x;
        c.bl.y += e.y * d.y;
        c.br.x += e.x * d.x;
        c.br.y += e.y * d.y;
        c.tl.x += e.x * d.x;
        c.tl.y += e.y * d.y;
        c.tr.x += e.x * d.x;
        c.tr.y += e.y * d.y;
        this.setTile(a, c)
    },
    startWithTarget: function (a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
        a = this._gridSize;
        this._tilesCount = a.width *
            a.height;
        for (var b = this._tilesOrder, c = b.length = 0; c < this._tilesCount; ++c) b[c] = c;
        this.shuffle(b, this._tilesCount);
        for (var b = this._tiles, c = b.length = 0, d = cc.size(0, 0), e = 0; e < a.width; ++e)
            for (var f = 0; f < a.height; ++f) b[c] = new cc.Tile, b[c].position = cc.p(e, f), b[c].startPosition = cc.p(e, f), d.width = e, d.height = f, b[c].delta = this.getDelta(d), ++c
    },
    update: function (a) {
        for (var b = 0, c = this._gridSize, d = this._tiles, e, f = cc.p(0, 0), g = 0; g < c.width; ++g)
            for (var h = 0; h < c.height; ++h) f.x = g, f.y = h, e = d[b], e.position.x = e.delta.width * a, e.position.y =
                e.delta.height * a, this.placeTile(f, e), ++b
    }
});
cc.ShuffleTiles.create = function (a, b, c) {
    var d = new cc.ShuffleTiles;
    d.initWithDuration(a, b, c);
    return d
};
cc.FadeOutTRTiles = cc.TiledGrid3DAction.extend({
    testFunc: function (a, b) {
        var c = this._gridSize.width * b,
            d = this._gridSize.height * b;
        return 0 == c + d ? 1 : Math.pow((a.width + a.height) / (c + d), 6)
    },
    turnOnTile: function (a) {
        this.setTile(a, this.originalTile(a))
    },
    turnOffTile: function (a) {
        this.setTile(a, new cc.Quad3)
    },
    transformTile: function (a, b) {
        var c = this.originalTile(a),
            d = this.target.grid.getStep();
        c.bl.x += d.x / 2 * (1 - b);
        c.bl.y += d.y / 2 * (1 - b);
        c.br.x -= d.x / 2 * (1 - b);
        c.br.y += d.y / 2 * (1 - b);
        c.tl.x += d.x / 2 * (1 - b);
        c.tl.y -= d.y / 2 * (1 - b);
        c.tr.x -=
            d.x / 2 * (1 - b);
        c.tr.y -= d.y / 2 * (1 - b);
        this.setTile(a, c)
    },
    update: function (a) {
        for (var b = this._gridSize, c = cc.p(0, 0), d = cc.size(0, 0), e, f = 0; f < b.width; ++f)
            for (var g = 0; g < b.height; ++g) c.x = f, c.y = g, d.width = f, d.height = g, e = this.testFunc(d, a), 0 == e ? this.turnOffTile(c) : 1 > e ? this.transformTile(c, e) : this.turnOnTile(c)
    }
});
cc.FadeOutTRTiles.create = function (a, b) {
    var c = new cc.FadeOutTRTiles;
    c.initWithDuration(a, b);
    return c
};
cc.FadeOutBLTiles = cc.FadeOutTRTiles.extend({
    testFunc: function (a, b) {
        return 0 == a.width + a.height ? 1 : Math.pow((this._gridSize.width * (1 - b) + this._gridSize.height * (1 - b)) / (a.width + a.height), 6)
    }
});
cc.FadeOutBLTiles.create = function (a, b) {
    var c = new cc.FadeOutBLTiles;
    c.initWithDuration(a, b);
    return c
};
cc.FadeOutUpTiles = cc.FadeOutTRTiles.extend({
    testFunc: function (a, b) {
        var c = this._gridSize.height * b;
        return 0 == c ? 1 : Math.pow(a.height / c, 6)
    },
    transformTile: function (a, b) {
        var c = this.originalTile(a),
            d = this.target.grid.getStep();
        c.bl.y += d.y / 2 * (1 - b);
        c.br.y += d.y / 2 * (1 - b);
        c.tl.y -= d.y / 2 * (1 - b);
        c.tr.y -= d.y / 2 * (1 - b);
        this.setTile(a, c)
    }
});
cc.FadeOutUpTiles.create = function (a, b) {
    var c = new cc.FadeOutUpTiles;
    c.initWithDuration(a, b);
    return c
};
cc.FadeOutDownTiles = cc.FadeOutUpTiles.extend({
    testFunc: function (a, b) {
        return 0 == a.height ? 1 : Math.pow(this._gridSize.height * (1 - b) / a.height, 6)
    }
});
cc.FadeOutDownTiles.create = function (a, b) {
    var c = new cc.FadeOutDownTiles;
    c.initWithDuration(a, b);
    return c
};
cc.TurnOffTiles = cc.TiledGrid3DAction.extend({
    _seed: null,
    _tilesCount: 0,
    _tilesOrder: null,
    ctor: function () {
        cc.GridAction.prototype.ctor.call(this);
        this._tilesOrder = [];
        this._seed = null;
        this._tilesCount = 0
    },
    initWithDuration: function (a, b, c) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._seed = c, this._tilesOrder.length = 0, !0) : !1
    },
    shuffle: function (a, b) {
        for (var c = b - 1; 0 <= c; c--) {
            var d = 0 | cc.rand() % (c + 1),
                e = a[c];
            a[c] = a[d];
            a[d] = e
        }
    },
    turnOnTile: function (a) {
        this.setTile(a, this.originalTile(a))
    },
    turnOffTile: function (a) {
        this.setTile(a, new cc.Quad3)
    },
    startWithTarget: function (a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
        this._tilesCount = this._gridSize.width * this._gridSize.height;
        a = this._tilesOrder;
        for (var b = a.length = 0; b < this._tilesCount; ++b) a[b] = b;
        this.shuffle(a, this._tilesCount)
    },
    update: function (a) {
        a = 0 | a * this._tilesCount;
        for (var b = this._gridSize, c, d = cc.p(0, 0), e = this._tilesOrder, f = 0; f < this._tilesCount; f++) c = e[f], d.x = 0 | c / b.height, d.y = c % (0 | b.height), f < a ? this.turnOffTile(d) : this.turnOnTile(d)
    }
});
cc.TurnOffTiles.create = function (a, b, c) {
    c = c || 0;
    var d = new cc.TurnOffTiles;
    d.initWithDuration(a, b, c);
    return d
};
cc.WavesTiles3D = cc.TiledGrid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function () {
        cc.GridAction.prototype.ctor.call(this);
        this._amplitudeRate = this._amplitude = this._waves = 0
    },
    getAmplitude: function () {
        return this._amplitude
    },
    setAmplitude: function (a) {
        this._amplitude = a
    },
    getAmplitudeRate: function () {
        return this._amplitudeRate
    },
    setAmplitudeRate: function (a) {
        this._amplitudeRate = a
    },
    initWithDuration: function (a, b, c, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves =
            c, this._amplitude = d, this._amplitudeRate = 1, !0) : !1
    },
    update: function (a) {
        for (var b = this._gridSize, c = this._waves, d = this._amplitude, e = this._amplitudeRate, f = cc.p(0, 0), g, h = 0; h < b.width; h++)
            for (var k = 0; k < b.height; k++) f.x = h, f.y = k, g = this.originalTile(f), g.bl.z = Math.sin(a * Math.PI * c * 2 + 0.01 * (g.bl.y + g.bl.x)) * d * e, g.br.z = g.bl.z, g.tl.z = g.bl.z, g.tr.z = g.bl.z, this.setTile(f, g)
    }
});
cc.WavesTiles3D.create = function (a, b, c, d) {
    var e = new cc.WavesTiles3D;
    e.initWithDuration(a, b, c, d);
    return e
};
cc.JumpTiles3D = cc.TiledGrid3DAction.extend({
    _jumps: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function () {
        cc.GridAction.prototype.ctor.call(this);
        this._amplitudeRate = this._amplitude = this._jumps = 0
    },
    getAmplitude: function () {
        return this._amplitude
    },
    setAmplitude: function (a) {
        this._amplitude = a
    },
    getAmplitudeRate: function () {
        return this._amplitudeRate
    },
    setAmplitudeRate: function (a) {
        this._amplitudeRate = a
    },
    initWithDuration: function (a, b, c, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._jumps =
            c, this._amplitude = d, this._amplitudeRate = 1, !0) : !1
    },
    update: function (a) {
        var b = Math.sin(Math.PI * a * this._jumps * 2) * this._amplitude * this._amplitudeRate;
        a = Math.sin(Math.PI * (a * this._jumps * 2 + 1)) * this._amplitude * this._amplitudeRate;
        for (var c = this._gridSize, d = this.target.grid, e, f = cc.p(0, 0), g = 0; g < c.width; g++)
            for (var h = 0; h < c.height; h++) f.x = g, f.y = h, e = d.originalTile(f), 0 == (g + h) % 2 ? (e.bl.z += b, e.br.z += b, e.tl.z += b, e.tr.z += b) : (e.bl.z += a, e.br.z += a, e.tl.z += a, e.tr.z += a), d.setTile(f, e)
    }
});
cc.JumpTiles3D.create = function (a, b, c, d) {
    var e = new cc.JumpTiles3D;
    e.initWithDuration(a, b, c, d);
    return e
};
cc.SplitRows = cc.TiledGrid3DAction.extend({
    _rows: 0,
    _winSize: null,
    ctor: function () {
        cc.GridAction.prototype.ctor.call(this);
        this._rows = 0;
        this._winSize = null
    },
    initWithDuration: function (a, b) {
        this._rows = b;
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, cc.size(1, b))
    },
    update: function (a) {
        for (var b = this._gridSize, c = this._winSize.width, d, e, f = cc.p(0, 0), g = 0; g < b.height; ++g) f.y = g, d = this.originalTile(f), e = 1, 0 == g % 2 && (e = -1), d.bl.x += e * c * a, d.br.x += e * c * a, d.tl.x += e * c * a, d.tr.x += e * c * a, this.setTile(f, d)
    },
    startWithTarget: function (a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
        this._winSize = cc.director.getWinSizeInPixels()
    }
});
cc.SplitRows.create = function (a, b) {
    var c = new cc.SplitRows;
    c.initWithDuration(a, b);
    return c
};
cc.SplitCols = cc.TiledGrid3DAction.extend({
    _cols: 0,
    _winSize: null,
    ctor: function () {
        cc.GridAction.prototype.ctor.call(this);
        this._cols = 0;
        this._winSize = null
    },
    initWithDuration: function (a, b) {
        this._cols = b;
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, cc.size(b, 1))
    },
    update: function (a) {
        for (var b = this._gridSize.width, c = this._winSize.height, d, e, f = cc.p(0, 0), g = 0; g < b; ++g) f.x = g, d = this.originalTile(f), e = 1, 0 == g % 2 && (e = -1), d.bl.y += e * c * a, d.br.y += e * c * a, d.tl.y += e * c * a, d.tr.y += e * c * a, this.setTile(f, d)
    },
    startWithTarget: function (a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
        this._winSize = cc.director.getWinSizeInPixels()
    }
});
cc.SplitCols.create = function (a, b) {
    var c = new cc.SplitCols;
    c.initWithDuration(a, b);
    return c
};
cc.PageTurn3D = cc.Grid3DAction.extend({
    update: function (a) {
        var b = Math.max(0, a - 0.25),
            b = -100 - b * b * 500;
        a = -Math.PI / 2 * Math.sqrt(a);
        var c = +Math.PI / 2 + a;
        a = Math.sin(c);
        for (var c = Math.cos(c), d = this._gridSize, e = cc.p(0, 0), f = 0; f <= d.width; ++f)
            for (var g = 0; g <= d.height; ++g) {
                e.x = f;
                e.y = g;
                var h = this.originalVertex(e),
                    k = Math.sqrt(h.x * h.x + (h.y - b) * (h.y - b)),
                    m = k * a,
                    n = Math.asin(h.x / k) / a,
                    p = Math.cos(n);
                h.x = n <= Math.PI ? m * Math.sin(n) : 0;
                h.y = k + b - m * (1 - p) * a;
                h.z = m * (1 - p) * c / 7;
                0.5 > h.z && (h.z = 0.5);
                this.setVertex(e, h)
            }
    }
});
cc.PageTurn3D.create = function (a, b) {
    var c = new cc.PageTurn3D;
    c.initWithDuration(a, b);
    return c
};
cc.PROGRESS_TIMER_TYPE_RADIAL = 0;
cc.PROGRESS_TIMER_TYPE_BAR = 1;
cc.PROGRESS_TEXTURE_COORDS_COUNT = 4;
cc.PROGRESS_TEXTURE_COORDS = 75;
cc.ProgressTimer = cc.NodeRGBA.extend({
    _type: null,
    _percentage: 0,
    _sprite: null,
    _midPoint: null,
    _barChangeRate: null,
    _reverseDirection: !1,
    _className: "ProgressTimer",
    getMidpoint: function () {
        return cc.p(this._midPoint.x, this._midPoint.y)
    },
    setMidpoint: function (a) {
        this._midPoint = cc.pClamp(a, cc.p(0, 0), cc.p(1, 1))
    },
    getBarChangeRate: function () {
        return cc.p(this._barChangeRate.x, this._barChangeRate.y)
    },
    setBarChangeRate: function (a) {
        this._barChangeRate = cc.pClamp(a, cc.p(0, 0), cc.p(1, 1))
    },
    getType: function () {
        return this._type
    },
    getPercentage: function () {
        return this._percentage
    },
    getSprite: function () {
        return this._sprite
    },
    setPercentage: function (a) {
        this._percentage != a && (this._percentage = cc.clampf(a, 0, 100), this._updateProgress())
    },
    setOpacityModifyRGB: function (a) {},
    isOpacityModifyRGB: function () {
        return !1
    },
    isReverseDirection: function () {
        return this._reverseDirection
    },
    _boundaryTexCoord: function (a) {
        if (a < cc.PROGRESS_TEXTURE_COORDS_COUNT) {
            var b = cc.PROGRESS_TEXTURE_COORDS;
            return this._reverseDirection ? cc.p(b >> 7 - (a << 1) & 1, b >> 7 - ((a << 1) + 1) &
                1) : cc.p(b >> (a << 1) + 1 & 1, b >> (a << 1) & 1)
        }
        return cc.p(0, 0)
    },
    _origin: null,
    _startAngle: 270,
    _endAngle: 270,
    _radius: 0,
    _counterClockWise: !1,
    _barRect: null,
    _vertexDataCount: 0,
    _vertexData: null,
    _vertexArrayBuffer: null,
    _vertexWebGLBuffer: null,
    _vertexDataDirty: !1,
    ctor: null,
    _ctorForCanvas: function () {
        cc.NodeRGBA.prototype.ctor.call(this);
        this._type = cc.PROGRESS_TIMER_TYPE_RADIAL;
        this._percentage = 0;
        this._midPoint = cc.p(0, 0);
        this._barChangeRate = cc.p(0, 0);
        this._reverseDirection = !1;
        this._sprite = null;
        this._origin = cc.p(0, 0);
        this._endAngle = this._startAngle = 270;
        this._radius = 0;
        this._counterClockWise = !1;
        this._barRect = cc.rect(0, 0, 0, 0)
    },
    _ctorForWebGL: function () {
        cc.NodeRGBA.prototype.ctor.call(this);
        this._type = cc.PROGRESS_TIMER_TYPE_RADIAL;
        this._percentage = 0;
        this._midPoint = cc.p(0, 0);
        this._barChangeRate = cc.p(0, 0);
        this._reverseDirection = !1;
        this._sprite = null;
        this._vertexWebGLBuffer = cc._renderContext.createBuffer();
        this._vertexDataCount = 0;
        this._vertexArrayBuffer = this._vertexData = null;
        this._vertexDataDirty = !1
    },
    setColor: function (a) {
        this._sprite.color =
            a;
        this._updateColor()
    },
    setOpacity: function (a) {
        this._sprite.opacity = a;
        this._updateColor()
    },
    getColor: function () {
        return this._sprite.color
    },
    getOpacity: function () {
        return this._sprite.opacity
    },
    setReverseProgress: null,
    _setReverseProgressForCanvas: function (a) {
        this._reverseDirection !== a && (this._reverseDirection = a)
    },
    _setReverseProgressForWebGL: function (a) {
        this._reverseDirection !== a && (this._reverseDirection = a, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0)
    },
    setSprite: null,
    _setSpriteForCanvas: function (a) {
        this._sprite !=
            a && (this._sprite = a, this.width = this._sprite.width, this.height = this._sprite.height)
    },
    _setSpriteForWebGL: function (a) {
        a && this._sprite != a && (this._sprite = a, this.width = a.width, this.height = a.height, this._vertexData && (this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0))
    },
    setType: null,
    _setTypeForCanvas: function (a) {
        a !== this._type && (this._type = a)
    },
    _setTypeForWebGL: function (a) {
        a !== this._type && (this._vertexData && (this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0), this._type =
            a)
    },
    setReverseDirection: null,
    _setReverseDirectionForCanvas: function (a) {
        this._reverseDirection !== a && (this._reverseDirection = a)
    },
    _setReverseDirectionForWebGL: function (a) {
        this._reverseDirection !== a && (this._reverseDirection = a, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0)
    },
    _textureCoordFromAlphaPoint: function (a) {
        var b = this._sprite;
        if (!b) return {
            u: 0,
            v: 0
        };
        var c = b.quad,
            d = cc.p(c.bl.texCoords.u, c.bl.texCoords.v),
            c = cc.p(c.tr.texCoords.u, c.tr.texCoords.v);
        b.textureRectRotated && (b = a.x,
            a.x = a.y, a.y = b);
        return {
            u: d.x * (1 - a.x) + c.x * a.x,
            v: d.y * (1 - a.y) + c.y * a.y
        }
    },
    _vertexFromAlphaPoint: function (a) {
        if (!this._sprite) return {
            x: 0,
            y: 0
        };
        var b = this._sprite.quad,
            c = cc.p(b.bl.vertices.x, b.bl.vertices.y),
            b = cc.p(b.tr.vertices.x, b.tr.vertices.y);
        return {
            x: c.x * (1 - a.x) + b.x * a.x,
            y: c.y * (1 - a.y) + b.y * a.y
        }
    },
    initWithSprite: null,
    _initWithSpriteForCanvas: function (a) {
        this.percentage = 0;
        this.anchorY = this.anchorX = 0.5;
        this._type = cc.PROGRESS_TIMER_TYPE_RADIAL;
        this._reverseDirection = !1;
        this.midPoint = cc.p(0.5, 0.5);
        this.barChangeRate =
            cc.p(1, 1);
        this.sprite = a;
        return !0
    },
    _initWithSpriteForWebGL: function (a) {
        this.percentage = 0;
        this._vertexArrayBuffer = this._vertexData = null;
        this._vertexDataCount = 0;
        this.anchorY = this.anchorX = 0.5;
        this._type = cc.PROGRESS_TIMER_TYPE_RADIAL;
        this._reverseDirection = !1;
        this.midPoint = cc.p(0.5, 0.5);
        this.barChangeRate = cc.p(1, 1);
        this.sprite = a;
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        return !0
    },
    draw: null,
    _drawForCanvas: function (a) {
        a = a || cc._renderContext;
        var b = this._sprite;
        b._isLighterMode &&
            (a.globalCompositeOperation = "lighter");
        var c = cc.view.getScaleX(),
            d = cc.view.getScaleY();
        a.globalAlpha = b._displayedOpacity / 255;
        var e = b._rect,
            f = b._contentSize,
            g = b._offsetPosition,
            h = b._drawSize_Canvas,
            k = 0 | g.x,
            m = -g.y - e.height,
            n = b._textureRect_Canvas;
        h.width = e.width * c;
        h.height = e.height * d;
        a.save();
        b._flippedX && (k = -g.x - e.width, a.scale(-1, 1));
        b._flippedY && (m = g.y, a.scale(1, -1));
        k *= c;
        m *= d;
        this._type == cc.PROGRESS_TIMER_TYPE_BAR ? (e = this._barRect, a.beginPath(), a.rect(e.x * c, e.y * d, e.width * c, e.height * d), a.clip(),
            a.closePath()) : this._type == cc.PROGRESS_TIMER_TYPE_RADIAL && (e = this._origin.x * c, g = this._origin.y * d, a.beginPath(), a.arc(e, g, this._radius * d, Math.PI / 180 * this._startAngle, Math.PI / 180 * this._endAngle, this._counterClockWise), a.lineTo(e, g), a.clip(), a.closePath());
        b._texture && n.validRect ? (c = b._texture.getHtmlElementObj(), this._colorized ? a.drawImage(c, 0, 0, n.width, n.height, k, m, h.width, h.height) : a.drawImage(c, n.x, n.y, n.width, n.height, k, m, h.width, h.height)) : 0 !== f.width && (h = this.color, a.fillStyle = "rgba(" + h.r + "," +
            h.g + "," + h.b + ",1)", a.fillRect(k, m, f.width * c, f.height * d));
        a.restore();
        cc.INCREMENT_GL_DRAWS(1)
    },
    _drawForWebGL: function (a) {
        a = a || cc._renderContext;
        if (this._vertexData && this._sprite) {
            cc.NODE_DRAW_SETUP(this);
            var b = this._sprite.getBlendFunc();
            cc.glBlendFunc(b.src, b.dst);
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
            cc.glBindTexture2D(this._sprite.texture);
            a.bindBuffer(a.ARRAY_BUFFER, this._vertexWebGLBuffer);
            this._vertexDataDirty && (a.bufferData(a.ARRAY_BUFFER, this._vertexArrayBuffer, a.DYNAMIC_DRAW),
                this._vertexDataDirty = !1);
            b = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, b, 0);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, b, 8);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, b, 12);
            this._type === cc.PROGRESS_TIMER_TYPE_RADIAL ? a.drawArrays(a.TRIANGLE_FAN, 0, this._vertexDataCount) : this._type == cc.PROGRESS_TIMER_TYPE_BAR && (this._reverseDirection ? (a.drawArrays(a.TRIANGLE_STRIP, 0, this._vertexDataCount / 2), a.drawArrays(a.TRIANGLE_STRIP,
                4, this._vertexDataCount / 2), cc.g_NumberOfDraws++) : a.drawArrays(a.TRIANGLE_STRIP, 0, this._vertexDataCount));
            cc.g_NumberOfDraws++
        }
    },
    _updateRadial: function () {
        if (this._sprite) {
            var a, b = this._midPoint;
            a = this._percentage / 100;
            var c = 2 * cc.PI * (this._reverseDirection ? a : 1 - a),
                d = cc.p(b.x, 1),
                e = cc.pRotateByAngle(d, b, c),
                c = 0;
            if (0 == a) e = d, c = 0;
            else if (1 == a) e = d, c = 4;
            else {
                var f = cc.FLT_MAX,
                    g = cc.PROGRESS_TEXTURE_COORDS_COUNT;
                for (a = 0; a <= g; ++a) {
                    var h = (a + (g - 1)) % g,
                        k = this._boundaryTexCoord(a % g),
                        h = this._boundaryTexCoord(h);
                    0 == a ? h =
                        cc.pLerp(k, h, 1 - b.x) : 4 == a && (k = cc.pLerp(k, h, 1 - b.x));
                    var m = cc.p(0, 0);
                    cc.pLineIntersect(k, h, b, e, m) && (0 != a && 4 != a || 0 <= m.x && 1 >= m.x) && 0 <= m.y && m.y < f && (f = m.y, c = a)
                }
                e = cc.pAdd(b, cc.pMult(cc.pSub(e, b), f))
            }
            f = !0;
            this._vertexDataCount != c + 3 && (f = !1, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0);
            if (!this._vertexData) {
                g = this._vertexDataCount = c + 3;
                k = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                this._vertexArrayBuffer = new ArrayBuffer(g * k);
                h = [];
                for (a = 0; a < g; a++) h[a] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer,
                    a * k);
                this._vertexData = h;
                if (!this._vertexData) {
                    cc.log("cc.ProgressTimer._updateRadial() : Not enough memory");
                    return
                }
            }
            this._updateColor();
            g = this._vertexData;
            if (!f)
                for (g[0].texCoords = this._textureCoordFromAlphaPoint(b), g[0].vertices = this._vertexFromAlphaPoint(b), g[1].texCoords = this._textureCoordFromAlphaPoint(d), g[1].vertices = this._vertexFromAlphaPoint(d), a = 0; a < c; a++) b = this._boundaryTexCoord(a), g[a + 2].texCoords = this._textureCoordFromAlphaPoint(b), g[a + 2].vertices = this._vertexFromAlphaPoint(b);
            g[this._vertexDataCount -
                1].texCoords = this._textureCoordFromAlphaPoint(e);
            g[this._vertexDataCount - 1].vertices = this._vertexFromAlphaPoint(e)
        }
    },
    _updateBar: function () {
        if (this._sprite) {
            var a, b = this._percentage / 100,
                c = this._barChangeRate,
                c = cc.pMult(cc.p(1 - c.x + b * c.x, 1 - c.y + b * c.y), 0.5),
                b = cc.pSub(this._midPoint, c),
                c = cc.pAdd(this._midPoint, c);
            0 > b.x && (c.x += -b.x, b.x = 0);
            1 < c.x && (b.x -= c.x - 1, c.x = 1);
            0 > b.y && (c.y += -b.y, b.y = 0);
            1 < c.y && (b.y -= c.y - 1, c.y = 1);
            if (this._reverseDirection) {
                if (!this._vertexData) {
                    this._vertexDataCount = 8;
                    var d = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                    this._vertexArrayBuffer = new ArrayBuffer(8 * d);
                    var e = [];
                    for (a = 0; 8 > a; a++) e[a] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, a * d);
                    e[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 1));
                    e[0].vertices = this._vertexFromAlphaPoint(cc.p(0, 1));
                    e[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 0));
                    e[1].vertices = this._vertexFromAlphaPoint(cc.p(0, 0));
                    e[6].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 1));
                    e[6].vertices = this._vertexFromAlphaPoint(cc.p(1, 1));
                    e[7].texCoords = this._textureCoordFromAlphaPoint(cc.p(1,
                        0));
                    e[7].vertices = this._vertexFromAlphaPoint(cc.p(1, 0));
                    this._vertexData = e
                }
                a = this._vertexData;
                a[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(b.x, c.y));
                a[2].vertices = this._vertexFromAlphaPoint(cc.p(b.x, c.y));
                a[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(b.x, b.y));
                a[3].vertices = this._vertexFromAlphaPoint(cc.p(b.x, b.y));
                a[4].texCoords = this._textureCoordFromAlphaPoint(cc.p(c.x, c.y));
                a[4].vertices = this._vertexFromAlphaPoint(cc.p(c.x, c.y));
                a[5].texCoords = this._textureCoordFromAlphaPoint(cc.p(c.x,
                    b.y));
                a[5].vertices = this._vertexFromAlphaPoint(cc.p(c.x, b.y))
            } else {
                if (!this._vertexData)
                    for (this._vertexDataCount = 4, d = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT, this._vertexArrayBuffer = new ArrayBuffer(4 * d), this._vertexData = [], a = 0; 4 > a; a++) this._vertexData[a] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, a * d);
                a = this._vertexData;
                a[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(b.x, c.y));
                a[0].vertices = this._vertexFromAlphaPoint(cc.p(b.x, c.y));
                a[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(b.x,
                    b.y));
                a[1].vertices = this._vertexFromAlphaPoint(cc.p(b.x, b.y));
                a[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(c.x, c.y));
                a[2].vertices = this._vertexFromAlphaPoint(cc.p(c.x, c.y));
                a[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(c.x, b.y));
                a[3].vertices = this._vertexFromAlphaPoint(cc.p(c.x, b.y))
            }
            this._updateColor()
        }
    },
    _updateColor: function () {
        if (this._sprite && this._vertexData) {
            for (var a = this._sprite.quad.tl.colors, b = this._vertexData, c = 0, d = this._vertexDataCount; c < d; ++c) b[c].colors = a;
            this._vertexDataDirty = !0
        }
    },
    _updateProgress: null,
    _updateProgressForCanvas: function () {
        var a = this._sprite,
            b = a.width,
            c = a.height,
            d = this._midPoint;
        if (this._type == cc.PROGRESS_TIMER_TYPE_RADIAL) {
            this._radius = Math.round(Math.sqrt(b * b + c * c));
            var e, f = !1,
                g = this._origin;
            g.x = b * d.x;
            g.y = -c * d.y;
            this._reverseDirection ? (e = 270, d = 270 - 3.6 * this._percentage) : (d = -90, e = -90 + 3.6 * this._percentage);
            a._flippedX && (g.x -= 2 * b * this._midPoint.x, d = -d - 180, e = -e - 180, f = !f);
            a._flippedY && (g.y += 2 * c * this._midPoint.y, f = !f, d = -d, e = -e);
            this._startAngle = d;
            this._endAngle =
                e;
            this._counterClockWise = f
        } else {
            e = this._barChangeRate;
            g = this._percentage / 100;
            f = this._barRect;
            e = cc.size(b * (1 - e.x), c * (1 - e.y));
            var g = cc.size((b - e.width) * g, (c - e.height) * g),
                g = cc.size(e.width + g.width, e.height + g.height),
                h = cc.p(b * d.x, c * d.y);
            e = h.x - g.width / 2;
            0.5 < d.x && g.width / 2 >= b - h.x && (e = b - g.width);
            b = h.y - g.height / 2;
            0.5 < d.y && g.height / 2 >= c - h.y && (b = c - g.height);
            f.x = 0;
            c = 1;
            a._flippedX && (f.x -= g.width, c = -1);
            0 < e && (f.x += e * c);
            f.y = 0;
            c = 1;
            a._flippedY && (f.y += g.height, c = -1);
            0 < b && (f.y -= b * c);
            f.width = g.width;
            f.height = -g.height
        }
    },
    _updateProgressForWebGL: function () {
        var a = this._type;
        a === cc.PROGRESS_TIMER_TYPE_RADIAL ? this._updateRadial() : a === cc.PROGRESS_TIMER_TYPE_BAR && this._updateBar();
        this._vertexDataDirty = !0
    }
});
window._p = cc.ProgressTimer.prototype;
cc._renderType == cc._RENDER_TYPE_WEBGL ? (_p.ctor = _p._ctorForWebGL, _p.setReverseProgress = _p._setReverseProgressForWebGL, _p.setSprite = _p._setSpriteForWebGL, _p.setType = _p._setTypeForWebGL, _p.setReverseDirection = _p._setReverseDirectionForWebGL, _p.initWithSprite = _p._initWithSpriteForWebGL, _p.draw = _p._drawForWebGL, _p._updateProgress = _p._updateProgressForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.setReverseProgress = _p._setReverseProgressForCanvas, _p.setSprite = _p._setSpriteForCanvas, _p.setType = _p._setTypeForCanvas,
    _p.setReverseDirection = _p._setReverseDirectionForCanvas, _p.initWithSprite = _p._initWithSpriteForCanvas, _p.draw = _p._drawForCanvas, _p._updateProgress = cc.ProgressTimer.prototype._updateProgressForCanvas);
cc.defineGetterSetter(_p, "midPoint", _p.getMidpoint, _p.setMidpoint);
cc.defineGetterSetter(_p, "barChangeRate", _p.getBarChangeRate, _p.setBarChangeRate);
cc.defineGetterSetter(_p, "type", _p.getType, _p.setType);
cc.defineGetterSetter(_p, "percentage", _p.getPercentage, _p.setPercentage);
cc.defineGetterSetter(_p, "sprite", _p.getSprite, _p.setSprite);
cc.defineGetterSetter(_p, "reverseDir", _p.isReverseDirection, _p.setReverseDirection);
delete window._p;
cc.ProgressTimer.create = function (a) {
    var b = new cc.ProgressTimer;
    return b.initWithSprite(a) ? b : null
};
cc.ProgressTo = cc.ActionInterval.extend({
    _to: 0,
    _from: 0,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._from = this._to = 0
    },
    initWithDuration: function (a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = b, !0) : !1
    },
    clone: function () {
        var a = new cc.ProgressTo;
        a.initWithDuration(this._duration, this._to);
        return a
    },
    reverse: function () {
        cc.log("cc.ProgressTo.reverse(): reverse hasn't been supported.");
        return null
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._from = a.percentage;
        100 == this._from && (this._from = 0)
    },
    update: function (a) {
        this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * a)
    }
});
cc.ProgressTo.create = function (a, b) {
    var c = new cc.ProgressTo;
    c.initWithDuration(a, b);
    return c
};
cc.ProgressFromTo = cc.ActionInterval.extend({
    _to: 0,
    _from: 0,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._from = this._to = 0
    },
    initWithDuration: function (a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = c, this._from = b, !0) : !1
    },
    clone: function () {
        var a = new cc.ProgressFromTo;
        a.initWithDuration(this._duration, this._from, this._to);
        return a
    },
    reverse: function () {
        return cc.ProgressFromTo.create(this._duration, this._to, this._from)
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a)
    },
    update: function (a) {
        this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * a)
    }
});
cc.ProgressFromTo.create = function (a, b, c) {
    var d = new cc.ProgressFromTo;
    d.initWithDuration(a, b, c);
    return d
};
cc.SCENE_FADE = 4208917214;
cc.TransitionEaseScene = cc.Class.extend({
    easeActionWithAction: function () {}
});
cc.TRANSITION_ORIENTATION_LEFT_OVER = 0;
cc.TRANSITION_ORIENTATION_RIGHT_OVER = 1;
cc.TRANSITION_ORIENTATION_UP_OVER = 0;
cc.TRANSITION_ORIENTATION_DOWN_OVER = 1;
cc.TransitionScene = cc.Scene.extend({
    _inScene: null,
    _outScene: null,
    _duration: null,
    _isInSceneOnTop: !1,
    _isSendCleanupToScene: !1,
    _className: "TransitionScene",
    _setNewScene: function (a) {
        this.unschedule(this._setNewScene);
        a = cc.director;
        this._isSendCleanupToScene = a.isSendCleanupToScene();
        a.runScene(this._inScene);
        cc.eventManager.setEnabled(!0);
        this._outScene.visible = !0
    },
    _sceneOrder: function () {
        this._isInSceneOnTop = !0
    },
    draw: function () {
        this._isInSceneOnTop ? (this._outScene.visit(), this._inScene.visit()) : (this._inScene.visit(),
            this._outScene.visit())
    },
    onEnter: function () {
        cc.Node.prototype.onEnter.call(this);
        cc.eventManager.setEnabled(!1);
        this._outScene.onExitTransitionDidStart();
        this._inScene.onEnter()
    },
    onExit: function () {
        cc.Node.prototype.onExit.call(this);
        cc.eventManager.setEnabled(!0);
        this._outScene.onExit();
        this._inScene.onEnterTransitionDidFinish()
    },
    cleanup: function () {
        cc.Node.prototype.cleanup.call(this);
        this._isSendCleanupToScene && this._outScene.cleanup()
    },
    initWithDuration: function (a, b) {
        if (!b) throw "cc.TransitionScene.initWithDuration(): Argument scene must be non-nil";
        if (this.init()) {
            this._duration = a;
            this.attr({
                x: 0,
                y: 0,
                anchorX: 0,
                anchorY: 0
            });
            this._inScene = b;
            this._outScene = cc.director.getRunningScene();
            this._outScene || (this._outScene = cc.Scene.create(), this._outScene.init());
            if (this._inScene == this._outScene) throw "cc.TransitionScene.initWithDuration(): Incoming scene must be different from the outgoing scene";
            this._sceneOrder();
            return !0
        }
        return !1
    },
    finish: function () {
        this._inScene.attr({
            visible: !0,
            x: 0,
            y: 0,
            scale: 1,
            rotation: 0
        });
        cc._renderType === cc._RENDER_TYPE_WEBGL && this._inScene.getCamera().restore();
        this._outScene.attr({
            visible: !1,
            x: 0,
            y: 0,
            scale: 1,
            rotation: 0
        });
        cc._renderType === cc._RENDER_TYPE_WEBGL && this._outScene.getCamera().restore();
        this.schedule(this._setNewScene, 0)
    },
    hideOutShowIn: function () {
        this._inScene.visible = !0;
        this._outScene.visible = !1
    }
});
cc.TransitionScene.create = function (a, b) {
    var c = new cc.TransitionScene;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionSceneOriented = cc.TransitionScene.extend({
    _orientation: 0,
    initWithDuration: function (a, b, c) {
        cc.TransitionScene.prototype.initWithDuration.call(this, a, b) && (this._orientation = c);
        return !0
    }
});
cc.TransitionSceneOriented.create = function (a, b, c) {
    var d = new cc.TransitionSceneOriented;
    d.initWithDuration(a, b, c);
    return d
};
cc.TransitionRotoZoom = cc.TransitionScene.extend({
    onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._inScene.attr({
            scale: 0.001,
            anchorX: 0.5,
            anchorY: 0.5
        });
        this._outScene.attr({
            scale: 1,
            anchorX: 0.5,
            anchorY: 0.5
        });
        var a = cc.Sequence.create(cc.Spawn.create(cc.ScaleBy.create(this._duration / 2, 0.001), cc.RotateBy.create(this._duration / 2, 720)), cc.DelayTime.create(this._duration / 2));
        this._outScene.runAction(a);
        this._inScene.runAction(cc.Sequence.create(a.reverse(), cc.CallFunc.create(this.finish,
            this)))
    }
});
cc.TransitionRotoZoom.create = function (a, b) {
    var c = new cc.TransitionRotoZoom;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionJumpZoom = cc.TransitionScene.extend({
    onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.director.getWinSize();
        this._inScene.attr({
            scale: 0.5,
            x: a.width,
            y: 0,
            anchorX: 0.5,
            anchorY: 0.5
        });
        this._outScene.anchorX = 0.5;
        this._outScene.anchorY = 0.5;
        var b = cc.JumpBy.create(this._duration / 4, cc.p(-a.width, 0), a.width / 4, 2),
            c = cc.ScaleTo.create(this._duration / 4, 1),
            a = cc.ScaleTo.create(this._duration / 4, 0.5),
            a = cc.Sequence.create(a, b),
            b = cc.Sequence.create(b, c),
            c = cc.DelayTime.create(this._duration /
                2);
        this._outScene.runAction(a);
        this._inScene.runAction(cc.Sequence.create(c, b, cc.CallFunc.create(this.finish, this)))
    }
});
cc.TransitionJumpZoom.create = function (a, b) {
    var c = new cc.TransitionJumpZoom;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionMoveInL = cc.TransitionScene.extend({
    onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        this.initScenes();
        var a = this.action();
        this._inScene.runAction(cc.Sequence.create(this.easeActionWithAction(a), cc.CallFunc.create(this.finish, this)))
    },
    initScenes: function () {
        this._inScene.setPosition(-cc.director.getWinSize().width, 0)
    },
    action: function () {
        return cc.MoveTo.create(this._duration, cc.p(0, 0))
    },
    easeActionWithAction: function (a) {
        return cc.EaseOut.create(a, 2)
    }
});
cc.TransitionMoveInL.create = function (a, b) {
    var c = new cc.TransitionMoveInL;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionMoveInR = cc.TransitionMoveInL.extend({
    initScenes: function () {
        this._inScene.setPosition(cc.director.getWinSize().width, 0)
    }
});
cc.TransitionMoveInR.create = function (a, b) {
    var c = new cc.TransitionMoveInR;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionMoveInT = cc.TransitionMoveInL.extend({
    initScenes: function () {
        this._inScene.setPosition(0, cc.director.getWinSize().height)
    }
});
cc.TransitionMoveInT.create = function (a, b) {
    var c = new cc.TransitionMoveInT;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionMoveInB = cc.TransitionMoveInL.extend({
    initScenes: function () {
        this._inScene.setPosition(0, -cc.director.getWinSize().height)
    }
});
cc.TransitionMoveInB.create = function (a, b) {
    var c = new cc.TransitionMoveInB;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.ADJUST_FACTOR = 0.5;
cc.TransitionSlideInL = cc.TransitionScene.extend({
    _sceneOrder: function () {
        this._isInSceneOnTop = !1
    },
    onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        this.initScenes();
        var a = this.action(),
            b = this.action(),
            a = this.easeActionWithAction(a),
            b = cc.Sequence.create(this.easeActionWithAction(b), cc.CallFunc.create(this.finish, this));
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    },
    initScenes: function () {
        this._inScene.setPosition(-cc.director.getWinSize().width + cc.ADJUST_FACTOR, 0)
    },
    action: function () {
        return cc.MoveBy.create(this._duration,
            cc.p(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0))
    },
    easeActionWithAction: function (a) {
        return cc.EaseOut.create(a, 2)
    }
});
cc.TransitionSlideInL.create = function (a, b) {
    var c = new cc.TransitionSlideInL;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionSlideInR = cc.TransitionSlideInL.extend({
    _sceneOrder: function () {
        this._isInSceneOnTop = !0
    },
    initScenes: function () {
        this._inScene.setPosition(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0)
    },
    action: function () {
        return cc.MoveBy.create(this._duration, cc.p(-(cc.director.getWinSize().width - cc.ADJUST_FACTOR), 0))
    }
});
cc.TransitionSlideInR.create = function (a, b) {
    var c = new cc.TransitionSlideInR;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionSlideInB = cc.TransitionSlideInL.extend({
    _sceneOrder: function () {
        this._isInSceneOnTop = !1
    },
    initScenes: function () {
        this._inScene.setPosition(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR)
    },
    action: function () {
        return cc.MoveBy.create(this._duration, cc.p(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR)))
    }
});
cc.TransitionSlideInB.create = function (a, b) {
    var c = new cc.TransitionSlideInB;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionSlideInT = cc.TransitionSlideInL.extend({
    _sceneOrder: function () {
        this._isInSceneOnTop = !0
    },
    initScenes: function () {
        this._inScene.setPosition(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR))
    },
    action: function () {
        return cc.MoveBy.create(this._duration, cc.p(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR))
    }
});
cc.TransitionSlideInT.create = function (a, b) {
    var c = new cc.TransitionSlideInT;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionShrinkGrow = cc.TransitionScene.extend({
    onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._inScene.attr({
            scale: 0.001,
            anchorX: 2 / 3,
            anchorY: 0.5
        });
        this._outScene.attr({
            scale: 1,
            anchorX: 1 / 3,
            anchorY: 0.5
        });
        var a = cc.ScaleTo.create(this._duration, 0.01),
            b = cc.ScaleTo.create(this._duration, 1);
        this._inScene.runAction(this.easeActionWithAction(b));
        this._outScene.runAction(cc.Sequence.create(this.easeActionWithAction(a), cc.CallFunc.create(this.finish, this)))
    },
    easeActionWithAction: function (a) {
        return cc.EaseOut.create(a,
            2)
    }
});
cc.TransitionShrinkGrow.create = function (a, b) {
    var c = new cc.TransitionShrinkGrow;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionFlipX = cc.TransitionSceneOriented.extend({
    onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
        a = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Show.create(), cc.OrbitCamera.create(this._duration / 2, 1, 0, c, a, 0, 0), cc.CallFunc.create(this.finish, this));
        b = cc.Sequence.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, 0, b, 0, 0), cc.Hide.create(),
            cc.DelayTime.create(this._duration / 2));
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionFlipX.create = function (a, b, c) {
    null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
    var d = new cc.TransitionFlipX;
    d.initWithDuration(a, b, c);
    return d
};
cc.TransitionFlipY = cc.TransitionSceneOriented.extend({
    onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation == cc.TRANSITION_ORIENTATION_UP_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
        a = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Show.create(), cc.OrbitCamera.create(this._duration / 2, 1, 0, c, a, 90, 0), cc.CallFunc.create(this.finish, this));
        b = cc.Sequence.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, 0, b, 90, 0), cc.Hide.create(),
            cc.DelayTime.create(this._duration / 2));
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionFlipY.create = function (a, b, c) {
    null == c && (c = cc.TRANSITION_ORIENTATION_UP_OVER);
    var d = new cc.TransitionFlipY;
    d.initWithDuration(a, b, c);
    return d
};
cc.TransitionFlipAngular = cc.TransitionSceneOriented.extend({
    onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
        a = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Show.create(), cc.OrbitCamera.create(this._duration / 2, 1, 0, c, a, -45, 0), cc.CallFunc.create(this.finish, this));
        b = cc.Sequence.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, 0, b, 45, 0),
            cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionFlipAngular.create = function (a, b, c) {
    null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
    var d = new cc.TransitionFlipAngular;
    d.initWithDuration(a, b, c);
    return d
};
cc.TransitionZoomFlipX = cc.TransitionSceneOriented.extend({
    onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
        a = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, c, a, 0, 0), cc.ScaleTo.create(this._duration / 2, 1), cc.Show.create()), cc.CallFunc.create(this.finish, this));
        b = cc.Sequence.create(cc.Spawn.create(cc.OrbitCamera.create(this._duration /
            2, 1, 0, 0, b, 0, 0), cc.ScaleTo.create(this._duration / 2, 0.5)), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
        this._inScene.scale = 0.5;
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionZoomFlipX.create = function (a, b, c) {
    null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
    var d = new cc.TransitionZoomFlipX;
    d.initWithDuration(a, b, c);
    return d
};
cc.TransitionZoomFlipY = cc.TransitionSceneOriented.extend({
    onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_UP_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
        a = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, c, a, 90, 0), cc.ScaleTo.create(this._duration / 2, 1), cc.Show.create()), cc.CallFunc.create(this.finish, this));
        b = cc.Sequence.create(cc.Spawn.create(cc.OrbitCamera.create(this._duration /
            2, 1, 0, 0, b, 90, 0), cc.ScaleTo.create(this._duration / 2, 0.5)), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
        this._inScene.scale = 0.5;
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionZoomFlipY.create = function (a, b, c) {
    null == c && (c = cc.TRANSITION_ORIENTATION_UP_OVER);
    var d = new cc.TransitionZoomFlipY;
    d.initWithDuration(a, b, c);
    return d
};
cc.TransitionZoomFlipAngular = cc.TransitionSceneOriented.extend({
    onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
        a = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, c, a, -45, 0), cc.ScaleTo.create(this._duration / 2, 1), cc.Show.create()), cc.Show.create(), cc.CallFunc.create(this.finish, this));
        b = cc.Sequence.create(cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, 0, b, 45, 0), cc.ScaleTo.create(this._duration / 2, 0.5)), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
        this._inScene.scale = 0.5;
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionZoomFlipAngular.create = function (a, b, c) {
    null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
    var d = new cc.TransitionZoomFlipAngular;
    d.initWithDuration(a, b, c);
    return d
};
cc.TransitionFade = cc.TransitionScene.extend({
    _color: null,
    ctor: function () {
        cc.TransitionScene.prototype.ctor.call(this);
        this._color = cc.color()
    },
    onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.LayerColor.create(this._color);
        this._inScene.visible = !1;
        this.addChild(a, 2, cc.SCENE_FADE);
        var a = this.getChildByTag(cc.SCENE_FADE),
            b = cc.Sequence.create(cc.FadeIn.create(this._duration / 2), cc.CallFunc.create(this.hideOutShowIn, this), cc.FadeOut.create(this._duration / 2), cc.CallFunc.create(this.finish,
                this));
        a.runAction(b)
    },
    onExit: function () {
        cc.TransitionScene.prototype.onExit.call(this);
        this.removeChildByTag(cc.SCENE_FADE, !1)
    },
    initWithDuration: function (a, b, c) {
        c = c || cc.color.BLACK;
        cc.TransitionScene.prototype.initWithDuration.call(this, a, b) && (this._color.r = c.r, this._color.g = c.g, this._color.b = c.b, this._color.a = 0);
        return !0
    }
});
cc.TransitionFade.create = function (a, b, c) {
    var d = new cc.TransitionFade;
    d.initWithDuration(a, b, c);
    return d
};
cc.TransitionCrossFade = cc.TransitionScene.extend({
    onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.color(0, 0, 0, 0),
            b = cc.director.getWinSize(),
            a = cc.LayerColor.create(a),
            c = cc.RenderTexture.create(b.width, b.height);
        if (null != c) {
            c.sprite.anchorX = 0.5;
            c.sprite.anchorY = 0.5;
            c.attr({
                x: b.width / 2,
                y: b.height / 2,
                anchorX: 0.5,
                anchorY: 0.5
            });
            c.begin();
            this._inScene.visit();
            c.end();
            var d = cc.RenderTexture.create(b.width, b.height);
            d.setPosition(b.width / 2, b.height / 2);
            d.sprite.anchorX = d.anchorX =
                0.5;
            d.sprite.anchorY = d.anchorY = 0.5;
            d.begin();
            this._outScene.visit();
            d.end();
            c.sprite.setBlendFunc(cc.ONE, cc.ONE);
            d.sprite.setBlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
            a.addChild(c);
            a.addChild(d);
            c.sprite.opacity = 255;
            d.sprite.opacity = 255;
            b = cc.Sequence.create(cc.FadeTo.create(this._duration, 0), cc.CallFunc.create(this.hideOutShowIn, this), cc.CallFunc.create(this.finish, this));
            d.sprite.runAction(b);
            this.addChild(a, 2, cc.SCENE_FADE)
        }
    },
    onExit: function () {
        this.removeChildByTag(cc.SCENE_FADE, !1);
        cc.TransitionScene.prototype.onExit.call(this)
    },
    draw: function () {}
});
cc.TransitionCrossFade.create = function (a, b) {
    var c = new cc.TransitionCrossFade;
    c.initWithDuration(a, b);
    return c
};
cc.TransitionTurnOffTiles = cc.TransitionScene.extend({
    _sceneOrder: function () {
        this._isInSceneOnTop = !1
    },
    onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.director.getWinSize(),
            a = cc.TurnOffTiles.create(this._duration, cc.size(0 | a.width / a.height * 12, 12)),
            a = this.easeActionWithAction(a);
        this._outScene.runAction(cc.Sequence.create(a, cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
    },
    easeActionWithAction: function (a) {
        return a
    }
});
cc.TransitionTurnOffTiles.create = function (a, b) {
    var c = new cc.TransitionTurnOffTiles;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionSplitCols = cc.TransitionScene.extend({
    onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._inScene.visible = !1;
        var a = this.action(),
            a = cc.Sequence.create(a, cc.CallFunc.create(this.hideOutShowIn, this), a.reverse());
        this.runAction(cc.Sequence.create(this.easeActionWithAction(a), cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
    },
    easeActionWithAction: function (a) {
        return cc.EaseInOut.create(a, 3)
    },
    action: function () {
        return cc.SplitCols.create(this._duration / 2, 3)
    }
});
cc.TransitionSplitCols.create = function (a, b) {
    var c = new cc.TransitionSplitCols;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionSplitRows = cc.TransitionSplitCols.extend({
    action: function () {
        return cc.SplitRows.create(this._duration / 2, 3)
    }
});
cc.TransitionSplitRows.create = function (a, b) {
    var c = new cc.TransitionSplitRows;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionFadeTR = cc.TransitionScene.extend({
    _sceneOrder: function () {
        this._isInSceneOnTop = !1
    },
    onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.director.getWinSize(),
            a = this.actionWithSize(cc.size(0 | a.width / a.height * 12, 12));
        this._outScene.runAction(cc.Sequence.create(this.easeActionWithAction(a), cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
    },
    easeActionWithAction: function (a) {
        return a
    },
    actionWithSize: function (a) {
        return cc.FadeOutTRTiles.create(this._duration,
            a)
    }
});
cc.TransitionFadeTR.create = function (a, b) {
    var c = new cc.TransitionFadeTR;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionFadeBL = cc.TransitionFadeTR.extend({
    actionWithSize: function (a) {
        return cc.FadeOutBLTiles.create(this._duration, a)
    }
});
cc.TransitionFadeBL.create = function (a, b) {
    var c = new cc.TransitionFadeBL;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionFadeUp = cc.TransitionFadeTR.extend({
    actionWithSize: function (a) {
        return cc.FadeOutUpTiles.create(this._duration, a)
    }
});
cc.TransitionFadeUp.create = function (a, b) {
    var c = new cc.TransitionFadeUp;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionFadeDown = cc.TransitionFadeTR.extend({
    actionWithSize: function (a) {
        return cc.FadeOutDownTiles.create(this._duration, a)
    }
});
cc.TransitionFadeDown.create = function (a, b) {
    var c = new cc.TransitionFadeDown;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.SCENE_RADIAL = 49153;
cc.TransitionProgress = cc.TransitionScene.extend({
    _to: 0,
    _from: 0,
    _sceneToBeModified: null,
    _className: "TransitionProgress",
    _setAttrs: function (a, b, c) {
        a.attr({
            x: b,
            y: c,
            anchorX: 0.5,
            anchorY: 0.5
        })
    },
    onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._setupTransition();
        var a = cc.director.getWinSize(),
            b = cc.RenderTexture.create(a.width, a.height);
        b.sprite.anchorX = 0.5;
        b.sprite.anchorY = 0.5;
        this._setAttrs(b, a.width / 2, a.height / 2);
        b.clear(0, 0, 0, 1);
        b.begin();
        this._sceneToBeModified.visit();
        b.end();
        this._sceneToBeModified == this._outScene && this.hideOutShowIn();
        a = this._progressTimerNodeWithRenderTexture(b);
        b = cc.Sequence.create(cc.ProgressFromTo.create(this._duration, this._from, this._to), cc.CallFunc.create(this.finish, this));
        a.runAction(b);
        this.addChild(a, 2, cc.SCENE_RADIAL)
    },
    onExit: function () {
        this.removeChildByTag(cc.SCENE_RADIAL, !0);
        cc.TransitionScene.prototype.onExit.call(this)
    },
    _setupTransition: function () {
        this._sceneToBeModified = this._outScene;
        this._from = 100;
        this._to = 0
    },
    _progressTimerNodeWithRenderTexture: function (a) {
        cc.log("cc.TransitionProgress._progressTimerNodeWithRenderTexture(): should be overridden in subclass");
        return null
    },
    _sceneOrder: function () {
        this._isInSceneOnTop = !1
    }
});
cc.TransitionProgress.create = function (a, b) {
    var c = new cc.TransitionProgress;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionProgressRadialCCW = cc.TransitionProgress.extend({
    _progressTimerNodeWithRenderTexture: function (a) {
        var b = cc.director.getWinSize();
        a = cc.ProgressTimer.create(a.sprite);
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.PROGRESS_TIMER_TYPE_RADIAL;
        a.reverseDir = !1;
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressRadialCCW.create = function (a, b) {
    var c = new cc.TransitionProgressRadialCCW;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionProgressRadialCW = cc.TransitionProgress.extend({
    _progressTimerNodeWithRenderTexture: function (a) {
        var b = cc.director.getWinSize();
        a = cc.ProgressTimer.create(a.sprite);
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.PROGRESS_TIMER_TYPE_RADIAL;
        a.reverseDir = !0;
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressRadialCW.create = function (a, b) {
    var c = new cc.TransitionProgressRadialCW;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionProgressHorizontal = cc.TransitionProgress.extend({
    _progressTimerNodeWithRenderTexture: function (a) {
        var b = cc.director.getWinSize();
        a = cc.ProgressTimer.create(a.sprite);
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.PROGRESS_TIMER_TYPE_BAR;
        a.midPoint = cc.p(1, 0);
        a.barChangeRate = cc.p(1, 0);
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressHorizontal.create = function (a, b) {
    var c = new cc.TransitionProgressHorizontal;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionProgressVertical = cc.TransitionProgress.extend({
    _progressTimerNodeWithRenderTexture: function (a) {
        var b = cc.director.getWinSize();
        a = cc.ProgressTimer.create(a.sprite);
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.PROGRESS_TIMER_TYPE_BAR;
        a.midPoint = cc.p(0, 0);
        a.barChangeRate = cc.p(0, 1);
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressVertical.create = function (a, b) {
    var c = new cc.TransitionProgressVertical;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionProgressInOut = cc.TransitionProgress.extend({
    _progressTimerNodeWithRenderTexture: function (a) {
        var b = cc.director.getWinSize();
        a = cc.ProgressTimer.create(a.sprite);
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.PROGRESS_TIMER_TYPE_BAR;
        a.midPoint = cc.p(0.5, 0.5);
        a.barChangeRate = cc.p(1, 1);
        a.percentage = 0;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    },
    _sceneOrder: function () {
        this._isInSceneOnTop = !1
    },
    _setupTransition: function () {
        this._sceneToBeModified = this._inScene;
        this._from =
            0;
        this._to = 100
    }
});
cc.TransitionProgressInOut.create = function (a, b) {
    var c = new cc.TransitionProgressInOut;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionProgressOutIn = cc.TransitionProgress.extend({
    _progressTimerNodeWithRenderTexture: function (a) {
        cc.director.getWinSize();
        a = cc.ProgressTimer.create(a.sprite);
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.PROGRESS_TIMER_TYPE_BAR;
        a.midPoint = cc.p(0.5, 0.5);
        a.barChangeRate = cc.p(1, 1);
        a.percentage = 100;
        this._setAttrs(a, winSize.width / 2, winSize.height / 2);
        return a
    }
});
cc.TransitionProgressOutIn.create = function (a, b) {
    var c = new cc.TransitionProgressOutIn;
    return null != c && c.initWithDuration(a, b) ? c : null
};
cc.TransitionPageTurn = cc.TransitionScene.extend({
    _back: !0,
    _className: "TransitionPageTurn",
    initWithDuration: function (a, b, c) {
        this._back = c;
        cc.TransitionScene.prototype.initWithDuration.call(this, a, b);
        return !0
    },
    actionWithSize: function (a) {
        return this._back ? cc.ReverseTime.create(cc.PageTurn3D.create(this._duration, a)) : cc.PageTurn3D.create(this._duration, a)
    },
    onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.director.getWinSize(),
            b;
        a.width > a.height ? (a = 16, b = 12) : (a = 12, b = 16);
        a = this.actionWithSize(cc.size(a,
            b));
        this._back ? (this._inScene.visible = !1, this._inScene.runAction(cc.Sequence.create(cc.Show.create(), a, cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))) : this._outScene.runAction(cc.Sequence.create(a, cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
    },
    _sceneOrder: function () {
        this._isInSceneOnTop = this._back
    }
});
cc.TransitionPageTurn.create = function (a, b, c) {
    var d = new cc.TransitionPageTurn;
    d.initWithDuration(a, b, c);
    return d
};
cc.Codec = {
    name: "Jacob__Codec"
};
cc.unzip = function () {
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments)
};
cc.unzipBase64 = function () {
    var a = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, [a])
};
cc.unzipBase64AsArray = function (a, b) {
    b = b || 1;
    var c = this.unzipBase64(a),
        d = [],
        e, f, g;
    e = 0;
    for (g = c.length / b; e < g; e++)
        for (d[e] = 0, f = b - 1; 0 <= f; --f) d[e] += c.charCodeAt(e * b + f) << 8 * f;
    return d
};
cc.unzipAsArray = function (a, b) {
    b = b || 1;
    var c = this.unzip(a),
        d = [],
        e, f, g;
    e = 0;
    for (g = c.length / b; e < g; e++)
        for (d[e] = 0, f = b - 1; 0 <= f; --f) d[e] += c.charCodeAt(e * b + f) << 8 * f;
    return d
};
cc.StringToArray = function (a) {
    a = a.split(",");
    var b = [],
        c;
    for (c = 0; c < a.length; c++) b.push(parseInt(a[c]));
    return b
};
cc.Codec.Base64 = {
    name: "Jacob__Codec__Base64"
};
cc.Codec.Base64._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\x3d";
cc.Codec.Base64.decode = function (a) {
    var b = [],
        c, d, e, f, g, h = 0;
    for (a = a.replace(/[^A-Za-z0-9\+\/\=]/g, ""); h < a.length;) c = this._keyStr.indexOf(a.charAt(h++)), d = this._keyStr.indexOf(a.charAt(h++)), f = this._keyStr.indexOf(a.charAt(h++)), g = this._keyStr.indexOf(a.charAt(h++)), c = c << 2 | d >> 4, d = (d & 15) << 4 | f >> 2, e = (f & 3) << 6 | g, b.push(String.fromCharCode(c)), 64 != f && b.push(String.fromCharCode(d)), 64 != g && b.push(String.fromCharCode(e));
    return b = b.join("")
};
cc.Codec.Base64.decodeAsArray = function (a, b) {
    var c = this.decode(a),
        d = [],
        e, f, g;
    e = 0;
    for (g = c.length / b; e < g; e++)
        for (d[e] = 0, f = b - 1; 0 <= f; --f) d[e] += c.charCodeAt(e * b + f) << 8 * f;
    return d
};
cc.uint8ArrayToUint32Array = function (a) {
    if (0 != a.length % 4) return null;
    for (var b = a.length / 4, c = window.Uint32Array ? new Uint32Array(b) : [], d = 0; d < b; d++) {
        var e = 4 * d;
        c[d] = a[e] + 256 * a[e + 1] + 65536 * a[e + 2] + 16777216 * a[e + 3]
    }
    return c
};
cc.Codec.GZip = function (a) {
    this.data = a;
    this.debug = !1;
    this.gpflags = void 0;
    this.files = 0;
    this.unzipped = [];
    this.buf32k = Array(32768);
    this.bIdx = 0;
    this.modeZIP = !1;
    this.bytepos = 0;
    this.bb = 1;
    this.bits = 0;
    this.nameBuf = [];
    this.fileout = void 0;
    this.literalTree = Array(cc.Codec.GZip.LITERALS);
    this.distanceTree = Array(32);
    this.treepos = 0;
    this.Places = null;
    this.len = 0;
    this.fpos = Array(17);
    this.fpos[0] = 0;
    this.fmax = this.flens = void 0
};
cc.Codec.GZip.gunzip = function (a) {
    return (new cc.Codec.GZip(a)).gunzip()[0][0]
};
cc.Codec.GZip.HufNode = function () {
    this.b1 = this.b0 = 0;
    this.jump = null;
    this.jumppos = -1
};
cc.Codec.GZip.LITERALS = 288;
cc.Codec.GZip.NAMEMAX = 256;
cc.Codec.GZip.bitReverse = [0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161,
    97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255
];
cc.Codec.GZip.cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
cc.Codec.GZip.cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99];
cc.Codec.GZip.cpdist = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
cc.Codec.GZip.cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
cc.Codec.GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
cc.Codec.GZip.prototype.gunzip = function () {
    this.outputArr = [];
    this.nextFile();
    return this.unzipped
};
cc.Codec.GZip.prototype.readByte = function () {
    this.bits += 8;
    return this.bytepos < this.data.length ? this.data.charCodeAt(this.bytepos++) : -1
};
cc.Codec.GZip.prototype.byteAlign = function () {
    this.bb = 1
};
cc.Codec.GZip.prototype.readBit = function () {
    var a;
    this.bits++;
    a = this.bb & 1;
    this.bb >>= 1;
    0 == this.bb && (this.bb = this.readByte(), a = this.bb & 1, this.bb = this.bb >> 1 | 128);
    return a
};
cc.Codec.GZip.prototype.readBits = function (a) {
    for (var b = 0, c = a; c--;) b = b << 1 | this.readBit();
    a && (b = cc.Codec.GZip.bitReverse[b] >> 8 - a);
    return b
};
cc.Codec.GZip.prototype.flushBuffer = function () {
    this.bIdx = 0
};
cc.Codec.GZip.prototype.addBuffer = function (a) {
    this.buf32k[this.bIdx++] = a;
    this.outputArr.push(String.fromCharCode(a));
    32768 == this.bIdx && (this.bIdx = 0)
};
cc.Codec.GZip.prototype.IsPat = function () {
    for (;;) {
        if (this.fpos[this.len] >= this.fmax) return -1;
        if (this.flens[this.fpos[this.len]] == this.len) return this.fpos[this.len]++;
        this.fpos[this.len]++
    }
};
cc.Codec.GZip.prototype.Rec = function () {
    var a = this.Places[this.treepos],
        b;
    if (17 == this.len) return -1;
    this.treepos++;
    this.len++;
    b = this.IsPat();
    if (0 <= b) a.b0 = b;
    else if (a.b0 = 32768, this.Rec()) return -1;
    b = this.IsPat();
    if (0 <= b) a.b1 = b, a.jump = null;
    else if (a.b1 = 32768, a.jump = this.Places[this.treepos], a.jumppos = this.treepos, this.Rec()) return -1;
    this.len--;
    return 0
};
cc.Codec.GZip.prototype.CreateTree = function (a, b, c, d) {
    this.Places = a;
    this.treepos = 0;
    this.flens = c;
    this.fmax = b;
    for (a = 0; 17 > a; a++) this.fpos[a] = 0;
    this.len = 0;
    return this.Rec() ? -1 : 0
};
cc.Codec.GZip.prototype.DecodeValue = function (a) {
    for (var b, c, d = 0, e = a[d];;)
        if (b = this.readBit()) {
            if (!(e.b1 & 32768)) return e.b1;
            e = e.jump;
            b = a.length;
            for (c = 0; c < b; c++)
                if (a[c] === e) {
                    d = c;
                    break
                }
        } else {
            if (!(e.b0 & 32768)) return e.b0;
            d++;
            e = a[d]
        }
    return -1
};
cc.Codec.GZip.prototype.DeflateLoop = function () {
    var a, b, c, d, e;
    do
        if (a = this.readBit(), c = this.readBits(2), 0 == c)
            for (this.byteAlign(), c = this.readByte(), c |= this.readByte() << 8, b = this.readByte(), b |= this.readByte() << 8, (c ^ ~b) & 65535 && document.write("BlockLen checksum mismatch\n"); c--;) b = this.readByte(), this.addBuffer(b);
        else if (1 == c)
        for (;;)
            if (c = cc.Codec.GZip.bitReverse[this.readBits(7)] >> 1, 23 < c ? (c = c << 1 | this.readBit(), 199 < c ? (c -= 128, c = c << 1 | this.readBit()) : (c -= 48, 143 < c && (c += 136))) : c += 256, 256 > c) this.addBuffer(c);
            else if (256 == c) break;
    else {
        var f;
        c -= 257;
        e = this.readBits(cc.Codec.GZip.cplext[c]) + cc.Codec.GZip.cplens[c];
        c = cc.Codec.GZip.bitReverse[this.readBits(5)] >> 3;
        8 < cc.Codec.GZip.cpdext[c] ? (f = this.readBits(8), f |= this.readBits(cc.Codec.GZip.cpdext[c] - 8) << 8) : f = this.readBits(cc.Codec.GZip.cpdext[c]);
        f += cc.Codec.GZip.cpdist[c];
        for (c = 0; c < e; c++) b = this.buf32k[this.bIdx - f & 32767], this.addBuffer(b)
    } else if (2 == c) {
        var g = Array(320);
        b = 257 + this.readBits(5);
        f = 1 + this.readBits(5);
        d = 4 + this.readBits(4);
        for (c = 0; 19 > c; c++) g[c] = 0;
        for (c = 0; c < d; c++) g[cc.Codec.GZip.border[c]] = this.readBits(3);
        e = this.distanceTree.length;
        for (d = 0; d < e; d++) this.distanceTree[d] = new cc.Codec.GZip.HufNode;
        if (this.CreateTree(this.distanceTree, 19, g, 0)) return this.flushBuffer(), 1;
        e = b + f;
        d = 0;
        for (var h = -1; d < e;)
            if (h++, c = this.DecodeValue(this.distanceTree), 16 > c) g[d++] = c;
            else if (16 == c) {
            var k;
            c = 3 + this.readBits(2);
            if (d + c > e) return this.flushBuffer(), 1;
            for (k = d ? g[d - 1] : 0; c--;) g[d++] = k
        } else {
            c = 17 == c ? 3 + this.readBits(3) : 11 + this.readBits(7);
            if (d + c > e) return this.flushBuffer(),
                1;
            for (; c--;) g[d++] = 0
        }
        e = this.literalTree.length;
        for (d = 0; d < e; d++) this.literalTree[d] = new cc.Codec.GZip.HufNode;
        if (this.CreateTree(this.literalTree, b, g, 0)) return this.flushBuffer(), 1;
        e = this.literalTree.length;
        for (d = 0; d < e; d++) this.distanceTree[d] = new cc.Codec.GZip.HufNode;
        c = [];
        for (d = b; d < g.length; d++) c[d - b] = g[d];
        if (this.CreateTree(this.distanceTree, f, c, 0)) return this.flushBuffer(), 1;
        for (;;)
            if (c = this.DecodeValue(this.literalTree), 256 <= c) {
                c -= 256;
                if (0 == c) break;
                c--;
                e = this.readBits(cc.Codec.GZip.cplext[c]) +
                    cc.Codec.GZip.cplens[c];
                c = this.DecodeValue(this.distanceTree);
                8 < cc.Codec.GZip.cpdext[c] ? (f = this.readBits(8), f |= this.readBits(cc.Codec.GZip.cpdext[c] - 8) << 8) : f = this.readBits(cc.Codec.GZip.cpdext[c]);
                for (f += cc.Codec.GZip.cpdist[c]; e--;) b = this.buf32k[this.bIdx - f & 32767], this.addBuffer(b)
            } else this.addBuffer(c)
    }
    while (!a);
    this.flushBuffer();
    this.byteAlign();
    return 0
};
cc.Codec.GZip.prototype.unzipFile = function (a) {
    var b;
    this.gunzip();
    for (b = 0; b < this.unzipped.length; b++)
        if (this.unzipped[b][1] == a) return this.unzipped[b][0]
};
cc.Codec.GZip.prototype.nextFile = function () {
    this.outputArr = [];
    this.modeZIP = !1;
    var a = [];
    a[0] = this.readByte();
    a[1] = this.readByte();
    120 == a[0] && 218 == a[1] && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), "geonext.gxt"], this.files++);
    31 == a[0] && 139 == a[1] && (this.skipdir(), this.unzipped[this.files] = [this.outputArr.join(""), "file"], this.files++);
    if (80 == a[0] && 75 == a[1] && (this.modeZIP = !0, a[2] = this.readByte(), a[3] = this.readByte(), 3 == a[2] && 4 == a[3])) {
        a[0] = this.readByte();
        a[1] = this.readByte();
        this.gpflags = this.readByte();
        this.gpflags |= this.readByte() << 8;
        a = this.readByte();
        a |= this.readByte() << 8;
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        var b = this.readByte(),
            b = b | this.readByte() << 8,
            c = this.readByte(),
            c = c | this.readByte() << 8,
            d = 0;
        for (this.nameBuf = []; b--;) {
            var e = this.readByte();
            "/" == e | ":" == e ? d = 0 : d < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[d++] = String.fromCharCode(e))
        }
        this.fileout ||
            (this.fileout = this.nameBuf);
        for (var d = 0; d < c;) this.readByte(), d++;
        8 == a && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), this.nameBuf.join("")], this.files++);
        this.skipdir()
    }
};
cc.Codec.GZip.prototype.skipdir = function () {
    var a = [],
        b;
    this.gpflags & 8 && (a[0] = this.readByte(), a[1] = this.readByte(), a[2] = this.readByte(), a[3] = this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte());
    this.modeZIP && this.nextFile();
    a[0] = this.readByte();
    if (8 != a[0]) return 0;
    this.gpflags = this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    if (this.gpflags & 4)
        for (a[0] =
            this.readByte(), a[2] = this.readByte(), this.len = a[0] + 256 * a[1], a = 0; a < this.len; a++) this.readByte();
    if (this.gpflags & 8)
        for (a = 0, this.nameBuf = []; b = this.readByte();) {
            if ("7" == b || ":" == b) a = 0;
            a < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[a++] = b)
        }
    if (this.gpflags & 16)
        for (; this.readByte(););
    this.gpflags & 2 && (this.readByte(), this.readByte());
    this.DeflateLoop();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.modeZIP && this.nextFile()
};
/*
 zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
(function () {
    function a(a) {
        throw a;
    }

    function b(a, b) {
        var c = a.split("."),
            d = z;
        c[0] in d || !d.execScript || d.execScript("var " + c[0]);
        for (var e; c.length && (e = c.shift());) c.length || b === B ? d = d[e] ? d[e] : d[e] = {} : d[e] = b
    }

    function c(a) {
        if ("string" === typeof a) {
            a = a.split("");
            var b, c;
            b = 0;
            for (c = a.length; b < c; b++) a[b] = (a[b].charCodeAt(0) & 255) >>> 0
        }
        b = 1;
        c = 0;
        for (var d = a.length, e, f = 0; 0 < d;) {
            e = 1024 < d ? 1024 : d;
            d -= e;
            do b += a[f++], c += b; while (--e);
            b %= 65521;
            c %= 65521
        }
        return (c << 16 | b) >>> 0
    }

    function d(b, c) {
        this.index = "number" === typeof c ? c : 0;
        this.i = 0;
        this.buffer = b instanceof(w ? Uint8Array : Array) ? b : new(w ? Uint8Array : Array)(32768);
        2 * this.buffer.length <= this.index && a(Error("invalid index"));
        this.buffer.length <= this.index && this.f()
    }

    function e(a) {
        this.buffer = new(w ? Uint16Array : Array)(2 * a);
        this.length = 0
    }

    function f(a) {
        var b = a.length,
            c = 0,
            d = Number.POSITIVE_INFINITY,
            e, f, g, h, k, m, n, p, r;
        for (p = 0; p < b; ++p) a[p] > c && (c = a[p]), a[p] < d && (d = a[p]);
        e = 1 << c;
        f = new(w ? Uint32Array : Array)(e);
        g = 1;
        h = 0;
        for (k = 2; g <= c;) {
            for (p = 0; p < b; ++p)
                if (a[p] === g) {
                    m = 0;
                    n = h;
                    for (r = 0; r < g; ++r) m =
                        m << 1 | n & 1, n >>= 1;
                    for (r = m; r < e; r += k) f[r] = g << 16 | p;
                    ++h
                }++g;
            h <<= 1;
            k <<= 1
        }
        return [f, c, d]
    }

    function g(a, b) {
        this.h = I;
        this.w = 0;
        this.input = a;
        this.b = 0;
        b && (b.lazy && (this.w = b.lazy), "number" === typeof b.compressionType && (this.h = b.compressionType), b.outputBuffer && (this.a = w && b.outputBuffer instanceof Array ? new Uint8Array(b.outputBuffer) : b.outputBuffer), "number" === typeof b.outputIndex && (this.b = b.outputIndex));
        this.a || (this.a = new(w ? Uint8Array : Array)(32768))
    }

    function h(a, b) {
        this.length = a;
        this.G = b
    }

    function k() {
        var b = J;
        switch (D) {
        case 3 ===
        b:
            return [257, b - 3, 0];
        case 4 === b:
            return [258, b - 4, 0];
        case 5 === b:
            return [259, b - 5, 0];
        case 6 === b:
            return [260, b - 6, 0];
        case 7 === b:
            return [261, b - 7, 0];
        case 8 === b:
            return [262, b - 8, 0];
        case 9 === b:
            return [263, b - 9, 0];
        case 10 === b:
            return [264, b - 10, 0];
        case 12 >= b:
            return [265, b - 11, 1];
        case 14 >= b:
            return [266, b - 13, 1];
        case 16 >= b:
            return [267, b - 15, 1];
        case 18 >= b:
            return [268, b - 17, 1];
        case 22 >= b:
            return [269, b - 19, 2];
        case 26 >= b:
            return [270, b - 23, 2];
        case 30 >= b:
            return [271, b - 27, 2];
        case 34 >= b:
            return [272, b - 31, 2];
        case 42 >= b:
            return [273, b - 35, 3];
        case 50 >=
        b:
            return [274, b - 43, 3];
        case 58 >= b:
            return [275, b - 51, 3];
        case 66 >= b:
            return [276, b - 59, 3];
        case 82 >= b:
            return [277, b - 67, 4];
        case 98 >= b:
            return [278, b - 83, 4];
        case 114 >= b:
            return [279, b - 99, 4];
        case 130 >= b:
            return [280, b - 115, 4];
        case 162 >= b:
            return [281, b - 131, 5];
        case 194 >= b:
            return [282, b - 163, 5];
        case 226 >= b:
            return [283, b - 195, 5];
        case 257 >= b:
            return [284, b - 227, 5];
        case 258 === b:
            return [285, b - 258, 0];
        default:
            a("invalid length: " + b)
        }
    }

    function m(b, c) {
        function d(b, c) {
            var e = b.G,
                f = [],
                g = 0,
                h;
            h = L[b.length];
            f[g++] = h & 65535;
            f[g++] = h >> 16 & 255;
            f[g++] =
                h >> 24;
            var k;
            switch (D) {
            case 1 === e:
                k = [0, e - 1, 0];
                break;
            case 2 === e:
                k = [1, e - 2, 0];
                break;
            case 3 === e:
                k = [2, e - 3, 0];
                break;
            case 4 === e:
                k = [3, e - 4, 0];
                break;
            case 6 >= e:
                k = [4, e - 5, 1];
                break;
            case 8 >= e:
                k = [5, e - 7, 1];
                break;
            case 12 >= e:
                k = [6, e - 9, 2];
                break;
            case 16 >= e:
                k = [7, e - 13, 2];
                break;
            case 24 >= e:
                k = [8, e - 17, 3];
                break;
            case 32 >= e:
                k = [9, e - 25, 3];
                break;
            case 48 >= e:
                k = [10, e - 33, 4];
                break;
            case 64 >= e:
                k = [11, e - 49, 4];
                break;
            case 96 >= e:
                k = [12, e - 65, 5];
                break;
            case 128 >= e:
                k = [13, e - 97, 5];
                break;
            case 192 >= e:
                k = [14, e - 129, 6];
                break;
            case 256 >= e:
                k = [15, e - 193, 6];
                break;
            case 384 >= e:
                k = [16, e - 257, 7];
                break;
            case 512 >= e:
                k = [17, e - 385, 7];
                break;
            case 768 >= e:
                k = [18, e - 513, 8];
                break;
            case 1024 >= e:
                k = [19, e - 769, 8];
                break;
            case 1536 >= e:
                k = [20, e - 1025, 9];
                break;
            case 2048 >= e:
                k = [21, e - 1537, 9];
                break;
            case 3072 >= e:
                k = [22, e - 2049, 10];
                break;
            case 4096 >= e:
                k = [23, e - 3073, 10];
                break;
            case 6144 >= e:
                k = [24, e - 4097, 11];
                break;
            case 8192 >= e:
                k = [25, e - 6145, 11];
                break;
            case 12288 >= e:
                k = [26, e - 8193, 12];
                break;
            case 16384 >= e:
                k = [27, e - 12289, 12];
                break;
            case 24576 >= e:
                k = [28, e - 16385, 13];
                break;
            case 32768 >= e:
                k = [29, e - 24577, 13];
                break;
            default:
                a("invalid distance")
            }
            h =
                k;
            f[g++] = h[0];
            f[g++] = h[1];
            f[g++] = h[2];
            e = 0;
            for (g = f.length; e < g; ++e) r[q++] = f[e];
            t[f[0]]++;
            u[f[3]]++;
            s = b.length + c - 1;
            p = null
        }
        var e, f, g, k, m, n = {},
            p, r = w ? new Uint16Array(2 * c.length) : [],
            q = 0,
            s = 0,
            t = new(w ? Uint32Array : Array)(286),
            u = new(w ? Uint32Array : Array)(30),
            y = b.w,
            C;
        if (!w) {
            for (g = 0; 285 >= g;) t[g++] = 0;
            for (g = 0; 29 >= g;) u[g++] = 0
        }
        t[256] = 1;
        e = 0;
        for (f = c.length; e < f; ++e) {
            g = m = 0;
            for (k = 3; g < k && e + g !== f; ++g) m = m << 8 | c[e + g];
            n[m] === B && (n[m] = []);
            g = n[m];
            if (!(0 < s--)) {
                for (; 0 < g.length && 32768 < e - g[0];) g.shift();
                if (e + 3 >= f) {
                    p && d(p, -1);
                    g = 0;
                    for (k = f - e; g < k; ++g) C = c[e + g], r[q++] = C, ++t[C];
                    break
                }
                if (0 < g.length) {
                    m = k = B;
                    var x = 0,
                        v = B,
                        A = B,
                        z = v = B,
                        G = c.length,
                        A = 0,
                        z = g.length;
                    a: for (; A < z; A++) {
                        k = g[z - A - 1];
                        v = 3;
                        if (3 < x) {
                            for (v = x; 3 < v; v--)
                                if (c[k + v - 1] !== c[e + v - 1]) continue a;
                            v = x
                        }
                        for (; 258 > v && e + v < G && c[k + v] === c[e + v];)++v;
                        v > x && (m = k, x = v);
                        if (258 === v) break
                    }
                    k = new h(x, e - m);
                    p ? p.length < k.length ? (C = c[e - 1], r[q++] = C, ++t[C], d(k, 0)) : d(p, -1) : k.length < y ? p = k : d(k, 0)
                } else p ? d(p, -1) : (C = c[e], r[q++] = C, ++t[C])
            }
            g.push(e)
        }
        r[q++] = 256;
        t[256]++;
        b.L = t;
        b.K = u;
        return w ? r.subarray(0, q) : r
    }

    function n(a,
        b) {
        function c(a) {
            var b = r[a][q[a]];
            b === n ? (c(a + 1), c(a + 1)) : --p[b];
            ++q[a]
        }
        var d = a.length,
            f = new e(572),
            g = new(w ? Uint8Array : Array)(d),
            h, k, m;
        if (!w)
            for (k = 0; k < d; k++) g[k] = 0;
        for (k = 0; k < d; ++k) 0 < a[k] && f.push(k, a[k]);
        d = Array(f.length / 2);
        h = new(w ? Uint32Array : Array)(f.length / 2);
        if (1 === d.length) return g[f.pop().index] = 1, g;
        k = 0;
        for (m = f.length / 2; k < m; ++k) d[k] = f.pop(), h[k] = d[k].value;
        var n = h.length;
        k = new(w ? Uint16Array : Array)(b);
        var f = new(w ? Uint8Array : Array)(b),
            p = new(w ? Uint8Array : Array)(n);
        m = Array(b);
        var r = Array(b),
            q =
            Array(b),
            s = (1 << b) - n,
            t = 1 << b - 1,
            u, v, x;
        k[b - 1] = n;
        for (u = 0; u < b; ++u) s < t ? f[u] = 0 : (f[u] = 1, s -= t), s <<= 1, k[b - 2 - u] = (k[b - 1 - u] / 2 | 0) + n;
        k[0] = f[0];
        m[0] = Array(k[0]);
        r[0] = Array(k[0]);
        for (u = 1; u < b; ++u) k[u] > 2 * k[u - 1] + f[u] && (k[u] = 2 * k[u - 1] + f[u]), m[u] = Array(k[u]), r[u] = Array(k[u]);
        for (s = 0; s < n; ++s) p[s] = b;
        for (t = 0; t < k[b - 1]; ++t) m[b - 1][t] = h[t], r[b - 1][t] = t;
        for (s = 0; s < b; ++s) q[s] = 0;
        1 === f[b - 1] && (--p[0], ++q[b - 1]);
        for (u = b - 2; 0 <= u; --u) {
            v = s = 0;
            x = q[u + 1];
            for (t = 0; t < k[u]; t++) v = m[u + 1][x] + m[u + 1][x + 1], v > h[s] ? (m[u][t] = v, r[u][t] = n, x += 2) : (m[u][t] = h[s],
                r[u][t] = s, ++s);
            q[u] = 0;
            1 === f[u] && c(u)
        }
        h = p;
        k = 0;
        for (m = d.length; k < m; ++k) g[d[k].index] = h[k];
        return g
    }

    function p(b) {
        var c = new(w ? Uint16Array : Array)(b.length),
            d = [],
            e = [],
            f = 0,
            g, h, k;
        g = 0;
        for (h = b.length; g < h; g++) d[b[g]] = (d[b[g]] | 0) + 1;
        g = 1;
        for (h = 16; g <= h; g++) e[g] = f, f += d[g] | 0, f > 1 << g && a("overcommitted"), f <<= 1;
        65536 > f && a("undercommitted");
        g = 0;
        for (h = b.length; g < h; g++)
            for (f = e[b[g]], e[b[g]] += 1, d = c[g] = 0, k = b[g]; d < k; d++) c[g] = c[g] << 1 | f & 1, f >>>= 1;
        return c
    }

    function r(a, b) {
        this.input = a;
        this.a = new(w ? Uint8Array : Array)(32768);
        this.h =
            H.j;
        var c = {},
            d;
        !b && (b = {}) || "number" !== typeof b.compressionType || (this.h = b.compressionType);
        for (d in b) c[d] = b[d];
        c.outputBuffer = this.a;
        this.z = new g(this.input, c)
    }

    function q(b, c) {
        this.k = [];
        this.l = 32768;
        this.e = this.g = this.c = this.q = 0;
        this.input = w ? new Uint8Array(b) : b;
        this.s = !1;
        this.m = O;
        this.B = !1;
        if (c || !(c = {})) c.index && (this.c = c.index), c.bufferSize && (this.l = c.bufferSize), c.bufferType && (this.m = c.bufferType), c.resize && (this.B = c.resize);
        switch (this.m) {
        case M:
            this.b = 32768;
            this.a = new(w ? Uint8Array : Array)(32768 +
                this.l + 258);
            break;
        case O:
            this.b = 0;
            this.a = new(w ? Uint8Array : Array)(this.l);
            this.f = this.J;
            this.t = this.H;
            this.o = this.I;
            break;
        default:
            a(Error("invalid inflate mode"))
        }
    }

    function s(b, c) {
        for (var d = b.g, e = b.e, f = b.input, g = b.c, h; e < c;) h = f[g++], h === B && a(Error("input buffer is broken")), d |= h << e, e += 8;
        b.g = d >>> c;
        b.e = e - c;
        b.c = g;
        return d & (1 << c) - 1
    }

    function t(b, c) {
        for (var d = b.g, e = b.e, f = b.input, g = b.c, h = c[0], k = c[1], m; e < k;) m = f[g++], m === B && a(Error("input buffer is broken")), d |= m << e, e += 8;
        f = h[d & (1 << k) - 1];
        h = f >>> 16;
        b.g = d >> h;
        b.e =
            e - h;
        b.c = g;
        return f & 65535
    }

    function x(a) {
        function b(a, c, d) {
            var e, f, g, h;
            for (h = 0; h < a;) switch (e = t(this, c), e) {
            case 16:
                for (g = 3 + s(this, 2); g--;) d[h++] = f;
                break;
            case 17:
                for (g = 3 + s(this, 3); g--;) d[h++] = 0;
                f = 0;
                break;
            case 18:
                for (g = 11 + s(this, 7); g--;) d[h++] = 0;
                f = 0;
                break;
            default:
                f = d[h++] = e
            }
            return d
        }
        var c = s(a, 5) + 257,
            d = s(a, 5) + 1,
            e = s(a, 4) + 4,
            g = new(w ? Uint8Array : Array)(R.length),
            h;
        for (h = 0; h < e; ++h) g[R[h]] = s(a, 3);
        e = f(g);
        g = new(w ? Uint8Array : Array)(c);
        h = new(w ? Uint8Array : Array)(d);
        a.o(f(b.call(a, c, e, g)), f(b.call(a, d, e, h)))
    }

    function y(b,
        c) {
        var d, e;
        this.input = b;
        this.c = 0;
        if (c || !(c = {})) c.index && (this.c = c.index), c.verify && (this.M = c.verify);
        d = b[this.c++];
        e = b[this.c++];
        switch (d & 15) {
        case N:
            this.method = N;
            break;
        default:
            a(Error("unsupported compression method"))
        }
        0 !== ((d << 8) + e) % 31 && a(Error("invalid fcheck flag:" + ((d << 8) + e) % 31));
        e & 32 && a(Error("fdict flag is not supported"));
        this.A = new q(b, {
            index: this.c,
            bufferSize: c.bufferSize,
            bufferType: c.bufferType,
            resize: c.resize
        })
    }
    var B = void 0,
        D = !0,
        z = this,
        w = "undefined" !== typeof Uint8Array && "undefined" !==
        typeof Uint16Array && "undefined" !== typeof Uint32Array;
    d.prototype.f = function () {
        var a = this.buffer,
            b, c = a.length,
            d = new(w ? Uint8Array : Array)(c << 1);
        if (w) d.set(a);
        else
            for (b = 0; b < c; ++b) d[b] = a[b];
        return this.buffer = d
    };
    d.prototype.d = function (a, b, c) {
        var d = this.buffer,
            e = this.index,
            f = this.i,
            g = d[e];
        c && 1 < b && (a = 8 < b ? (G[a & 255] << 24 | G[a >>> 8 & 255] << 16 | G[a >>> 16 & 255] << 8 | G[a >>> 24 & 255]) >> 32 - b : G[a] >> 8 - b);
        if (8 > b + f) g = g << b | a, f += b;
        else
            for (c = 0; c < b; ++c) g = g << 1 | a >> b - c - 1 & 1, 8 === ++f && (f = 0, d[e++] = G[g], g = 0, e === d.length && (d = this.f()));
        d[e] = g;
        this.buffer = d;
        this.i = f;
        this.index = e
    };
    d.prototype.finish = function () {
        var a = this.buffer,
            b = this.index,
            c;
        0 < this.i && (a[b] <<= 8 - this.i, a[b] = G[a[b]], b++);
        w ? c = a.subarray(0, b) : (a.length = b, c = a);
        return c
    };
    var v = new(w ? Uint8Array : Array)(256),
        u;
    for (u = 0; 256 > u; ++u) {
        for (var A = u, E = A, F = 7, A = A >>> 1; A; A >>>= 1) E <<= 1, E |= A & 1, --F;
        v[u] = (E << F & 255) >>> 0
    }
    var G = v,
        v = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049,
            498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275,
            3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277,
            2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143,
            2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112,
            2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746,
            711928724, 3020668471, 3272380065, 1510334235, 755167117
        ];
    w && new Uint32Array(v);
    e.prototype.getParent = function (a) {
        return 2 * ((a - 2) / 4 | 0)
    };
    e.prototype.push = function (a, b) {
        var c, d, e = this.buffer,
            f;
        c = this.length;
        e[this.length++] = b;
        for (e[this.length++] = a; 0 < c;)
            if (d = this.getParent(c), e[c] > e[d]) f = e[c], e[c] = e[d], e[d] = f, f = e[c + 1], e[c + 1] = e[d + 1], e[d + 1] = f, c = d;
            else break;
        return this.length
    };
    e.prototype.pop = function () {
        var a, b, c = this.buffer,
            d, e, f;
        b = c[0];
        a = c[1];
        this.length -= 2;
        c[0] = c[this.length];
        c[1] = c[this.length + 1];
        for (f =
            0;;) {
            e = 2 * f + 2;
            if (e >= this.length) break;
            e + 2 < this.length && c[e + 2] > c[e] && (e += 2);
            if (c[e] > c[f]) d = c[f], c[f] = c[e], c[e] = d, d = c[f + 1], c[f + 1] = c[e + 1], c[e + 1] = d;
            else break;
            f = e
        }
        return {
            index: a,
            value: b,
            length: this.length
        }
    };
    var I = 2,
        v = {
            NONE: 0,
            r: 1,
            j: I,
            N: 3
        },
        K = [];
    for (u = 0; 288 > u; u++) switch (D) {
    case 143 >= u:
        K.push([u + 48, 8]);
        break;
    case 255 >= u:
        K.push([u - 144 + 400, 9]);
        break;
    case 279 >= u:
        K.push([u - 256 + 0, 7]);
        break;
    case 287 >= u:
        K.push([u - 280 + 192, 8]);
        break;
    default:
        a("invalid literal: " + u)
    }
    g.prototype.n = function () {
        var b, c, e, f, g = this.input;
        switch (this.h) {
        case 0:
            e = 0;
            for (f = g.length; e < f;) {
                c = w ? g.subarray(e, e + 65535) : g.slice(e, e + 65535);
                e += c.length;
                var h = e === f,
                    k = B,
                    r = k = B,
                    r = k = B,
                    q = this.a,
                    s = this.b;
                if (w) {
                    for (q = new Uint8Array(this.a.buffer); q.length <= s + c.length + 5;) q = new Uint8Array(q.length << 1);
                    q.set(this.a)
                }
                k = h ? 1 : 0;
                q[s++] = k | 0;
                k = c.length;
                r = ~k + 65536 & 65535;
                q[s++] = k & 255;
                q[s++] = k >>> 8 & 255;
                q[s++] = r & 255;
                q[s++] = r >>> 8 & 255;
                if (w) q.set(c, s), s += c.length, q = q.subarray(0, s);
                else {
                    k = 0;
                    for (r = c.length; k < r; ++k) q[s++] = c[k];
                    q.length = s
                }
                this.b = s;
                this.a = q
            }
            break;
        case 1:
            e =
                new d(new Uint8Array(this.a.buffer), this.b);
            e.d(1, 1, D);
            e.d(1, 2, D);
            g = m(this, g);
            c = 0;
            for (h = g.length; c < h; c++)
                if (f = g[c], d.prototype.d.apply(e, K[f]), 256 < f) e.d(g[++c], g[++c], D), e.d(g[++c], 5), e.d(g[++c], g[++c], D);
                else if (256 === f) break;
            this.a = e.finish();
            this.b = this.a.length;
            break;
        case I:
            f = new d(new Uint8Array(this.a), this.b);
            var t, u, v, x = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                y, A, k = Array(19),
                C, q = I;
            f.d(1, 1, D);
            f.d(q, 2, D);
            g = m(this, g);
            r = n(this.L, 15);
            y = p(r);
            q = n(this.K, 7);
            s = p(q);
            for (t = 286; 257 < t && 0 === r[t -
                1]; t--);
            for (u = 30; 1 < u && 0 === q[u - 1]; u--);
            var z = t,
                G = u;
            b = new(w ? Uint32Array : Array)(z + G);
            var H = new(w ? Uint32Array : Array)(316),
                E, F;
            A = new(w ? Uint8Array : Array)(19);
            for (C = v = 0; C < z; C++) b[v++] = r[C];
            for (C = 0; C < G; C++) b[v++] = q[C];
            if (!w)
                for (C = 0, G = A.length; C < G; ++C) A[C] = 0;
            C = E = 0;
            for (G = b.length; C < G; C += v) {
                for (v = 1; C + v < G && b[C + v] === b[C]; ++v);
                z = v;
                if (0 === b[C])
                    if (3 > z)
                        for (; 0 < z--;) H[E++] = 0, A[0]++;
                    else
                        for (; 0 < z;) F = 138 > z ? z : 138, F > z - 3 && F < z && (F = z - 3), 10 >= F ? (H[E++] = 17, H[E++] = F - 3, A[17]++) : (H[E++] = 18, H[E++] = F - 11, A[18]++), z -= F;
                else if (H[E++] =
                    b[C], A[b[C]]++, z--, 3 > z)
                    for (; 0 < z--;) H[E++] = b[C], A[b[C]]++;
                else
                    for (; 0 < z;) F = 6 > z ? z : 6, F > z - 3 && F < z && (F = z - 3), H[E++] = 16, H[E++] = F - 3, A[16]++, z -= F
            }
            b = w ? H.subarray(0, E) : H.slice(0, E);
            A = n(A, 7);
            for (C = 0; 19 > C; C++) k[C] = A[x[C]];
            for (v = 19; 4 < v && 0 === k[v - 1]; v--);
            x = p(A);
            f.d(t - 257, 5, D);
            f.d(u - 1, 5, D);
            f.d(v - 4, 4, D);
            for (C = 0; C < v; C++) f.d(k[C], 3, D);
            C = 0;
            for (k = b.length; C < k; C++)
                if (c = b[C], f.d(x[c], A[c], D), 16 <= c) {
                    C++;
                    switch (c) {
                    case 16:
                        h = 2;
                        break;
                    case 17:
                        h = 3;
                        break;
                    case 18:
                        h = 7;
                        break;
                    default:
                        a("invalid code: " + c)
                    }
                    f.d(b[C], h, D)
                }
            h = [y, r];
            s = [s,
                q
            ];
            c = h[0];
            h = h[1];
            q = s[0];
            y = s[1];
            s = 0;
            for (k = g.length; s < k; ++s)
                if (e = g[s], f.d(c[e], h[e], D), 256 < e) f.d(g[++s], g[++s], D), r = g[++s], f.d(q[r], y[r], D), f.d(g[++s], g[++s], D);
                else if (256 === e) break;
            this.a = f.finish();
            this.b = this.a.length;
            break;
        default:
            a("invalid compression type")
        }
        return this.a
    };
    u = [];
    var J;
    for (J = 3; 258 >= J; J++) A = k(), u[J] = A[2] << 24 | A[1] << 16 | A[0];
    var L = w ? new Uint32Array(u) : u,
        H = v;
    r.prototype.n = function () {
        var b, d, e, f, g = 0;
        f = this.a;
        b = N;
        switch (b) {
        case N:
            d = Math.LOG2E * Math.log(32768) - 8;
            break;
        default:
            a(Error("invalid compression method"))
        }
        d =
            d << 4 | b;
        f[g++] = d;
        switch (b) {
        case N:
            switch (this.h) {
            case H.NONE:
                e = 0;
                break;
            case H.r:
                e = 1;
                break;
            case H.j:
                e = 2;
                break;
            default:
                a(Error("unsupported compression type"))
            }
            break;
        default:
            a(Error("invalid compression method"))
        }
        b = e << 6 | 0;
        f[g++] = b | 31 - (256 * d + b) % 31;
        b = c(this.input);
        this.z.b = g;
        f = this.z.n();
        g = f.length;
        w && (f = new Uint8Array(f.buffer), f.length <= g + 4 && (this.a = new Uint8Array(f.length + 4), this.a.set(f), f = this.a), f = f.subarray(0, g + 4));
        f[g++] = b >> 24 & 255;
        f[g++] = b >> 16 & 255;
        f[g++] = b >> 8 & 255;
        f[g++] = b & 255;
        return f
    };
    b("Zlib.Deflate",
        r);
    b("Zlib.Deflate.compress", function (a, b) {
        return (new r(a, b)).n()
    });
    b("Zlib.Deflate.CompressionType", H);
    b("Zlib.Deflate.CompressionType.NONE", H.NONE);
    b("Zlib.Deflate.CompressionType.FIXED", H.r);
    b("Zlib.Deflate.CompressionType.DYNAMIC", H.j);
    var M = 0,
        O = 1,
        v = {
            D: M,
            C: O
        };
    q.prototype.p = function () {
        for (; !this.s;) {
            var b = s(this, 3);
            b & 1 && (this.s = D);
            b >>>= 1;
            switch (b) {
            case 0:
                var b = this.input,
                    c = this.c,
                    d = this.a,
                    e = this.b,
                    f = B,
                    g = B,
                    h = B,
                    k = d.length,
                    f = B;
                this.e = this.g = 0;
                f = b[c++];
                f === B && a(Error("invalid uncompressed block header: LEN (first byte)"));
                g = f;
                f = b[c++];
                f === B && a(Error("invalid uncompressed block header: LEN (second byte)"));
                g |= f << 8;
                f = b[c++];
                f === B && a(Error("invalid uncompressed block header: NLEN (first byte)"));
                h = f;
                f = b[c++];
                f === B && a(Error("invalid uncompressed block header: NLEN (second byte)"));
                h |= f << 8;
                g === ~h && a(Error("invalid uncompressed block header: length verify"));
                c + g > b.length && a(Error("input buffer is broken"));
                switch (this.m) {
                case M:
                    for (; e + g > d.length;) {
                        f = k - e;
                        g -= f;
                        if (w) d.set(b.subarray(c, c + f), e), e += f, c += f;
                        else
                            for (; f--;) d[e++] =
                                b[c++];
                        this.b = e;
                        d = this.f();
                        e = this.b
                    }
                    break;
                case O:
                    for (; e + g > d.length;) d = this.f({
                        v: 2
                    });
                    break;
                default:
                    a(Error("invalid inflate mode"))
                }
                if (w) d.set(b.subarray(c, c + g), e), e += g, c += g;
                else
                    for (; g--;) d[e++] = b[c++];
                this.c = c;
                this.b = e;
                this.a = d;
                break;
            case 1:
                this.o(U, V);
                break;
            case 2:
                x(this);
                break;
            default:
                a(Error("unknown BTYPE: " + b))
            }
        }
        return this.t()
    };
    u = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var R = w ? new Uint16Array(u) : u;
    u = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227,
        258, 258, 258
    ];
    var S = w ? new Uint16Array(u) : u;
    u = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
    var P = w ? new Uint8Array(u) : u;
    u = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    var T = w ? new Uint16Array(u) : u;
    u = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var Q = w ? new Uint8Array(u) : u;
    u = new(w ? Uint8Array : Array)(288);
    A = 0;
    for (E = u.length; A < E; ++A) u[A] = 143 >= A ? 8 : 255 >= A ? 9 : 279 >= A ? 7 : 8;
    var U = f(u);
    u = new(w ? Uint8Array :
        Array)(30);
    A = 0;
    for (E = u.length; A < E; ++A) u[A] = 5;
    var V = f(u);
    q.prototype.o = function (a, b) {
        var c = this.a,
            d = this.b;
        this.u = a;
        for (var e = c.length - 258, f, g, h; 256 !== (f = t(this, a));)
            if (256 > f) d >= e && (this.b = d, c = this.f(), d = this.b), c[d++] = f;
            else
                for (f -= 257, h = S[f], 0 < P[f] && (h += s(this, P[f])), f = t(this, b), g = T[f], 0 < Q[f] && (g += s(this, Q[f])), d >= e && (this.b = d, c = this.f(), d = this.b); h--;) c[d] = c[d++-g];
        for (; 8 <= this.e;) this.e -= 8, this.c--;
        this.b = d
    };
    q.prototype.I = function (a, b) {
        var c = this.a,
            d = this.b;
        this.u = a;
        for (var e = c.length, f, g, h; 256 !==
            (f = t(this, a));)
            if (256 > f) d >= e && (c = this.f(), e = c.length), c[d++] = f;
            else
                for (f -= 257, h = S[f], 0 < P[f] && (h += s(this, P[f])), f = t(this, b), g = T[f], 0 < Q[f] && (g += s(this, Q[f])), d + h > e && (c = this.f(), e = c.length); h--;) c[d] = c[d++-g];
        for (; 8 <= this.e;) this.e -= 8, this.c--;
        this.b = d
    };
    q.prototype.f = function () {
        var a = new(w ? Uint8Array : Array)(this.b - 32768),
            b = this.b - 32768,
            c, d, e = this.a;
        if (w) a.set(e.subarray(32768, a.length));
        else
            for (c = 0, d = a.length; c < d; ++c) a[c] = e[c + 32768];
        this.k.push(a);
        this.q += a.length;
        if (w) e.set(e.subarray(b, b + 32768));
        else
            for (c = 0; 32768 > c; ++c) e[c] = e[b + c];
        this.b = 32768;
        return e
    };
    q.prototype.J = function (a) {
        var b, c = this.input.length / this.c + 1 | 0,
            d, e, f, g = this.input,
            h = this.a;
        a && ("number" === typeof a.v && (c = a.v), "number" === typeof a.F && (c += a.F));
        2 > c ? (d = (g.length - this.c) / this.u[2], f = d / 2 * 258 | 0, e = f < h.length ? h.length + f : h.length << 1) : e = h.length * c;
        w ? (b = new Uint8Array(e), b.set(h)) : b = h;
        return this.a = b
    };
    q.prototype.t = function () {
        var a = 0,
            b = this.a,
            c = this.k,
            d, e = new(w ? Uint8Array : Array)(this.q + (this.b - 32768)),
            f, g, h, k;
        if (0 === c.length) return w ?
            this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
        f = 0;
        for (g = c.length; f < g; ++f)
            for (d = c[f], h = 0, k = d.length; h < k; ++h) e[a++] = d[h];
        f = 32768;
        for (g = this.b; f < g; ++f) e[a++] = b[f];
        this.k = [];
        return this.buffer = e
    };
    q.prototype.H = function () {
        var a, b = this.b;
        w ? this.B ? (a = new Uint8Array(b), a.set(this.a.subarray(0, b))) : a = this.a.subarray(0, b) : (this.a.length > b && (this.a.length = b), a = this.a);
        return this.buffer = a
    };
    y.prototype.p = function () {
        var b = this.input,
            d, e;
        d = this.A.p();
        this.c = this.A.c;
        this.M && (e = (b[this.c++] << 24 | b[this.c++] <<
            16 | b[this.c++] << 8 | b[this.c++]) >>> 0, e !== c(d) && a(Error("invalid adler-32 checksum")));
        return d
    };
    b("Zlib.Inflate", y);
    b("Zlib.Inflate.BufferType", v);
    v.ADAPTIVE = v.C;
    v.BLOCK = v.D;
    b("Zlib.Inflate.prototype.decompress", y.prototype.p);
    v = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    w && new Uint16Array(v);
    v = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
    w && new Uint16Array(v);
    v = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
    w && new Uint8Array(v);
    v = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    w && new Uint16Array(v);
    v = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    w && new Uint8Array(v);
    v = new(w ? Uint8Array : Array)(288);
    u = 0;
    for (A = v.length; u < A; ++u) v[u] = 143 >= u ? 8 : 255 >= u ? 9 : 279 >= u ? 7 : 8;
    f(v);
    v = new(w ? Uint8Array : Array)(30);
    u = 0;
    for (A = v.length; u < A; ++u) v[u] = 5;
    f(v);
    var N = 8
}).call(this);
_p = window;
_p = _p.Zlib = _p.Zlib;
_p.Deflate = _p.Deflate;
_p.Deflate.compress = _p.Deflate.compress;
_p.Inflate = _p.Inflate;
_p.Inflate.BufferType = _p.Inflate.BufferType;
_p.Inflate.prototype.decompress = _p.Inflate.prototype.decompress;
delete window._p;
cc.PNGReader = cc.Class.extend({
    ctor: function (a) {
        var b, c, d, e;
        this.data = a;
        this.pos = 8;
        this.palette = [];
        this.imgData = [];
        this.transparency = {};
        this.animation = null;
        this.text = {};
        for (d = null;;) {
            b = this.readUInt32();
            e = a = void 0;
            e = [];
            for (a = 0; 4 > a; ++a) e.push(String.fromCharCode(this.data[this.pos++]));
            a = e.join("");
            switch (a) {
            case "IHDR":
                this.width = this.readUInt32();
                this.height = this.readUInt32();
                this.bits = this.data[this.pos++];
                this.colorType = this.data[this.pos++];
                this.compressionMethod = this.data[this.pos++];
                this.filterMethod =
                    this.data[this.pos++];
                this.interlaceMethod = this.data[this.pos++];
                break;
            case "acTL":
                this.animation = {
                    numFrames: this.readUInt32(),
                    numPlays: this.readUInt32() || Infinity,
                    frames: []
                };
                break;
            case "PLTE":
                this.palette = this.read(b);
                break;
            case "fcTL":
                d && this.animation.frames.push(d);
                this.pos += 4;
                d = {
                    width: this.readUInt32(),
                    height: this.readUInt32(),
                    xOffset: this.readUInt32(),
                    yOffset: this.readUInt32()
                };
                a = this.readUInt16();
                b = this.readUInt16() || 100;
                d.delay = 1E3 * a / b;
                d.disposeOp = this.data[this.pos++];
                d.blendOp = this.data[this.pos++];
                d.data = [];
                break;
            case "IDAT":
            case "fdAT":
                "fdAT" === a && (this.pos += 4, b -= 4);
                a = (null != d ? d.data : void 0) || this.imgData;
                for (e = 0; 0 <= b ? e < b : e > b; 0 <= b ? ++e : --e) a.push(this.data[this.pos++]);
                break;
            case "tRNS":
                this.transparency = {};
                switch (this.colorType) {
                case 3:
                    this.transparency.indexed = this.read(b);
                    b = 255 - this.transparency.indexed.length;
                    if (0 < b)
                        for (a = 0; 0 <= b ? a < b : a > b; 0 <= b ? ++a : --a) this.transparency.indexed.push(255);
                    break;
                case 0:
                    this.transparency.grayscale = this.read(b)[0];
                    break;
                case 2:
                    this.transparency.rgb = this.read(b)
                }
                break;
            case "tEXt":
                e = this.read(b);
                b = e.indexOf(0);
                a = String.fromCharCode.apply(String, e.slice(0, b));
                this.text[a] = String.fromCharCode.apply(String, e.slice(b + 1));
                break;
            case "IEND":
                d && this.animation.frames.push(d);
                a: {
                    switch (this.colorType) {
                    case 0:
                    case 3:
                    case 4:
                        d = 1;
                        break a;
                    case 2:
                    case 6:
                        d = 3;
                        break a
                    }
                    d = void 0
                }
                this.colors = d;
                this.hasAlphaChannel = 4 === (c = this.colorType) || 6 === c;
                c = this.colors + (this.hasAlphaChannel ? 1 : 0);
                this.pixelBitlength = this.bits * c;
                a: {
                    switch (this.colors) {
                    case 1:
                        c = "DeviceGray";
                        break a;
                    case 3:
                        c = "DeviceRGB";
                        break a
                    }
                    c = void 0
                }
                this.colorSpace = c;
                Uint8Array != Array && (this.imgData = new Uint8Array(this.imgData));
                return;
            default:
                this.pos += b
            }
            this.pos += 4;
            if (this.pos > this.data.length) throw Error("Incomplete or corrupt PNG file");
        }
    },
    read: function (a) {
        var b, c;
        c = [];
        for (b = 0; 0 <= a ? b < a : b > a; 0 <= a ? ++b : --b) c.push(this.data[this.pos++]);
        return c
    },
    readUInt32: function () {
        var a, b, c, d;
        a = this.data[this.pos++] << 24;
        b = this.data[this.pos++] << 16;
        c = this.data[this.pos++] << 8;
        d = this.data[this.pos++];
        return a | b | c | d
    },
    readUInt16: function () {
        var a,
            b;
        a = this.data[this.pos++] << 8;
        b = this.data[this.pos++];
        return a | b
    },
    decodePixels: function (a) {
        var b, c, d, e, f, g, h, k, m, n, p, r, q, s, t;
        null == a && (a = this.imgData);
        if (0 === a.length) return new Uint8Array(0);
        a = (new Zlib.Inflate(a, {
            index: 0,
            verify: !1
        })).decompress();
        k = this.pixelBitlength / 8;
        r = k * this.width;
        m = new Uint8Array(r * this.height);
        g = a.length;
        for (c = n = p = 0; n < g;) {
            switch (a[n++]) {
            case 0:
                for (b = 0; b < r; b += 1) m[c++] = a[n++];
                break;
            case 1:
                for (e = q = 0; q < r; e = q += 1) b = a[n++], f = e < k ? 0 : m[c - k], m[c++] = (b + f) % 256;
                break;
            case 2:
                for (e = f = 0; f <
                    r; e = f += 1) b = a[n++], d = (e - e % k) / k, q = p && m[(p - 1) * r + d * k + e % k], m[c++] = (q + b) % 256;
                break;
            case 3:
                for (e = t = 0; t < r; e = t += 1) b = a[n++], d = (e - e % k) / k, f = e < k ? 0 : m[c - k], q = p && m[(p - 1) * r + d * k + e % k], m[c++] = (b + Math.floor((f + q) / 2)) % 256;
                break;
            case 4:
                for (e = t = 0; t < r; e = t += 1) b = a[n++], d = (e - e % k) / k, f = e < k ? 0 : m[c - k], 0 === p ? q = s = 0 : (q = m[(p - 1) * r + d * k + e % k], s = d && m[(p - 1) * r + (d - 1) * k + e % k]), h = f + q - s, e = Math.abs(h - f), d = Math.abs(h - q), h = Math.abs(h - s), f = e <= d && e <= h ? f : d <= h ? q : s, m[c++] = (b + f) % 256;
                break;
            default:
                throw Error("Invalid filter algorithm: " + a[n - 1]);
            }
            p++
        }
        return m
    },
    copyToImageData: function (a, b) {
        var c, d, e, f, g, h, k, m;
        d = this.colors;
        m = null;
        c = this.hasAlphaChannel;
        this.palette.length && (m = null != (e = this._decodedPalette) ? e : this._decodedPalette = this.decodePalette(), d = 4, c = !0);
        e = a.data || a;
        k = e.length;
        g = m || b;
        f = h = 0;
        if (1 === d)
            for (; f < k;) d = m ? 4 * b[f / 4] : h, h = g[d++], e[f++] = h, e[f++] = h, e[f++] = h, e[f++] = c ? g[d++] : 255, h = d;
        else
            for (; f < k;) d = m ? 4 * b[f / 4] : h, e[f++] = g[d++], e[f++] = g[d++], e[f++] = g[d++], e[f++] = c ? g[d++] : 255, h = d
    },
    decodePalette: function () {
        var a, b, c, d, e, f, g, h, k;
        c = this.palette;
        f = this.transparency.indexed || [];
        e = new Uint8Array((f.length || 0) + c.length);
        b = g = a = d = 0;
        for (h = c.length; g < h; b = g += 3) e[d++] = c[b], e[d++] = c[b + 1], e[d++] = c[b + 2], e[d++] = null != (k = f[a++]) ? k : 255;
        return e
    },
    render: function (a) {
        var b;
        a.width = this.width;
        a.height = this.height;
        a = a.getContext("2d");
        b = a.createImageData(this.width, this.height);
        this.copyToImageData(b, this.decodePixels());
        return a.putImageData(b, 0, 0)
    }
});
cc.tiffReader = {
    _littleEndian: !1,
    _tiffData: null,
    _fileDirectories: [],
    getUint8: function (a) {
        return this._tiffData[a]
    },
    getUint16: function (a) {
        return this._littleEndian ? this._tiffData[a + 1] << 8 | this._tiffData[a] : this._tiffData[a] << 8 | this._tiffData[a + 1]
    },
    getUint32: function (a) {
        var b = this._tiffData;
        return this._littleEndian ? b[a + 3] << 24 | b[a + 2] << 16 | b[a + 1] << 8 | b[a] : b[a] << 24 | b[a + 1] << 16 | b[a + 2] << 8 | b[a + 3]
    },
    checkLittleEndian: function () {
        var a = this.getUint16(0);
        if (18761 === a) this.littleEndian = !0;
        else if (19789 === a) this.littleEndian = !1;
        else throw console.log(a), TypeError("Invalid byte order value.");
        return this.littleEndian
    },
    hasTowel: function () {
        if (42 !== this.getUint16(2)) throw RangeError("You forgot your towel!");
        return !0
    },
    getFieldTypeName: function (a) {
        var b = this.fieldTypeNames;
        return a in b ? b[a] : null
    },
    getFieldTagName: function (a) {
        var b = this.fieldTagNames;
        if (a in b) return b[a];
        console.log("Unknown Field Tag:", a);
        return "Tag" + a
    },
    getFieldTypeLength: function (a) {
        return -1 !== ["BYTE", "ASCII", "SBYTE", "UNDEFINED"].indexOf(a) ? 1 : -1 !== ["SHORT",
            "SSHORT"
        ].indexOf(a) ? 2 : -1 !== ["LONG", "SLONG", "FLOAT"].indexOf(a) ? 4 : -1 !== ["RATIONAL", "SRATIONAL", "DOUBLE"].indexOf(a) ? 8 : null
    },
    getFieldValues: function (a, b, c, d) {
        a = [];
        var e = this.getFieldTypeLength(b);
        if (4 >= e * c)!1 === this.littleEndian ? a.push(d >>> 8 * (4 - e)) : a.push(d);
        else
            for (var f = 0; f < c; f++) {
                var g = e * f;
                8 <= e ? -1 !== ["RATIONAL", "SRATIONAL"].indexOf(b) ? (a.push(this.getUint32(d + g)), a.push(this.getUint32(d + g + 4))) : cc.log("Can't handle this field type or size") : a.push(this.getBytes(e, d + g))
            }
        "ASCII" === b && a.forEach(function (a,
            b, c) {
            c[b] = String.fromCharCode(a)
        });
        return a
    },
    getBytes: function (a, b) {
        if (0 >= a) cc.log("No bytes requested");
        else {
            if (1 >= a) return this.getUint8(b);
            if (2 >= a) return this.getUint16(b);
            if (3 >= a) return this.getUint32(b) >>> 8;
            if (4 >= a) return this.getUint32(b);
            cc.log("Too many bytes requested")
        }
    },
    getBits: function (a, b, c) {
        c = c || 0;
        b += Math.floor(c / 8);
        var d = c + a;
        a = 32 - a;
        var e, f;
        0 >= d ? console.log("No bits requested") : 8 >= d ? (e = 24 + c, f = this.getUint8(b)) : 16 >= d ? (e = 16 + c, f = this.getUint16(b)) : 32 >= d ? (e = c, f = this.getUint32(b)) : console.log("Too many bits requested");
        return {
            bits: f << e >>> a,
            byteOffset: b + Math.floor(d / 8),
            bitOffset: d % 8
        }
    },
    parseFileDirectory: function (a) {
        var b = this.getUint16(a),
            c = [];
        a += 2;
        for (var d = 0; d < b; a += 12, d++) {
            var e = this.getUint16(a),
                f = this.getUint16(a + 2),
                g = this.getUint32(a + 4),
                h = this.getUint32(a + 8),
                e = this.getFieldTagName(e),
                f = this.getFieldTypeName(f),
                g = this.getFieldValues(e, f, g, h);
            c[e] = {
                type: f,
                values: g
            }
        }
        this._fileDirectories.push(c);
        b = this.getUint32(a);
        0 !== b && this.parseFileDirectory(b)
    },
    clampColorSample: function (a, b) {
        var c = Math.pow(2, 8 - b);
        return Math.floor(a *
            c + (c - 1))
    },
    parseTIFF: function (a, b) {
        b = b || document.createElement("canvas");
        this._tiffData = a;
        this.canvas = b;
        this.checkLittleEndian();
        if (this.hasTowel()) {
            var c = this.getUint32(4);
            this._fileDirectories.length = 0;
            this.parseFileDirectory(c);
            var d = this._fileDirectories[0],
                c = d.ImageWidth.values[0],
                e = d.ImageLength.values[0];
            this.canvas.width = c;
            this.canvas.height = e;
            var f = [],
                g = d.Compression ? d.Compression.values[0] : 1,
                h = d.SamplesPerPixel.values[0],
                k = [],
                m = 0,
                n = !1;
            d.BitsPerSample.values.forEach(function (a, b, c) {
                k[b] = {
                    bitsPerSample: a,
                    hasBytesPerSample: !1,
                    bytesPerSample: void 0
                };
                0 === a % 8 && (k[b].hasBytesPerSample = !0, k[b].bytesPerSample = a / 8);
                m += a
            }, this);
            if (0 === m % 8) var n = !0,
                p = m / 8;
            var r = d.StripOffsets.values,
                q = r.length;
            if (d.StripByteCounts) var s = d.StripByteCounts.values;
            else if (cc.log("Missing StripByteCounts!"), 1 === q) s = [Math.ceil(c * e * m / 8)];
            else throw Error("Cannot recover from missing StripByteCounts");
            for (var t = 0; t < q; t++) {
                var x = r[t];
                f[t] = [];
                for (var y = s[t], B = 0, D = 0, z = 1, w = !0, v = [], u = 0, A = 0, E = 0; B < y; B += z) switch (g) {
                case 1:
                    z = 0;
                    for (v = []; z < h; z++)
                        if (k[z].hasBytesPerSample) v.push(this.getBytes(k[z].bytesPerSample,
                            x + B + k[z].bytesPerSample * z));
                        else {
                            var F = this.getBits(k[z].bitsPerSample, x + B, D);
                            v.push(F.bits);
                            B = F.byteOffset - x;
                            D = F.bitOffset;
                            throw RangeError("Cannot handle sub-byte bits per sample");
                        }
                    f[t].push(v);
                    if (n) z = p;
                    else throw z = 0, RangeError("Cannot handle sub-byte bits per pixel");
                    break;
                case 32773:
                    if (w) {
                        var w = !1,
                            G = 1,
                            I = 1,
                            z = this.getInt8(x + B);
                        0 <= z && 127 >= z ? G = z + 1 : -127 <= z && -1 >= z ? I = -z + 1 : w = !0
                    } else {
                        for (var K = this.getUint8(x + B), z = 0; z < I; z++) {
                            if (k[A].hasBytesPerSample) E = E << 8 * u | K, u++, u === k[A].bytesPerSample && (v.push(E),
                                E = u = 0, A++);
                            else throw RangeError("Cannot handle sub-byte bits per sample");
                            A === h && (f[t].push(v), v = [], A = 0)
                        }
                        G--;
                        0 === G && (w = !0)
                    }
                    z = 1
                }
            }
            if (b.getContext) {
                p = this.canvas.getContext("2d");
                p.fillStyle = "rgba(255, 255, 255, 0)";
                t = d.RowsPerStrip ? d.RowsPerStrip.values[0] : e;
                x = f.length;
                e %= t;
                e = 0 === e ? t : e;
                B = t;
                g = 0;
                v = d.PhotometricInterpretation.values[0];
                G = [];
                I = 0;
                d.ExtraSamples && (G = d.ExtraSamples.values, I = G.length);
                if (d.ColorMap) var F = d.ColorMap.values,
                    J = Math.pow(2, k[0].bitsPerSample);
                for (t = 0; t < x; t++) {
                    t + 1 === x && (B = e);
                    d =
                        f[t].length;
                    g *= t;
                    for (n = h = 0; h < B, n < d; h++)
                        for (r = 0; r < c; r++, n++) {
                            s = f[t][n];
                            w = D = y = 0;
                            q = 1;
                            if (0 < I)
                                for (y = 0; y < I; y++)
                                    if (1 === G[y] || 2 === G[y]) {
                                        q = s[3 + y] / 256;
                                        break
                                    }
                            switch (v) {
                            case 0:
                                if (k[0].hasBytesPerSample) var L = Math.pow(16, 2 * k[0].bytesPerSample);
                                s.forEach(function (a, b, c) {
                                    c[b] = L - a
                                });
                            case 1:
                                y = D = w = this.clampColorSample(s[0], k[0].bitsPerSample);
                                break;
                            case 2:
                                y = this.clampColorSample(s[0], k[0].bitsPerSample);
                                D = this.clampColorSample(s[1], k[1].bitsPerSample);
                                w = this.clampColorSample(s[2], k[2].bitsPerSample);
                                break;
                            case 3:
                                if (void 0 ===
                                    F) throw Error("Palette image missing color map");
                                s = s[0];
                                y = this.clampColorSample(F[s], 16);
                                D = this.clampColorSample(F[J + s], 16);
                                w = this.clampColorSample(F[2 * J + s], 16);
                                break;
                            default:
                                throw RangeError("Unknown Photometric Interpretation:", v);
                            }
                            p.fillStyle = "rgba(" + y + ", " + D + ", " + w + ", " + q + ")";
                            p.fillRect(r, g + h, 1, 1)
                        }
                    g = B
                }
            }
            return this.canvas
        }
    },
    fieldTagNames: {
        315: "Artist",
        258: "BitsPerSample",
        265: "CellLength",
        264: "CellWidth",
        320: "ColorMap",
        259: "Compression",
        33432: "Copyright",
        306: "DateTime",
        338: "ExtraSamples",
        266: "FillOrder",
        289: "FreeByteCounts",
        288: "FreeOffsets",
        291: "GrayResponseCurve",
        290: "GrayResponseUnit",
        316: "HostComputer",
        270: "ImageDescription",
        257: "ImageLength",
        256: "ImageWidth",
        271: "Make",
        281: "MaxSampleValue",
        280: "MinSampleValue",
        272: "Model",
        254: "NewSubfileType",
        274: "Orientation",
        262: "PhotometricInterpretation",
        284: "PlanarConfiguration",
        296: "ResolutionUnit",
        278: "RowsPerStrip",
        277: "SamplesPerPixel",
        305: "Software",
        279: "StripByteCounts",
        273: "StripOffsets",
        255: "SubfileType",
        263: "Threshholding",
        282: "XResolution",
        283: "YResolution",
        326: "BadFaxLines",
        327: "CleanFaxData",
        343: "ClipPath",
        328: "ConsecutiveBadFaxLines",
        433: "Decode",
        434: "DefaultImageColor",
        269: "DocumentName",
        336: "DotRange",
        321: "HalftoneHints",
        346: "Indexed",
        347: "JPEGTables",
        285: "PageName",
        297: "PageNumber",
        317: "Predictor",
        319: "PrimaryChromaticities",
        532: "ReferenceBlackWhite",
        339: "SampleFormat",
        559: "StripRowCounts",
        330: "SubIFDs",
        292: "T4Options",
        293: "T6Options",
        325: "TileByteCounts",
        323: "TileLength",
        324: "TileOffsets",
        322: "TileWidth",
        301: "TransferFunction",
        318: "WhitePoint",
        344: "XClipPathUnits",
        286: "XPosition",
        529: "YCbCrCoefficients",
        531: "YCbCrPositioning",
        530: "YCbCrSubSampling",
        345: "YClipPathUnits",
        287: "YPosition",
        37378: "ApertureValue",
        40961: "ColorSpace",
        36868: "DateTimeDigitized",
        36867: "DateTimeOriginal",
        34665: "Exif IFD",
        36864: "ExifVersion",
        33434: "ExposureTime",
        41728: "FileSource",
        37385: "Flash",
        40960: "FlashpixVersion",
        33437: "FNumber",
        42016: "ImageUniqueID",
        37384: "LightSource",
        37500: "MakerNote",
        37377: "ShutterSpeedValue",
        37510: "UserComment",
        33723: "IPTC",
        34675: "ICC Profile",
        700: "XMP",
        42112: "GDAL_METADATA",
        42113: "GDAL_NODATA",
        34377: "Photoshop"
    },
    fieldTypeNames: {
        1: "BYTE",
        2: "ASCII",
        3: "SHORT",
        4: "LONG",
        5: "RATIONAL",
        6: "SBYTE",
        7: "UNDEFINED",
        8: "SSHORT",
        9: "SLONG",
        10: "SRATIONAL",
        11: "FLOAT",
        12: "DOUBLE"
    }
};
cc.PARTICLE_SHAPE_MODE = 0;
cc.PARTICLE_TEXTURE_MODE = 1;
cc.PARTICLE_STAR_SHAPE = 0;
cc.PARTICLE_BALL_SHAPE = 1;
cc.PARTICLE_DURATION_INFINITY = -1;
cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE = -1;
cc.PARTICLE_START_RADIUS_EQUAL_TO_END_RADIUS = -1;
cc.PARTICLE_MODE_GRAVITY = 0;
cc.PARTICLE_MODE_RADIUS = 1;
cc.PARTICLE_TYPE_FREE = 0;
cc.PARTICLE_TYPE_RELATIVE = 1;
cc.PARTICLE_TYPE_GROUPED = 2;
cc.Particle = function (a, b, c, d, e, f, g, h, k, m, n, p) {
    this.pos = a ? a : cc.p(0, 0);
    this.startPos = b ? b : cc.p(0, 0);
    this.color = c ? c : {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    };
    this.deltaColor = d ? d : {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    };
    this.size = e || 0;
    this.deltaSize = f || 0;
    this.rotation = g || 0;
    this.deltaRotation = h || 0;
    this.timeToLive = k || 0;
    this.atlasIndex = m || 0;
    this.modeA = n ? n : new cc.Particle.ModeA;
    this.modeB = p ? p : new cc.Particle.ModeB;
    this.isChangeColor = !1;
    this.drawPos = cc.p(0, 0)
};
cc.Particle.ModeA = function (a, b, c) {
    this.dir = a ? a : cc.p(0, 0);
    this.radialAccel = b || 0;
    this.tangentialAccel = c || 0
};
cc.Particle.ModeB = function (a, b, c, d) {
    this.angle = a || 0;
    this.degreesPerSecond = b || 0;
    this.radius = c || 0;
    this.deltaRadius = d || 0
};
cc.Particle.TemporaryPoints = [cc.p(), cc.p(), cc.p(), cc.p()];
cc.ParticleSystem = cc.Node.extend({
    _plistFile: "",
    _elapsed: 0,
    _dontTint: !1,
    modeA: null,
    modeB: null,
    _className: "ParticleSystem",
    _pointZeroForParticle: cc.p(0, 0),
    _particles: null,
    _emitCounter: 0,
    _particleIdx: 0,
    _batchNode: null,
    atlasIndex: 0,
    _transformSystemDirty: !1,
    _allocatedParticles: 0,
    drawMode: cc.PARTICLE_SHAPE_MODE,
    shapeType: cc.PARTICLE_BALL_SHAPE,
    _isActive: !1,
    particleCount: 0,
    duration: 0,
    _sourcePosition: null,
    _posVar: null,
    life: 0,
    lifeVar: 0,
    angle: 0,
    angleVar: 0,
    startSize: 0,
    startSizeVar: 0,
    endSize: 0,
    endSizeVar: 0,
    _startColor: null,
    _startColorVar: null,
    _endColor: null,
    _endColorVar: null,
    startSpin: 0,
    startSpinVar: 0,
    endSpin: 0,
    endSpinVar: 0,
    emissionRate: 0,
    _totalParticles: 0,
    _texture: null,
    _blendFunc: null,
    _opacityModifyRGB: !1,
    positionType: cc.PARTICLE_TYPE_FREE,
    autoRemoveOnFinish: !1,
    emitterMode: 0,
    _quads: null,
    _indices: null,
    _buffersVBO: null,
    _pointRect: null,
    _textureLoaded: null,
    _quadsArrayBuffer: null,
    ctor: function () {
        cc.Node.prototype.ctor.call(this);
        this.emitterMode = cc.PARTICLE_MODE_GRAVITY;
        this.modeA = new cc.ParticleSystem.ModeA;
        this.modeB = new cc.ParticleSystem.ModeB;
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._particles = [];
        this._sourcePosition = cc.p(0, 0);
        this._posVar = cc.p(0, 0);
        this._startColor = cc.color(255, 255, 255, 255);
        this._startColorVar = cc.color(255, 255, 255, 255);
        this._endColor = cc.color(255, 255, 255, 255);
        this._endColorVar = cc.color(255, 255, 255, 255);
        this._plistFile = "";
        this._elapsed = 0;
        this._dontTint = !1;
        this._pointZeroForParticle = cc.p(0, 0);
        this._particleIdx = this._emitCounter = 0;
        this._batchNode = null;
        this.atlasIndex =
            0;
        this._transformSystemDirty = !1;
        this._allocatedParticles = 0;
        this.drawMode = cc.PARTICLE_SHAPE_MODE;
        this.shapeType = cc.PARTICLE_BALL_SHAPE;
        this._isActive = !1;
        this._totalParticles = this.emissionRate = this.endSpinVar = this.endSpin = this.startSpinVar = this.startSpin = this.endSizeVar = this.endSize = this.startSizeVar = this.startSize = this.angleVar = this.angle = this.lifeVar = this.life = this.duration = this.particleCount = 0;
        this._texture = null;
        this._opacityModifyRGB = !1;
        this.positionType = cc.PARTICLE_TYPE_FREE;
        this.autoRemoveOnFinish = !1;
        this._buffersVBO = [0, 0];
        this._quads = [];
        this._indices = [];
        this._pointRect = cc.rect(0, 0, 0, 0);
        this._textureLoaded = !0;
        cc._renderType === cc._RENDER_TYPE_WEBGL && (this._quadsArrayBuffer = null)
    },
    initIndices: function () {
        for (var a = this._indices, b = 0, c = this._totalParticles; b < c; ++b) {
            var d = 6 * b,
                e = 4 * b;
            a[d + 0] = e + 0;
            a[d + 1] = e + 1;
            a[d + 2] = e + 2;
            a[d + 5] = e + 1;
            a[d + 4] = e + 2;
            a[d + 3] = e + 3
        }
    },
    initTexCoordsWithRect: function (a) {
        var b = cc.CONTENT_SCALE_FACTOR(),
            c = cc.rect(a.x * b, a.y * b, a.width * b, a.height * b),
            d = a.width,
            e = a.height;
        this._texture && (d =
            this._texture.pixelsWidth, e = this._texture.pixelsHeight);
        if (cc._renderType !== cc._RENDER_TYPE_CANVAS) {
            cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (a = (2 * c.x + 1) / (2 * d), b = (2 * c.y + 1) / (2 * e), d = a + (2 * c.width - 2) / (2 * d), c = b + (2 * c.height - 2) / (2 * e)) : (a = c.x / d, b = c.y / e, d = a + c.width / d, c = b + c.height / e);
            var e = c,
                c = b,
                b = e,
                f = 0,
                g = 0;
            this._batchNode ? (e = this._batchNode.textureAtlas.quads, f = this.atlasIndex, g = this.atlasIndex + this._totalParticles) : (e = this._quads, f = 0, g = this._totalParticles);
            for (; f < g; f++) {
                e[f] || (e[f] = cc.V3F_C4B_T2F_QuadZero());
                var h = e[f];
                h.bl.texCoords.u = a;
                h.bl.texCoords.v = b;
                h.br.texCoords.u = d;
                h.br.texCoords.v = b;
                h.tl.texCoords.u = a;
                h.tl.texCoords.v = c;
                h.tr.texCoords.u = d;
                h.tr.texCoords.v = c
            }
        }
    },
    getBatchNode: function () {
        return this._batchNode
    },
    setBatchNode: function (a) {
        if (this._batchNode != a) {
            var b = this._batchNode;
            if (this._batchNode = a)
                for (var c = this._particles, d = 0; d < this._totalParticles; d++) c[d].atlasIndex = d;
            a ? b || (this._batchNode.textureAtlas._copyQuadsToTextureAtlas(this._quads, this.atlasIndex), cc._renderContext.deleteBuffer(this._buffersVBO[1])) :
                (this._allocMemory(), this.initIndices(), this.setTexture(b.getTexture()), this._setupVBO())
        }
    },
    getAtlasIndex: function () {
        return this.atlasIndex
    },
    setAtlasIndex: function (a) {
        this.atlasIndex = a
    },
    getDrawMode: function () {
        return this.drawMode
    },
    setDrawMode: function (a) {
        this.drawMode = a
    },
    getShapeType: function () {
        return this.shapeType
    },
    setShapeType: function (a) {
        this.shapeType = a
    },
    isActive: function () {
        return this._isActive
    },
    getParticleCount: function () {
        return this.particleCount
    },
    setParticleCount: function (a) {
        this.particleCount =
            a
    },
    getDuration: function () {
        return this.duration
    },
    setDuration: function (a) {
        this.duration = a
    },
    getSourcePosition: function () {
        return {
            x: this._sourcePosition.x,
            y: this._sourcePosition.y
        }
    },
    setSourcePosition: function (a) {
        this._sourcePosition = a
    },
    getPosVar: function () {
        return {
            x: this._posVar.x,
            y: this._posVar.y
        }
    },
    setPosVar: function (a) {
        this._posVar = a
    },
    getLife: function () {
        return this.life
    },
    setLife: function (a) {
        this.life = a
    },
    getLifeVar: function () {
        return this.lifeVar
    },
    setLifeVar: function (a) {
        this.lifeVar = a
    },
    getAngle: function () {
        return this.angle
    },
    setAngle: function (a) {
        this.angle = a
    },
    getAngleVar: function () {
        return this.angleVar
    },
    setAngleVar: function (a) {
        this.angleVar = a
    },
    getGravity: function () {
        this.emitterMode !== cc.PARTICLE_MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getGravity() : Particle Mode should be Gravity");
        var a = this.modeA.gravity;
        return cc.p(a.x, a.y)
    },
    setGravity: function (a) {
        this.emitterMode !== cc.PARTICLE_MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setGravity() : Particle Mode should be Gravity");
        this.modeA.gravity = a
    },
    getSpeed: function () {
        this.emitterMode !==
            cc.PARTICLE_MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeed() : Particle Mode should be Gravity");
        return this.modeA.speed
    },
    setSpeed: function (a) {
        this.emitterMode !== cc.PARTICLE_MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeed() : Particle Mode should be Gravity");
        this.modeA.speed = a
    },
    getSpeedVar: function () {
        this.emitterMode !== cc.PARTICLE_MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeedVar() : Particle Mode should be Gravity");
        return this.modeA.speedVar
    },
    setSpeedVar: function (a) {
        this.emitterMode !==
            cc.PARTICLE_MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeedVar() : Particle Mode should be Gravity");
        this.modeA.speedVar = a
    },
    getTangentialAccel: function () {
        this.emitterMode !== cc.PARTICLE_MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccel() : Particle Mode should be Gravity");
        return this.modeA.tangentialAccel
    },
    setTangentialAccel: function (a) {
        this.emitterMode !== cc.PARTICLE_MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccel() : Particle Mode should be Gravity");
        this.modeA.tangentialAccel =
            a
    },
    getTangentialAccelVar: function () {
        this.emitterMode !== cc.PARTICLE_MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccelVar() : Particle Mode should be Gravity");
        return this.modeA.tangentialAccelVar
    },
    setTangentialAccelVar: function (a) {
        this.emitterMode !== cc.PARTICLE_MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccelVar() : Particle Mode should be Gravity");
        this.modeA.tangentialAccelVar = a
    },
    getRadialAccel: function () {
        this.emitterMode !== cc.PARTICLE_MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccel() : Particle Mode should be Gravity");
        return this.modeA.radialAccel
    },
    setRadialAccel: function (a) {
        this.emitterMode !== cc.PARTICLE_MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccel() : Particle Mode should be Gravity");
        this.modeA.radialAccel = a
    },
    getRadialAccelVar: function () {
        this.emitterMode !== cc.PARTICLE_MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccelVar() : Particle Mode should be Gravity");
        return this.modeA.radialAccelVar
    },
    setRadialAccelVar: function (a) {
        this.emitterMode !== cc.PARTICLE_MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccelVar() : Particle Mode should be Gravity");
        this.modeA.radialAccelVar = a
    },
    getRotationIsDir: function () {
        this.emitterMode !== cc.PARTICLE_MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRotationIsDir() : Particle Mode should be Gravity");
        return this.modeA.rotationIsDir
    },
    setRotationIsDir: function (a) {
        this.emitterMode !== cc.PARTICLE_MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRotationIsDir() : Particle Mode should be Gravity");
        this.modeA.rotationIsDir = a
    },
    getStartRadius: function () {
        this.emitterMode !== cc.PARTICLE_MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadius() : Particle Mode should be Radius");
        return this.modeB.startRadius
    },
    setStartRadius: function (a) {
        this.emitterMode !== cc.PARTICLE_MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadius() : Particle Mode should be Radius");
        this.modeB.startRadius = a
    },
    getStartRadiusVar: function () {
        this.emitterMode !== cc.PARTICLE_MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadiusVar() : Particle Mode should be Radius");
        return this.modeB.startRadiusVar
    },
    setStartRadiusVar: function (a) {
        this.emitterMode !== cc.PARTICLE_MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadiusVar() : Particle Mode should be Radius");
        this.modeB.startRadiusVar = a
    },
    getEndRadius: function () {
        this.emitterMode !== cc.PARTICLE_MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadius() : Particle Mode should be Radius");
        return this.modeB.endRadius
    },
    setEndRadius: function (a) {
        this.emitterMode !== cc.PARTICLE_MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadius() : Particle Mode should be Radius");
        this.modeB.endRadius = a
    },
    getEndRadiusVar: function () {
        this.emitterMode !== cc.PARTICLE_MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadiusVar() : Particle Mode should be Radius");
        return this.modeB.endRadiusVar
    },
    setEndRadiusVar: function (a) {
        this.emitterMode !== cc.PARTICLE_MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadiusVar() : Particle Mode should be Radius");
        this.modeB.endRadiusVar = a
    },
    getRotatePerSecond: function () {
        this.emitterMode !== cc.PARTICLE_MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecond() : Particle Mode should be Radius");
        return this.modeB.rotatePerSecond
    },
    setRotatePerSecond: function (a) {
        this.emitterMode !== cc.PARTICLE_MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecond() : Particle Mode should be Radius");
        this.modeB.rotatePerSecond = a
    },
    getRotatePerSecondVar: function () {
        this.emitterMode !== cc.PARTICLE_MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecondVar() : Particle Mode should be Radius");
        return this.modeB.rotatePerSecondVar
    },
    setRotatePerSecondVar: function (a) {
        this.emitterMode !== cc.PARTICLE_MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecondVar() : Particle Mode should be Radius");
        this.modeB.rotatePerSecondVar = a
    },
    setScale: function (a, b) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setScale.call(this,
            a, b)
    },
    setRotation: function (a) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setRotation.call(this, a)
    },
    setScaleX: function (a) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setScaleX.call(this, a)
    },
    setScaleY: function (a) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setScaleY.call(this, a)
    },
    getStartSize: function () {
        return this.startSize
    },
    setStartSize: function (a) {
        this.startSize = a
    },
    getStartSizeVar: function () {
        return this.startSizeVar
    },
    setStartSizeVar: function (a) {
        this.startSizeVar = a
    },
    getEndSize: function () {
        return this.endSize
    },
    setEndSize: function (a) {
        this.endSize = a
    },
    getEndSizeVar: function () {
        return this.endSizeVar
    },
    setEndSizeVar: function (a) {
        this.endSizeVar = a
    },
    getStartColor: function () {
        return this._startColor
    },
    setStartColor: function (a) {
        this._startColor = cc.color(a)
    },
    getStartColorVar: function () {
        return this._startColorVar
    },
    setStartColorVar: function (a) {
        this._startColorVar = cc.color(a)
    },
    getEndColor: function () {
        return this._endColor
    },
    setEndColor: function (a) {
        this._endColor = cc.color(a)
    },
    getEndColorVar: function () {
        return this._endColorVar
    },
    setEndColorVar: function (a) {
        this._endColorVar = cc.color(a)
    },
    getStartSpin: function () {
        return this.startSpin
    },
    setStartSpin: function (a) {
        this.startSpin = a
    },
    getStartSpinVar: function () {
        return this.startSpinVar
    },
    setStartSpinVar: function (a) {
        this.startSpinVar = a
    },
    getEndSpin: function () {
        return this.endSpin
    },
    setEndSpin: function (a) {
        this.endSpin = a
    },
    getEndSpinVar: function () {
        return this.endSpinVar
    },
    setEndSpinVar: function (a) {
        this.endSpinVar = a
    },
    getEmissionRate: function () {
        return this.emissionRate
    },
    setEmissionRate: function (a) {
        this.emissionRate =
            a
    },
    getTotalParticles: function () {
        return this._totalParticles
    },
    setTotalParticles: function (a) {
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) this._totalParticles = 200 > a ? a : 200;
        else {
            if (a > this._allocatedParticles) {
                var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                this._indices = new Uint16Array(6 * a);
                var c = new ArrayBuffer(a * b),
                    d = this._particles;
                d.length = 0;
                for (var e = this._quads, f = e.length = 0; f < a; f++) d[f] = new cc.Particle, e[f] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, c, f * b);
                this._totalParticles = this._allocatedParticles =
                    a;
                if (this._batchNode)
                    for (b = 0; b < a; b++) d[b].atlasIndex = b;
                this._quadsArrayBuffer = c;
                this.initIndices();
                this._setupVBO();
                this._texture && this.initTexCoordsWithRect(cc.rect(0, 0, this._texture.width, this._texture.height))
            } else this._totalParticles = a;
            this.resetSystem()
        }
    },
    getTexture: function () {
        return this._texture
    },
    setTexture: function (a) {
        a.isLoaded() ? this.setTextureWithRect(a, cc.rect(0, 0, a.width, a.height)) : (this._textureLoaded = !1, a.addLoadedEventListener(function (a) {
            this._textureLoaded = !0;
            this.setTextureWithRect(a,
                cc.rect(0, 0, a.width, a.height))
        }, this))
    },
    getBlendFunc: function () {
        return this._blendFunc
    },
    setBlendFunc: function (a, b) {
        if (void 0 === b) this._blendFunc != a && (this._blendFunc = a, this._updateBlendFunc());
        else if (this._blendFunc.src != a || this._blendFunc.dst != b) this._blendFunc = {
            src: a,
            dst: b
        }, this._updateBlendFunc()
    },
    isOpacityModifyRGB: function () {
        return this._opacityModifyRGB
    },
    setOpacityModifyRGB: function (a) {
        this._opacityModifyRGB = a
    },
    isBlendAdditive: function () {
        return this._blendFunc.src == cc.SRC_ALPHA && this._blendFunc.dst ==
            cc.ONE || this._blendFunc.src == cc.ONE && this._blendFunc.dst == cc.ONE
    },
    setBlendAdditive: function (a) {
        var b = this._blendFunc;
        a ? (b.src = cc.SRC_ALPHA, b.dst = cc.ONE) : cc._renderType === cc._RENDER_TYPE_WEBGL ? this._texture && !this._texture.hasPremultipliedAlpha() ? (b.src = cc.SRC_ALPHA, b.dst = cc.ONE_MINUS_SRC_ALPHA) : (b.src = cc.BLEND_SRC, b.dst = cc.BLEND_DST) : (b.src = cc.BLEND_SRC, b.dst = cc.BLEND_DST)
    },
    getPositionType: function () {
        return this.positionType
    },
    setPositionType: function (a) {
        this.positionType = a
    },
    isAutoRemoveOnFinish: function () {
        return this.autoRemoveOnFinish
    },
    setAutoRemoveOnFinish: function (a) {
        this.autoRemoveOnFinish = a
    },
    getEmitterMode: function () {
        return this.emitterMode
    },
    setEmitterMode: function (a) {
        this.emitterMode = a
    },
    init: function () {
        return this.initWithTotalParticles(150)
    },
    initWithFile: function (a) {
        this._plistFile = a;
        a = cc.loader.getRes(a);
        return a ? this.initWithDictionary(a, "") : (cc.log("cc.ParticleSystem.initWithFile(): Particles: file not found"), !1)
    },
    getBoundingBoxToWorld: function () {
        return cc.rect(0, 0, cc._canvas.width, cc._canvas.height)
    },
    initWithDictionary: function (a,
        b) {
        var c = !1,
            d = null,
            d = this._valueForKey,
            e = parseInt(d("maxParticles", a));
        if (this.initWithTotalParticles(e)) {
            this.angle = parseFloat(d("angle", a));
            this.angleVar = parseFloat(d("angleVariance", a));
            this.duration = parseFloat(d("duration", a));
            this._blendFunc.src = parseInt(d("blendFuncSource", a));
            this._blendFunc.dst = parseInt(d("blendFuncDestination", a));
            c = this._startColor;
            c.r = 255 * parseFloat(d("startColorRed", a));
            c.g = 255 * parseFloat(d("startColorGreen", a));
            c.b = 255 * parseFloat(d("startColorBlue", a));
            c.a = 255 * parseFloat(d("startColorAlpha",
                a));
            c = this._startColorVar;
            c.r = 255 * parseFloat(d("startColorVarianceRed", a));
            c.g = 255 * parseFloat(d("startColorVarianceGreen", a));
            c.b = 255 * parseFloat(d("startColorVarianceBlue", a));
            c.a = 255 * parseFloat(d("startColorVarianceAlpha", a));
            c = this._endColor;
            c.r = 255 * parseFloat(d("finishColorRed", a));
            c.g = 255 * parseFloat(d("finishColorGreen", a));
            c.b = 255 * parseFloat(d("finishColorBlue", a));
            c.a = 255 * parseFloat(d("finishColorAlpha", a));
            c = this._endColorVar;
            c.r = 255 * parseFloat(d("finishColorVarianceRed", a));
            c.g = 255 * parseFloat(d("finishColorVarianceGreen",
                a));
            c.b = 255 * parseFloat(d("finishColorVarianceBlue", a));
            c.a = 255 * parseFloat(d("finishColorVarianceAlpha", a));
            this.startSize = parseFloat(d("startParticleSize", a));
            this.startSizeVar = parseFloat(d("startParticleSizeVariance", a));
            this.endSize = parseFloat(d("finishParticleSize", a));
            this.endSizeVar = parseFloat(d("finishParticleSizeVariance", a));
            this.setPosition(parseFloat(d("sourcePositionx", a)), parseFloat(d("sourcePositiony", a)));
            this._posVar.x = parseFloat(d("sourcePositionVariancex", a));
            this._posVar.y = parseFloat(d("sourcePositionVariancey",
                a));
            this.startSpin = parseFloat(d("rotationStart", a));
            this.startSpinVar = parseFloat(d("rotationStartVariance", a));
            this.endSpin = parseFloat(d("rotationEnd", a));
            this.endSpinVar = parseFloat(d("rotationEndVariance", a));
            this.emitterMode = parseInt(d("emitterType", a));
            if (this.emitterMode == cc.PARTICLE_MODE_GRAVITY) c = this.modeA, c.gravity.x = parseFloat(d("gravityx", a)), c.gravity.y = parseFloat(d("gravityy", a)), c.speed = parseFloat(d("speed", a)), c.speedVar = parseFloat(d("speedVariance", a)), e = d("radialAcceleration", a), c.radialAccel =
                e ? parseFloat(e) : 0, e = d("radialAccelVariance", a), c.radialAccelVar = e ? parseFloat(e) : 0, e = d("tangentialAcceleration", a), c.tangentialAccel = e ? parseFloat(e) : 0, e = d("tangentialAccelVariance", a), c.tangentialAccelVar = e ? parseFloat(e) : 0, e = d("rotationIsDir", a).toLowerCase(), c.rotationIsDir = null != e && ("true" === e || "1" === e);
            else if (this.emitterMode == cc.PARTICLE_MODE_RADIUS) c = this.modeB, c.startRadius = parseFloat(d("maxRadius", a)), c.startRadiusVar = parseFloat(d("maxRadiusVariance", a)), c.endRadius = parseFloat(d("minRadius",
                a)), c.endRadiusVar = 0, c.rotatePerSecond = parseFloat(d("rotatePerSecond", a)), c.rotatePerSecondVar = parseFloat(d("rotatePerSecondVariance", a));
            else return cc.log("cc.ParticleSystem.initWithDictionary(): Invalid emitterType in config file"), !1;
            this.life = parseFloat(d("particleLifespan", a));
            this.lifeVar = parseFloat(d("particleLifespanVariance", a));
            this.emissionRate = this._totalParticles / this.life;
            if (!this._batchNode)
                if (this._opacityModifyRGB = !1, c = d("textureFileName", a), c = cc.path.changeBasename(this._plistFile,
                    c), e = cc.textureCache.textureForKey(c)) this.setTexture(e);
                else if ((d = d("textureImageData", a)) && 0 == d.length) {
                e = cc.textureCache.addImage(c);
                if (!e) return !1;
                this.setTexture(e)
            } else {
                d = cc.unzipBase64AsArray(d, 1);
                if (!d) return cc.log("cc.ParticleSystem: error decoding or ungzipping textureImageData"), !1;
                e = cc.getImageFormatByData(d);
                if (e !== cc.FMT_TIFF && e !== cc.FMT_PNG) return cc.log("cc.ParticleSystem: unknown image format with Data"), !1;
                var f = document.createElement("canvas");
                e === cc.FMT_PNG ? (new cc.PNGReader(d)).render(f) :
                    cc.tiffReader.parseTIFF(d, f);
                cc.textureCache.cacheImage(c, f);
                (d = cc.textureCache.textureForKey(c)) || cc.log("cc.ParticleSystem.initWithDictionary() : error loading the texture");
                this.setTexture(d)
            }
            c = !0
        }
        return c
    },
    initWithTotalParticles: function (a) {
        this._totalParticles = a;
        var b, c = this._particles;
        for (b = c.length = 0; b < a; b++) c[b] = new cc.Particle;
        if (!c) return cc.log("Particle system: not enough memory"), !1;
        this._allocatedParticles = a;
        if (this._batchNode)
            for (b = 0; b < this._totalParticles; b++) c[b].atlasIndex = b;
        this._isActive = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this.positionType = cc.PARTICLE_TYPE_FREE;
        this.emitterMode = cc.PARTICLE_MODE_GRAVITY;
        this._transformSystemDirty = this.autoRemoveOnFinish = !1;
        this.scheduleUpdateWithPriority(1);
        if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
            if (!this._allocMemory()) return !1;
            this.initIndices();
            this._setupVBO();
            this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
        }
        return !0
    },
    destroyParticleSystem: function () {
        this.unscheduleUpdate()
    },
    addParticle: function () {
        if (this.isFull()) return !1;
        var a, b = this._particles;
        cc._renderType === cc._RENDER_TYPE_CANVAS ? this.particleCount < b.length ? a = b[this.particleCount] : (a = new cc.Particle, b.push(a)) : a = b[this.particleCount];
        this.initParticle(a);
        ++this.particleCount;
        return !0
    },
    initParticle: function (a) {
        var b = cc.RANDOM_MINUS1_1;
        a.timeToLive = this.life + this.lifeVar * b();
        a.timeToLive = Math.max(0, a.timeToLive);
        a.pos.x = this._sourcePosition.x + this._posVar.x * b();
        a.pos.y = this._sourcePosition.y + this._posVar.y * b();
        var c,
            d;
        c = this._startColor;
        var e = this._startColorVar,
            f = this._endColor;
        d = this._endColorVar;
        cc._renderType === cc._RENDER_TYPE_CANVAS ? (c = cc.color(cc.clampf(c.r + e.r * b(), 0, 255), cc.clampf(c.g + e.g * b(), 0, 255), cc.clampf(c.b + e.b * b(), 0, 255), cc.clampf(c.a + e.a * b(), 0, 255)), d = cc.color(cc.clampf(f.r + d.r * b(), 0, 255), cc.clampf(f.g + d.g * b(), 0, 255), cc.clampf(f.b + d.b * b(), 0, 255), cc.clampf(f.a + d.a * b(), 0, 255))) : (c = {
            r: cc.clampf(c.r + e.r * b(), 0, 255),
            g: cc.clampf(c.g + e.g * b(), 0, 255),
            b: cc.clampf(c.b + e.b * b(), 0, 255),
            a: cc.clampf(c.a + e.a * b(),
                0, 255)
        }, d = {
            r: cc.clampf(f.r + d.r * b(), 0, 255),
            g: cc.clampf(f.g + d.g * b(), 0, 255),
            b: cc.clampf(f.b + d.b * b(), 0, 255),
            a: cc.clampf(f.a + d.a * b(), 0, 255)
        });
        a.color = c;
        e = a.deltaColor;
        f = a.timeToLive;
        e.r = (d.r - c.r) / f;
        e.g = (d.g - c.g) / f;
        e.b = (d.b - c.b) / f;
        e.a = (d.a - c.a) / f;
        c = this.startSize + this.startSizeVar * b();
        c = Math.max(0, c);
        a.size = c;
        this.endSize === cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE ? a.deltaSize = 0 : (d = this.endSize + this.endSizeVar * b(), d = Math.max(0, d), a.deltaSize = (d - c) / f);
        c = this.startSpin + this.startSpinVar * b();
        d = this.endSpin +
            this.endSpinVar * b();
        a.rotation = c;
        a.deltaRotation = (d - c) / f;
        this.positionType == cc.PARTICLE_TYPE_FREE ? a.startPos = this.convertToWorldSpace(this._pointZeroForParticle) : this.positionType == cc.PARTICLE_TYPE_RELATIVE && (a.startPos.x = this._position.x, a.startPos.y = this._position.y);
        c = cc.DEGREES_TO_RADIANS(this.angle + this.angleVar * b());
        if (this.emitterMode === cc.PARTICLE_MODE_GRAVITY) f = this.modeA, d = a.modeA, e = f.speed + f.speedVar * b(), d.dir.x = Math.cos(c), d.dir.y = Math.sin(c), cc.pMultIn(d.dir, e), d.radialAccel = f.radialAccel +
            f.radialAccelVar * b(), d.tangentialAccel = f.tangentialAccel + f.tangentialAccelVar * b(), f.rotationIsDir && (a.rotation = -cc.RADIANS_TO_DEGREES(cc.pToAngle(d.dir)));
        else {
            d = this.modeB;
            a = a.modeB;
            var e = d.startRadius + d.startRadiusVar * b(),
                g = d.endRadius + d.endRadiusVar * b();
            a.radius = e;
            a.deltaRadius = d.endRadius === cc.PARTICLE_START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (g - e) / f;
            a.angle = c;
            a.degreesPerSecond = cc.DEGREES_TO_RADIANS(d.rotatePerSecond + d.rotatePerSecondVar * b())
        }
    },
    stopSystem: function () {
        this._isActive = !1;
        this._elapsed =
            this.duration;
        this._emitCounter = 0
    },
    resetSystem: function () {
        this._isActive = !0;
        this._elapsed = 0;
        var a = this._particles;
        for (this._particleIdx = 0; this._particleIdx < this.particleCount; ++this._particleIdx) a[this._particleIdx].timeToLive = 0
    },
    isFull: function () {
        return this.particleCount >= this._totalParticles
    },
    updateQuadWithParticle: function (a, b) {
        var c = null;
        this._batchNode ? (c = this._batchNode.textureAtlas.quads[this.atlasIndex + a.atlasIndex], this._batchNode.textureAtlas.dirty = !0) : c = this._quads[this._particleIdx];
        var d, e, f, g;
        this._opacityModifyRGB ? (d = 0 | a.color.r * a.color.a / 255, e = 0 | a.color.g * a.color.a / 255, f = 0 | a.color.b * a.color.a / 255) : (d = 0 | a.color.r, e = 0 | a.color.g, f = 0 | a.color.b);
        g = 0 | a.color.a;
        var h = c.bl.colors;
        h.r = d;
        h.g = e;
        h.b = f;
        h.a = g;
        h = c.br.colors;
        h.r = d;
        h.g = e;
        h.b = f;
        h.a = g;
        h = c.tl.colors;
        h.r = d;
        h.g = e;
        h.b = f;
        h.a = g;
        h = c.tr.colors;
        h.r = d;
        h.g = e;
        h.b = f;
        h.a = g;
        d = a.size / 2;
        if (a.rotation) {
            e = -d;
            f = -d;
            g = b.x;
            var h = b.y,
                k = -cc.DEGREES_TO_RADIANS(a.rotation),
                m = Math.cos(k),
                k = Math.sin(k);
            c.bl.vertices.x = e * m - f * k + g;
            c.bl.vertices.y = e * k + f * m +
                h;
            c.br.vertices.x = d * m - f * k + g;
            c.br.vertices.y = d * k + f * m + h;
            c.tl.vertices.x = e * m - d * k + g;
            c.tl.vertices.y = e * k + d * m + h;
            c.tr.vertices.x = d * m - d * k + g;
            c.tr.vertices.y = d * k + d * m + h
        } else c.bl.vertices.x = b.x - d, c.bl.vertices.y = b.y - d, c.br.vertices.x = b.x + d, c.br.vertices.y = b.y - d, c.tl.vertices.x = b.x - d, c.tl.vertices.y = b.y + d, c.tr.vertices.x = b.x + d, c.tr.vertices.y = b.y + d
    },
    postStep: function () {
        if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
            var a = cc._renderContext;
            a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]);
            a.bufferData(a.ARRAY_BUFFER,
                this._quadsArrayBuffer, a.DYNAMIC_DRAW)
        }
    },
    update: function (a) {
        if (this._isActive && this.emissionRate) {
            var b = 1 / this.emissionRate;
            this.particleCount < this._totalParticles && (this._emitCounter += a);
            for (; this.particleCount < this._totalParticles && this._emitCounter > b;) this.addParticle(), this._emitCounter -= b;
            this._elapsed += a; - 1 != this.duration && this.duration < this._elapsed && this.stopSystem()
        }
        this._particleIdx = 0;
        b = cc.Particle.TemporaryPoints[0];
        this.positionType == cc.PARTICLE_TYPE_FREE ? cc.pIn(b, this.convertToWorldSpace(this._pointZeroForParticle)) :
            this.positionType == cc.PARTICLE_TYPE_RELATIVE && (b.x = this._position.x, b.y = this._position.y);
        if (this._visible) {
            for (var c = cc.Particle.TemporaryPoints[1], d = cc.Particle.TemporaryPoints[2], e = cc.Particle.TemporaryPoints[3], f = this._particles; this._particleIdx < this.particleCount;) {
                cc.pZeroIn(c);
                cc.pZeroIn(d);
                cc.pZeroIn(e);
                var g = f[this._particleIdx];
                g.timeToLive -= a;
                if (0 < g.timeToLive) {
                    if (this.emitterMode == cc.PARTICLE_MODE_GRAVITY) {
                        var h = e,
                            k = c,
                            m = d;
                        g.pos.x || g.pos.y ? (cc.pIn(k, g.pos), cc.pNormalizeIn(k)) : cc.pZeroIn(k);
                        cc.pIn(m, k);
                        cc.pMultIn(k, g.modeA.radialAccel);
                        var n = m.x;
                        m.x = -m.y;
                        m.y = n;
                        cc.pMultIn(m, g.modeA.tangentialAccel);
                        cc.pIn(h, k);
                        cc.pAddIn(h, m);
                        cc.pAddIn(h, this.modeA.gravity);
                        cc.pMultIn(h, a);
                        cc.pAddIn(g.modeA.dir, h);
                        cc.pIn(h, g.modeA.dir);
                        cc.pMultIn(h, a);
                        cc.pAddIn(g.pos, h)
                    } else h = g.modeB, h.angle += h.degreesPerSecond * a, h.radius += h.deltaRadius * a, g.pos.x = -Math.cos(h.angle) * h.radius, g.pos.y = -Math.sin(h.angle) * h.radius;
                    this._dontTint || (g.color.r += g.deltaColor.r * a, g.color.g += g.deltaColor.g * a, g.color.b += g.deltaColor.b *
                        a, g.color.a += g.deltaColor.a * a, g.isChangeColor = !0);
                    g.size += g.deltaSize * a;
                    g.size = Math.max(0, g.size);
                    g.rotation += g.deltaRotation * a;
                    h = c;
                    this.positionType == cc.PARTICLE_TYPE_FREE || this.positionType == cc.PARTICLE_TYPE_RELATIVE ? (k = d, cc.pIn(k, b), cc.pSubIn(k, g.startPos), cc.pIn(h, g.pos), cc.pSubIn(h, k)) : cc.pIn(h, g.pos);
                    this._batchNode && (h.x += this._position.x, h.y += this._position.y);
                    cc._renderType == cc._RENDER_TYPE_WEBGL ? this.updateQuadWithParticle(g, h) : cc.pIn(g.drawPos, h);
                    ++this._particleIdx
                } else if (g = g.atlasIndex,
                    this._particleIdx !== this.particleCount - 1 && (h = f[this._particleIdx], f[this._particleIdx] = f[this.particleCount - 1], f[this.particleCount - 1] = h), this._batchNode && (this._batchNode.disableParticle(this.atlasIndex + g), f[this.particleCount - 1].atlasIndex = g), --this.particleCount, 0 == this.particleCount && this.autoRemoveOnFinish) {
                    this.unscheduleUpdate();
                    this._parent.removeChild(this, !0);
                    return
                }
            }
            this._transformSystemDirty = !1
        }
        this._batchNode || this.postStep()
    },
    updateWithNoTime: function () {
        this.update(0)
    },
    _valueForKey: function (a,
        b) {
        if (b) {
            var c = b[a];
            return null != c ? c : ""
        }
        return ""
    },
    _updateBlendFunc: function () {
        if (this._batchNode) cc.log("Can't change blending functions when the particle is being batched");
        else {
            var a = this._texture;
            if (a && a instanceof cc.Texture2D) {
                this._opacityModifyRGB = !1;
                var b = this._blendFunc;
                b.src == cc.BLEND_SRC && b.dst == cc.BLEND_DST && (a.hasPremultipliedAlpha() ? this._opacityModifyRGB = !0 : (b.src = cc.SRC_ALPHA, b.dst = cc.ONE_MINUS_SRC_ALPHA))
            }
        }
    },
    clone: function () {
        var a = new cc.ParticleSystem;
        if (a.initWithTotalParticles(this._totalParticles)) {
            a.angle =
                this.angle;
            a.angleVar = this.angleVar;
            a.duration = this.duration;
            a._blendFunc.src = this._blendFunc.src;
            a._blendFunc.dst = this._blendFunc.dst;
            var b = a._startColor,
                c = this._startColor;
            b.r = c.r;
            b.g = c.g;
            b.b = c.b;
            b.a = c.a;
            b = a._startColorVar;
            c = this._startColorVar;
            b.r = c.r;
            b.g = c.g;
            b.b = c.b;
            b.a = c.a;
            b = a._endColor;
            c = this._endColor;
            b.r = c.r;
            b.g = c.g;
            b.b = c.b;
            b.a = c.a;
            b = a._endColorVar;
            c = this._endColorVar;
            b.r = c.r;
            b.g = c.g;
            b.b = c.b;
            b.a = c.a;
            a.startSize = this.startSize;
            a.startSizeVar = this.startSizeVar;
            a.endSize = this.endSize;
            a.endSizeVar =
                this.endSizeVar;
            a.x = this._position.x;
            a.y = this._position.y;
            a._posVar.x = this._posVar.x;
            a._posVar.y = this._posVar.y;
            a.startSpin = this.startSpin;
            a.startSpinVar = this.startSpinVar;
            a.endSpin = this.endSpin;
            a.endSpinVar = this.endSpinVar;
            a.emitterMode = this.emitterMode;
            this.emitterMode == cc.PARTICLE_MODE_GRAVITY ? (b = a.modeA, c = this.modeA, b.gravity.x = c.gravity.x, b.gravity.y = c.gravity.y, b.speed = c.speed, b.speedVar = c.speedVar, b.radialAccel = c.radialAccel, b.radialAccelVar = c.radialAccelVar, b.tangentialAccel = c.tangentialAccel,
                b.tangentialAccelVar = c.tangentialAccelVar) : this.emitterMode == cc.PARTICLE_MODE_RADIUS && (b = a.modeB, c = this.modeB, b.startRadius = c.startRadius, b.startRadiusVar = c.startRadiusVar, b.endRadius = c.endRadius, b.endRadiusVar = c.endRadiusVar, b.rotatePerSecond = c.rotatePerSecond, b.rotatePerSecondVar = c.rotatePerSecondVar);
            a.life = this.life;
            a.lifeVar = this.lifeVar;
            a.emissionRate = this.emissionRate;
            this._batchNode || (a._opacityModifyRGB = this._opacityModifyRGB, a._texture = this._texture)
        }
        return a
    },
    setDisplayFrame: function (a) {
        var b =
            a.getOffsetInPixels();
        0 == b.x && 0 == b.y || cc.log("cc.ParticleSystem.setDisplayFrame(): QuadParticle only supports SpriteFrames with no offsets");
        cc._renderType === cc._RENDER_TYPE_WEBGL && (this._texture && a.getTexture()._webTextureObj == this._texture._webTextureObj || this.setTexture(a.getTexture()))
    },
    setTextureWithRect: function (a, b) {
        var c = this._texture;
        cc._renderType === cc._RENDER_TYPE_WEBGL ? c && a._webTextureObj == c._webTextureObj || c == a || (this._texture = a, this._updateBlendFunc()) : c && a == c || c == a || (this._texture =
            a, this._updateBlendFunc());
        this._pointRect = b;
        this.initTexCoordsWithRect(b)
    },
    draw: function (a) {
        this._textureLoaded && !this._batchNode && (cc._renderType === cc._RENDER_TYPE_CANVAS ? this._drawForCanvas(a) : this._drawForWebGL(a), cc.g_NumberOfDraws++)
    },
    _drawForCanvas: function (a) {
        a = a || cc._renderContext;
        a.save();
        this.isBlendAdditive() ? a.globalCompositeOperation = "lighter" : a.globalCompositeOperation = "source-over";
        for (var b = 0; b < this.particleCount; b++) {
            var c = this._particles[b],
                d = 0 | 0.5 * c.size;
            if (this.drawMode == cc.PARTICLE_TEXTURE_MODE) {
                if (d =
                    this._texture.getHtmlElementObj(), d.width && d.height) {
                    a.save();
                    a.globalAlpha = c.color.a / 255;
                    a.translate(0 | c.drawPos.x, -(0 | c.drawPos.y));
                    var e = 4 * Math.floor(c.size / 4),
                        f = this._pointRect.width,
                        g = this._pointRect.height;
                    a.scale(Math.max(1 / f * e, 1E-6), Math.max(1 / g * e, 1E-6));
                    c.rotation && a.rotate(cc.DEGREES_TO_RADIANS(c.rotation));
                    a.translate(-(0 | f / 2), -(0 | g / 2));
                    c.isChangeColor && (e = cc.textureCache.getTextureColors(d)) && (e.tintCache || (e.tintCache = document.createElement("canvas"), e.tintCache.width = d.width, e.tintCache.height =
                        d.height), cc.generateTintImage(d, e, c.color, this._pointRect, e.tintCache), d = e.tintCache);
                    a.drawImage(d, 0, 0);
                    a.restore()
                }
            } else a.save(), a.globalAlpha = c.color.a / 255, a.translate(0 | c.drawPos.x, -(0 | c.drawPos.y)), this.shapeType == cc.PARTICLE_STAR_SHAPE ? (c.rotation && a.rotate(cc.DEGREES_TO_RADIANS(c.rotation)), cc._drawingUtil.drawStar(a, d, c.color)) : cc._drawingUtil.drawColorBall(a, d, c.color), a.restore()
        }
        a.restore()
    },
    _drawForWebGL: function (a) {
        this._texture && (a = a || cc._renderContext, this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(),
            cc.glBindTexture2D(this._texture), cc.glBlendFuncForParticle(this._blendFunc.src, this._blendFunc.dst), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 24, 16), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), a.drawElements(a.TRIANGLES,
                6 * this._particleIdx, a.UNSIGNED_SHORT, 0))
    },
    listenBackToForeground: function (a) {
        cc.TEXTURE_ATLAS_USE_VAO ? this._setupVBOandVAO() : this._setupVBO()
    },
    _setupVBOandVAO: function () {},
    _setupVBO: function () {
        if (cc._renderType != cc._RENDER_TYPE_CANVAS) {
            var a = cc._renderContext;
            this._buffersVBO[0] = a.createBuffer();
            a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]);
            a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
            this._buffersVBO[1] = a.createBuffer();
            a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
            a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
        }
    },
    _allocMemory: function () {
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) return !0;
        if (this._batchNode) return cc.log("cc.ParticleSystem._allocMemory(): Memory should not be allocated when not using batchNode"), !1;
        var a = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            b = this._totalParticles,
            c = this._quads;
        c.length = 0;
        this._indices = new Uint16Array(6 * b);
        for (var d = new ArrayBuffer(a * b), e = 0; e < b; e++) c[e] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, d, e * a);
        if (!c ||
            !this._indices) return cc.log("cocos2d: Particle system: not enough memory"), !1;
        this._quadsArrayBuffer = d;
        return !0
    }
});
window._p = cc.ParticleSystem.prototype;
cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode);
cc.defineGetterSetter(_p, "active", _p.isActive);
cc.defineGetterSetter(_p, "sourcePos", _p.getSourcePosition, _p.setSourcePosition);
cc.defineGetterSetter(_p, "posVar", _p.getPosVar, _p.setPosVar);
cc.defineGetterSetter(_p, "gravity", _p.getGravity, _p.setGravity);
cc.defineGetterSetter(_p, "speed", _p.getSpeed, _p.setSpeed);
cc.defineGetterSetter(_p, "speedVar", _p.getSpeedVar, _p.setSpeedVar);
cc.defineGetterSetter(_p, "tangentialAccel", _p.getTangentialAccel, _p.setTangentialAccel);
cc.defineGetterSetter(_p, "tangentialAccelVar", _p.getTangentialAccelVar, _p.setTangentialAccelVar);
cc.defineGetterSetter(_p, "radialAccel", _p.getRadialAccel, _p.setRadialAccel);
cc.defineGetterSetter(_p, "radialAccelVar", _p.getRadialAccelVar, _p.setRadialAccelVar);
cc.defineGetterSetter(_p, "rotationIsDir", _p.getRotationIsDir, _p.setRotationIsDir);
cc.defineGetterSetter(_p, "startRadius", _p.getStartRadius, _p.setStartRadius);
cc.defineGetterSetter(_p, "startRadiusVar", _p.getStartRadiusVar, _p.setStartRadiusVar);
cc.defineGetterSetter(_p, "endRadius", _p.getEndRadius, _p.setEndRadius);
cc.defineGetterSetter(_p, "endRadiusVar", _p.getEndRadiusVar, _p.setEndRadiusVar);
cc.defineGetterSetter(_p, "rotatePerS", _p.getRotatePerSecond, _p.setRotatePerSecond);
cc.defineGetterSetter(_p, "rotatePerSVar", _p.getRotatePerSecondVar, _p.setRotatePerSecondVar);
cc.defineGetterSetter(_p, "startColor", _p.getStartColor, _p.setStartColor);
cc.defineGetterSetter(_p, "startColorVar", _p.getStartColorVar, _p.setStartColorVar);
cc.defineGetterSetter(_p, "endColor", _p.getEndColor, _p.setEndColor);
cc.defineGetterSetter(_p, "endColorVar", _p.getEndColorVar, _p.setEndColorVar);
cc.defineGetterSetter(_p, "totalParticles", _p.getTotalParticles, _p.setTotalParticles);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
delete window._p;
cc.ParticleSystem.create = function (a) {
    var b = new cc.ParticleSystem;
    return a && "number" !== typeof a ? b && b.initWithFile(a) ? b : null : (a = a || 100, b.setDrawMode(cc.PARTICLE_TEXTURE_MODE), b.initWithTotalParticles(a), b)
};
cc.ParticleSystem.ModeA = function (a, b, c, d, e, f, g, h) {
    this.gravity = a ? a : cc.p(0, 0);
    this.speed = b || 0;
    this.speedVar = c || 0;
    this.tangentialAccel = d || 0;
    this.tangentialAccelVar = e || 0;
    this.radialAccel = f || 0;
    this.radialAccelVar = g || 0;
    this.rotationIsDir = h || !1
};
cc.ParticleSystem.ModeB = function (a, b, c, d, e, f) {
    this.startRadius = a || 0;
    this.startRadiusVar = b || 0;
    this.endRadius = c || 0;
    this.endRadiusVar = d || 0;
    this.rotatePerSecond = e || 0;
    this.rotatePerSecondVar = f || 0
};
cc.ParticleFire = cc.ParticleSystem.extend({
    init: function () {
        return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 300 : 150)
    },
    initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(60), this.setSpeedVar(20), this.setAngle(90), this.setAngleVar(10), a = cc.director.getWinSize(),
            this.setPosition(a.width / 2, 60), this.setPosVar(cc.p(40, 20)), this.setLife(3), this.setLifeVar(0.25), this.setStartSize(54), this.setStartSizeVar(10), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleFire.create = function () {
    var a = new cc.ParticleFire;
    return a.init() ? a : null
};
cc.ParticleFireworks = cc.ParticleSystem.extend({
    init: function () {
        return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 1500 : 150)
    },
    initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(0, -90)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(180), this.setSpeedVar(50), a = cc.director.getWinSize(), this.setPosition(a.width /
            2, a.height / 2), this.setAngle(90), this.setAngleVar(20), this.setLife(3.5), this.setLifeVar(1), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 255)), this.setEndColor(cc.color(26, 26, 26, 51)), this.setEndColorVar(cc.color(26, 26, 26, 51)), this.setStartSize(8), this.setStartSizeVar(2), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleFireworks.create = function () {
    var a = new cc.ParticleFireworks;
    return a.init() ? a : null
};
cc.ParticleSun = cc.ParticleSystem.extend({
    init: function () {
        return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 350 : 150)
    },
    initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setBlendAdditive(!0), this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(20), this.setSpeedVar(5), this.setAngle(90), this.setAngleVar(360),
            a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(1), this.setLifeVar(0.5), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), !0) : !1
    }
});
cc.ParticleSun.create = function () {
    var a = new cc.ParticleSun;
    return a.init() ? a : null
};
cc.ParticleGalaxy = cc.ParticleSystem.extend({
    init: function () {
        return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 200 : 100)
    },
    initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(60), this.setSpeedVar(10), this.setRadialAccel(-80), this.setRadialAccelVar(0), this.setTangentialAccel(80), this.setTangentialAccelVar(0),
            this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(37), this.setStartSizeVar(10), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(31, 64, 194, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleGalaxy.create = function () {
    var a = new cc.ParticleGalaxy;
    return a.init() ? a : null
};
cc.ParticleFlower = cc.ParticleSystem.extend({
    init: function () {
        return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 250 : 100)
    },
    initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(80), this.setSpeedVar(10), this.setRadialAccel(-60), this.setRadialAccelVar(0), this.setTangentialAccel(15), this.setTangentialAccelVar(0),
            this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 128)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0,
                0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleFlower.create = function () {
    var a = new cc.ParticleFlower;
    return a.init() ? a : null
};
cc.ParticleMeteor = cc.ParticleSystem.extend({
    init: function () {
        return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 150 : 100)
    },
    initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(-200, 200)), this.setSpeed(15), this.setSpeedVar(5), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0),
            this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(2), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(51, 102, 179)), this.setStartColorVar(cc.color(0, 0, 51, 26)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleMeteor.create = function () {
    var a = new cc.ParticleMeteor;
    return a.init() ? a : null
};
cc.ParticleSpiral = cc.ParticleSystem.extend({
    init: function () {
        return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 500 : 100)
    },
    initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(150), this.setSpeedVar(0), this.setRadialAccel(-380), this.setRadialAccelVar(0), this.setTangentialAccel(45), this.setTangentialAccelVar(0),
            this.setAngle(90), this.setAngleVar(0), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(12), this.setLifeVar(0), this.setStartSize(20), this.setStartSizeVar(0), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 255)), this.setEndColorVar(cc.color(128,
                128, 128, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleSpiral.create = function () {
    var a = new cc.ParticleSpiral;
    return a.init() ? a : null
};
cc.ParticleExplosion = cc.ParticleSystem.extend({
    init: function () {
        return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 700 : 300)
    },
    initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(0.1), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(70), this.setSpeedVar(40), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0), this.setAngle(90),
            this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(5), this.setLifeVar(2), this.setStartSize(15), this.setStartSizeVar(10), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getDuration()), this.setStartColor(cc.color(179, 26, 51, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 0)), this.setEndColorVar(cc.color(128, 128, 128, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleExplosion.create = function () {
    var a = new cc.ParticleExplosion;
    return a.init() ? a : null
};
cc.ParticleSmoke = cc.ParticleSystem.extend({
    init: function () {
        return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 200 : 100)
    },
    initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(25), this.setSpeedVar(10), this.setAngle(90), this.setAngleVar(5), a = cc.director.getWinSize(),
            this.setPosition(a.width / 2, 0), this.setPosVar(cc.p(20, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(204, 204, 204, 255)), this.setStartColorVar(cc.color(5, 5, 5, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleSmoke.create = function () {
    var a = new cc.ParticleSmoke;
    return a.init() ? a : null
};
cc.ParticleSnow = cc.ParticleSystem.extend({
    init: function () {
        return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 700 : 250)
    },
    initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(0, -1)), this.setSpeed(5), this.setSpeedVar(1), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1),
                a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height + 10), this.setPosVar(cc.p(a.width / 2, 0)), this.setAngle(-90), this.setAngleVar(5), this.setLife(45), this.setLifeVar(15), this.setStartSize(10), this.setStartSizeVar(5), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(10), this.setStartColor(cc.color(255, 255, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(255, 255, 255, 0)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) :
            !1
    }
});
cc.ParticleSnow.create = function () {
    var a = new cc.ParticleSnow;
    return a.init() ? a : null
};
cc.ParticleRain = cc.ParticleSystem.extend({
    init: function () {
        return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 1E3 : 300)
    },
    initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(10, -10)), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1), this.setSpeed(130), this.setSpeedVar(30),
                this.setAngle(-90), this.setAngleVar(5), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height), this.setPosVar(cc.p(a.width / 2, 0)), this.setLife(4.5), this.setLifeVar(0), this.setStartSize(4), this.setStartSizeVar(2), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(20), this.setStartColor(cc.color(179, 204, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(179, 204, 255, 128)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) :
            !1
    }
});
cc.ParticleRain.create = function () {
    var a = new cc.ParticleRain;
    return a.init() ? a : null
};
cc.PARTICLE_DEFAULT_CAPACITY = 500;
cc.ParticleBatchNode = cc.Node.extend({
    textureAtlas: null,
    TextureProtocol: !0,
    _blendFunc: null,
    _className: "ParticleBatchNode",
    ctor: function () {
        cc.Node.prototype.ctor.call(this);
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        }
    },
    initWithTexture: function (a, b) {
        this.textureAtlas = new cc.TextureAtlas;
        this.textureAtlas.initWithTexture(a, b);
        this._children.length = 0;
        cc._renderType === cc._RENDER_TYPE_WEBGL && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR));
        return !0
    },
    initWithFile: function (a,
        b) {
        var c = cc.textureCache.addImage(a);
        return this.initWithTexture(c, b)
    },
    init: function (a, b) {
        var c = cc.TextureCache.getInstance().addImage(a);
        return this.initWithTexture(c, b)
    },
    addChild: function (a, b, c) {
        if (!a) throw "cc.ParticleBatchNode.addChild() : child should be non-null";
        if (!(a instanceof cc.ParticleSystem)) throw "cc.ParticleBatchNode.addChild() : only supports cc.ParticleSystem as children";
        b = null == b ? a.zIndex : b;
        c = null == c ? a.tag : c;
        if (a.getTexture() != this.textureAtlas.texture) throw "cc.ParticleSystem.addChild() : the child is not using the same texture id";
        var d = a.getBlendFunc();
        if (0 === this._children.length) this.setBlendFunc(d);
        else if (d.src != this._blendFunc.src || d.dst != this._blendFunc.dst) {
            cc.log("cc.ParticleSystem.addChild() : Can't add a ParticleSystem that uses a different blending function");
            return
        }
        b = this._addChildHelper(a, b, c);
        c = 0;
        0 != b ? (b = this._children[b - 1], c = b.getAtlasIndex() + b.getTotalParticles()) : c = 0;
        this.insertChild(a, c);
        a.setBatchNode(this)
    },
    insertChild: function (a, b) {
        var c = a.getTotalParticles(),
            d = this.textureAtlas,
            e = d.totalQuads;
        a.setAtlasIndex(b);
        e + c > d.getCapacity() && (this._increaseAtlasCapacityTo(e + c), d.fillWithEmptyQuadsFromIndex(d.getCapacity() - c, c));
        a.getAtlasIndex() + c != e && d.moveQuadsFromIndex(b, b + c);
        d.increaseTotalQuadsWith(c);
        this._updateAllAtlasIndexes()
    },
    removeChild: function (a, b) {
        if (null != a) {
            if (!(a instanceof cc.ParticleSystem)) throw "cc.ParticleBatchNode.removeChild(): only supports cc.ParticleSystem as children";
            if (-1 == this._children.indexOf(a)) cc.log("cc.ParticleBatchNode.removeChild(): doesn't contain the sprite. Can't remove it");
            else {
                cc.Node.prototype.removeChild.call(this, a, b);
                var c = this.textureAtlas;
                c.removeQuadsAtIndex(a.getAtlasIndex(), a.getTotalParticles());
                c.fillWithEmptyQuadsFromIndex(c.totalQuads, a.getTotalParticles());
                a.setBatchNode(null);
                this._updateAllAtlasIndexes()
            }
        }
    },
    reorderChild: function (a, b) {
        if (!a) throw "cc.ParticleBatchNode.reorderChild(): child should be non-null";
        if (!(a instanceof cc.ParticleSystem)) throw "cc.ParticleBatchNode.reorderChild(): only supports cc.QuadParticleSystems as children";
        if (-1 === this._children.indexOf(a)) cc.log("cc.ParticleBatchNode.reorderChild(): Child doesn't belong to batch");
        else if (b != a.zIndex) {
            if (1 < this._children.length) {
                var c = this._getCurrentIndex(a, b);
                if (c.oldIndex != c.newIndex) {
                    this._children.splice(c.oldIndex, 1);
                    this._children.splice(c.newIndex, 0, a);
                    c = a.getAtlasIndex();
                    this._updateAllAtlasIndexes();
                    for (var d = 0, e = this._children, f = 0; f < e.length; f++)
                        if (e[f] == a) {
                            d = a.getAtlasIndex();
                            break
                        }
                    this.textureAtlas.moveQuadsFromIndex(c, a.getTotalParticles(), d);
                    a.updateWithNoTime()
                }
            }
            a._setLocalZOrder(b)
        }
    },
    removeChildAtIndex: function (a, b) {
        this.removeChild(this._children[i], b)
    },
    removeAllChildren: function (a) {
        for (var b =
            this._children, c = 0; c < b.length; c++) b[c].setBatchNode(null);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this.textureAtlas.removeAllQuads()
    },
    disableParticle: function (a) {
        a = this.textureAtlas.quads[a];
        a.br.vertices.x = a.br.vertices.y = a.tr.vertices.x = a.tr.vertices.y = a.tl.vertices.x = a.tl.vertices.y = a.bl.vertices.x = a.bl.vertices.y = 0;
        this.textureAtlas._setDirty(!0)
    },
    draw: function (a) {
        cc._renderType !== cc._RENDER_TYPE_CANVAS && 0 != this.textureAtlas.totalQuads && (cc.NODE_DRAW_SETUP(this), cc.glBlendFuncForParticle(this._blendFunc.src,
            this._blendFunc.dst), this.textureAtlas.drawQuads())
    },
    getTexture: function () {
        return this.textureAtlas.texture
    },
    setTexture: function (a) {
        this.textureAtlas.texture = a;
        var b = this._blendFunc;
        a && !a.hasPremultipliedAlpha() && b.src == cc.BLEND_SRC && b.dst == cc.BLEND_DST && (b.src = cc.SRC_ALPHA, b.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    setBlendFunc: function (a, b) {
        void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.src = b)
    },
    getBlendFunc: function () {
        return {
            src: this._blendFunc.src,
            dst: this._blendFunc.dst
        }
    },
    visit: function (a) {
        cc._renderType !== cc._RENDER_TYPE_CANVAS && this._visible && (cc.kmGLPushMatrix(), this.grid && this.grid.isActive() && (this.grid.beforeDraw(), this.transformAncestors()), this.transform(a), this.draw(a), this.grid && this.grid.isActive() && this.grid.afterDraw(this), cc.kmGLPopMatrix())
    },
    _updateAllAtlasIndexes: function () {
        for (var a = 0, b = this._children, c = 0; c < b.length; c++) {
            var d = b[c];
            d.setAtlasIndex(a);
            a += d.getTotalParticles()
        }
    },
    _increaseAtlasCapacityTo: function (a) {
        cc.log("cocos2d: cc.ParticleBatchNode: resizing TextureAtlas capacity from [" +
            this.textureAtlas.getCapacity() + "] to [" + a + "].");
        this.textureAtlas.resizeCapacity(a) || cc.log("cc.ParticleBatchNode._increaseAtlasCapacityTo() : WARNING: Not enough memory to resize the atlas")
    },
    _searchNewPositionInChildrenForZ: function (a) {
        for (var b = this._children, c = b.length, d = 0; d < c; d++)
            if (b[d].zIndex > a) return d;
        return c
    },
    _getCurrentIndex: function (a, b) {
        for (var c = !1, d = !1, e = 0, f = 0, g = 0, h = this._children, k = h.length, m = 0; m < k; m++) {
            var n = h[m];
            if (n.zIndex > b && !d && (e = m, d = !0, c && d)) break;
            if (a == n && (f = m, c = !0, d || (g = -1), c && d)) break
        }
        d || (e = k);
        return {
            newIndex: e + g,
            oldIndex: f
        }
    },
    _addChildHelper: function (a, b, c) {
        if (!a) throw "cc.ParticleBatchNode._addChildHelper(): child should be non-null";
        if (a.parent) return cc.log("cc.ParticleBatchNode._addChildHelper(): child already added. It can't be added again"), null;
        this._children || (this._children = []);
        var d = this._searchNewPositionInChildrenForZ(b);
        this._children.splice(d, 0, a);
        a.tag = c;
        a._setLocalZOrder(b);
        a.parent = this;
        this._running && (a.onEnter(), a.onEnterTransitionDidFinish());
        return d
    },
    _updateBlendFunc: function () {
        this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    getTextureAtlas: function () {
        return this.textureAtlas
    },
    setTextureAtlas: function (a) {
        this.textureAtlas = a
    }
});
window._p = cc.ParticleBatchNode.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
delete window._p;
cc.ParticleBatchNode.create = function (a, b) {
    var c = new cc.ParticleBatchNode;
    "string" == typeof a ? c.init(a, b) : a instanceof cc.Texture2D && c.initWithTexture(a, b);
    return c
};
cc.IMEKeyboardNotificationInfo = function (a, b, c) {
    this.begin = a || cc.rect(0, 0, 0, 0);
    this.end = b || cc.rect(0, 0, 0, 0);
    this.duration = c || 0
};
cc.IMEDelegate = cc.Class.extend({
    ctor: function () {
        cc.imeDispatcher.addDelegate(this)
    },
    removeDelegate: function () {
        cc.imeDispatcher.removeDelegate(this)
    },
    attachWithIME: function () {
        return cc.imeDispatcher.attachDelegateWithIME(this)
    },
    detachWithIME: function () {
        return cc.imeDispatcher.detachDelegateWithIME(this)
    },
    canAttachWithIME: function () {
        return !1
    },
    didAttachWithIME: function () {},
    canDetachWithIME: function () {
        return !1
    },
    didDetachWithIME: function () {},
    insertText: function (a, b) {},
    deleteBackward: function () {},
    getContentText: function () {
        return ""
    },
    keyboardWillShow: function (a) {},
    keyboardDidShow: function (a) {},
    keyboardWillHide: function (a) {},
    keyboardDidHide: function (a) {}
});
cc.IMEDispatcher = cc.Class.extend({
    _domInputControl: null,
    impl: null,
    _currentInputString: "",
    _lastClickPosition: null,
    ctor: function () {
        this.impl = new cc.IMEDispatcher.Impl;
        this._lastClickPosition = cc.p(0, 0)
    },
    init: function () {
        if (!cc.sys.isMobile) {
            this._domInputControl = cc.$("#imeDispatcherInput");
            this._domInputControl || (this._domInputControl = cc.$new("input"), this._domInputControl.setAttribute("type", "text"), this._domInputControl.setAttribute("id", "imeDispatcherInput"), this._domInputControl.resize(0, 0), this._domInputControl.translates(0,
                0), this._domInputControl.style.opacity = "0", this._domInputControl.style.fontSize = "1px", this._domInputControl.setAttribute("tabindex", 2), this._domInputControl.style.position = "absolute", this._domInputControl.style.top = 0, this._domInputControl.style.left = 0, document.body.appendChild(this._domInputControl));
            var a = this;
            this._domInputControl.addEventListener("input", function () {
                a._processDomInputString(a._domInputControl.value)
            }, !1);
            this._domInputControl.addEventListener("keydown", function (b) {
                b.keyCode === cc.KEY.tab ?
                    (b.stopPropagation(), b.preventDefault()) : b.keyCode == cc.KEY.enter && (a.dispatchInsertText("\n", 1), b.stopPropagation(), b.preventDefault())
            }, !1);
            /msie/i.test(navigator.userAgent) && this._domInputControl.addEventListener("keyup", function (b) {
                b.keyCode == cc.KEY.backspace && a._processDomInputString(a._domInputControl.value)
            }, !1);
            window.addEventListener("mousedown", function (b) {
                var c = b.pageY || 0;
                a._lastClickPosition.x = b.pageX || 0;
                a._lastClickPosition.y = c
            }, !1)
        }
    },
    _processDomInputString: function (a) {
        var b, c;
        b = this._currentInputString.length <
            a.length ? this._currentInputString.length : a.length;
        for (c = 0; c < b && a[c] === this._currentInputString[c]; c++);
        var d = this._currentInputString.length - c,
            e = a.length - c;
        for (b = 0; b < d; b++) this.dispatchDeleteBackward();
        for (b = 0; b < e; b++) this.dispatchInsertText(a[c + b], 1);
        this._currentInputString = a
    },
    dispatchInsertText: function (a, b) {
        !this.impl || !a || 0 >= b || this.impl._delegateWithIme && this.impl._delegateWithIme.insertText(a, b)
    },
    dispatchDeleteBackward: function () {
        this.impl && this.impl._delegateWithIme && this.impl._delegateWithIme.deleteBackward()
    },
    getContentText: function () {
        if (this.impl && this.impl._delegateWithIme) {
            var a = this.impl._delegateWithIme.getContentText();
            return a ? a : ""
        }
        return ""
    },
    dispatchKeyboardWillShow: function (a) {
        if (this.impl)
            for (var b = 0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardWillShow(a)
            }
    },
    dispatchKeyboardDidShow: function (a) {
        if (this.impl)
            for (var b = 0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardDidShow(a)
            }
    },
    dispatchKeyboardWillHide: function (a) {
        if (this.impl)
            for (var b =
                0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardWillHide(a)
            }
    },
    dispatchKeyboardDidHide: function (a) {
        if (this.impl)
            for (var b = 0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardDidHide(a)
            }
    },
    addDelegate: function (a) {
        a && this.impl && (-1 < this.impl._delegateList.indexOf(a) || this.impl._delegateList.splice(0, 0, a))
    },
    attachDelegateWithIME: function (a) {
        if (!this.impl || !a || -1 == this.impl._delegateList.indexOf(a)) return !1;
        if (this.impl._delegateWithIme) {
            if (!this.impl._delegateWithIme.canDetachWithIME() ||
                !a.canAttachWithIME()) return !1;
            var b = this.impl._delegateWithIme;
            this.impl._delegateWithIme = null;
            b.didDetachWithIME();
            this._focusDomInput(a);
            return !0
        }
        if (!a.canAttachWithIME()) return !1;
        this._focusDomInput(a);
        return !0
    },
    _focusDomInput: function (a) {
        cc.sys.isMobile ? (this.impl._delegateWithIme = a, a.didAttachWithIME(), this._currentInputString = a.string || "", a = prompt("please enter your word:", this._currentInputString), null != a && this._processDomInputString(a), this.dispatchInsertText("\n", 1)) : (this.impl._delegateWithIme =
            a, this._currentInputString = a.string || "", a.didAttachWithIME(), this._domInputControl.focus(), this._domInputControl.value = this._currentInputString, this._domInputControlTranslate())
    },
    _domInputControlTranslate: function () {
        /msie/i.test(navigator.userAgent) ? (this._domInputControl.style.left = this._lastClickPosition.x + "px", this._domInputControl.style.top = this._lastClickPosition.y + "px") : this._domInputControl.translates(this._lastClickPosition.x, this._lastClickPosition.y)
    },
    detachDelegateWithIME: function (a) {
        if (!this.impl ||
            !a || this.impl._delegateWithIme != a || !a.canDetachWithIME()) return !1;
        this.impl._delegateWithIme = null;
        a.didDetachWithIME();
        cc._canvas.focus();
        return !0
    },
    removeDelegate: function (a) {
        this.impl && a && -1 != this.impl._delegateList.indexOf(a) && (this.impl._delegateWithIme && a == this.impl._delegateWithIme && (this.impl._delegateWithIme = null), cc.arrayRemoveObject(this.impl._delegateList, a))
    },
    processKeycode: function (a) {
        32 > a ? a == cc.KEY.backspace ? this.dispatchDeleteBackward() : a == cc.KEY.enter && this.dispatchInsertText("\n",
            1) : 255 > a && this.dispatchInsertText(String.fromCharCode(a), 1)
    }
});
cc.IMEDispatcher.Impl = cc.Class.extend({
    _delegateWithIme: null,
    _delegateList: null,
    ctor: function () {
        this._delegateList = []
    },
    findDelegate: function (a) {
        for (var b = 0; b < this._delegateList.length; b++)
            if (this._delegateList[b] == a) return b;
        return null
    }
});
cc.imeDispatcher = new cc.IMEDispatcher;
cc.imeDispatcher.init();
cc.TextFieldDelegate = cc.Class.extend({
    onTextFieldAttachWithIME: function (a) {
        return !1
    },
    onTextFieldDetachWithIME: function (a) {
        return !1
    },
    onTextFieldInsertText: function (a, b, c) {
        return !1
    },
    onTextFieldDeleteBackward: function (a, b, c) {
        return !1
    },
    onDraw: function (a) {
        return !1
    }
});
cc.TextFieldTTF = cc.LabelTTF.extend({
    delegate: null,
    colorSpaceHolder: null,
    _lens: null,
    _inputText: "",
    _placeHolder: "",
    _charCount: 0,
    _className: "TextFieldTTF",
    ctor: function () {
        this.colorSpaceHolder = cc.color(127, 127, 127);
        cc.imeDispatcher.addDelegate(this);
        cc.LabelTTF.prototype.ctor.call(this)
    },
    getDelegate: function () {
        return this.delegate
    },
    setDelegate: function (a) {
        this.delegate = a
    },
    getCharCount: function () {
        return this._charCount
    },
    getColorSpaceHolder: function () {
        return this.colorSpaceHolder
    },
    setColorSpaceHolder: function (a) {
        this.colorSpaceHolder =
            a
    },
    initWithPlaceHolder: function (a, b, c, d, e) {
        switch (arguments.length) {
        case 5:
            return a && (this._placeHolder = a), this.initWithString(this._placeHolder, d, e, b, c);
        case 3:
            return a && (this._placeHolder = a), d = arguments[1], e = arguments[2], this.initWithString(this._placeHolder, d, e);
        default:
            throw "Argument must be non-nil ";
        }
    },
    setString: function (a) {
        this._inputText = (a = String(a)) || "";
        this._inputText.length ? cc.LabelTTF.prototype.setString.call(this, this._inputText) : cc.LabelTTF.prototype.setString.call(this, this._placeHolder);
        this._charCount = this._inputText.length
    },
    getString: function () {
        return this._inputText
    },
    setPlaceHolder: function (a) {
        this._placeHolder = a || "";
        this._inputText.length || cc.LabelTTF.prototype.setString.call(this, this._placeHolder)
    },
    getPlaceHolder: function () {
        return this._placeHolder
    },
    draw: function (a) {
        a = a || cc._renderContext;
        if (!this.delegate || !this.delegate.onDraw(this))
            if (this._inputText && 0 < this._inputText.length) cc.LabelTTF.prototype.draw.call(this, a);
            else {
                var b = this.color;
                this.color = this.colorSpaceHolder;
                cc._renderType === cc._RENDER_TYPE_CANVAS && this._updateTexture();
                cc.LabelTTF.prototype.draw.call(this, a);
                this.color = b
            }
    },
    attachWithIME: function () {
        return cc.imeDispatcher.attachDelegateWithIME(this)
    },
    detachWithIME: function () {
        return cc.imeDispatcher.detachDelegateWithIME(this)
    },
    canAttachWithIME: function () {
        return this.delegate ? !this.delegate.onTextFieldAttachWithIME(this) : !0
    },
    didAttachWithIME: function () {},
    canDetachWithIME: function () {
        return this.delegate ? !this.delegate.onTextFieldDetachWithIME(this) : !0
    },
    didDetachWithIME: function () {},
    deleteBackward: function () {
        var a = this._inputText.length;
        0 == a || this.delegate && this.delegate.onTextFieldDeleteBackward(this, this._inputText[a - 1], 1) || (1 >= a ? (this._inputText = "", this._charCount = 0, cc.LabelTTF.prototype.setString.call(this, this._placeHolder)) : this.string = this._inputText.substring(0, a - 1))
    },
    removeDelegate: function () {
        cc.imeDispatcher.removeDelegate(this)
    },
    insertText: function (a, b) {
        var c = a,
            d = c.indexOf("\n"); - 1 < d && (c = c.substring(0, d));
        if (0 < c.length) {
            if (this.delegate &&
                this.delegate.onTextFieldInsertText(this, c, c.length)) return;
            c = this._inputText + c;
            this._charCount = c.length;
            this.string = c
        } - 1 != d && (this.delegate && this.delegate.onTextFieldInsertText(this, "\n", 1) || this.detachWithIME())
    },
    getContentText: function () {
        return this._inputText
    },
    keyboardWillShow: function (a) {},
    keyboardDidShow: function (a) {},
    keyboardWillHide: function (a) {},
    keyboardDidHide: function (a) {}
});
window._p = cc.TextFieldTTF.prototype;
cc.defineGetterSetter(_p, "charCount", _p.getCharCount);
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder);
delete window._p;
cc.TextFieldTTF.create = function (a, b, c, d, e) {
    var f;
    switch (arguments.length) {
    case 5:
        return (f = new cc.TextFieldTTF) && f.initWithPlaceHolder("", b, c, d, e) ? (a && (f.placeHolder = a), f) : null;
    case 3:
        return f = new cc.TextFieldTTF, d = arguments[1], e = arguments[2], f && f.initWithString("", d, e) ? (a && (f.placeHolder = a), f) : null;
    default:
        throw "Argument must be non-nil ";
    }
};
cc.ITEM_SIZE = 32;
cc._globalFontSize = cc.ITEM_SIZE;
cc._globalFontName = "Arial";
cc._globalFontNameRelease = !1;
cc.CURRENT_ITEM = 3233828865;
cc.ZOOM_ACTION_TAG = 3233828866;
cc.NORMAL_TAG = 8801;
cc.SELECTED_TAG = 8802;
cc.DISABLE_TAG = 8803;
cc.MenuItem = cc.NodeRGBA.extend({
    _enabled: !1,
    _target: null,
    _callback: null,
    _isSelected: !1,
    _className: "MenuItem",
    ctor: function (a, b) {
        var c = cc.NodeRGBA.prototype;
        c.ctor.call(this);
        this._callback = this._target = null;
        this._enabled = this._isSelected = !1;
        c.setAnchorPoint.call(this, 0.5, 0.5);
        this._target = b || null;
        if (this._callback = a || null) this._enabled = !0
    },
    isSelected: function () {
        return this._isSelected
    },
    setOpacityModifyRGB: function (a) {},
    isOpacityModifyRGB: function () {
        return !1
    },
    setTarget: function (a, b) {
        this._target = b;
        this._callback = a
    },
    isEnabled: function () {
        return this._enabled
    },
    setEnabled: function (a) {
        this._enabled = a
    },
    initWithCallback: function (a, b) {
        this.anchorY = this.anchorX = 0.5;
        this._target = b;
        this._callback = a;
        this._enabled = !0;
        this._isSelected = !1;
        return !0
    },
    rect: function () {
        var a = this._position,
            b = this._contentSize,
            c = this._anchorPoint;
        return cc.rect(a.x - b.width * c.x, a.y - b.height * c.y, b.width, b.height)
    },
    selected: function () {
        this._isSelected = !0
    },
    unselected: function () {
        this._isSelected = !1
    },
    setCallback: function (a, b) {
        this._target =
            b;
        this._callback = a
    },
    activate: function () {
        if (this._enabled) {
            var a = this._target,
                b = this._callback;
            if (b)
                if (a && "string" == typeof b) a[b](this);
                else a && "function" == typeof b ? b.call(a, this) : b(this)
        }
    }
});
window._p = cc.MenuItem.prototype;
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
delete window._p;
cc.MenuItem.create = function (a, b) {
    return new cc.MenuItem(a, b)
};
cc.MenuItemLabel = cc.MenuItem.extend({
    _disabledColor: null,
    _label: null,
    _orginalScale: 0,
    _colorBackup: null,
    ctor: function (a, b, c) {
        cc.MenuItem.prototype.ctor.call(this, b, c);
        this._label = this._disabledColor = null;
        this._orginalScale = 0;
        this._colorBackup = null;
        a && (this._originalScale = 1, this._colorBackup = cc.color.WHITE, this._disabledColor = cc.color(126, 126, 126), this.setLabel(a), this.cascadeOpacity = this.cascadeColor = !0)
    },
    getDisabledColor: function () {
        return this._disabledColor
    },
    setDisabledColor: function (a) {
        this._disabledColor =
            a
    },
    getLabel: function () {
        return this._label
    },
    setLabel: function (a) {
        a && (this.addChild(a), a.anchorX = 0, a.anchorY = 0, this.width = a.width, this.height = a.height);
        this._label && this.removeChild(this._label, !0);
        this._label = a
    },
    setEnabled: function (a) {
        if (this._enabled != a) {
            var b = this._label;
            a ? b.color = this._colorBackup : (this._colorBackup = b.color, b.color = this._disabledColor)
        }
        cc.MenuItem.prototype.setEnabled.call(this, a)
    },
    setOpacity: function (a) {
        this._label.opacity = a
    },
    getOpacity: function () {
        return this._label.opacity
    },
    setColor: function (a) {
        this._label.color =
            a
    },
    getColor: function () {
        return this._label.color
    },
    initWithLabel: function (a, b, c) {
        this.initWithCallback(b, c);
        this._originalScale = 1;
        this._colorBackup = cc.color.WHITE;
        this._disabledColor = cc.color(126, 126, 126);
        this.setLabel(a);
        return this.cascadeOpacity = this.cascadeColor = !0
    },
    setString: function (a) {
        this._label.string = a;
        this.width = this._label.width;
        this.height = this._label.height
    },
    getString: function () {
        return this._label.string
    },
    activate: function () {
        this._enabled && (this.stopAllActions(), this.scale = this._originalScale,
            cc.MenuItem.prototype.activate.call(this))
    },
    selected: function () {
        if (this._enabled) {
            cc.MenuItem.prototype.selected.call(this);
            var a = this.getActionByTag(cc.ZOOM_ACTION_TAG);
            a ? this.stopAction(a) : this._originalScale = this.scale;
            a = cc.ScaleTo.create(0.1, 1.2 * this._originalScale);
            a.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(a)
        }
    },
    unselected: function () {
        if (this._enabled) {
            cc.MenuItem.prototype.unselected.call(this);
            this.stopActionByTag(cc.ZOOM_ACTION_TAG);
            var a = cc.ScaleTo.create(0.1, this._originalScale);
            a.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(a)
        }
    }
});
window._p = cc.MenuItemLabel.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "disabledColor", _p.getDisabledColor, _p.setDisabledColor);
cc.defineGetterSetter(_p, "label", _p.getLabel, _p.setLabel);
delete window._p;
cc.MenuItemLabel.create = function (a, b, c) {
    return new cc.MenuItemLabel(a, b, c)
};
cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({
    ctor: function (a, b, c, d, e, f, g) {
        var h;
        a && 0 < a.length && (h = cc.LabelAtlas.create(a, b, c, d, e));
        cc.MenuItemLabel.prototype.ctor.call(this, h, f, g)
    },
    initWithString: function (a, b, c, d, e, f, g) {
        if (!a || 0 == a.length) throw "cc.MenuItemAtlasFont.initWithString(): value should be non-null and its length should be greater than 0";
        var h = new cc.LabelAtlas;
        h.initWithString(a, b, c, d, e);
        this.initWithLabel(h, f, g);
        return !0
    }
});
cc.MenuItemAtlasFont.create = function (a, b, c, d, e, f, g) {
    return new cc.MenuItemAtlasFont(a, b, c, d, e, f, g)
};
cc.MenuItemFont = cc.MenuItemLabel.extend({
    _fontSize: null,
    _fontName: null,
    ctor: function (a, b, c) {
        var d;
        a && 0 < a.length ? (this._fontName = cc._globalFontName, this._fontSize = cc._globalFontSize, d = cc.LabelTTF.create(a, this._fontName, this._fontSize)) : (this._fontSize = 0, this._fontName = "");
        cc.MenuItemLabel.prototype.ctor.call(this, d, b, c)
    },
    initWithString: function (a, b, c) {
        if (!a || 0 == a.length) throw "Value should be non-null and its length should be greater than 0";
        this._fontName = cc._globalFontName;
        this._fontSize = cc._globalFontSize;
        a = cc.LabelTTF.create(a, this._fontName, this._fontSize);
        this.initWithLabel(a, b, c);
        return !0
    },
    setFontSize: function (a) {
        this._fontSize = a;
        this._recreateLabel()
    },
    getFontSize: function () {
        return this._fontSize
    },
    setFontName: function (a) {
        this._fontName = a;
        this._recreateLabel()
    },
    getFontName: function () {
        return this._fontName
    },
    _recreateLabel: function () {
        var a = cc.LabelTTF.create(this._label.string, this._fontName, this._fontSize);
        this.setLabel(a)
    }
});
cc.MenuItemFont.setFontSize = function (a) {
    cc._globalFontSize = a
};
cc.MenuItemFont.fontSize = function () {
    return cc._globalFontSize
};
cc.MenuItemFont.setFontName = function (a) {
    cc._globalFontNameRelease && (cc._globalFontName = "");
    cc._globalFontName = a;
    cc._globalFontNameRelease = !0
};
window._p = cc.MenuItemFont.prototype;
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
delete window._p;
cc.MenuItemFont.fontName = function () {
    return cc._globalFontName
};
cc.MenuItemFont.create = function (a, b, c) {
    return new cc.MenuItemFont(a, b, c)
};
cc.MenuItemSprite = cc.MenuItem.extend({
    _normalImage: null,
    _selectedImage: null,
    _disabledImage: null,
    ctor: function (a, b, c, d, e) {
        cc.MenuItem.prototype.ctor.call(this);
        this._disabledImage = this._selectedImage = this._normalImage = null;
        var f = arguments.length;
        if (1 < f) {
            a = arguments[0];
            b = arguments[1];
            var g, h, k;
            5 == f ? (g = arguments[2], k = arguments[3], h = arguments[4]) : 4 == f && "function" === typeof arguments[3] ? (g = arguments[2], k = arguments[3]) : 4 == f && "function" === typeof arguments[2] ? (h = arguments[3], k = arguments[2]) : 2 >= f && (g = arguments[2]);
            this.initWithNormalSprite(a, b, g, k, h)
        }
    },
    getNormalImage: function () {
        return this._normalImage
    },
    setNormalImage: function (a) {
        this._normalImage != a && (a && (this.addChild(a, 0, cc.NORMAL_TAG), a.anchorX = 0, a.anchorY = 0), this._normalImage && this.removeChild(this._normalImage, !0), this._normalImage = a, this.width = this._normalImage.width, this.height = this._normalImage.height, this._updateImagesVisibility(), a.textureLoaded && !a.textureLoaded() && a.addLoadedEventListener(function (a) {
            this.width = a.width;
            this.height = a.height
        }, this))
    },
    getSelectedImage: function () {
        return this._selectedImage
    },
    setSelectedImage: function (a) {
        this._selectedImage != a && (a && (this.addChild(a, 0, cc.SELECTED_TAG), a.anchorX = 0, a.anchorY = 0), this._selectedImage && this.removeChild(this._selectedImage, !0), this._selectedImage = a, this._updateImagesVisibility())
    },
    getDisabledImage: function () {
        return this._disabledImage
    },
    setDisabledImage: function (a) {
        this._disabledImage != a && (a && (this.addChild(a, 0, cc.DISABLE_TAG), a.anchorX = 0, a.anchorY = 0), this._disabledImage && this.removeChild(this._disabledImage, !0), this._disabledImage = a, this._updateImagesVisibility())
    },
    initWithNormalSprite: function (a, b, c, d, e) {
        this.initWithCallback(d, e);
        this.setNormalImage(a);
        this.setSelectedImage(b);
        this.setDisabledImage(c);
        if (a = this._normalImage) this.width = a.width, this.height = a.height, a.textureLoaded && !a.textureLoaded() && a.addLoadedEventListener(function (a) {
            this.width = a.width;
            this.height = a.height;
            this.cascadeOpacity = this.cascadeColor = !0
        }, this);
        return this.cascadeOpacity = this.cascadeColor = !0
    },
    setColor: function (a) {
        this._normalImage.color =
            a;
        this._selectedImage && (this._selectedImage.color = a);
        this._disabledImage && (this._disabledImage.color = a)
    },
    getColor: function () {
        return this._normalImage.color
    },
    setOpacity: function (a) {
        this._normalImage.opacity = a;
        this._selectedImage && (this._selectedImage.opacity = a);
        this._disabledImage && (this._disabledImage.opacity = a)
    },
    getOpacity: function () {
        return this._normalImage.opacity
    },
    selected: function () {
        cc.MenuItem.prototype.selected.call(this);
        this._normalImage && (this._disabledImage && (this._disabledImage.visible = !1), this._selectedImage ? (this._normalImage.visible = !1, this._selectedImage.visible = !0) : this._normalImage.visible = !0)
    },
    unselected: function () {
        cc.MenuItem.prototype.unselected.call(this);
        this._normalImage && (this._normalImage.visible = !0, this._selectedImage && (this._selectedImage.visible = !1), this._disabledImage && (this._disabledImage.visible = !1))
    },
    setEnabled: function (a) {
        this._enabled != a && (cc.MenuItem.prototype.setEnabled.call(this, a), this._updateImagesVisibility())
    },
    _updateImagesVisibility: function () {
        var a =
            this._normalImage,
            b = this._selectedImage,
            c = this._disabledImage;
        this._enabled ? (a && (a.visible = !0), b && (b.visible = !1), c && (c.visible = !1)) : c ? (a && (a.visible = !1), b && (b.visible = !1), c && (c.visible = !0)) : (a && (a.visible = !0), b && (b.visible = !1))
    }
});
window._p = cc.MenuItemSprite.prototype;
cc.defineGetterSetter(_p, "normalImage", _p.getNormalImage, _p.setNormalImage);
cc.defineGetterSetter(_p, "selectedImage", _p.getSelectedImage, _p.setSelectedImage);
cc.defineGetterSetter(_p, "disabledImage", _p.getDisabledImage, _p.setDisabledImage);
delete window._p;
cc.MenuItemSprite.create = function (a, b, c, d, e) {
    return new cc.MenuItemSprite(a, b, c, d, e)
};
cc.MenuItemImage = cc.MenuItemSprite.extend({
    ctor: function (a, b, c, d, e) {
        var f = null,
            g = null,
            h = null,
            k = null,
            m = null;
        void 0 === a ? cc.MenuItemSprite.prototype.ctor.call(this) : (f = cc.Sprite.create(a), b && (g = cc.Sprite.create(b)), void 0 === d ? k = c : void 0 === e ? (k = c, m = d) : e && (h = cc.Sprite.create(c), k = d, m = e), cc.MenuItemSprite.prototype.ctor.call(this, f, g, h, k, m))
    },
    setNormalSpriteFrame: function (a) {
        this.setNormalImage(cc.Sprite.create(a))
    },
    setSelectedSpriteFrame: function (a) {
        this.setSelectedImage(cc.Sprite.create(a))
    },
    setDisabledSpriteFrame: function (a) {
        this.setDisabledImage(cc.Sprite.create(a))
    },
    initWithNormalImage: function (a, b, c, d, e) {
        var f = null,
            g = null,
            h = null;
        a && (f = cc.Sprite.create(a));
        b && (g = cc.Sprite.create(b));
        c && (h = cc.Sprite.create(c));
        return this.initWithNormalSprite(f, g, h, d, e)
    }
});
cc.MenuItemImage.create = function (a, b, c, d, e) {
    return new cc.MenuItemImage(a, b, c, d, e)
};
cc.MenuItemToggle = cc.MenuItem.extend({
    subItems: null,
    _selectedIndex: 0,
    _opacity: null,
    _color: null,
    ctor: function () {
        var a = arguments.length,
            b, c;
        "function" === typeof arguments[a - 2] ? (b = arguments[a - 2], c = arguments[a - 1], a -= 2) : "function" === typeof arguments[a - 1] && (b = arguments[a - 1], a -= 1);
        cc.MenuItem.prototype.ctor.call(this, b, c);
        this._selectedIndex = 0;
        this.subItems = [];
        this._opacity = 0;
        this._color = cc.color.WHITE;
        if (0 < a) {
            b = this.subItems;
            for (c = b.length = 0; c < a; c++) arguments[c] && b.push(arguments[c]);
            this._selectedIndex =
                cc.UINT_MAX;
            this.setSelectedIndex(0);
            this.setCascadeColorEnabled(!0);
            this.setCascadeOpacityEnabled(!0)
        }
    },
    getOpacity: function () {
        return this._opacity
    },
    setOpacity: function (a) {
        this._opacity = a;
        if (this.subItems && 0 < this.subItems.length)
            for (var b = 0; b < this.subItems.length; b++) this.subItems[b].opacity = a;
        this._color.a = a
    },
    getColor: function () {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setColor: function (a) {
        var b = this._color;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        if (this.subItems && 0 < this.subItems.length)
            for (b = 0; b < this.subItems.length; b++) this.subItems[b].setColor(a);
        void 0 === a.a || a.a_undefined || this.setOpacity(a.a)
    },
    getSelectedIndex: function () {
        return this._selectedIndex
    },
    setSelectedIndex: function (a) {
        if (a != this._selectedIndex) {
            this._selectedIndex = a;
            (a = this.getChildByTag(cc.CURRENT_ITEM)) && a.removeFromParent(!1);
            a = this.subItems[this._selectedIndex];
            this.addChild(a, 0, cc.CURRENT_ITEM);
            var b = a.width,
                c = a.height;
            this.width = b;
            this.height = c;
            a.setPosition(b / 2, c / 2)
        }
    },
    getSubItems: function () {
        return this.subItems
    },
    setSubItems: function (a) {
        this.subItems = a
    },
    initWithItems: function (a) {
        var b =
            a.length;
        "function" === typeof a[a.length - 2] ? (this.initWithCallback(a[a.length - 2], a[a.length - 1]), b -= 2) : "function" === typeof a[a.length - 1] ? (this.initWithCallback(a[a.length - 1], null), b -= 1) : this.initWithCallback(null, null);
        for (var c = this.subItems, d = c.length = 0; d < b; d++) a[d] && c.push(a[d]);
        this._selectedIndex = cc.UINT_MAX;
        this.setSelectedIndex(0);
        return this.cascadeOpacity = this.cascadeColor = !0
    },
    addSubItem: function (a) {
        this.subItems.push(a)
    },
    activate: function () {
        this._enabled && this.setSelectedIndex((this._selectedIndex +
            1) % this.subItems.length);
        cc.MenuItem.prototype.activate.call(this)
    },
    selected: function () {
        cc.MenuItem.prototype.selected.call(this);
        this.subItems[this._selectedIndex].selected()
    },
    unselected: function () {
        cc.MenuItem.prototype.unselected.call(this);
        this.subItems[this._selectedIndex].unselected()
    },
    setEnabled: function (a) {
        if (this._enabled != a) {
            cc.MenuItem.prototype.setEnabled.call(this, a);
            var b = this.subItems;
            if (b && 0 < b.length)
                for (var c = 0; c < b.length; c++) b[c].enabled = a
        }
    },
    selectedItem: function () {
        return this.subItems[this._selectedIndex]
    },
    onEnter: function () {
        cc.Node.prototype.onEnter.call(this);
        this.setSelectedIndex(this._selectedIndex)
    }
});
window._p = cc.MenuItemToggle.prototype;
cc.defineGetterSetter(_p, "selectedIndex", _p.getSelectedIndex, _p.setSelectedIndex);
delete window._p;
cc.MenuItemToggle.create = function () {
    0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    var a = new cc.MenuItemToggle;
    a.initWithItems(arguments);
    return a
};
cc.MENU_STATE_WAITING = 0;
cc.MENU_STATE_TRACKING_TOUCH = 1;
cc.MENU_HANDLER_PRIORITY = -128;
cc.DEFAULT_PADDING = 5;
cc.Menu = cc.LayerRGBA.extend({
    enabled: !1,
    _color: null,
    _opacity: 0,
    _selectedItem: null,
    _state: -1,
    _touchListener: null,
    _className: "Menu",
    ctor: function (a) {
        cc.LayerRGBA.prototype.ctor.call(this);
        this._color = cc.color.WHITE;
        this.enabled = !1;
        this._opacity = 255;
        this._selectedItem = null;
        this._state = -1;
        this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: this._onTouchBegan,
            onTouchMoved: this._onTouchMoved,
            onTouchEnded: this._onTouchEnded,
            onTouchCancelled: this._onTouchCancelled
        });
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        var b = arguments.length,
            c;
        if (0 == b) c = [];
        else if (1 == b) c = a instanceof Array ? a : [a];
        else if (1 < b) {
            c = [];
            for (var d = 0; d < b; d++) arguments[d] && c.push(arguments[d])
        }
        this.initWithArray(c)
    },
    onEnter: function () {
        var a = this._touchListener;
        a._isRegistered() || cc.eventManager.addListener(a, this);
        cc.Node.prototype.onEnter.call(this)
    },
    getColor: function () {
        var a = this._color;
        return cc.color(a.r, a.g, a.b,
            a.a)
    },
    setColor: function (a) {
        var b = this._color;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        if ((b = this._children) && 0 < b.length)
            for (var c = 0; c < b.length; c++) b[c].setColor(a);
        void 0 === a.a || a.a_undefined || this.setOpacity(a.a)
    },
    getOpacity: function () {
        return this._opacity
    },
    setOpacity: function (a) {
        this._opacity = a;
        var b = this._children;
        if (b && 0 < b.length)
            for (var c = 0; c < b.length; c++) b[c].setOpacity(a);
        this._color.a = a
    },
    isEnabled: function () {
        return this.enabled
    },
    setEnabled: function (a) {
        this.enabled = a
    },
    initWithItems: function (a) {
        var b = [];
        if (a)
            for (var c =
                0; c < a.length; c++) a[c] && b.push(a[c]);
        return this.initWithArray(b)
    },
    initWithArray: function (a) {
        if (cc.LayerRGBA.prototype.init.call(this)) {
            this.enabled = !0;
            var b = cc.winSize;
            this.setPosition(b.width / 2, b.height / 2);
            this.setContentSize(b);
            this.setAnchorPoint(0.5, 0.5);
            this.ignoreAnchorPointForPosition(!0);
            if (a)
                for (b = 0; b < a.length; b++) this.addChild(a[b], b);
            this._selectedItem = null;
            this._state = cc.MENU_STATE_WAITING;
            return this.cascadeOpacity = this.cascadeColor = !0
        }
        return !1
    },
    addChild: function (a, b, c) {
        if (!(a instanceof cc.MenuItem)) throw "cc.Menu.addChild() : Menu only supports MenuItem objects as children";
        cc.Layer.prototype.addChild.call(this, a, b, c)
    },
    alignItemsVertically: function () {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsVerticallyWithPadding: function (a) {
        var b = -a,
            c = this._children,
            d, e, f, g;
        if (c && 0 < c.length) {
            e = 0;
            for (d = c.length; e < d; e++) b += c[e].height * c[e].scaleY + a;
            var h = b / 2;
            e = 0;
            for (d = c.length; e < d; e++) g = c[e], f = g.height, b = g.scaleY, g.setPosition(0, h - f * b / 2), h -= f * b + a
        }
    },
    alignItemsHorizontally: function () {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsHorizontallyWithPadding: function (a) {
        var b = -a,
            c = this._children,
            d, e, f, g;
        if (c && 0 < c.length) {
            d = 0;
            for (e = c.length; d < e; d++) b += c[d].width * c[d].scaleX + a;
            var h = -b / 2;
            d = 0;
            for (e = c.length; d < e; d++) g = c[d], b = g.scaleX, f = c[d].width, g.setPosition(h + f * b / 2, 0), h += f * b + a
        }
    },
    alignItemsInColumns: function () {
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        for (var a = [], b = 0; b < arguments.length; b++) a.push(arguments[b]);
        var c = -5,
            d = 0,
            e = 0,
            f = 0,
            g, h, k, m =
            this._children;
        if (m && 0 < m.length)
            for (b = 0, k = m.length; b < k; b++) d >= a.length || !(g = a[d]) || (h = m[b].height, e = e >= h || isNaN(h) ? e : h, ++f, f >= g && (c += e + 5, e = f = 0, ++d));
        var n = cc.director.getWinSize(),
            p = g = e = d = 0,
            r = 0,
            c = c / 2;
        if (m && 0 < m.length)
            for (b = 0, k = m.length; b < k; b++) {
                var q = m[b];
                0 == g && (g = a[d], r = p = n.width / (1 + g));
                h = q._getHeight();
                e = e >= h || isNaN(h) ? e : h;
                q.setPosition(r - n.width / 2, c - h / 2);
                r += p;
                ++f;
                f >= g && (c -= e + 5, e = g = f = 0, ++d)
            }
    },
    alignItemsInRows: function () {
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        var a = [],
            b;
        for (b = 0; b < arguments.length; b++) a.push(arguments[b]);
        var c = [],
            d = [],
            e = -10,
            f = -5,
            g = 0,
            h = 0,
            k = 0,
            m, n, p, r, q = this._children;
        if (q && 0 < q.length)
            for (b = 0, p = q.length; b < p; b++)(n = q[b], g >= a.length || !(m = a[g])) || (r = n.width, h = h >= r || isNaN(r) ? h : r, f += n.height + 5, ++k, k >= m && (c.push(h), d.push(f), e += h + 10, h = k = 0, f = -5, ++g));
        f = cc.director.getWinSize();
        m = h = g = 0;
        var e = -e / 2,
            s = 0;
        if (q && 0 < q.length)
            for (b = 0, p = q.length; b < p; b++) n = q[b], 0 == m && (m = a[g], s = d[g]), r = n._getWidth(), h = h >= r || isNaN(r) ? h : r, n.setPosition(e + c[g] / 2, s - f.height / 2),
                s -= n.height + 10, ++k, k >= m && (e += h + 5, h = m = k = 0, ++g)
    },
    removeChild: function (a, b) {
        null != a && (a instanceof cc.MenuItem ? (this._selectedItem == a && (this._selectedItem = null), cc.Node.prototype.removeChild.call(this, a, b)) : cc.log("cc.Menu.removeChild():Menu only supports MenuItem objects as children"))
    },
    _onTouchBegan: function (a, b) {
        var c = b.getCurrentTarget();
        if (c._state != cc.MENU_STATE_WAITING || !c._visible || !c.enabled) return !1;
        for (var d = c.parent; null != d; d = d.parent)
            if (!d.isVisible()) return !1;
        c._selectedItem = c._itemForTouch(a);
        return c._selectedItem ? (c._state = cc.MENU_STATE_TRACKING_TOUCH, c._selectedItem.selected(), !0) : !1
    },
    _onTouchEnded: function (a, b) {
        var c = b.getCurrentTarget();
        c._state !== cc.MENU_STATE_TRACKING_TOUCH ? cc.log("cc.Menu.onTouchEnded(): invalid state") : (c._selectedItem && (c._selectedItem.unselected(), c._selectedItem.activate()), c._state = cc.MENU_STATE_WAITING)
    },
    _onTouchCancelled: function (a, b) {
        var c = b.getCurrentTarget();
        c._state !== cc.MENU_STATE_TRACKING_TOUCH ? cc.log("cc.Menu.onTouchCancelled(): invalid state") : (this._selectedItem &&
            c._selectedItem.unselected(), c._state = cc.MENU_STATE_WAITING)
    },
    _onTouchMoved: function (a, b) {
        var c = b.getCurrentTarget();
        if (c._state !== cc.MENU_STATE_TRACKING_TOUCH) cc.log("cc.Menu.onTouchMoved(): invalid state");
        else {
            var d = c._itemForTouch(a);
            d != c._selectedItem && (c._selectedItem && c._selectedItem.unselected(), c._selectedItem = d, c._selectedItem && c._selectedItem.selected())
        }
    },
    onExit: function () {
        this._state == cc.MENU_STATE_TRACKING_TOUCH && (this._selectedItem && (this._selectedItem.unselected(), this._selectedItem =
            null), this._state = cc.MENU_STATE_WAITING);
        cc.Node.prototype.onExit.call(this)
    },
    setOpacityModifyRGB: function (a) {},
    isOpacityModifyRGB: function () {
        return !1
    },
    _itemForTouch: function (a) {
        a = a.getLocation();
        var b = this._children,
            c;
        if (b && 0 < b.length)
            for (var d = 0; d < b.length; d++)
                if (c = b[d], c.isVisible() && c.isEnabled()) {
                    var e = c.convertToNodeSpace(a),
                        f = c.rect();
                    f.x = 0;
                    f.y = 0;
                    if (cc.rectContainsPoint(f, e)) return c
                }
        return null
    }
});
window._p = cc.Menu.prototype;
delete window._p;
cc.Menu.create = function (a) {
    var b = arguments.length;
    0 < b && null == arguments[b - 1] && cc.log("parameters should not be ending with null in Javascript");
    return 0 == b ? new cc.Menu : 1 == b ? new cc.Menu(a) : new cc.Menu(Array.prototype.slice.call(arguments, 0))
};
cc.TGA_OK = 0;
cc.TGA_ERROR_FILE_OPEN = 1;
cc.TGA_ERROR_READING_FILE = 2;
cc.TGA_ERROR_INDEXED_COLOR = 3;
cc.TGA_ERROR_MEMORY = 4;
cc.TGA_ERROR_COMPRESSED_FILE = 5;
cc.ImageTGA = function (a, b, c, d, e, f, g) {
    this.status = a || 0;
    this.type = b || 0;
    this.pixelDepth = c || 0;
    this.width = d || 0;
    this.height = e || 0;
    this.imageData = f || [];
    this.flipped = g || 0
};
cc.tgaLoadHeader = function (a, b, c) {
    var d = 2;
    if (d + 1 > b) return !1;
    a = new cc.BinaryStreamReader(a);
    a.setOffset(d);
    c.type = a.readByte();
    d += 10;
    if (d + 4 + 1 > b) return !1;
    a.setOffset(d);
    c.width = a.readUnsignedShort();
    c.height = a.readUnsignedInteger();
    c.pixelDepth = a.readByte();
    if (d + 5 + 1 > b) return !1;
    b = a.readByte();
    c.flipped = 0;
    b & 32 && (c.flipped = 1);
    return !0
};
cc.tgaLoadImageData = function (a, b, c) {
    var d, e;
    d = 0 | c.pixelDepth / 2;
    e = c.height * c.width * d;
    if (18 + e > b) return !1;
    c.imageData = cc.__getSubArray(a, 18, 18 + e);
    if (3 <= d)
        for (a = 0; a < e; a += d) b = c.imageData[a], c.imageData[a] = c.imageData[a + 2], c.imageData[a + 2] = b;
    return !0
};
cc.tgaRGBtogreyscale = function (a) {
    var b, c;
    if (8 !== a.pixelDepth) {
        var d = a.pixelDepth / 8,
            e = new Uint8Array(a.height * a.width);
        if (null !== e) {
            for (c = b = 0; c < a.width * a.height; b += d, c++) e[c] = 0.3 * a.imageData[b] + 0.59 * a.imageData[b + 1] + 0.11 * a.imageData[b + 2];
            a.pixelDepth = 8;
            a.type = 3;
            a.imageData = e
        }
    }
};
cc.tgaDestroy = function (a) {
    a && (a.imageData = null)
};
cc.tgaLoadRLEImageData = function (a, b, c) {
    var d, e, f, g = 0,
        h = 0,
        k = 0,
        m = [],
        n = 0,
        p = 18;
    d = c.pixelDepth / 8;
    e = c.height * c.width;
    for (f = 0; f < e; f++) {
        if (0 != n) n--, h = 0 != k;
        else {
            if (p + 1 > b) break;
            n = a[p];
            p += 1;
            (k = n & 128) && (n -= 128);
            h = 0
        } if (!h) {
            if (p + d > b) break;
            m = cc.__getSubArray(a, p, p + d);
            p += d;
            3 <= d && (h = m[0], m[0] = m[2], m[2] = h)
        }
        for (h = 0; h < d; h++) c.imageData[g + h] = m[h];
        g += d
    }
    return !0
};
cc.tgaFlipImage = function (a) {
    for (var b = a.pixelDepth / 8 * a.width, c = 0; c < a.height / 2; c++) {
        var d = cc.__getSubArray(a.imageData, c * b, c * b + b);
        cc.__setDataToArray(cc.__getSubArray(a.imageData, (a.height - (c + 1)) * b, b), a.imageData, c * b);
        cc.__setDataToArray(d, a.imageData, (a.height - (c + 1)) * b)
    }
    a.flipped = 0
};
cc.__getSubArray = function (a, b, c) {
    return a instanceof Array ? a.slice(b, c) : a.subarray(b, c)
};
cc.__setDataToArray = function (a, b, c) {
    for (var d = 0; d < a.length; d++) b[c + d] = a[d]
};
cc.BinaryStreamReader = cc.Class.extend({
    _binaryData: null,
    _offset: 0,
    ctor: function (a) {
        this._binaryData = a
    },
    setBinaryData: function (a) {
        this._binaryData = a;
        this._offset = 0
    },
    getBinaryData: function () {
        return this._binaryData
    },
    _checkSize: function (a) {
        if (!(this._offset + Math.ceil(a / 8) < this._data.length)) throw Error("Index out of bound");
    },
    _decodeFloat: function (a, b) {
        var c = a + b + 1,
            d = c >> 3;
        this._checkSize(c);
        var c = Math.pow(2, b - 1) - 1,
            e = this._readBits(a + b, 1, d),
            f = this._readBits(a, b, d),
            g = 0,
            h = 2,
            k = 0;
        do
            for (var m = this._readByte(++k,
                d), n = a % 8 || 8, p = 1 << n; p >>= 1;) m & p && (g += 1 / h), h *= 2; while (a -= n);
        this._offset += d;
        return f == (c << 1) + 1 ? g ? NaN : e ? -Infinity : Infinity : (1 + -2 * e) * (f || g ? f ? Math.pow(2, f - c) * (1 + g) : Math.pow(2, -c + 1) * g : 0)
    },
    _readByte: function (a, b) {
        return this._data[this._offset + b - a - 1]
    },
    _decodeInt: function (a, b) {
        var c = this._readBits(0, a, a / 8),
            d = Math.pow(2, a);
        this._offset += a / 8;
        return b && c >= d / 2 ? c - d : c
    },
    _shl: function (a, b) {
        for (++b; --b; a = 1073741824 == ((a %= 2147483648) & 1073741824) ? 2 * a : 2 * (a - 1073741824) + 2147483648);
        return a
    },
    _readBits: function (a, b, c) {
        var d =
            (a + b) % 8,
            e = a % 8,
            f = c - (a >> 3) - 1;
        a = c + (-(a + b) >> 3);
        var g = f - a;
        b = this._readByte(f, c) >> e & (1 << (g ? 8 - e : b)) - 1;
        for (g && d && (b += (this._readByte(a++, c) & (1 << d) - 1) << (g-- << 3) - e); g;) b += this._shl(this._readByte(a++, c), (g-- << 3) - e);
        return b
    },
    readInteger: function () {
        return this._decodeInt(32, !0)
    },
    readUnsignedInteger: function () {
        return this._decodeInt(32, !1)
    },
    readSingle: function () {
        return this._decodeFloat(23, 8)
    },
    readShort: function () {
        return this._decodeInt(16, !0)
    },
    readUnsignedShort: function () {
        return this._decodeInt(16, !1)
    },
    readByte: function () {
        var a =
            this._data[this._offset];
        this._offset += 1;
        return a
    },
    readData: function (a, b) {
        return this._binaryData instanceof Array ? this._binaryData.slice(a, b) : this._binaryData.subarray(a, b)
    },
    setOffset: function (a) {
        this._offset = a
    },
    getOffset: function () {
        return this._offset
    }
});
cc.TMX_ORIENTATION_ORTHO = 0;
cc.TMX_ORIENTATION_HEX = 1;
cc.TMX_ORIENTATION_ISO = 2;
cc.TMXTiledMap = cc.NodeRGBA.extend({
    properties: null,
    mapOrientation: null,
    objectGroups: null,
    _mapSize: null,
    _tileSize: null,
    _tileProperties: null,
    _className: "TMXTiledMap",
    ctor: function () {
        cc.Node.prototype.ctor.call(this);
        this._mapSize = cc.size(0, 0);
        this._tileSize = cc.size(0, 0)
    },
    getMapSize: function () {
        return cc.size(this._mapSize.width, this._mapSize.height)
    },
    setMapSize: function (a) {
        this._mapSize.width = a.width;
        this._mapSize.height = a.height
    },
    _getMapWidth: function () {
        return this._mapSize.width
    },
    _setMapWidth: function (a) {
        this._mapSize.width =
            a
    },
    _getMapHeight: function () {
        return this._mapSize.height
    },
    _setMapHeight: function (a) {
        this._mapSize.height = a
    },
    getTileSize: function () {
        return cc.size(this._tileSize.width, this._tileSize.height)
    },
    setTileSize: function (a) {
        this._tileSize.width = a.width;
        this._tileSize.height = a.height
    },
    _getTileWidth: function () {
        return this._tileSize.width
    },
    _setTileWidth: function (a) {
        this._tileSize.width = a
    },
    _getTileHeight: function () {
        return this._tileSize.height
    },
    _setTileHeight: function (a) {
        this._tileSize.height = a
    },
    getMapOrientation: function () {
        return this.mapOrientation
    },
    setMapOrientation: function (a) {
        this.mapOrientation = a
    },
    getObjectGroups: function () {
        return this.objectGroups
    },
    setObjectGroups: function (a) {
        this.objectGroups = a
    },
    getProperties: function () {
        return this.properties
    },
    setProperties: function (a) {
        this.properties = a
    },
    initWithTMXFile: function (a) {
        if (!a || 0 == a.length) throw "cc.TMXTiledMap.initWithTMXFile(): tmxFile should be non-null or non-empty string.";
        this.height = this.width = 0;
        a = cc.TMXMapInfo.create(a);
        if (!a) return !1;
        var b = a.getTilesets();
        b && 0 !== b.length || cc.log("cc.TMXTiledMap.initWithTMXFile(): Map not found. Please check the filename.");
        this._buildWithMapInfo(a);
        return !0
    },
    initWithXML: function (a, b) {
        this.height = this.width = 0;
        var c = cc.TMXMapInfo.create(a, b),
            d = c.getTilesets();
        d && 0 !== d.length || cc.log("cc.TMXTiledMap.initWithXML(): Map not found. Please check the filename.");
        this._buildWithMapInfo(c);
        return !0
    },
    _buildWithMapInfo: function (a) {
        this._mapSize = a.getMapSize();
        this._tileSize = a.getTileSize();
        this.mapOrientation = a.orientation;
        this.objectGroups = a.getObjectGroups();
        this.properties = a.properties;
        this._tileProperties = a.getTileProperties();
        var b = 0,
            c = a.getLayers();
        if (c)
            for (var d = null, e = 0, f = c.length; e < f; e++)(d = c[e]) && d.visible && (d = this._parseLayer(d, a), this.addChild(d, b, b), this.width = Math.max(this.width, d.width), this.height = Math.max(this.height, d.height), b++)
    },
    allLayers: function () {
        for (var a = [], b = this._children, c = 0, d = b.length; c < d; c++) {
            var e = b[c];
            e && e instanceof cc.TMXLayer && a.push(e)
        }
        return a
    },
    getLayer: function (a) {
        if (!a || 0 === a.length) throw "cc.TMXTiledMap.getLayer(): layerName should be non-null or non-empty string.";
        for (var b = this._children,
            c = 0; c < b.length; c++) {
            var d = b[c];
            if (d && d.layerName == a) return d
        }
        return null
    },
    getObjectGroup: function (a) {
        if (!a || 0 === a.length) throw "cc.TMXTiledMap.getObjectGroup(): groupName should be non-null or non-empty string.";
        if (this.objectGroups)
            for (var b = 0; b < this.objectGroups.length; b++) {
                var c = this.objectGroups[b];
                if (c && c.groupName == a) return c
            }
        return null
    },
    getProperty: function (a) {
        return this.properties[a.toString()]
    },
    propertiesForGID: function (a) {
        return this._tileProperties[a]
    },
    _parseLayer: function (a, b) {
        var c =
            this._tilesetForLayer(a, b),
            c = cc.TMXLayer.create(c, a, b);
        a.ownTiles = !1;
        c.setupTiles();
        return c
    },
    _tilesetForLayer: function (a, b) {
        var c = a._layerSize,
            d = b.getTilesets();
        if (d)
            for (var e = d.length - 1; 0 <= e; e--) {
                var f = d[e];
                if (f)
                    for (var g = 0; g < c.height; g++)
                        for (var h = 0; h < c.width; h++) {
                            var k = a._tiles[h + c.width * g];
                            if (0 != k && (k & cc.TMX_TILE_FLIPPED_MASK) >>> 0 >= f.firstGid) return f
                        }
            }
        cc.log("cocos2d: Warning: TMX Layer " + a.name + " has no tiles");
        return null
    }
});
window._p = cc.TMXTiledMap.prototype;
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
delete window._p;
cc.TMXTiledMap.create = function (a, b) {
    var c = new cc.TMXTiledMap;
    if (b) {
        if (c.initWithXML(a, b)) return c
    } else if (c.initWithTMXFile(a)) return c;
    return null
};
cc.TMX_LAYER_ATTRIB_NONE = 1;
cc.TMX_LAYER_ATTRIB_BASE64 = 2;
cc.TMX_LAYER_ATTRIB_GZIP = 4;
cc.TMX_LAYER_ATTRIB_ZLIB = 8;
cc.TMX_PROPERTY_NONE = 0;
cc.TMX_PROPERTY_MAP = 1;
cc.TMX_PROPERTY_LAYER = 2;
cc.TMX_PROPERTY_OBJECTGROUP = 3;
cc.TMX_PROPERTY_OBJECT = 4;
cc.TMX_PROPERTY_TILE = 5;
cc.TMX_TILE_HORIZONTAL_FLAG = 2147483648;
cc.TMX_TILE_VERTICAL_FLAG = 1073741824;
cc.TMX_TILE_DIAGONAL_FLAG = 536870912;
cc.TMX_TILE_FLIPPED_ALL = (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_DIAGONAL_FLAG) >>> 0;
cc.TMX_TILE_FLIPPED_MASK = ~cc.TMX_TILE_FLIPPED_ALL >>> 0;
cc.TMXLayerInfo = cc.Class.extend({
    properties: null,
    name: "",
    _layerSize: null,
    _tiles: null,
    visible: null,
    _opacity: null,
    ownTiles: !0,
    _minGID: 1E5,
    _maxGID: 0,
    offset: null,
    ctor: function () {
        this.properties = [];
        this.name = "";
        this._layerSize = null;
        this._tiles = [];
        this.visible = !0;
        this._opacity = 0;
        this.ownTiles = !0;
        this._minGID = 1E5;
        this._maxGID = 0;
        this.offset = cc.p(0, 0)
    },
    getProperties: function () {
        return this.properties
    },
    setProperties: function (a) {
        this.properties = a
    }
});
cc.TMXTilesetInfo = cc.Class.extend({
    name: "",
    firstGid: 0,
    _tileSize: null,
    spacing: 0,
    margin: 0,
    sourceImage: "",
    imageSize: null,
    ctor: function () {
        this._tileSize = cc.size(0, 0);
        this.imageSize = cc.size(0, 0)
    },
    rectForGID: function (a) {
        var b = cc.rect(0, 0, 0, 0);
        b.width = this._tileSize.width;
        b.height = this._tileSize.height;
        a &= cc.TMX_TILE_FLIPPED_MASK;
        a -= parseInt(this.firstGid, 10);
        var c = parseInt((this.imageSize.width - 2 * this.margin + this.spacing) / (this._tileSize.width + this.spacing), 10);
        b.x = parseInt(a % c * (this._tileSize.width + this.spacing) +
            this.margin, 10);
        b.y = parseInt(parseInt(a / c, 10) * (this._tileSize.height + this.spacing) + this.margin, 10);
        return b
    }
});
cc.TMXMapInfo = cc.SAXParser.extend({
    properties: null,
    orientation: null,
    parentElement: null,
    parentGID: null,
    layerAttrs: 0,
    storingCharacters: !1,
    tmxFileName: null,
    currentString: null,
    _objectGroups: null,
    _mapSize: null,
    _tileSize: null,
    _layers: null,
    _tilesets: null,
    _tileProperties: null,
    _resources: "",
    _currentFirstGID: 0,
    ctor: function () {
        cc.SAXParser.prototype.ctor.apply(this);
        this._mapSize = cc.size(0, 0);
        this._tileSize = cc.size(0, 0);
        this._layers = [];
        this._tilesets = [];
        this._objectGroups = [];
        this.properties = [];
        this._tileProperties = {};
        this._currentFirstGID = 0
    },
    getOrientation: function () {
        return this.orientation
    },
    setOrientation: function (a) {
        this.orientation = a
    },
    getMapSize: function () {
        return cc.size(this._mapSize.width, this._mapSize.height)
    },
    setMapSize: function (a) {
        this._mapSize.width = a.width;
        this._mapSize.height = a.height
    },
    _getMapWidth: function () {
        return this._mapSize.width
    },
    _setMapWidth: function (a) {
        this._mapSize.width = a
    },
    _getMapHeight: function () {
        return this._mapSize.height
    },
    _setMapHeight: function (a) {
        this._mapSize.height = a
    },
    getTileSize: function () {
        return cc.size(this._tileSize.width,
            this._tileSize.height)
    },
    setTileSize: function (a) {
        this._tileSize.width = a.width;
        this._tileSize.height = a.height
    },
    _getTileWidth: function () {
        return this._tileSize.width
    },
    _setTileWidth: function (a) {
        this._tileSize.width = a
    },
    _getTileHeight: function () {
        return this._tileSize.height
    },
    _setTileHeight: function (a) {
        this._tileSize.height = a
    },
    getLayers: function () {
        return this._layers
    },
    setLayers: function (a) {
        this._layers.push(a)
    },
    getTilesets: function () {
        return this._tilesets
    },
    setTilesets: function (a) {
        this._tilesets.push(a)
    },
    getObjectGroups: function () {
        return this._objectGroups
    },
    setObjectGroups: function (a) {
        this._objectGroups.push(a)
    },
    getParentElement: function () {
        return this.parentElement
    },
    setParentElement: function (a) {
        this.parentElement = a
    },
    getParentGID: function () {
        return this.parentGID
    },
    setParentGID: function (a) {
        this.parentGID = a
    },
    getLayerAttribs: function () {
        return this.layerAttrs
    },
    setLayerAttribs: function (a) {
        this.layerAttrs = a
    },
    getStoringCharacters: function () {
        return this.storingCharacters
    },
    setStoringCharacters: function (a) {
        this.storingCharacters =
            a
    },
    getProperties: function () {
        return this.properties
    },
    setProperties: function (a) {
        this.properties = a
    },
    initWithTMXFile: function (a) {
        this._internalInit(a, null);
        return this.parseXMLFile(a)
    },
    initWithXML: function (a, b) {
        this._internalInit(null, b);
        return this.parseXMLString(a)
    },
    parseXMLFile: function (a, b) {
        var c = (b = b || !1) ? a : cc.loader.getRes(a);
        if (!c) throw "Please load the resource first : " + a;
        var d, e, c = this._parseXML(c).documentElement;
        d = c.getAttribute("version");
        e = c.getAttribute("orientation");
        if ("map" == c.nodeName &&
            ("1.0" != d && null !== d && cc.log("cocos2d: TMXFormat: Unsupported TMX version:" + d), "orthogonal" == e ? this.orientation = cc.TMX_ORIENTATION_ORTHO : "isometric" == e ? this.orientation = cc.TMX_ORIENTATION_ISO : "hexagonal" == e ? this.orientation = cc.TMX_ORIENTATION_HEX : null !== e && cc.log("cocos2d: TMXFomat: Unsupported orientation:" + e), d = cc.size(0, 0), d.width = parseFloat(c.getAttribute("width")), d.height = parseFloat(c.getAttribute("height")), this.setMapSize(d), d = cc.size(0, 0), d.width = parseFloat(c.getAttribute("tilewidth")), d.height =
                parseFloat(c.getAttribute("tileheight")), this.setTileSize(d), e = c.querySelectorAll("map \x3e properties \x3e  property"))) {
            var f = {};
            for (d = 0; d < e.length; d++) f[e[d].getAttribute("name")] = e[d].getAttribute("value");
            this.properties = f
        }
        e = c.getElementsByTagName("tileset");
        "map" !== c.nodeName && (e = [], e.push(c));
        for (d = 0; d < e.length; d++) {
            var g = e[d];
            if (f = g.getAttribute("source")) f = b ? cc.path.join(this._resources, f) : cc.path.changeBasename(a, f), this.parseXMLFile(f);
            else {
                f = new cc.TMXTilesetInfo;
                f.name = g.getAttribute("name") ||
                    "";
                f.firstGid = parseInt(g.getAttribute("firstgid")) || 0;
                f.spacing = parseInt(g.getAttribute("spacing")) || 0;
                f.margin = parseInt(g.getAttribute("margin")) || 0;
                var h = cc.size(0, 0);
                h.width = parseFloat(g.getAttribute("tilewidth"));
                h.height = parseFloat(g.getAttribute("tileheight"));
                f._tileSize = h;
                g = g.getElementsByTagName("image")[0].getAttribute("source");
                h = -1;
                this.tmxFileName && (h = this.tmxFileName.lastIndexOf("/")); - 1 !== h ? (h = this.tmxFileName.substr(0, h + 1), f.sourceImage = h + g) : f.sourceImage = this._resources + (this._resources ?
                    "/" : "") + g;
                this.setTilesets(f)
            }
        }
        if (f = c.querySelectorAll("tile"))
            for (d = 0; d < f.length; d++)
                if (e = f[d], this.parentGID = parseInt(this._tilesets[0].firstGid) + parseInt(e.getAttribute("id") || 0), g = e.querySelectorAll("properties \x3e property")) {
                    h = {};
                    for (e = 0; e < g.length; e++) {
                        var k = g[e].getAttribute("name");
                        h[k] = g[e].getAttribute("value")
                    }
                    this._tileProperties[this.parentGID] = h
                }
        if (f = c.getElementsByTagName("layer"))
            for (d = 0; d < f.length; d++) {
                h = f[d];
                k = h.getElementsByTagName("data")[0];
                g = new cc.TMXLayerInfo;
                g.name = h.getAttribute("name");
                e = cc.size(0, 0);
                e.width = parseFloat(h.getAttribute("width"));
                e.height = parseFloat(h.getAttribute("height"));
                g._layerSize = e;
                e = h.getAttribute("visible");
                g.visible = "0" != e;
                e = h.getAttribute("opacity") || 1;
                g._opacity = e ? parseInt(255 * parseFloat(e)) : 255;
                g.offset = cc.p(parseFloat(h.getAttribute("x")) || 0, parseFloat(h.getAttribute("y")) || 0);
                var m = "";
                for (e = 0; e < k.childNodes.length; e++) m += k.childNodes[e].nodeValue;
                m = m.trim();
                e = k.getAttribute("compression");
                var n = k.getAttribute("encoding");
                if (e && "gzip" !== e && "zlib" !==
                    e) return cc.log("cc.TMXMapInfo.parseXMLFile(): unsupported compression method"), null;
                switch (e) {
                case "gzip":
                    g._tiles = cc.unzipBase64AsArray(m, 4);
                    break;
                case "zlib":
                    e = new Zlib.Inflate(cc.Codec.Base64.decodeAsArray(m, 1));
                    g._tiles = cc.uint8ArrayToUint32Array(e.decompress());
                    break;
                case null:
                case "":
                    if ("base64" == n) g._tiles = cc.Codec.Base64.decodeAsArray(m, 4);
                    else if ("csv" === n)
                        for (g._tiles = [], e = m.split(","), k = 0; k < e.length; k++) g._tiles.push(parseInt(e[k]));
                    else
                        for (e = k.getElementsByTagName("tile"), g._tiles = [],
                            k = 0; k < e.length; k++) g._tiles.push(parseInt(e[k].getAttribute("gid")));
                    break;
                default:
                    this.layerAttrs == cc.TMX_LAYER_ATTRIB_NONE && cc.log("cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported")
                }
                if (h = h.querySelectorAll("properties \x3e property")) {
                    k = {};
                    for (e = 0; e < h.length; e++) k[h[e].getAttribute("name")] = h[e].getAttribute("value");
                    g.properties = k
                }
                this.setLayers(g)
            }
        if (f = c.getElementsByTagName("objectgroup"))
            for (d = 0; d < f.length; d++) {
                h = f[d];
                g = new cc.TMXObjectGroup;
                g.groupName = h.getAttribute("name");
                g.setPositionOffset(cc.p(parseFloat(h.getAttribute("x")) * this.getTileSize().width || 0, parseFloat(h.getAttribute("y")) * this.getTileSize().height || 0));
                if (k = h.querySelectorAll("objectgroup \x3e properties \x3e property"))
                    for (e = 0; e < k.length; e++) m = {}, m[k[e].getAttribute("name")] = k[e].getAttribute("value"), g.properties = m;
                if (h = h.querySelectorAll("object"))
                    for (e = 0; e < h.length; e++) {
                        m = h[e];
                        k = {};
                        k.name = m.getAttribute("name") || "";
                        k.type = m.getAttribute("type") || "";
                        k.x = parseInt(m.getAttribute("x") || 0) + g.getPositionOffset().x;
                        n = parseInt(m.getAttribute("y") || 0) + g.getPositionOffset().y;
                        k.width = parseInt(m.getAttribute("width")) || 0;
                        k.height = parseInt(m.getAttribute("height")) || 0;
                        k.y = parseInt(this.getMapSize().height * this.getTileSize().height) - n - k.height;
                        if (n = m.querySelectorAll("properties \x3e property"))
                            for (var p = 0; p < n.length; p++) k[n[p].getAttribute("name")] = n[p].getAttribute("value");
                        (n = m.querySelectorAll("polygon")) && 0 < n.length && (n = n[0].getAttribute("points")) && (k.polygonPoints = this._parsePointsString(n));
                        (m = m.querySelectorAll("polyline")) &&
                        0 < m.length && (m = m[0].getAttribute("points")) && (k.polylinePoints = this._parsePointsString(m));
                        g.setObjects(k)
                    }
                this.setObjectGroups(g)
            }
        return c
    },
    _parsePointsString: function (a) {
        if (!a) return null;
        var b = [];
        a = a.split(" ");
        for (var c = 0; c < a.length; c++) {
            var d = a[c].split(",");
            b.push({
                x: d[0],
                y: d[1]
            })
        }
        return b
    },
    parseXMLString: function (a) {
        return this.parseXMLFile(a, !0)
    },
    getTileProperties: function () {
        return this._tileProperties
    },
    setTileProperties: function (a) {
        this._tileProperties.push(a)
    },
    getCurrentString: function () {
        return this.currentString
    },
    setCurrentString: function (a) {
        this.currentString = a
    },
    getTMXFileName: function () {
        return this.tmxFileName
    },
    setTMXFileName: function (a) {
        this.tmxFileName = a
    },
    _internalInit: function (a, b) {
        this._tilesets.length = 0;
        this._layers.length = 0;
        this.tmxFileName = a;
        b && (this._resources = b);
        this._objectGroups.length = 0;
        this.properties.length = 0;
        this._tileProperties.length = 0;
        this.currentString = "";
        this.storingCharacters = !1;
        this.layerAttrs = cc.TMX_LAYER_ATTRIB_NONE;
        this.parentElement = cc.TMX_PROPERTY_NONE;
        this._currentFirstGID = 0
    }
});
window._p = cc.TMXMapInfo.prototype;
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
delete window._p;
cc.TMXMapInfo.create = function (a, b) {
    var c = new cc.TMXMapInfo;
    if (b) {
        if (c.initWithXML(a, b)) return c
    } else if (c.initWithTMXFile(a)) return c;
    return null
};
cc.loader.register(["tmx", "tsx"], cc._txtLoader);
cc.TMXObjectGroup = cc.Class.extend({
    properties: null,
    groupName: "",
    _positionOffset: null,
    _objects: null,
    ctor: function () {
        this.groupName = "";
        this._positionOffset = cc.p(0, 0);
        this.properties = [];
        this._objects = []
    },
    getPositionOffset: function () {
        return this._positionOffset
    },
    setPositionOffset: function (a) {
        this._positionOffset.x = a.x;
        this._positionOffset.y = a.y
    },
    getProperties: function () {
        return this.properties
    },
    setProperties: function (a) {
        this.properties.push(a)
    },
    getGroupName: function () {
        return this.groupName.toString()
    },
    setGroupName: function (a) {
        this.groupName = a
    },
    propertyNamed: function (a) {
        return this.properties[a]
    },
    objectNamed: function (a) {
        if (this._objects && 0 < this._objects.length)
            for (var b = this._objects, c = 0, d = b.length; c < d; c++) {
                var e = b[c].name;
                if (e && e == a) return b[c]
            }
        return null
    },
    getObjects: function () {
        return this._objects
    },
    setObjects: function (a) {
        this._objects.push(a)
    }
});
cc.TMXLayer = cc.SpriteBatchNode.extend({
    tiles: null,
    tileset: null,
    layerOrientation: null,
    properties: null,
    layerName: "",
    _layerSize: null,
    _mapTileSize: null,
    _opacity: 255,
    _minGID: null,
    _maxGID: null,
    _vertexZvalue: null,
    _useAutomaticVertexZ: null,
    _alphaFuncValue: null,
    _reusedTile: null,
    _atlasIndexArray: null,
    _contentScaleFactor: null,
    _cacheCanvas: null,
    _cacheContext: null,
    _cacheTexture: null,
    _subCacheCanvas: null,
    _subCacheContext: null,
    _subCacheCount: 0,
    _subCacheWidth: 0,
    _maxCachePixel: 1E7,
    _className: "TMXLayer",
    ctor: function () {
        cc.SpriteBatchNode.prototype.ctor.call(this);
        this._descendants = [];
        this._layerSize = cc.size(0, 0);
        this._mapTileSize = cc.size(0, 0);
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
            var a = cc._canvas,
                b = document.createElement("canvas");
            b.width = a.width;
            b.height = a.height;
            this._cacheCanvas = b;
            this._cacheContext = this._cacheCanvas.getContext("2d");
            var c = new cc.Texture2D;
            c.initWithElement(b);
            c.handleLoadedTexture();
            this._cacheTexture = c;
            this.width = a.width;
            this.height = a.height;
            this._cachedParent = this
        }
    },
    setContentSize: function (a, b) {
        var c = this._contentSize;
        cc.Node.prototype.setContentSize.call(this,
            a, b);
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
            var d = this._cacheCanvas,
                e = cc.CONTENT_SCALE_FACTOR();
            d.width = 0 | 1.5 * c.width * e;
            d.height = 0 | 1.5 * c.height * e;
            this._cacheContext.translate(0, d.height);
            c = this._cacheTexture._contentSize;
            c.width = d.width;
            c.height = d.height;
            c = d.width * d.height;
            if (c > this._maxCachePixel) {
                this._subCacheCanvas || (this._subCacheCanvas = []);
                this._subCacheContext || (this._subCacheContext = []);
                this._subCacheCount = Math.ceil(c / this._maxCachePixel);
                c = this._subCacheCanvas;
                for (e = 0; e < this._subCacheCount; e++) {
                    c[e] ||
                        (c[e] = document.createElement("canvas"), this._subCacheContext[e] = c[e].getContext("2d"));
                    var f = c[e];
                    f.width = this._subCacheWidth = Math.round(d.width / this._subCacheCount);
                    f.height = d.height
                }
                for (e = this._subCacheCount; e < c.length; e++) f.width = 0, f.height = 0
            } else this._subCacheCount = 0
        }
    },
    getTexture: null,
    _getTextureForCanvas: function () {
        return this._cacheTexture
    },
    visit: null,
    _visitForCanvas: function (a) {
        var b = a || cc._renderContext;
        if (this._visible) {
            b.save();
            this.transform(a);
            var c, d = this._children;
            if (this._cacheDirty) {
                var e =
                    cc.view;
                e._setScaleXYForRenderTexture();
                var f = this._cacheContext,
                    g = this._cacheCanvas;
                f.clearRect(0, 0, g.width, -g.height);
                f.save();
                f.translate(this._anchorPointInPoints.x, -this._anchorPointInPoints.y);
                if (d)
                    for (this.sortAllChildren(), c = 0; c < d.length; c++) d[c] && d[c].visit(f);
                f.restore();
                if (0 < this._subCacheCount)
                    for (d = this._subCacheWidth, f = g.height, c = 0; c < this._subCacheCount; c++) this._subCacheContext[c].drawImage(g, c * d, 0, d, f, 0, 0, d, f);
                e._resetScale();
                this._cacheDirty = !1
            }
            this.draw(a);
            b.restore()
        }
    },
    draw: null,
    _drawForCanvas: function (a) {
        a = a || cc._renderContext;
        var b = 0 | -this._anchorPointInPoints.x,
            c = 0 | -this._anchorPointInPoints.y,
            d = cc.view,
            e = this._cacheCanvas;
        if (e) {
            var f = this._subCacheCount,
                g = e.height * d._scaleY;
            if (0 < f)
                for (var e = this._subCacheCanvas, h = 0; h < f; h++) {
                    var k = e[h];
                    a.drawImage(e[h], 0, 0, k.width, k.height, b + h * this._subCacheWidth, -(c + g), k.width * d._scaleX, g)
                } else a.drawImage(e, 0, 0, e.width, e.height, b, -(c + g), e.width * d._scaleX, g)
        }
    },
    getLayerSize: function () {
        return cc.size(this._layerSize.width, this._layerSize.height)
    },
    setLayerSize: function (a) {
        this._layerSize.width = a.width;
        this._layerSize.height = a.height
    },
    _getLayerWidth: function () {
        return this._layerSize.width
    },
    _setLayerWidth: function (a) {
        this._layerSize.width = a
    },
    _getLayerHeight: function () {
        return this._layerSize.height
    },
    _setLayerHeight: function (a) {
        this._layerSize.height = a
    },
    getMapTileSize: function () {
        return cc.size(this._mapTileSize.width, this._mapTileSize.height)
    },
    setMapTileSize: function (a) {
        this._mapTileSize.width = a.width;
        this._mapTileSize.height = a.height
    },
    _getTileWidth: function () {
        return this._mapTileSize.width
    },
    _setTileWidth: function (a) {
        this._mapTileSize.width = a
    },
    _getTileHeight: function () {
        return this._mapTileSize.height
    },
    _setTileHeight: function (a) {
        this._mapTileSize.height = a
    },
    getTiles: function () {
        return this.tiles
    },
    setTiles: function (a) {
        this.tiles = a
    },
    getTileset: function () {
        return this.tileset
    },
    setTileset: function (a) {
        this.tileset = a
    },
    getLayerOrientation: function () {
        return this.layerOrientation
    },
    setLayerOrientation: function (a) {
        this.layerOrientation = a
    },
    getProperties: function () {
        return this.properties
    },
    setProperties: function (a) {
        this.properties =
            a
    },
    initWithTilesetInfo: function (a, b, c) {
        var d = b._layerSize,
            e = 0.35 * parseInt(d.width * d.height) + 1,
            f;
        a && (f = cc.textureCache.addImage(a.sourceImage));
        return this.initWithTexture(f, e) ? (this.layerName = b.name, this._layerSize = d, this.tiles = b._tiles, this._minGID = b._minGID, this._maxGID = b._maxGID, this._opacity = b._opacity, this.properties = b.properties, this._contentScaleFactor = cc.director.getContentScaleFactor(), this.tileset = a, this._mapTileSize = c.getTileSize(), this.layerOrientation = c.orientation, a = this._calculateLayerOffset(b.offset),
            this.setPosition(cc.POINT_PIXELS_TO_POINTS(a)), this._atlasIndexArray = [], this.setContentSize(cc.SIZE_PIXELS_TO_POINTS(cc.size(this._layerSize.width * this._mapTileSize.width, this._layerSize.height * this._mapTileSize.height))), this._useAutomaticVertexZ = !1, this._vertexZvalue = 0, !0) : !1
    },
    releaseMap: function () {
        this.tiles && (this.tiles = null);
        this._atlasIndexArray && (this._atlasIndexArray = null)
    },
    getTileAt: function (a) {
        if (!a) throw "cc.TMXLayer.getTileAt(): pos should be non-null";
        if (a.x >= this._layerSize.width || a.y >=
            this._layerSize.height || 0 > a.x || 0 > a.y) throw "cc.TMXLayer.getTileAt(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) return cc.log("cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released"), null;
        var b = null,
            c = this.getTileGIDAt(a);
        if (0 === c) return b;
        var d = 0 | a.x + a.y * this._layerSize.width,
            b = this.getChildByTag(d);
        b || (c = this.tileset.rectForGID(c), c = cc.RECT_PIXELS_TO_POINTS(c), b = new cc.Sprite, b.initWithTexture(this.texture, c), b.batchNode = this, b.setPosition(this.getPositionAt(a)), b.vertexZ =
            this._vertexZForPos(a), b.anchorX = 0, b.anchorY = 0, b.opacity = this._opacity, a = this._atlasIndexForExistantZ(d), this.addSpriteWithoutQuad(b, a, d));
        return b
    },
    getTileGIDAt: function (a) {
        if (!a) throw "cc.TMXLayer.getTileGIDAt(): pos should be non-null";
        if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw "cc.TMXLayer.getTileGIDAt(): invalid position";
        return this.tiles && this._atlasIndexArray ? (this.tiles[0 | a.x + a.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_MASK) >>> 0 : (cc.log("cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released"),
            null)
    },
    getTileFlagsAt: function (a) {
        if (!a) throw "cc.TMXLayer.getTileFlagsAt(): pos should be non-null";
        if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw "cc.TMXLayer.getTileFlagsAt(): invalid position";
        return this.tiles && this._atlasIndexArray ? (this.tiles[0 | a.x + a.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_ALL) >>> 0 : (cc.log("cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released"), null)
    },
    setTileGID: function (a, b, c) {
        if (!b) throw "cc.TMXLayer.setTileGID(): pos should be non-null";
        if (b.x >= this._layerSize.width || b.y >= this._layerSize.height || 0 > b.x || 0 > b.y) throw "cc.TMXLayer.setTileGID(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) return cc.log("cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released"), null;
        if (0 !== a && a < this.tileset.firstGid) return cc.log("cc.TMXLayer.setTileGID(): invalid gid:" + a), null;
        c = c || 0;
        this._setNodeDirtyForCache();
        var d = this.getTileFlagsAt(b),
            e = this.getTileGIDAt(b);
        if (e != a || d != c)
            if (d = (a | c) >>> 0, 0 === a) this.removeTileAt(b);
            else if (0 ===
            e) this._insertTileForGID(d, b);
        else {
            var e = b.x + b.y * this._layerSize.width,
                f = this.getChildByTag(e);
            f ? (a = this.tileset.rectForGID(a), a = cc.RECT_PIXELS_TO_POINTS(a), f.setTextureRect(a, !1), null != c && this._setupTileSprite(f, b, d), this.tiles[e] = d) : this._updateTileForGID(d, b)
        }
    },
    removeTileAt: function (a) {
        if (!a) throw "cc.TMXLayer.removeTileAt(): pos should be non-null";
        if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw "cc.TMXLayer.removeTileAt(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) return cc.log("cc.TMXLayer.removeTileAt(): TMXLayer: the tiles map has been released"),
            null;
        if (0 !== this.getTileGIDAt(a)) {
            cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
            var b = 0 | a.x + a.y * this._layerSize.width;
            a = this._atlasIndexForExistantZ(b);
            this.tiles[b] = 0;
            this._atlasIndexArray.splice(a, 1);
            if (b = this.getChildByTag(b)) cc.SpriteBatchNode.prototype.removeChild.call(this, b, !0);
            else if (cc._renderType === cc._RENDER_TYPE_WEBGL && this.textureAtlas.removeQuadAtIndex(a), this._children)
                for (var b = this._children, c = 0, d = b.length; c < d; c++) {
                    var e = b[c];
                    if (e) {
                        var f = e.atlasIndex;
                        f >= a &&
                            (e.atlasIndex = f - 1)
                    }
                }
        }
    },
    getPositionAt: function (a) {
        var b = cc.p(0, 0);
        switch (this.layerOrientation) {
        case cc.TMX_ORIENTATION_ORTHO:
            b = this._positionForOrthoAt(a);
            break;
        case cc.TMX_ORIENTATION_ISO:
            b = this._positionForIsoAt(a);
            break;
        case cc.TMX_ORIENTATION_HEX:
            b = this._positionForHexAt(a)
        }
        return cc.POINT_PIXELS_TO_POINTS(b)
    },
    getProperty: function (a) {
        return this.properties[a]
    },
    setupTiles: function () {
        cc._renderType === cc._RENDER_TYPE_CANVAS ? this.tileset.imageSize = this._originalTexture.getContentSizeInPixels() : (this.tileset.imageSize =
            this.textureAtlas.texture.getContentSizeInPixels(), this.textureAtlas.texture.setAliasTexParameters());
        this._parseInternalProperties();
        cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
        for (var a = this._layerSize.height, b = this._layerSize.width, c = 0; c < a; c++)
            for (var d = 0; d < b; d++) {
                var e = this.tiles[d + b * c];
                0 !== e && (this._appendTileForGID(e, cc.p(d, c)), this._minGID = Math.min(e, this._minGID), this._maxGID = Math.max(e, this._maxGID))
            }
        this._maxGID >= this.tileset.firstGid && this._minGID >= this.tileset.firstGid ||
            cc.log("cocos2d:TMX: Only 1 tileset per layer is supported")
    },
    addChild: function (a, b, c) {
        cc.log("addChild: is not supported on cc.TMXLayer. Instead use setTileGID or tileAt.")
    },
    removeChild: function (a, b) {
        if (a)
            if (-1 === this._children.indexOf(a)) cc.log("cc.TMXLayer.removeChild(): Tile does not belong to TMXLayer");
            else {
                cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
                var c = a.atlasIndex;
                this.tiles[this._atlasIndexArray[c]] = 0;
                this._atlasIndexArray.splice(c, 1);
                cc.SpriteBatchNode.prototype.removeChild.call(this,
                    a, b)
            }
    },
    getLayerName: function () {
        return this.layerName
    },
    setLayerName: function (a) {
        this.layerName = a
    },
    _positionForIsoAt: function (a) {
        return cc.p(this._mapTileSize.width / 2 * (this._layerSize.width + a.x - a.y - 1), this._mapTileSize.height / 2 * (2 * this._layerSize.height - a.x - a.y - 2))
    },
    _positionForOrthoAt: function (a) {
        return cc.p(a.x * this._mapTileSize.width, (this._layerSize.height - a.y - 1) * this._mapTileSize.height)
    },
    _positionForHexAt: function (a) {
        return cc.p(a.x * this._mapTileSize.width * 3 / 4, (this._layerSize.height - a.y - 1) * this._mapTileSize.height +
            (1 == a.x % 2 ? -this._mapTileSize.height / 2 : 0))
    },
    _calculateLayerOffset: function (a) {
        var b = cc.p(0, 0);
        switch (this.layerOrientation) {
        case cc.TMX_ORIENTATION_ORTHO:
            b = cc.p(a.x * this._mapTileSize.width, -a.y * this._mapTileSize.height);
            break;
        case cc.TMX_ORIENTATION_ISO:
            b = cc.p(this._mapTileSize.width / 2 * (a.x - a.y), this._mapTileSize.height / 2 * (-a.x - a.y));
            break;
        case cc.TMX_ORIENTATION_HEX:
            0 === a.x && 0 === a.y || cc.log("offset for hexagonal map not implemented yet")
        }
        return b
    },
    _appendTileForGID: function (a, b) {
        var c = this.tileset.rectForGID(a),
            c = cc.RECT_PIXELS_TO_POINTS(c),
            d = 0 | b.x + b.y * this._layerSize.width,
            c = this._reusedTileWithRect(c);
        this._setupTileSprite(c, b, a);
        var e = this._atlasIndexArray.length;
        this.insertQuadFromSprite(c, e);
        this._atlasIndexArray.splice(e, 0, d);
        return c
    },
    _insertTileForGID: function (a, b) {
        var c = this.tileset.rectForGID(a),
            c = cc.RECT_PIXELS_TO_POINTS(c),
            d = 0 | b.x + b.y * this._layerSize.width,
            c = this._reusedTileWithRect(c);
        this._setupTileSprite(c, b, a);
        var e = this._atlasIndexForNewZ(d);
        this.insertQuadFromSprite(c, e);
        this._atlasIndexArray.splice(e,
            0, d);
        if (this._children)
            for (var f = this._children, g = 0, h = f.length; g < h; g++) {
                var k = f[g];
                if (k) {
                    var m = k.atlasIndex;
                    m >= e && (k.atlasIndex = m + 1)
                }
            }
        this.tiles[d] = a;
        return c
    },
    _updateTileForGID: function (a, b) {
        var c = this.tileset.rectForGID(a),
            d = this._contentScaleFactor,
            c = cc.rect(c.x / d, c.y / d, c.width / d, c.height / d),
            d = b.x + b.y * this._layerSize.width,
            c = this._reusedTileWithRect(c);
        this._setupTileSprite(c, b, a);
        var e = this._atlasIndexForExistantZ(d);
        c.atlasIndex = e;
        c.dirty = !0;
        c.updateTransform();
        this.tiles[d] = a;
        return c
    },
    _parseInternalProperties: function () {
        var a =
            this.getProperty("cc_vertexz");
        if (a)
            if ("automatic" == a) {
                this._useAutomaticVertexZ = !0;
                var b = this.getProperty("cc_alpha_func"),
                    a = 0;
                b && (a = parseFloat(b));
                cc._renderType === cc._RENDER_TYPE_WEBGL && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST), b = cc._renderContext.getUniformLocation(this.shaderProgram.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S), this.shaderProgram.use(), this.shaderProgram.setUniformLocationWith1f(b, a))
            } else this._vertexZvalue = parseInt(a, 10)
    },
    _setupTileSprite: function (a,
        b, c) {
        var d = b.x + b.y * this._layerSize.width;
        a.setPosition(this.getPositionAt(b));
        cc._renderType === cc._RENDER_TYPE_WEBGL ? a.vertexZ = this._vertexZForPos(b) : a.tag = d;
        a.anchorX = 0;
        a.anchorY = 0;
        a.opacity = this._opacity;
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.rotation = 0);
        a.setFlippedX(!1);
        a.setFlippedY(!1);
        (c & cc.TMX_TILE_DIAGONAL_FLAG) >>> 0 ? (a.anchorX = 0.5, a.anchorY = 0.5, a.x = this.getPositionAt(b).x + a.width / 2, a.y = this.getPositionAt(b).y + a.height / 2, b = (c & (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG) >>> 0) >>>
            0, b == cc.TMX_TILE_HORIZONTAL_FLAG ? a.rotation = 90 : b == cc.TMX_TILE_VERTICAL_FLAG ? a.rotation = 270 : (a.rotation = b == (cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 ? 90 : 270, a.setFlippedX(!0))) : ((c & cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 && a.setFlippedX(!0), (c & cc.TMX_TILE_VERTICAL_FLAG) >>> 0 && a.setFlippedY(!0))
    },
    _reusedTileWithRect: function (a) {
        cc._renderType === cc._RENDER_TYPE_WEBGL ? (this._reusedTile ? (this._reusedTile.batchNode = null, this._reusedTile.setTextureRect(a, !1)) : (this._reusedTile = new cc.Sprite, this._reusedTile.initWithTexture(this.texture,
            a, !1)), this._reusedTile.batchNode = this) : (this._reusedTile = new cc.Sprite, this._reusedTile.initWithTexture(this._textureForCanvas, a, !1), this._reusedTile.batchNode = this, this._reusedTile.parent = this);
        return this._reusedTile
    },
    _vertexZForPos: function (a) {
        var b = 0,
            c = 0;
        if (this._useAutomaticVertexZ) switch (this.layerOrientation) {
        case cc.TMX_ORIENTATION_ISO:
            c = this._layerSize.width + this._layerSize.height;
            b = -(c - (a.x + a.y));
            break;
        case cc.TMX_ORIENTATION_ORTHO:
            b = -(this._layerSize.height - a.y);
            break;
        case cc.TMX_ORIENTATION_HEX:
            cc.log("TMX Hexa zOrder not supported");
            break;
        default:
            cc.log("TMX invalid value")
        } else b = this._vertexZvalue;
        return b
    },
    _atlasIndexForExistantZ: function (a) {
        var b;
        if (this._atlasIndexArray)
            for (var c = this._atlasIndexArray, d = 0, e = c.length; d < e && (b = c[d], b != a); d++);
        "number" != typeof b && cc.log("cc.TMXLayer._atlasIndexForExistantZ(): TMX atlas index not found. Shall not happen");
        return d
    },
    _atlasIndexForNewZ: function (a) {
        for (var b = this._atlasIndexArray, c = 0, d = b.length; c < d && !(a < b[c]); c++);
        return c
    }
});
window._p = cc.TMXLayer.prototype;
cc._renderType == cc._RENDER_TYPE_WEBGL ? (_p.draw = cc.SpriteBatchNode.prototype.draw, _p.visit = cc.SpriteBatchNode.prototype.visit, _p.getTexture = cc.SpriteBatchNode.prototype.getTexture) : (_p.draw = _p._drawForCanvas, _p.visit = _p._visitForCanvas, _p.getTexture = _p._getTextureForCanvas);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "layerWidth", _p._getLayerWidth, _p._setLayerWidth);
cc.defineGetterSetter(_p, "layerHeight", _p._getLayerHeight, _p._setLayerHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
delete window._p;
cc.TMXLayer.create = function (a, b, c) {
    var d = new cc.TMXLayer;
    return d.initWithTilesetInfo(a, b, c) ? d : null
};
cc.PointObject = cc.Class.extend({
    _ratio: null,
    _offset: null,
    _child: null,
    getRatio: function () {
        return this._ratio
    },
    setRatio: function (a) {
        this._ratio = a
    },
    getOffset: function () {
        return this._offset
    },
    setOffset: function (a) {
        this._offset = a
    },
    getChild: function () {
        return this._child
    },
    setChild: function (a) {
        this._child = a
    },
    initWithCCPoint: function (a, b) {
        this._ratio = a;
        this._offset = b;
        this._child = null;
        return !0
    }
});
cc.PointObject.create = function (a, b) {
    var c = new cc.PointObject;
    c.initWithCCPoint(a, b);
    return c
};
cc.ParallaxNode = cc.NodeRGBA.extend({
    parallaxArray: null,
    _lastPosition: null,
    _className: "ParallaxNode",
    getParallaxArray: function () {
        return this.parallaxArray
    },
    setParallaxArray: function (a) {
        this.parallaxArray = a
    },
    ctor: function () {
        cc.NodeRGBA.prototype.ctor.call(this);
        this.parallaxArray = [];
        this._lastPosition = cc.p(-100, -100)
    },
    addChild: function (a, b, c, d) {
        if (3 === arguments.length) cc.log("ParallaxNode: use addChild(child, z, ratio, offset) instead");
        else {
            if (!a) throw "cc.ParallaxNode.addChild(): child should be non-null";
            var e = cc.PointObject.create(c, d);
            e.setChild(a);
            this.parallaxArray.push(e);
            a.setPosition(this._position.x * c.x + d.x, this._position.y * c.y + d.y);
            cc.NodeRGBA.prototype.addChild.call(this, a, b, a.tag)
        }
    },
    removeChild: function (a, b) {
        for (var c = this.parallaxArray, d = 0; d < c.length; d++)
            if (c[d].getChild() == a) {
                c.splice(d, 1);
                break
            }
        cc.NodeRGBA.prototype.removeChild.call(this, a, b)
    },
    removeAllChildren: function (a) {
        this.parallaxArray.length = 0;
        cc.NodeRGBA.prototype.removeAllChildren.call(this, a)
    },
    visit: function () {
        var a = this._absolutePosition();
        if (!cc.pointEqualToPoint(a, this._lastPosition)) {
            for (var b = this.parallaxArray, c = 0, d = b.length; c < d; c++) {
                var e = b[c];
                e.getChild().setPosition(-a.x + a.x * e.getRatio().x + e.getOffset().x, -a.y + a.y * e.getRatio().y + e.getOffset().y)
            }
            this._lastPosition = a
        }
        cc.NodeRGBA.prototype.visit.call(this)
    },
    _absolutePosition: function () {
        for (var a = this._position, b = this; null != b.parent;) b = b.parent, a = cc.pAdd(a, b.getPosition());
        return a
    }
});
cc.ParallaxNode.create = function () {
    return new cc.ParallaxNode
};
if (cc.sys._supportWebAudio) {
    var _ctx = cc.webAudioContext = new(window.AudioContext || window.webkitAudioContext || window.mozAudioContext);
    cc.WebAudio = cc.Class.extend({
        _events: null,
        _buffer: null,
        _sourceNode: null,
        _volumeNode: null,
        src: null,
        preload: null,
        autoplay: null,
        controls: null,
        mediagroup: null,
        currentTime: 0,
        startTime: 0,
        duration: 0,
        _loop: null,
        _volume: 1,
        _pauseTime: 0,
        _paused: !1,
        _stopped: !0,
        _loadState: -1,
        ctor: function (a) {
            this._events = {};
            this.src = a;
            this._volumeNode = _ctx.createGain ? _ctx.createGain() : _ctx.createGainNode();
            this._onSuccess1 = this._onSuccess.bind(this);
            this._onError1 = this._onError.bind(this)
        },
        _play: function (a) {
            var b = this._sourceNode = _ctx.createBufferSource(),
                c = this._volumeNode;
            b.buffer = this._buffer;
            c.gain.value = this._volume;
            b.connect(c);
            c.connect(_ctx.destination);
            b.loop = this._loop;
            this._stopped = this._paused = !1;
            b.start ? b.start(0, a) : b.noteGrainOn ? (c = b.buffer.duration, this.loop ? b.noteGrainOn(0, a, c) : b.noteGrainOn(0, a, c - a)) : b.noteOn(0);
            this._pauseTime = 0
        },
        _stop: function () {
            var a = this._sourceNode;
            this._stopped ||
                (a.stop ? a.stop(0) : a.noteOff(0), this._stopped = !0)
        },
        play: function () {
            if (-1 == this._loadState) this._loadState = 0;
            else if (1 == this._loadState) {
                var a = this._sourceNode;
                if (this._stopped || !a || 2 != a.playbackState) this.startTime = _ctx.currentTime, this._play(0)
            }
        },
        pause: function () {
            this._pauseTime = _ctx.currentTime;
            this._paused = !0;
            this._stop()
        },
        resume: function () {
            this._paused && this._play(this._buffer ? (this._pauseTime - this.startTime) % this._buffer.duration : 0)
        },
        stop: function () {
            this._pauseTime = 0;
            this._paused = !1;
            this._stop()
        },
        load: function () {
            var a = this;
            if (1 != a._loadState) {
                a._loadState = -1;
                a.played = !1;
                a.ended = !0;
                var b = new XMLHttpRequest;
                b.open("GET", a.src, !0);
                b.responseType = "arraybuffer";
                b.onload = function () {
                    _ctx.decodeAudioData(b.response, a._onSuccess1, a._onError1)
                };
                b.send()
            }
        },
        addEventListener: function (a, b) {
            this._events[a] = b.bind(this)
        },
        removeEventListener: function (a) {
            delete this._events[a]
        },
        canplay: function () {
            return cc.sys._supportWebAudio
        },
        _onSuccess: function (a) {
            this._buffer = a;
            a = this._events.success;
            var b = this._events.canplaythrough;
            a && a();
            b && b();
            0 != this._loadState && "autoplay" != this.autoplay && !0 != this.autoplay || this._play();
            this._loadState = 1
        },
        _onError: function () {
            var a = this._events.error;
            a && a();
            this._loadState = -2
        },
        cloneNode: function () {
            var a = new cc.WebAudio(this.src);
            a.volume = this.volume;
            a._loadState = this._loadState;
            a._buffer = this._buffer;
            0 != a._loadState && -1 != a._loadState || a.load();
            return a
        }
    });
    window._p = cc.WebAudio.prototype;
    cc.defineGetterSetter(_p, "loop", function () {
        return this._loop
    }, function (a) {
        this._loop = a;
        this._sourceNode &&
            (this._sourceNode.loop = a)
    });
    cc.defineGetterSetter(_p, "volume", function () {
        return this._volume
    }, function (a) {
        this._volume = a;
        this._volumeNode.gain.value = a
    });
    cc.defineGetterSetter(_p, "paused", function () {
        return this._paused
    });
    cc.defineGetterSetter(_p, "ended", function () {
        var a = this._sourceNode;
        return !this._paused && (this._stopped || !a || 3 == a.playbackState)
    });
    cc.defineGetterSetter(_p, "played", function () {
        var a = this._sourceNode;
        return a && 2 == a.playbackState
    });
    delete window._p
}
cc.AudioEngine = cc.Class.extend({
    _soundSupported: !1,
    _currMusic: null,
    _currMusicPath: null,
    _musicPlayState: 0,
    _audioID: 0,
    _effects: {},
    _audioPool: {},
    _effectsVolume: 1,
    _maxAudioInstance: 5,
    _effectPauseCb: null,
    _playings: [],
    ctor: function () {
        this._soundSupported = 0 < cc._audioLoader._supportedAudioTypes.length;
        this._effectPauseCb && (this._effectPauseCb = this._effectPauseCb.bind(this))
    },
    willPlayMusic: function () {
        return !1
    },
    getEffectsVolume: function () {
        return this._effectsVolume
    },
    playMusic: function (a, b) {
        if (this._soundSupported) {
            var c =
                this._currMusic;
            c && this._stopAudio(c);
            a != this._currMusicPath && (this._currMusic = c = this._getAudioByUrl(a), this._currMusicPath = a);
            c && (c.loop = b || !1, this._playMusic(c))
        }
    },
    _getAudioByUrl: function (a) {
        var b = cc.loader,
            c = b.getRes(a);
        c || (b.load(a), c = b.getRes(a));
        return c
    },
    _playMusic: function (a) {
        a.ended || (a.stop ? a.stop() : (a.pause(), a.duration && (a.currentTime = a.duration)));
        this._musicPlayState = 2;
        a.play()
    },
    stopMusic: function (a) {
        if (0 < this._musicPlayState) {
            var b = this._currMusic;
            b && (this._stopAudio(b), a && cc.loader.release(this._currMusicPath),
                this._currMusicPath = this._currMusic = null, this._musicPlayState = 0)
        }
    },
    _stopAudio: function (a) {
        a && !a.ended && (a.stop ? a.stop() : (a.pause(), a.duration && (a.currentTime = a.duration)))
    },
    pauseMusic: function () {
        2 == this._musicPlayState && (this._currMusic.pause(), this._musicPlayState = 1)
    },
    resumeMusic: function () {
        1 == this._musicPlayState && (this._resumeAudio(this._currMusic), this._musicPlayState = 2)
    },
    _resumeAudio: function (a) {
        a && !a.ended && (a.resume ? a.resume() : a.play())
    },
    rewindMusic: function () {
        this._currMusic && this._playMusic(this._currMusic)
    },
    getMusicVolume: function () {
        return 0 == this._musicPlayState ? 0 : this._currMusic.volume
    },
    setMusicVolume: function (a) {
        0 < this._musicPlayState && (this._currMusic.volume = Math.min(Math.max(a, 0), 1))
    },
    isMusicPlaying: function () {
        return 2 == this._musicPlayState && this._currMusic && !this._currMusic.ended
    },
    _getEffectList: function (a) {
        var b = this._audioPool[a];
        b || (b = this._audioPool[a] = []);
        return b
    },
    _getEffect: function (a) {
        var b;
        if (this._soundSupported) {
            for (var c = this._getEffectList(a), d = 0, e = c.length; d < e; d++) {
                var f = c[d];
                if (f.ended) {
                    b =
                        f;
                    b.currentTime = 0;
                    window.chrome && b.load();
                    break
                }
            }
            if (!b) {
                if (c.length >= this._maxAudioInstance) return cc.log("Error: " + a + " greater than " + this._maxAudioInstance), null;
                b = this._getAudioByUrl(a);
                if (!b) return null;
                b = b.cloneNode(!0);
                this._effectPauseCb && b.addEventListener("pause", this._effectPauseCb);
                b.volume = this._effectsVolume;
                c.push(b)
            }
            return b
        }
    },
    playEffect: function (a, b) {
        var c = this._getEffect(a);
        if (!c) return null;
        c.loop = b || !1;
        c.play();
        var d = this._audioID++;
        this._effects[d] = c;
        return d
    },
    setEffectsVolume: function (a) {
        a =
            this._effectsVolume = Math.min(Math.max(a, 0), 1);
        var b = this._effects,
            c;
        for (c in b) b[c].volume = a
    },
    pauseEffect: function (a) {
        (a = this._effects[a]) && !a.ended && a.pause()
    },
    pauseAllEffects: function () {
        var a = this._effects,
            b;
        for (b in a) {
            var c = a[b];
            c.ended || c.pause()
        }
    },
    resumeEffect: function (a) {
        this._resumeAudio(this._effects[a])
    },
    resumeAllEffects: function () {
        var a = this._effects,
            b;
        for (b in a) this._resumeAudio(a[b])
    },
    stopEffect: function (a) {
        this._stopAudio(this._effects[a]);
        delete this._effects[a]
    },
    stopAllEffects: function () {
        var a =
            this._effects,
            b;
        for (b in a) this._stopAudio(a[b]), delete a[b]
    },
    unloadEffect: function (a) {
        var b = cc.loader,
            c = this._effects,
            d = this._getEffectList(a);
        b.release(a);
        if (0 != d.length) {
            b = d[0].src;
            delete this._audioPool[a];
            for (var e in c) c[e].src == b && (this._stopAudio(c[e]), delete c[e])
        }
    },
    end: function () {
        this.stopMusic();
        this.stopAllEffects()
    },
    _pausePlaying: function () {
        var a = this._effects,
            b, c;
        for (c in a)!(b = a[c]) || b.ended || b.paused || (this._playings.push(b), b.pause());
        this.isMusicPlaying() && (this._playings.push(this._currMusic),
            this._currMusic.pause())
    },
    _resumePlaying: function () {
        for (var a = this._playings, b = 0, c = a.length; b < c; b++) this._resumeAudio(a[b]);
        a.length = 0
    }
});
!cc.sys._supportWebAudio && 0 > cc.sys._supportMultipleAudio && (cc.AudioEngineForSingle = cc.AudioEngine.extend({
    _waitingEffIds: [],
    _pausedEffIds: [],
    _currEffect: null,
    _maxAudioInstance: 2,
    _effectCache4Single: {},
    _needToResumeMusic: !1,
    _expendTime4Music: 0,
    _isHiddenMode: !1,
    _playMusic: function (a) {
        this._stopAllEffects();
        this._super(a)
    },
    resumeMusic: function () {
        1 == this._musicPlayState && (this._stopAllEffects(), this._needToResumeMusic = !1, this._expendTime4Music = 0, this._super())
    },
    playEffect: function (a, b) {
        var c = this._currEffect,
            d = b ? this._getEffect(a) : this._getSingleEffect(a);
        if (!d) return null;
        d.loop = b || !1;
        var e = this._audioID++;
        this._effects[e] = d;
        this.isMusicPlaying() && (this.pauseMusic(), this._needToResumeMusic = !0);
        c ? (c != d && this._waitingEffIds.push(this._currEffectId), this._waitingEffIds.push(e), c.pause()) : (this._currEffect = d, this._currEffectId = e, d.play());
        return e
    },
    pauseEffect: function (a) {
        cc.log("pauseEffect not supported in single audio mode!")
    },
    pauseAllEffects: function () {
        var a = this._waitingEffIds,
            b = this._pausedEffIds,
            c = this._currEffect;
        if (c) {
            for (var d = 0, e = a.length; d < e; d++) b.push(a[d]);
            a.length = 0;
            b.push(this._currEffectId);
            c.pause()
        }
    },
    resumeEffect: function (a) {
        cc.log("resumeEffect not supported in single audio mode!")
    },
    resumeAllEffects: function () {
        var a = this._waitingEffIds,
            b = this._pausedEffIds;
        this.isMusicPlaying() && (this.pauseMusic(), this._needToResumeMusic = !0);
        for (var c = 0, d = b.length; c < d; c++) a.push(b[c]);
        b.length = 0;
        !this._currEffect && 0 <= a.length && (a = a.pop(), b = this._effects[a]) && (this._currEffectId = a, this._currEffect =
            b, this._resumeAudio(b))
    },
    stopEffect: function (a) {
        var b = this._currEffect,
            c = this._waitingEffIds,
            d = this._pausedEffIds;
        b && this._currEffectId == a ? this._stopAudio(b) : (b = c.indexOf(a), 0 <= b ? c.splice(b, 1) : (b = d.indexOf(a), 0 <= b && d.splice(b, 1)))
    },
    stopAllEffects: function () {
        this._stopAllEffects();
        !this._currEffect && this._needToResumeMusic && (this._resumeAudio(this._currMusic), this._musicPlayState = 2, this._needToResumeMusic = !1, this._expendTime4Music = 0)
    },
    unloadEffect: function (a) {
        var b = cc.loader,
            c = this._effects,
            d = this._effectCache4Single,
            e = this._getEffectList(a),
            f = this._currEffect;
        b.release(a);
        if (0 != e.length || d[a]) {
            b = 0 < e.length ? e[0].src : d[a].src;
            delete this._audioPool[a];
            delete d[a];
            for (var g in c) c[g].src == b && delete c[g];
            f && f.src == b && this._stopAudio(f)
        }
    },
    _getSingleEffect: function (a) {
        var b = this._effectCache4Single[a],
            c = this._waitingEffIds,
            d = this._pausedEffIds,
            e = this._effects;
        if (b) b.duration && (b.currentTime = 0);
        else {
            b = this._getAudioByUrl(a);
            if (!b) return null;
            b = b.cloneNode(!0);
            this._effectPauseCb && b.addEventListener("pause", this._effectPauseCb);
            b.volume = this._effectsVolume;
            this._effectCache4Single[a] = b
        }
        a = 0;
        for (var f = c.length; a < f;) e[c[a]] == b ? c.splice(a, 1) : a++;
        a = 0;
        for (f = d.length; a < f;) e[d[a]] == b ? d.splice(a, 1) : a++;
        b._isToPlay = !0;
        return b
    },
    _stopAllEffects: function () {
        var a = this._currEffect,
            b = this._audioPool,
            c = this._effectCache4Single,
            d = this._waitingEffIds,
            e = this._pausedEffIds;
        if (a || 0 != d.length || 0 != e.length) {
            for (var f in c) {
                var g = c[f];
                g.duration && (g.currentTime = g.duration)
            }
            d.length = 0;
            e.length = 0;
            for (f in b)
                for (c = b[f], d = 0, e = c.length; d < e; d++) g = c[d],
                    g.loop = !1, g.duration && (g.currentTime = g.duration);
            a && this._stopAudio(a)
        }
    },
    _effectPauseCb: function () {
        if (!this._isHiddenMode) {
            var a = this._getWaitingEffToPlay();
            if (a) a._isToPlay ? (delete a._isToPlay, a.play()) : this._resumeAudio(a);
            else if (this._needToResumeMusic) {
                a = this._currMusic;
                if (a.duration) {
                    var b = a.currentTime + this._expendTime4Music,
                        b = b - a.duration * (b / a.duration | 0);
                    a.currentTime = b
                }
                this._expendTime4Music = 0;
                this._resumeAudio(a);
                this._musicPlayState = 2;
                this._needToResumeMusic = !1
            }
        }
    },
    _getWaitingEffToPlay: function () {
        var a =
            this._waitingEffIds,
            b = this._effects,
            c = this._currEffect,
            d = c ? c.currentTime - (c.startTime || 0) : 0;
        for (this._expendTime4Music += d; 0 != a.length;) {
            var e = a.pop();
            if (c = b[e]) {
                if (c._isToPlay || c.loop || c.duration && c.currentTime + d < c.duration) return this._currEffectId = e, this._currEffect = c, !c._isToPlay && c.duration && (a = c.currentTime + d, a -= c.duration * (a / c.duration | 0), c.currentTime = a), c._isToPlay = !1, c;
                c.duration && (c.currentTime = c.duration)
            }
        }
        return this._currEffect = this._currEffectId = null
    },
    _pausePlaying: function () {
        var a =
            this._currEffect;
        this._isHiddenMode = !0;
        if (a = 2 == this._musicPlayState ? this._currMusic : a) this._playings.push(a), a.pause()
    },
    _resumePlaying: function () {
        var a = this._playings;
        this._isHiddenMode = !1;
        0 < a.length && (this._resumeAudio(a[0]), a.length = 0)
    }
}));
cc._audioLoader = {
    _supportedAudioTypes: null,
    getBasePath: function () {
        return cc.loader.audioPath
    },
    _load: function (a, b, c, d, e, f, g) {
        var h = this,
            k = cc.loader,
            m = cc.path,
            n = this._supportedAudioTypes,
            p = "";
        if (0 == n.length) return g("can not support audio!");
        if (-1 == d) p = (m.extname(a) || "").toLowerCase(), h.audioTypeSupported(p) || (p = n[0], d = 0);
        else if (d < n.length) p = n[d];
        else return g("can not found the resource of audio! Last match url is : " + a); if (0 <= e.indexOf(p)) return h._load(a, b, c, d + 1, e, f, g);
        a = m.changeExtname(a, p);
        e.push(p);
        f = h._loadAudio(a, f, function (k) {
            if (k) return h._load(a, b, c, d + 1, e, f, g);
            g(null, f)
        });
        k.cache[b] = f
    },
    audioTypeSupported: function (a) {
        return a ? 0 <= this._supportedAudioTypes.indexOf(a.toLowerCase()) : !1
    },
    _loadAudio: function (a, b, c) {
        var d = cc.WebAudio || Audio;
        2 == arguments.length ? (c = b, b = new d) : 3 != arguments.length || b || (b = new d);
        b.src = a;
        b.preload = "auto";
        d = navigator.userAgent;
        /Mobile/.test(d) && (/iPhone OS/.test(d) || /iPad/.test(d) || /Firefox/.test(d)) || /MSIE/.test(d) ? (b.load(), c(null, b)) : (b.addEventListener("canplaythrough",
            function () {
                c(null, b);
                this.removeEventListener("canplaythrough", arguments.callee, !1);
                this.removeEventListener("error", arguments.callee, !1)
            }, !1), b.addEventListener("error", function () {
            c("load " + a + " failed");
            this.removeEventListener("canplaythrough", arguments.callee, !1);
            this.removeEventListener("error", arguments.callee, !1)
        }, !1), b.load());
        return b
    },
    load: function (a, b, c, d) {
        this._load(a, b, c, -1, [], null, d)
    }
};
cc._audioLoader._supportedAudioTypes = function () {
    var a = document.createElement("audio"),
        b = [];
    if (a.canPlayType) {
        var c = function (b) {
            b = a.canPlayType(b);
            return "no" != b && "" != b
        };
        c('audio/ogg; codecs\x3d"vorbis"') && b.push(".ogg");
        c("audio/mpeg") && b.push(".mp3");
        c('audio/wav; codecs\x3d"1"') && b.push(".wav");
        c("audio/mp4") && b.push(".mp4");
        (c("audio/x-m4a") || c("audio/aac")) && b.push(".m4a")
    }
    return b
}();
cc.loader.register(["mp3", "ogg", "wav", "mp4", "m4a"], cc._audioLoader);
cc.audioEngine = cc.AudioEngineForSingle ? new cc.AudioEngineForSingle : new cc.AudioEngine;
cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function () {
    cc.audioEngine._pausePlaying()
});
cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function () {
    cc.audioEngine._resumePlaying()
});

function SignalBinding(a, b, c, d, e) {
    this._listener = b;
    this._isOnce = c;
    this.context = d;
    this._signal = a;
    this._priority = e || 0
}
SignalBinding.prototype = {
    active: !0,
    params: null,
    execute: function (a) {
        var b;
        this.active && this._listener && (a = this.params ? this.params.concat(a) : a, b = this._listener.apply(this.context, a), this._isOnce && this.detach());
        return b
    },
    detach: function () {
        return this.isBound() ? this._signal.remove(this._listener, this.context) : null
    },
    isBound: function () {
        return !!this._signal && !!this._listener
    },
    isOnce: function () {
        return this._isOnce
    },
    getListener: function () {
        return this._listener
    },
    getSignal: function () {
        return this._signal
    },
    _destroy: function () {
        delete this._signal;
        delete this._listener;
        delete this.context
    },
    toString: function () {
        return "[SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
    }
};

function validateListener(a, b) {
    if ("function" !== typeof a) throw Error("listener is a required param of {fn}() and should be a Function.".replace("{fn}", b));
}

function Signal() {
    this._bindings = [];
    this._prevParams = null;
    var a = this;
    this.dispatch = function () {
        Signal.prototype.dispatch.apply(a, arguments)
    }
}
Signal.prototype = {
    VERSION: "::VERSION_NUMBER::",
    memorize: !1,
    _shouldPropagate: !0,
    active: !0,
    _registerListener: function (a, b, c, d) {
        var e = this._indexOfListener(a, c);
        if (-1 !== e) {
            if (a = this._bindings[e], a.isOnce() !== b) throw Error("You cannot add" + (b ? "" : "Once") + "() then add" + (b ? "Once" : "") + "() the same listener without removing the relationship first.");
        } else a = new SignalBinding(this, a, b, c, d), this._addBinding(a);
        this.memorize && this._prevParams && a.execute(this._prevParams);
        return a
    },
    _addBinding: function (a) {
        var b =
            this._bindings.length;
        do --b; while (this._bindings[b] && a._priority <= this._bindings[b]._priority);
        this._bindings.splice(b + 1, 0, a)
    },
    _indexOfListener: function (a, b) {
        for (var c = this._bindings.length, d; c--;)
            if (d = this._bindings[c], d._listener === a && d.context === b) return c;
        return -1
    },
    has: function (a, b) {
        return -1 !== this._indexOfListener(a, b)
    },
    add: function (a, b, c) {
        validateListener(a, "add");
        return this._registerListener(a, !1, b, c)
    },
    addOnce: function (a, b, c) {
        validateListener(a, "addOnce");
        return this._registerListener(a, !0,
            b, c)
    },
    remove: function (a, b) {
        validateListener(a, "remove");
        var c = this._indexOfListener(a, b); - 1 !== c && (this._bindings[c]._destroy(), this._bindings.splice(c, 1));
        return a
    },
    removeAll: function () {
        for (var a = this._bindings.length; a--;) this._bindings[a]._destroy();
        this._bindings.length = 0
    },
    getNumListeners: function () {
        return this._bindings.length
    },
    halt: function () {
        this._shouldPropagate = !1
    },
    dispatch: function (a) {
        if (this.active) {
            var b = Array.prototype.slice.call(arguments),
                c = this._bindings.length,
                d;
            this.memorize && (this._prevParams =
                b);
            if (c) {
                d = this._bindings.slice();
                this._shouldPropagate = !0;
                do c--; while (d[c] && this._shouldPropagate && !1 !== d[c].execute(b))
            }
        }
    },
    forget: function () {
        this._prevParams = null
    },
    dispose: function () {
        this.removeAll();
        delete this._bindings;
        delete this._prevParams
    },
    toString: function () {
        return "[Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
    }
};
var signals = Signal;
signals.Signal = Signal;
(function (a) {
    "function" === typeof define && define.amd ? define(function () {
        return signals
    }) : "undefined" !== typeof module && module.exports ? module.exports = signals : a.signals = signals
})(this);
var lg = lg || {};
lg.Preloader = cc.Scene.extend({
    _interval: null,
    _length: 0,
    _count: 0,
    _label: null,
    _className: "lg.Preloader",
    _logo: null,
    init: function () {
        var a = cc.director.getWinSize(),
            b = logoH,
            a = cc.p(a.width / 2, a.height / 2),
            c = this._bgLayer = cc.LayerColor.create(cc.color(backgroundColor[0], backgroundColor[1], backgroundColor[2], 255));
        c.setPosition(0, 0);
        this.addChild(c, 0);
        this._logo = cc.Sprite.create(logoSrc);
        this._logo.setPosition(a);
        this._bgLayer.addChild(this._logo, 10);
        var d = this._label = cc.LabelTTF.create("Loading... 0%", "Arial",
            14);
        d.setColor(cc.color(38, 192, 216));
        d.setPosition(cc.pAdd(a, cc.p(0, logoOnCenter ? 0 : -b / 2 - 10)));
        c.addChild(this._label, 10);
        return !0
    },
    onEnter: function () {
        cc.Node.prototype.onEnter.call(this);
        this.schedule(this._startLoading, 0.3)
    },
    onExit: function () {
        cc.Node.prototype.onExit.call(this);
        this._label.setString("Loading... 0%")
    },
    initWithResources: function (a, b) {
        "string" == typeof a && (a = [a]);
        this.resources = a || [];
        this.cb = b
    },
    _startLoading: function () {
        var a = this;
        a.unschedule(a._startLoading);
        var b = a.resources;
        a._length =
            b.length;
        cc.loader.load(b, function (b, d) {
            a._count = d
        }, function () {
            a.cb()
        });
        a.schedule(a._updatePercent)
    },
    _updatePercent: function () {
        var a = this._count,
            b = this._length,
            c;
        c = Math.min(a / b * 100 | 0, 100);
        this._label.setString("Loading... " + c + "%");
        a >= b && this.unschedule(this._updatePercent)
    }
});
lg.preload = function (a, b) {
    if (null == a || 0 == a.length) b();
    else {
        for (var c = !0, d = -1; ++d < a.length;) - 1 == lg._resourcesLoaded.indexOf(a[d].src) && (lg._resourcesLoaded.push(a[d].src), c = !1);
        if (c) b();
        else return c = cc, c.loaderScene || (c.loaderScene = new lg.Preloader, c.loaderScene.init()), c.loaderScene.initWithResources(a, b), cc.director.runScene(c.loaderScene), c.loaderScene
    }
};
lg = lg || {};
EIGHT_DIRECTIONS = [
    [0, 1],
    [0, -1],
    [-1, 0],
    [1, 0],
    [-1, 1],
    [1, 1],
    [1, -1],
    [-1, -1]
];
MAX_IN_TILE = 10;
var TileValue = TileValue || {
    WALKABLE: 0,
    BLOCK1: 1,
    BLOCK2: 2,
    BLOCK3: 3,
    BLOCK4: 4,
    BLOCK5: 5
};
lg.TileMap = cc.Class.extend({
    id: "default",
    offsetX: 0,
    offsetY: 0,
    autoLayout: !1,
    _tileWidth: 0,
    _tileHeight: 0,
    _mapWidth: 0,
    _mapHeight: 0,
    _objectsMap: null,
    _objectsArr: null,
    setTileSize: function (a, b) {
        if (this._tileWidth != a || this._tileHeight != b) this._tileWidth = a, this._tileHeight = b
    },
    setMapSizePixel: function (a, b) {
        null == a && (a = cc.visibleRect.width);
        null == b && (b = cc.visibleRect.height);
        return this.setMapSize(Math.ceil(a / this._tileWidth), Math.ceil(b / this._tileHeight))
    },
    setMapSize: function (a, b) {
        var c = [
            [],
            []
        ];
        if (this._mapWidth ==
            a && this._mapHeight == b) return c;
        null == this._objectsArr && (this._objectsArr = []);
        null == this._objectsMap && (this._objectsMap = []);
        for (var d = this._mapWidth, e = this._mapHeight, f = -1, g = -1, h = Math.max(a, d), k = Math.max(b, e); ++f < h;) {
            null == this._objectsMap[f] && (this._objectsMap[f] = []);
            for (g = -1; ++g < k;) f >= a || g >= b ? (c[0] = c[0].concat(this._objectsMap[f][g]), this.removeObjects(f, g), delete this._objectsMap[f][g]) : f < d && g < e || (this._objectsMap[f][g] = [], c[1].push([f, g]));
            0 == this._objectsMap[f].length && delete this._objectsMap[f]
        }
        this._mapWidth =
            a;
        this._mapHeight = b;
        return c
    },
    clear: function (a) {
        if (0 != this._objectsArr.length) {
            void 0 === a && (a = !0);
            for (var b, c = 0; c < this._mapWidth; c++)
                for (var d = 0; d < this._mapHeight; d++) {
                    if (a) {
                        b = this._objectsMap[c][d];
                        for (var e in b) {
                            var f = b[e];
                            f instanceof cc.Node && f.destroy()
                        }
                    }
                    this._objectsMap[c][d] = []
                }
            this._objectsArr.length = 0
        }
    },
    getPixelSize: function () {
        return cc.size(this._tileWidth * this._mapWidth, this._tileHeight * this._mapHeight)
    },
    getTileIndexX: function (a) {
        return Math.floor((a - this.offsetX) / this._tileWidth)
    },
    getTileIndexY: function (a) {
        return Math.floor((a -
            this.offsetY) / this._tileHeight)
    },
    getTiledPositionX: function (a) {
        return (a + 0.5) * this._tileWidth + this.offsetX
    },
    getTiledPositionY: function (a) {
        return (a + 0.5) * this._tileHeight + this.offsetY
    },
    getCoveredTiles: function (a, b) {
        var c = lg.getRect(a, !0);
        return this.getCoveredTiles1(c, b)
    },
    getCoveredTiles1: function (a, b) {
        b = !0 === b;
        for (var c = this.getTileIndexX(a.x), d = this.getTileIndexY(a.y), e = this.getTileIndexX(a.x + a.width), f = this.getTileIndexY(a.y + a.height), g = [], c = c - 1, h = 0; ++c <= e;)
            for (h = d - 1; ++h <= f;) b ? g = g.concat(this.getObjects(c,
                h)) : g.push(cc.p(c, h));
        return g
    },
    isValideTile: function (a, b) {
        return 0 <= a && a < this._mapWidth && 0 <= b && b < this._mapHeight
    },
    snapToTile: function (a, b, c, d) {
        if (a instanceof cc.Node) {
            var e = null;
            if (void 0 === b || void 0 === c) e = a.getPosition(), a.parent && (e = a.parent.convertToWorldSpace(e)), b = this.getTileIndexX(e.x), c = this.getTileIndexY(e.y);
            e = cc.p(this.getTiledPositionX(b), this.getTiledPositionY(c));
            a.parent && (e = a.parent.convertToNodeSpace(e));
            a.setPosition(e);
            !0 === d && a.setTileMap(this)
        }
    },
    snapAll: function () {
        for (var a =
            this._objectsArr.length, b = -1, c = null; ++b < a;) c = this._objectsArr[b], this.snapToTile(c)
    },
    addObject: function (a, b, c) {
        void 0 === b && (b = a.tx);
        void 0 === c && (c = a.ty);
        a.tx = b;
        a.ty = c;
        if (this.isValideTile(b, c) && !(-1 < this._objectsArr.indexOf(a))) {
            this._objectsArr.push(a);
            var d = this._objectsMap[b][c];
            if (a instanceof cc.Node && this.autoLayout) {
                b = (b + (this._mapHeight - 1 - c) * this._mapWidth) * MAX_IN_TILE;
                c = null;
                for (var e = 0, f = !1, g = 0; g < d.length; g++) c = d[g], c instanceof cc.Node && (!f && c.y <= a.y && (d.splice(g, 0, a), a.zIndex = Math.min(e,
                    MAX_IN_TILE) + b, f = !0, e++, g++), c.zIndex = Math.min(e, MAX_IN_TILE) + b, e++);
                f || (d.push(a), a.zOrder = Math.min(e, MAX_IN_TILE) + b)
            } else d.push(a)
        }
    },
    updateLayout: function (a, b) {
        if (this.isValideTile(a, b)) {
            var c = this._objectsMap[a][b];
            if (0 != c.length) {
                c.sort(this._sortByY);
                for (var d = null, e = 0, f = 0; f < c.length; f++) d = c[f], d instanceof cc.Node && (d.zIndex = Math.min(e, MAX_IN_TILE) + zIndex0, e++)
            }
        }
    },
    removeObject: function (a, b, c) {
        void 0 === b && (b = a.tx);
        void 0 === c && (c = a.ty);
        this.isValideTile(b, c) && (b = this._objectsMap[b][c], c = b.indexOf(a), -1 < c && b.splice(c, 1), c = this._objectsArr.indexOf(a), -1 < c && this._objectsArr.splice(c, 1))
    },
    removeObjects: function (a, b) {
        if (this.isValideTile(a, b))
            for (var c = this._objectsMap[a][b], d = null, d = -1; c.length;) d = c[0], d.tx = d.ty = -1, d = this._objectsArr.indexOf(d), -1 < d && this._objectsArr.splice(d, 1), c.splice(0, 1)
    },
    getObjects: function (a, b) {
        return this.isValideTile(a, b) ? this._objectsMap[a][b] : []
    },
    getObjects1: function (a, b) {
        var c = this.getTileIndexX(a),
            d = this.getTileIndexY(b);
        return this.getObjects(c, d)
    },
    getAllObjects: function () {
        return this._objectsArr
    },
    getTiles: function (a) {
        for (var b = [], c = -1, d = -1; ++c < this._mapWidth;)
            for (d = -1; ++d < this._mapHeight;) null != a && !1 === a(this, c, d) || b.push(cc.p(c, d));
        return b
    },
    getRow: function (a, b) {
        for (var c = -1, d = []; ++c < this._mapHeight;) d = !0 === b ? d.concat(this.getObjects(a, c)) : d.push(cc.p(a, c));
        return d
    },
    getCol: function (a, b) {
        for (var c = -1, d = []; ++c < this._mapWidth;) d = !0 === b ? d.concat(this.getObjects(c, a)) : d.push(cc.p(c, a));
        return d
    },
    isEmptyTile: function (a, b) {
        if (!this.isValideTile(a, b)) return !1;
        var c = this.getObjects(a, b);
        return c ?
            0 == c.length : !1
    },
    _sortByY: function (a, b) {
        if (a.y > b.y) return -1;
        if (a.y < b.y) return 1
    }
});
lg.TileMap.create = function (a) {
    var b = new lg.TileMap;
    b.id = a;
    return b
};
RADIAN_TO_DEGREE = 180 / Math.PI;
DEGREE_TO_RADIAN = Math.PI / 180;
lg = lg || {};
lg.version = 1.32;
lg.language = "en";
lg.languageIndex = -1;
lg.assetsManager = null;
lg.inputManager = null;
lg.currentSceneName = "";
lg.currentScene = null;
lg.buttonSound = null;
lg._scenesDict = {};
lg._resourcesLoaded = [];
lg._soundEnabled = !0;
lg._inited = !1;
lg._orientationTip = null;
lg.init = function () {
    lg._inited || (lg._inited = !0, lg.assetsManager = lg.AssetsManager.create(), lg.inputManager = lg.InputManager.create(), cc.game.config.timeScale && cc.director.getScheduler().setTimeScale(cc.game.config.timeScale))
};
lg.registerScene = function (a, b, c) {
    lg.init();
    lg._scenesDict[a] = {
        scene: b,
        res: c
    }
};
lg.replaceScene = function (a) {
    var b = lg._scenesDict[a];
    if (null == b) throw "Please register the scene: " + a + " firstly!";
    lg.ObjectPool.release();
    lg.bulletCanvas && (lg.bulletCanvas = null);
    lg.currentSceneName = a;
    lg.inputManager.removeFromParent(!1);
    lg.currentScene = new b.scene;
    lg.preload(b.res, function () {
        lg.currentScene.addChild(lg.inputManager, 999999);
        cc.director.runScene(lg.currentScene);
        lg._checkDeviceOrientation()
    })
};
lg._tileMaps = {};
lg.getTileMap = function (a) {
    if ("undefined" !== typeof lg._tileMaps[a]) return lg._tileMaps[a];
    cc.log("The tileMap: " + a + " hasn't been defined, pls use lg.registerTileMap to define it firstly!");
    return null
};
lg.registerTileMap = function (a) {
    lg._tileMaps[a.id] = a
};
lg.setSoundEnabled = function (a) {
    if (lg._soundEnabled != a) {
        lg._soundEnabled = a;
        var b = cc.audioEngine;
        a ? b.resumeMusic() : (b.pauseMusic(), b.stopAllEffects())
    }
};
lg.getSoundEnabled = function () {
    return lg._soundEnabled
};
lg.playMusic = function (a, b) {
    if (lg._soundEnabled) {
        var c = cc.audioEngine;
        c.stopMusic(!0);
        c.playMusic(a, b)
    }
};
lg.playSound = function (a) {
    lg._soundEnabled && cc.audioEngine.playEffect(a)
};
lg._checkDeviceOrientation = function () {
    if (!lg._orientationTip && cc.sys.isMobile && cc.game.config.rotateImg) {
        lg._orientationTip = cc.LayerColor.create(cc.color(0, 0, 0), cc.visibleRect.width + 10, cc.visibleRect.height + 10);
        var a = cc.Sprite.create(cc.game.config.rotateImg);
        a.setPosition(cc.visibleRect.center);
        lg._orientationTip.__icon = a;
        lg._orientationTip.addChild(a);
        window.addEventListener("onorientationchange" in window ? "orientationchange" : "resize", lg._showOrientaionTip, !0);
        lg._showOrientaionTip()
    }
    lg._orientationTip &&
        (lg._orientationTip.removeFromParent(), lg.currentScene.addChild(lg._orientationTip, 1E6))
};
lg._oldGamePauseState = !1;
lg._showOrientaionTip = function () {
    var a = 90 == Math.abs(window.orientation);
    lg._orientationTip.visible = cc.game.config.landscape != a;
    lg._orientationTip.__icon.rotation = a ? -90 : 0;
    document.body.scrollTop = 0;
    lg._orientationTip.visible ? (lg._oldGamePauseState = cc.director.isPaused(), cc.director.pause()) : lg._oldGamePauseState || cc.director.resume()
};
lg.getAngle = function (a, b, c) {
    return lg.getAngle1(b.x - a.x, b.y - a.y, c)
};
lg.getAngle1 = function (a, b, c) {
    void 0 === c && (c = !0);
    a = Math.atan2(a, b);
    0 > a && (a += 2 * Math.PI);
    c && (a *= RADIAN_TO_DEGREE);
    return a
};
lg.getPointOnCircle = function (a, b) {
    b = -b * DEGREE_TO_RADIAN;
    return new cc.Point(a * Math.cos(b), a * Math.sin(b))
};
lg.getPosition = function (a, b) {
    var c = a.getPosition();
    !0 === b && a.parent && (c = a.parent.convertToWorldSpace(c));
    return c
};
lg.getRotation = function (a, b) {
    if (!0 !== b) return a.rotation;
    for (var c = 0, d = a; d;) c += d.rotation, d = d.parent;
    return c
};
lg.getScale = function (a, b) {
    if (!0 !== b) return cc.p(a.scaleX, a.scaleY);
    for (var c = 1, d = 1, e = a; e;) c *= e.scaleX, d *= e.scaleY, e = e.parent;
    return cc.p(c, d)
};
lg.getRect = function (a, b) {
    var c;
    if (a.getRect) return c = a.getRect(b);
    b = !1 !== b;
    c = a.getPosition();
    b && a.parent && (c = a.parent.convertToWorldSpace(c));
    var d = a.getContentSize(),
        e = a.getAnchorPoint();
    return c = cc.rect(c.x - d.width * e.x, c.y - d.height * e.y, d.width, d.height)
};
lg.drawRect = function (a, b, c, d, e) {
    null == b && (b = cc.DrawNode.create(), lg.currentScene && lg.currentScene.addChild(b, 99999));
    null == c && (c = 1);
    null == d && (d = cc.color(255, 0, 0, 255));
    var f = cc.pAdd(cc.p(a.x, a.y), cc.p(a.width, a.height));
    b.drawRect(cc.p(a.x, a.y), f, e, c, d)
};
lg.ifTouched = function (a, b) {
    if (null == a || !(a instanceof cc.Node)) return !1;
    var c = a.convertToNodeSpace(b),
        d = lg.getRect(a);
    d.x = d.y = 0;
    return cc.rectContainsPoint(d, c)
};
lg.ifCollide = function (a, b) {
    var c = lg.getRect(a, !0),
        d = lg.getRect(b, !0);
    return cc.rectIntersectsRect(c, d)
};
lg.isChildOf = function (a, b) {
    if (null == a || null == b || a == b) return !1;
    for (var c = a.parent; c;) {
        if (c == b) return !0;
        c = c.parent
    }
    return !1
};
lg.findParentWithClass = function (a, b) {
    for (var c = a; c;) {
        if (c instanceof b) return c;
        c = c.parent
    }
    return null
};
lg.findChildWithClass = function (a, b) {
    for (var c = a.children, d = c.length, e; d--;)
        if (e = c[d], e instanceof b || (e = lg.findChildWithClass(e, b))) return e;
    return null
};
lg.nameToObject = function (a, b) {
    if (void 0 == a || "" == a) return null;
    b = b || "function";
    for (var c = a.split("."), d = window || this, e = 0, f = c.length; e < f; e++) try {
        d = d[c[e]]
    } catch (g) {
        break
    }
    return typeof d !== b ? null : d
};
lg.createBGLayer = function (a, b) {
    null == b && (b = cc.color(255, 255, 255, 255));
    var c = cc.LayerColor.create(b, cc.visibleRect.width, cc.visibleRect.height);
    a.addChild(c, 0);
    return c
};
Array.prototype.shuffle = function (a) {
    if (void 0 === a || 0 >= a || a > this.length) a = this.length;
    for (a -= 1; 0 <= a; a--) {
        var b = 0 | cc.rand() % (a + 1),
            c = this[a];
        this[a] = this[b];
        this[b] = c
    }
};
lg.restrictValue = function (a, b, c) {
    a = Math.max(b, a);
    return a = Math.min(c, a)
};
lg.randInt = function (a, b) {
    return a + Math.floor(Math.random() * (b - a))
};
lg.getRandomInArray = function (a) {
    if (null == a) return null;
    var b = lg.randInt(0, a.length);
    return a[b]
};
lg.getFileExtension = function (a) {
    a = a.substring(a.lastIndexOf(".") + 1, a.length);
    var b = a.indexOf("?");
    0 < b && (a = a.substring(0, b));
    return a
};
lg.isImageFile = function (a) {
    a = lg.getFileExtension(a);
    return -1 < cc.RESOURCE_TYPE.IMAGE.indexOf(a)
};
lg.copyProperties = function (a, b) {
    if (null != a && null != b)
        for (var c in a) try {
            b[c] = a[c]
        } catch (d) {}
};
lg.createDInts = function (a, b) {
    isNaN(b) && (b = 0);
    for (var c = [], d = -1, e = b - 1, f = b; ++d < a;) 0 == d % 2 ? c.push(++e) : c.push(--f);
    return c
};
var lg = lg || {},
    InputType = {
        press: "onPress",
        up: "onUp",
        click: "onClick",
        move: "onMouseMove"
    };
lg.InputManager = cc.Node.extend({
    enabled: !0,
    inTouching: !1,
    inDragging: !1,
    _masks: [],
    _callbacks: {},
    _globalListener: null,
    onEnter: function () {
        this._super();
        var a = this,
            b = cc.EventListener.create({
                event: cc.EventListener.TOUCH_ONE_BY_ONE,
                swallowTouches: !1,
                onTouchBegan: function (b, d) {
                    a.inDragging = !1;
                    a.inTouching = !0;
                    a._dispatchOne(a, b, d, InputType.press);
                    return !0
                },
                onTouchEnded: function (b, d) {
                    a.inDragging = !1;
                    a.inTouching = !1;
                    a._dispatchOne(a, b, d, InputType.up);
                    a._dispatchOne(a, b, d, InputType.click)
                },
                onTouchMoved: function (b,
                    d) {
                    a.inDragging = !0;
                    a._dispatchOne(a, b, d, InputType.move)
                }
            });
        cc.eventManager.addListener(b, this)
    },
    onExit: function () {
        this._super();
        _masks = [];
        this.inTouching = !1;
        this._callbacks = {};
        cc.eventManager.removeAllListeners()
    },
    addMask: function (a) {
        -1 < this._masks.indexOf(a) || this._masks.push(a)
    },
    removeMask: function (a) {
        a = this._masks.indexOf(a); - 1 < a && this._masks.splice(a, 1)
    },
    _compareRealZIndex: function (a, b) {
        if (!a.parent || !b.parent) return 1;
        if (a.parent == b.parent) return this._childIsOnFront(a, b);
        for (var c = null, d = 0,
            e = [], f = a.parent; f;) e.push(f), f = f.parent;
        for (var g = [], f = b.parent; f;) {
            d = e.indexOf(f);
            if (-1 < d) {
                c = f;
                break
            }
            g.push(f);
            f = f.parent
        }
        e = e.slice(0, d);
        return this._childIsOnFront(e[e.length - 1] || a, g[g.length - 1] || b, c) ? 1 : -1
    },
    _childIsOnFront: function (a, b, c) {
        null == c && (c = a.parent);
        return c.children.indexOf(a) > c.children.indexOf(b)
    },
    addListener: function (a, b, c, d) {
        if (null == b) throw "Event callback can not be null!";
        null == a && (a = this);
        c = null == c ? InputType.click : c;
        var e = this._callbacks[a.__instanceId];
        null == e && (e = [], this._callbacks[a.__instanceId] =
            e, a != this && this._createListener(a, !0));
        for (var f = e.length; f--;)
            if (e[f].type == c && e[f].func == b) return;
        e.push({
            type: c,
            func: b,
            context: d || a
        })
    },
    removeListener: function (a, b, c) {
        null == a && (a = this);
        var d = this._callbacks[a.__instanceId];
        d && this.scheduleOnce(function () {
            var e = null,
                f = d.length;
            if (b || c)
                for (; f--;) e = d[f], (c && e.type == c || b && e.func == b) && d.splice(f, 1);
            0 != d.length && (b || c) || delete this._callbacks[a.__instanceId]
        }, 0.01)
    },
    handleTouchBegan: function (a, b) {
        if (!this.enabled) return !1;
        var c = b.getCurrentTarget();
        if (this._ifTargetIgnore(c,
            a)) return !1;
        for (var d = a.getLocation(), e = this._masks.length, f = null, f = null; e--;)
            if (f = this._masks[e], c != f && !lg.isChildOf(c, f) && !lg.isChildOf(f, c) && !this._ifTargetIgnore(f) && 1 == this._compareRealZIndex(f, c) && (f = this._findRealTarget(f, d))) return !1;
        lg.isButton(c) && (lg.buttonSound && lg.playSound(lg.buttonSound), this._setButtonState(c, ButtonState.DOWN));
        b.currentTarget = c;
        b.target = this._findRealTarget(c, d) || c;
        if ((c instanceof cc.Layer || c instanceof lg.MovieClip) && b.target == c) return !1;
        this._dispatch(c, a, b, InputType.press);
        return !0
    },
    handleTouchEnded: function (a, b) {
        var c = b.getCurrentTarget();
        b.currentTarget = c;
        b.target = this._findRealTarget(c, a.getLocation()) || c;
        this._dispatch(c, a, b, InputType.up);
        var d = lg.ifTouched(c, a.getLocation());
        d && lg.isButton(c) && (c.isSelectable() ? c.isSelected() ? c.setState(ButtonState.UP) : c.setState(ButtonState.SELECTED) : c.setState(ButtonState.UP));
        d && this._dispatch(c, a, b, InputType.click)
    },
    handleTouchMoved: function (a, b) {
        var c = b.getCurrentTarget();
        lg.isButton(c) && (lg.ifTouched(c, a.getLocation()) ? this._setButtonState(c,
            ButtonState.DOWN) : this._setButtonState(c, ButtonState.UP));
        this._dispatch(c, a, b, InputType.move)
    },
    _createListener: function (a, b) {
        var c = this;
        listener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: b,
            onTouchBegan: function (a, b) {
                return c.handleTouchBegan(a, b)
            },
            onTouchEnded: function (a, b) {
                c.handleTouchEnded(a, b)
            },
            onTouchMoved: function (a, b) {
                c.handleTouchMoved(a, b)
            },
            onTouchCancelled: function (a, b) {
                c.handleTouchEnded(a, b)
            }
        });
        cc.eventManager.addListener(listener, a)
    },
    _findRealTarget: function (a,
        b) {
        a instanceof Array || (a = [a]);
        for (var c = null, d = a.length; d--;)
            if (c = a[d], !this._ifTargetIgnore(c)) {
                if (0 < c.children.length && (this._temp = this._findRealTarget(c.children, b))) return this._temp;
                if (lg.ifTouched(c, b)) return c
            }
        return null
    },
    _ifTargetIgnore: function (a, b) {
        return null == a || !a.running || !this._ifTargetVisible(a) || a.isMouseEnabled && !1 === a.isMouseEnabled() || b && !lg.ifTouched(a, b.getLocation()) ? !0 : !1
    },
    _ifTargetVisible: function (a) {
        for (; a;) {
            if (!a.visible) return !1;
            a = a.parent
        }
        return !0
    },
    _setButtonState: function (a,
        b) {
        a.isSelectable() && a.isSelected() && (b = b == ButtonState.UP ? ButtonState.SELECTED : "selected_" + b);
        a.setState(b)
    },
    _dispatch: function (a, b, c, d) {
        for (; a;) this._dispatchOne(a, b, c, d), a = a.parent
    },
    _dispatchOne: function (a, b, c, d) {
        var e = this._callbacks[a.__instanceId];
        if (e)
            for (var f = null, g = e.length; g--;) f = e[g], f.type == d && (c.currentTarget = a, f.func.apply(f.context, [b, c]))
    }
});
lg.InputManager.create = function () {
    var a = new lg.InputManager;
    a.init();
    return a
};
lg = lg || {};
F2C_ALIAS = {
    mc: "lg.MovieClip",
    btn: "lg.SimpleButton",
    button: "lg.Button",
    progress: "lg.ProgressBar",
    scrollPane: "lg.ScrollPane",
    scrollPane1: "lg.ScrollPane1"
};
lg.AssetsManager = cc.Class.extend({
    framesCache: null,
    displaysCache: null,
    displayDefineCache: null,
    mcsCache: null,
    subAnimsCache: null,
    fontsCache: null,
    init: function () {
        this.framesCache = {};
        this.displaysCache = {};
        this.displayDefineCache = {};
        this.mcsCache = {};
        this.subAnimsCache = {};
        this.fontsCache = {}
    },
    createDisplay: function (a, b, c, d, e, f) {
        if (null == a || null == b) throw "Pleas give me plistFile and assetID!";
        this.addPlist(a);
        var g = !1;
        c ? g = !0 : c = b;
        var h = lg.nameToObject(c);
        if (null == h && !g) {
            var g = !1,
                k = this.getDisplayDefine(a, b);
            null == k && (k = this.getMc(a, b), g = !0);
            k ? (c = k.type, h = lg.nameToObject(c), null == h && (c = F2C_ALIAS[c], h = lg.nameToObject(c)), null == h && (h = g ? lg.MovieClip : lg.Animator, c = g ? "lg.MovieClip" : "lg.Animator")) : g && (g = this.getSubAnims(a, b), g.length && (b = b + "$" + g[0], h = lg.MovieClip, c = "lg.MovieClip"));
            if (null == h) throw "There is no display with assetID: " + b + " in plist: " + a;
        }
        this._checkCreateFunc(h, c);
        g = null;
        !0 === d ? g = lg.ObjectPool.get(a, c, b).fetch(b, e, f) : (g = h.create(a, b), f && g.attr(f), e && e.addChild(g), g.clsName = c);
        return g
    },
    cloneDisplay: function (a,
        b, c) {
        if (!(a instanceof lg.TimeLine)) throw "cloneDisplay only support lg.TimeLine type!";
        b = this.createDisplay(a.plistFile, a.assetID, a.clsName, b, c ? a.parent : null);
        c && b.setPosition(a.getPosition());
        b.setScale(a.getScale());
        b.setRotation(a.rotation);
        b.zIndex = a.zIndex;
        return b
    },
    _checkCreateFunc: function (a, b) {
        if (null == a) throw "The class: " + b + " is not found!";
        if (null == a.create) throw "Please implement  a create(plistFile, assetID) method for the target class: " + b;
    },
    addPlist: function (a) {
        if (null == a) cc.log("Plist File can't be null!");
        else {
            if ("undefined" !== typeof this.framesCache[a]) return !1;
            var b = this._getFrameConfig(a);
            cc.spriteFrameCache.addSpriteFrames(a);
            var c = [],
                d = b.frames,
                e;
            for (e in d) c.push(e);
            c.sort();
            this.framesCache[a] = c;
            if (b.hasOwnProperty("displays")) {
                c = b.displays;
                d = [];
                e = null;
                if (c)
                    for (var f in c) d.push(f), e = c[f], e.anchors = this._parseFrames(e.anchors, lg.Anchor), e.colliders = this._parseFrames(e.colliders, lg.Collider), this.displayDefineCache[a + f] = e, this._parseSubAnims(a, f);
                this.displaysCache[a] = d
            }
            if (b.hasOwnProperty("mcs")) {
                f =
                    b.mcs;
                for (var g in f) {
                    d = f[g];
                    c = {};
                    c.type = d.type;
                    c.totalFrames = d.totalFrames;
                    c.labels = d.labels;
                    c.anchorX = d.anchorX;
                    c.anchorY = d.anchorY;
                    c.rect = this._strToRect(d.rect);
                    c.anchors = this._parseFrames(d.anchors, lg.Anchor);
                    c.colliders = this._parseFrames(d.colliders, lg.Collider);
                    c.children = {};
                    e = d.children;
                    for (var h in e) {
                        var d = e[h],
                            k = c.children[h] = {};
                        k.frames = this._strToArray(d.frames);
                        k["class"] = d["class"];
                        k.zIndex = parseInt(d.zIndex);
                        d.hasOwnProperty("text") && (k.text = d.text, k.align = d.align, k.width = d.width,
                            k.height = d.height)
                    }
                    this.mcsCache[a + g] = c;
                    this._parseSubAnims(a, g)
                }
            }
            if (b.hasOwnProperty("fonts")) {
                var b = b.fonts,
                    m;
                for (m in b) this.fontsCache[a + m] = b[m]
            }
            return !0
        }
    },
    getFrameNames: function (a, b, c) {
        "undefined" === typeof this.framesCache[a] && this.addPlist(a);
        a = this.framesCache[a];
        if (null == a) return []; - 1 == b && (b = 0); - 1 == c && (c = a.length - 1);
        return a.slice(parseInt(b), parseInt(c) + 1)
    },
    getDisplayDefine: function (a, b) {
        var c = a + b;
        c in this.displayDefineCache || this.addPlist(a);
        return this.displayDefineCache[c]
    },
    getDisplayNames: function (a) {
        "undefined" ===
        typeof this.displaysCache[a] && this.addPlist(a);
        return this.displaysCache[a] || []
    },
    getRandomDisplayName: function (a) {
        a = this.getDisplayNames(a);
        var b = Math.floor(Math.random() * a.length);
        return a[b]
    },
    getMc: function (a, b) {
        var c = a + b;
        c in this.mcsCache || this.addPlist(a);
        return this.mcsCache[c]
    },
    getSubAnims: function (a, b) {
        return this.subAnimsCache[a + b] || []
    },
    getFont: function (a, b) {
        var c = a + b;
        "undefined" === typeof this.fontsCache[c] && this.addPlist(a);
        return this.fontsCache[c]
    },
    _parseSubAnims: function (a, b) {
        var c = b.split("$"),
            d = c[0],
            c = c[1];
        if (d && c && "" != d && "" != c) {
            var d = a + d,
                e = this.subAnimsCache[d];
            null == e && (e = [], this.subAnimsCache[d] = e);
            e.push(c)
        }
    },
    _parseFrames: function (a, b) {
        var c = {};
        if (null == a) return c;
        for (var d in a) c[d] = this._strToArray(a[d], b);
        return c
    },
    _strToArray: function (a, b) {
        for (var c = a.split("|"), d = -1, e = []; ++d < c.length;) {
            var f = c[d];
            "null" === f ? e.push(null) : "" === f ? e.push(e[d - 1]) : b ? e.push(new b(this._strToArray2(f))) : e.push(this._strToArray2(f))
        }
        return e
    },
    _strToArray2: function (a) {
        a = a.split(",");
        for (var b = 0; b < a.length; b++) isNaN(parseInt(a[b],
            10)) || (-1 < a[b].indexOf(".") ? a[b] = parseFloat(a[b]) : a[b] = parseInt(a[b]));
        return a
    },
    _strToRect: function (a) {
        a = a.split(",");
        return cc.rect(parseFloat(a[0]), parseFloat(a[1]), parseFloat(a[2]), parseFloat(a[3]))
    },
    _getFrameConfig: function (a) {
        var b = cc.loader.getRes(a);
        if (!b) throw "Please load the resource first : " + a;
        var c = cc.spriteFrameCache;
        cc.loader.release(a);
        if (b._inited) return c._frameConfigCache[a] = b;
        var d = b.frames,
            e = b.metadata || b.meta,
            f = {},
            g = {},
            h = 0;
        e && (h = e.format, h = 1 >= h.length ? parseInt(h) : h, g.image = e.textureFileName ||
            e.textureFileName || e.image);
        for (var k in d) {
            var m = d[k];
            if (m) {
                e = {};
                if (0 == h) {
                    e.rect = cc.rect(m.x, m.y, m.width, m.height);
                    e.rotated = !1;
                    e.offset = cc.p(m.offsetX, m.offsetY);
                    var n = m.originalWidth,
                        m = m.originalHeight;
                    n && m || cc.log("cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist");
                    n = Math.abs(n);
                    m = Math.abs(m);
                    e.size = cc.size(n, m)
                } else if (1 == h || 2 == h) e.rect = c._rectFromString(m.frame), e.rotated = m.rotated || !1, e.offset = c._pointFromString(m.offset),
                    e.size = c._sizeFromString(m.sourceSize);
                else if (3 == h) {
                    var n = c._sizeFromString(m.spriteSize),
                        p = c._rectFromString(m.textureRect);
                    n && (p = cc.rect(p.x, p.y, n.width, n.height));
                    e.rect = p;
                    e.rotated = m.textureRotated || !1;
                    e.offset = c._pointFromString(m.spriteOffset);
                    e.size = c._sizeFromString(m.spriteSourceSize);
                    e.aliases = m.aliases
                } else n = m.frame, p = m.sourceSize, k = m.filename || k, e.rect = cc.rect(n.x, n.y, n.w, n.h), e.rotated = m.rotated || !1, e.offset = cc.p(0, 0), e.size = cc.size(p.w, p.h);
                f[k] = e
            }
        }
        c._frameConfigCache[a] = {
            _inited: !0,
            frames: f,
            meta: g
        };
        return b
    }
});
lg.AssetsManager.create = function () {
    var a = new lg.AssetsManager;
    a.init();
    return a
};
lg = lg || {};
lg.ColliderType = {
    rect: "Rect",
    circle: "Circle"
};
lg.Collider = cc.Class.extend({
    name: null,
    owner: null,
    type: lg.ColliderType.rect,
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    rotation: 0,
    _bottomLeft: null,
    _localRect: null,
    ctor: function (a, b) {
        this.type = a[0];
        this.x = a[1];
        this.y = a[2];
        this.width = a[3];
        this.height = a[4];
        this.rotation = a[5];
        !1 === b ? (this._bottomLeft = cc.p(this.x, this.y), this.x += this.width / 2, this.y += this.height / 2) : this._bottomLeft = cc.p(this.x - this.width / 2, this.y - this.height / 2);
        this._localRect = cc.rect(this._bottomLeft.x, this._bottomLeft.y, this.width, this.height)
    },
    clone: function () {
        var a =
            new lg.Collider([this.type, this.x, this.y, this.width, this.height, this.rotation]);
        a.name = this.name;
        a.owner = this.owner;
        return a
    },
    checkCollision: function (a) {
        if (a.type == this.type && this.type == lg.ColliderType.rect) return cc.rectIntersectsRect(this.getRect(), a.getRect())
    },
    getRect: function (a) {
        if (!1 === a) return this._localRect;
        a = this.owner.convertToWorldSpace(this._bottomLeft);
        var b = lg.getScale(this.owner, !0);
        return cc.rect(a.x, a.y, this.width * Math.abs(b.x), this.height * Math.abs(b.y))
    }
});
lg.Anchor = cc.Class.extend({
    x: 0,
    y: 0,
    zIndex: 0,
    ctor: function (a) {
        this.x = a[0];
        this.y = a[1];
        2 < a.length && (this.zIndex = a[2])
    }
});
lg.TimeLine = cc.Sprite.extend({
    onAnimationOver: null,
    autoDestroyWhenOver: !1,
    autoStopWhenOver: !1,
    autoHideWhenOver: !1,
    autoRecycle: !1,
    plistFile: null,
    currentFrame: 0,
    currentAnim: null,
    prevFrame: -1,
    totalFrames: 0,
    frameInterval: 0,
    loopStart: 0,
    loopEnd: 0,
    define: null,
    name: null,
    assetID: null,
    clsName: "lg.TimeLine",
    fps: 30,
    playing: !1,
    inRecycle: !1,
    _colliders: null,
    _mainCollider: null,
    _definedMainCollider: !1,
    _anchorBindings: null,
    _inited: !1,
    tx: 0,
    ty: 0,
    autoUpdateTileWhenMove: !0,
    tileValue: TileValue.WALKABLE,
    _tileMap: null,
    _tileInited: !1,
    _mouseEnabled: !0,
    _baseAssetID: null,
    _currentSubAnim: null,
    _subAnims: null,
    _animSequence: null,
    ctor: function (a, b) {
        cc.Sprite.prototype.ctor.call(this);
        if (!a || !b) throw "Please set plistFile and assetID to me!";
        this._anchorBindings = [];
        this._animSequence = [];
        this.onAnimationOver = new signals.Signal;
        this.setPlist(a, b)
    },
    setPlist: function (a, b) {
        if (null == a || null == b) throw "plistFile and assetID can not be null!";
        if (this.plistFile != a || this.assetID != b && this._baseAssetID != b) {
            this.plistFile = a;
            lg.assetsManager.addPlist(a);
            var c = b.split("$");
            this._baseAssetID = c[0];
            this._subAnims = lg.assetsManager.getSubAnims(a, this._baseAssetID);
            c = c[1];
            null == c && this._subAnims && (c = this._subAnims[0]);
            b = this._baseAssetID;
            c && (b = this._baseAssetID + "$" + c, this._currentSubAnim = c);
            this.assetID = b;
            if (this.define = this.getDefine()) {
                var c = this.define.anchorX,
                    d = this.define.anchorY;
                isNaN(c) || isNaN(d) || this.setAnchorPoint(c, d);
                this.onNewSheet();
                this.currentFrame = 0;
                this.renderFrame(this.currentFrame, !0);
                this._initColliders()
            } else cc.log("There is no display named: " +
                b + " in plist: " + a)
        }
    },
    getLabels: function (a) {
        return this.define.labels ? this.define.labels[a] : null
    },
    hasLabel: function (a) {
        return null != this.getLabels(a)
    },
    getMainCollider: function () {
        return this._mainCollider
    },
    getCollider: function (a) {
        return this._colliders && (a = this._colliders[a], null != a) ? a = a[this.currentFrame] : null
    },
    _initColliders: function () {
        this._mainCollider = null;
        this._colliders = {};
        var a = this.define.colliders;
        if (a) {
            var b = null,
                c;
            for (c in a) {
                this._colliders[c] = [];
                for (var d = a[c], e = -1; ++e < d.length;) null ==
                    d[e] ? this._colliders[c][e] = null : (b = this._colliders[c][e] = d[e].clone(), b.name = c, b.owner = this, "main" == c && (this._mainCollider = b))
            }
        }
        this._definedMainCollider = null != this._mainCollider;
        this._definedMainCollider || (this._mainCollider = new lg.Collider(["Rect", 0, 0, this.width, this.height, 0], !1), this._mainCollider.name = "main", this._mainCollider.owner = this)
    },
    getRect: function (a) {
        return this._mainCollider.getRect(a)
    },
    getCenter: function (a) {
        a = this.getRect(a);
        return cc.p(a.x + a.width / 2, a.y + a.height / 2)
    },
    getAnchor: function (a) {
        return this.define.anchors &&
            (a = this.define.anchors[a], null != a) ? a = a[this.currentFrame] : null
    },
    bindAnchor: function (a, b, c) {
        if (!this.define.anchors) return cc.log(this.assetID + ": there is no any anchor!"), !1;
        if (null == this.define.anchors[a]) return cc.log(this.assetID + ": there is no anchor named " + a), !1;
        if (-1 < this._anchorBindings.indexOf(b)) return cc.log(this.assetID + ": anchor has been bound, " + a), !1;
        !1 !== c && this._anchorBindings.push(b);
        b.__anchor__ = a;
        this._updateAnchorNode(b, this.getAnchor(a));
        b.parent != this && (b.removeFromParent(!1),
            this.addChild(b));
        return !0
    },
    getCurrentLabel: function () {
        if (!this.define.labels) return null;
        var a = this.define.labels,
            b = null,
            c;
        for (c in a)
            if (b = a[c], this.currentFrame >= b.start && this.currentFrame <= b.end) return c;
        return null
    },
    play: function () {
        this.loopStart = 0;
        this.loopEnd = this.totalFrames - 1;
        this.updatePlaying(!0);
        this._animSequence.length = 0
    },
    playSequence: function (a) {
        if (null == a) return !1;
        a instanceof Array || (a = Array.prototype.slice.call(arguments));
        if (0 == a.length) return !1;
        var b = this.gotoAndPlay(a.shift());
        this._animSequence = a;
        return b
    },
    setSubAnim: function (a, b) {
        if (!a || 0 == a.length || null == this._subAnims || -1 == this._subAnims.indexOf(a)) return !1;
        this._currentSubAnim = a;
        this.setPlist(this.plistFile, this._baseAssetID + "$" + a);
        !1 === b ? this.gotoAndStop(0) : this.gotoAndPlay(0);
        this._animSequence.length = 0;
        return !0
    },
    gotoAndPlay: function (a) {
        if (isNaN(a)) {
            var b = this.getLabels(a);
            if (null == b) {
                if (this.setSubAnim(a, !0)) return !0;
                this.play();
                return !1
            }
            this.loopStart = b.start;
            this.loopEnd = b.end;
            this.currentFrame = this.loopStart;
            this.currentAnim = a
        } else {
            if (!this.isValideFrame(a)) return cc.log("The frame: " + a + " is out of range!"), !1;
            this.loopStart = 0;
            this.loopEnd = this.totalFrames - 1;
            this.currentFrame = a
        }
        this.renderFrame(this.currentFrame);
        this.updatePlaying(!0);
        this._animSequence.length = 0;
        return !0
    },
    stop: function () {
        this.updatePlaying(!1)
    },
    gotoAndStop: function (a) {
        if (isNaN(a)) {
            var b = this.getLabels(a);
            if (null == b) return this.setSubAnim(a, !1);
            this.currentAnim = a;
            a = b.start
        } else this.currentAnim = null; if (!this.isValideFrame(a)) return cc.log("The frame: " +
            a + " is out of range!"), !1;
        this.updatePlaying(!1);
        this.currentFrame = a;
        this.renderFrame(a);
        this._animSequence.length = 0;
        return !0
    },
    setFPS: function (a) {
        this.fps != a && (this.fps = a, this.updateSchedule())
    },
    updatePlaying: function (a) {
        this.playing != a && (this.playing = a, this.updateSchedule())
    },
    updateSchedule: function () {
        this.playing ? 1 < this.totalFrames && this.schedule(this.onFrame, 1 / this.fps, cc.REPEAT_FOREVER, 0) : this.unschedule(this.onFrame)
    },
    onFrame: function (a) {
        this._visible && !this.inRecycle && (this.renderFrame(this.currentFrame),
            this.currentFrame++, this.currentFrame > this.loopEnd && (this.onAnimationOver.getNumListeners() && this.onAnimationOver.dispatch(this), this.autoDestroyWhenOver ? (this.updatePlaying(!1), this.destroy()) : this.autoStopWhenOver ? (this.currentFrame = this.loopEnd, this.updatePlaying(!1)) : this.autoHideWhenOver ? (this.currentFrame = this.loopEnd, this.updatePlaying(!1), this.visible = !1) : this._animSequence.length ? (a = this._animSequence.concat(), this.gotoAndPlay(a.shift()), this._animSequence = a) : this.currentFrame = this.loopStart))
    },
    isValideFrame: function (a) {
        return 0 <= a && a < this.totalFrames
    },
    renderFrame: function (a, b) {
        if (this.prevFrame != a || !0 == b) this.prevFrame != a && (this.prevFrame = a), this._handleAnchorBindings(), this._updateCollider(), this.doRenderFrame(a)
    },
    doRenderFrame: function (a) {},
    _handleAnchorBindings: function () {
        for (var a = null, b = null, c = -1, d = this._anchorBindings.length; ++c < d;) a = this._anchorBindings[c], a.visible && (b = this.getAnchor(a.__anchor__), null != b && this._updateAnchorNode(a, b))
    },
    _updateAnchorNode: function (a, b) {
        null != b && (a.x =
            b.x, a.y = b.y, a.zIndex = b.zIndex)
    },
    onEnter: function () {
        this._super();
        this.inRecycle = !1;
        this._tileMap && !this._tileInited && this._updateTileMap(!0);
        this._updateCollider(); - 1 < lg.languageIndex && this.name && -1 < this.name.indexOf("label__") && this.gotoAndStop(lg.languageIndex)
    },
    onExit: function () {
        this._super();
        this._tileMap && this._tileMap.removeObject(this);
        lg.inputManager.removeListener(this);
        this.onAnimationOver.removeAll()
    },
    getTileMap: function () {
        return this._tileMap
    },
    setTileMap: function (a) {
        !a || a instanceof lg.TileMap ||
            (a = lg.getTileMap(a));
        this._tileMap != a && (this._tileMap && this._tileMap.removeObject(this), this._tileMap = a, null != this._tileMap && this._parent && (this._updateTileMap(!0), this._updateCollider()))
    },
    _updateTileMap: function (a) {
        var b = this._position;
        this.parent && (b = this.parent.convertToWorldSpace(b));
        var c = this._tileMap.getTileIndexX(b.x),
            b = this._tileMap.getTileIndexY(b.y);
        this.setTile(c, b, a)
    },
    _updateCollider: function () {},
    setPosition: function (a, b) {
        var c = !1;
        void 0 === b ? (c = a.x != this._position._x || a.y != this._position._y) &&
            this._super(a) : (c = a != this._position._x || b != this._position._y) && this._super(a, b);
        c && !this.inRecycle && (this.autoUpdateTileWhenMove && this._tileMap && this._updateTileMap(), this._updateCollider())
    },
    setTile: function (a, b, c) {
        if (!0 === c || a != this.tx || b != this.ty) {
            c = this.tx;
            var d = this.ty;
            this.tx = a;
            this.ty = b;
            this._tileMap && this._parent && (this._tileMap.removeObject(this, c, d), this.inRecycle || (this._tileMap.addObject(this), this._tileInited = !0))
        }
    },
    destroy: function () {
        this.autoRecycle && (this.inRecycle || lg.ObjectPool.get(this.plistFile,
            this.clsName, this.__pool__id__ || "").recycle(this));
        this.removeFromParent()
    },
    onRecycle: function () {
        this.inRecycle = !0;
        this.autoRecycle = !1;
        this.setScale(1);
        this.opacity = 255;
        this.rotation = 0;
        this.autoHideWhenOver = this.autoStopWhenOver = this.autoDestroyWhenOver = !1;
        this.gotoAndStop(0);
        this._tileMap && this._tileMap.removeObject(this);
        lg.inputManager.removeListener(this);
        this._tileInited = !1;
        this.setPosition(0, 0);
        this._animSequence.length = 0;
        for (var a = null, b = -1, c = this._anchorBindings.length; ++b < c;) a = this._anchorBindings[b],
            a.destroy ? a.destroy() : a.removeFromParent(!0), delete a.__anchor__;
        this._anchorBindings.length = 0
    },
    isMouseEnabled: function () {
        return this._mouseEnabled
    },
    setMouseEnabled: function (a) {
        this._mouseEnabled = a
    },
    getDefine: function () {
        return null
    },
    onNewSheet: function () {}
});
lg.TimeLine.create = function (a, b) {
    var c = new lg.TimeLine(a, b);
    c.clsName = "lg.TimeLine";
    return c
};
window._p = lg.TimeLine.prototype;
cc.defineGetterSetter(_p, "mainCollider", _p.getMainCollider);
cc.defineGetterSetter(_p, "center", _p.getCenter);
delete window._p;
lg = lg || {};
lg.Animator = lg.TimeLine.extend({
    frameNames: null,
    onNewSheet: function () {
        this.frameNames = lg.assetsManager.getFrameNames(this.plistFile, this.define.start, this.define.end);
        this.totalFrames = this.frameNames.length;
        0 == this.totalFrames && cc.log("There is no frame for display: " + this.assetID)
    },
    doRenderFrame: function (a) {
        (a = cc.spriteFrameCache.getSpriteFrame(this.frameNames[a])) && this.setSpriteFrame(a)
    },
    getDefine: function () {
        return lg.assetsManager.getDisplayDefine(this.plistFile, this.assetID)
    }
});
lg.Animator.create = function (a, b) {
    var c = new lg.Animator(a, b);
    c.clsName = "lg.Animator";
    return c
};
lg = lg || {};
lg.MovieClip = lg.TimeLine.extend({
    autoPlayChildren: !1,
    noOpacity: !0,
    _namedChildren: null,
    _theRect: null,
    replaceChild: function (a, b) {
        var c = this.define.children[a];
        if (null == c) cc.log("There is no child with named: " + a + "  in MovieClip: " + this.assetID);
        else {
            var d = this._namedChildren[a];
            d ? d.setPlist(this.plistFile, b) : c["class"] = b
        }
    },
    onNewSheet: function () {
        for (var a in this._namedChildren) this._namedChildren[a].destroy(), delete this[a];
        this._namedChildren = {};
        this.totalFrames = this.define.totalFrames;
        this._theRect = cc.rect(this.define.rect);
        this.setContentSize(this._theRect.width, this._theRect.height)
    },
    onEnter: function () {
        this._super();
        this.setContentSize(this._theRect.width, this._theRect.height);
        this.opacity = 0
    },
    doRenderFrame: function (a) {
        var b, c, d, e;
        for (e in this.define.children)
            if (c = this.define.children[e], d = c.frames[a], b = this._namedChildren[e], null == d) b && (b.visible = !1);
            else {
                null == b && (null != c.text ? (b = lg.Label.create(this.plistFile, c["class"]), b.params = c, b.setString(c.text)) : b = lg.assetsManager.createDisplay(this.plistFile, c["class"],
                    null, !0), b.name = e, this._namedChildren[e] = b, this.autoPlayChildren && (this.playing ? b.gotoAndPlay(0) : b.gotoAndStop(0)), this[e] = b, this.onNewChild(b));
                var f = d[0],
                    g = d[1],
                    h = d[2],
                    k = d[3],
                    m = d[4];
                d = Math.round(255 * d[5]);
                f != b.x && (b.x = f);
                g != b.y && (b.y = g);
                h != b.rotation && (b.rotation = h);
                k != b.scaleX && (b.scaleX = k);
                m != b.scaleY && (b.scaleY = m);
                !0 !== b.noOpacity && b.setOpacity && d != b.opacity && (b.opacity = d);
                b.visible = !0;
                (b.autoPlayChildren = this.autoPlayChildren) && (this.playing ? b.play() : b.stop());
                b.parent != this ? (b.removeFromParent(!1),
                    this.addChild(b, c.zIndex)) : b.zIndex != c.zIndex && (b.zIndex = c.zIndex)
            }
    },
    stop: function () {
        this._super();
        if (this.autoPlayChildren)
            for (var a in this._namedChildren) {
                var b = this._namedChildren[a];
                b instanceof lg.TimeLine && b.stop()
            }
    },
    play: function () {
        this._super();
        if (this.autoPlayChildren)
            for (var a in this._namedChildren) {
                var b = this._namedChildren[a];
                b instanceof lg.TimeLine && b.play()
            }
    },
    onNewChild: function (a) {},
    getDefine: function () {
        return lg.assetsManager.getMc(this.plistFile, this.assetID)
    },
    getChildByName: function (a,
        b) {
        void 0 === b && (b = !0);
        var c = this._namedChildren[a];
        if (c) return c;
        if (!b) return null;
        for (var d in this._namedChildren)
            if (c = this._namedChildren[d], c.getChildByName && (c = c.getChildByName(a, b))) return c
    },
    getChildByAssetID: function (a) {
        var b = null,
            c;
        for (c in this._namedChildren)
            if (b = this._namedChildren[c], b.assetID == a) return b;
        return null
    },
    getRect: function (a) {
        a = !1 !== a;
        if (!a) return this._mainCollider.getRect(!1);
        var b = this._mainCollider.width,
            c = this._mainCollider.height,
            d = cc.p(this._mainCollider._bottomLeft.x,
                this._mainCollider._bottomLeft.y);
        a = lg.getScale(this, a);
        0 > a.x && (d.x += b);
        0 > a.y && (d.y += c);
        d = this.convertToWorldSpace(d);
        return cc.rect(d.x, d.y, b * Math.abs(a.x), c * Math.abs(a.y))
    },
    getLabelText: function (a, b) {
        var c = this.getChildByName(a, void 0 === b ? !0 : b);
        return c && c instanceof lg.Label ? c.getString() : null
    },
    setLabelText: function (a, b, c) {
        return (a = this.getChildByName(a, void 0 === c ? !0 : c)) && a instanceof lg.Label ? (a.setString(b), a) : null
    },
    onRecycle: function () {
        this._super();
        this.autoPlayChildren = !1
    }
});
lg.MovieClip.create = function (a, b) {
    var c = new lg.MovieClip(a, b);
    c.clsName = "lg.MovieClip";
    return c
};
lg = lg || {};
lg.ProgressBarType = {
    HORIZONTAL: "horizontal",
    VERTICAL: "vertical",
    RADIAL: "radial"
};
lg.ProgressBar = lg.Animator.extend({
    noOpacity: !0,
    pBar: null,
    _type: lg.ProgressBarType.HORIZONTAL,
    _reversed: !1,
    _tween: null,
    onEnter: function () {
        this._super();
        this.setOpacity(0)
    },
    getPercentage: function () {
        return this.pBar ? this.pBar.percentage : 0
    },
    setPercentage: function (a) {
        this.pBar && (this.pBar.percentage = a)
    },
    getType: function () {
        return this._type
    },
    setType: function (a) {
        this._type != a && (this._type = a, this._updatePBar())
    },
    getReversed: function () {
        return this._reversed
    },
    setReversed: function (a) {
        this._reversed != a && (this._reversed =
            a, this._updatePBar(), this.percentage += 0.1, this.percentage -= 0.1)
    },
    tween: function (a, b, c) {
        null != this.pBar && (this._tween && this.pBar.stopAction(this._tween), this._tween = cc.ProgressFromTo.create(c, a, b), this.pBar.runAction(this._tween))
    },
    stopTween: function () {
        this._tween && this.pBar && (this.pBar.stopAction(this._tween), this._tween = null)
    },
    doRenderFrame: function (a) {
        if (a = cc.spriteFrameCache.getSpriteFrame(this.frameNames[a])) a = cc.Sprite.create(a), null == this.pBar ? (this.width = a.width, this.height = a.height, this.pBar =
            cc.ProgressTimer.create(a), this._updatePBar(), this.pBar.setAnchorPoint(this.getAnchorPoint()), this.pBar.setPosition(this.getAnchorPointInPoints()), this.addChild(this.pBar)) : this.pBar.setSprite(a)
    },
    _updatePBar: function () {
        if (null != this.pBar)
            if (this._type == lg.ProgressBarType.RADIAL) this.pBar.type = cc.PROGRESS_TIMER_TYPE_RADIAL, this.pBar.setReverseDirection(this._reversed), this.pBar.midPoint = cc.p(0.5, 0.5);
            else {
                this.pBar.type = cc.PROGRESS_TIMER_TYPE_BAR;
                var a = this._type == lg.ProgressBarType.HORIZONTAL,
                    b =
                    cc.p(0, 0),
                    c = cc.p(a ? 1 : 0, a ? 0 : 1);
                this._reversed && (a ? b.x = 1 : b.y = 1);
                this.pBar.midPoint = b;
                this.pBar.barChangeRate = c
            }
    }
});
lg.ProgressBar.create = function (a, b) {
    var c = new lg.ProgressBar(a, b);
    c.clsName = "lg.ProgressBar";
    return c
};
window._p = lg.ProgressBar.prototype;
cc.defineGetterSetter(_p, "percentage", _p.getPercentage, _p.setPercentage);
cc.defineGetterSetter(_p, "type", _p.getType, _p.setType);
cc.defineGetterSetter(_p, "reversed", _p.getReversed, _p.setReversed);
delete window._p;
SPACE_CHAR_GAP = 10;
lg = lg || {};
lg.Label = cc.Sprite.extend({
    mlWidth: 0,
    mlHeight: 0,
    gapScale: 1,
    str: null,
    fontName: null,
    fontSize: 20,
    frames: [],
    chars: [],
    plistFile: null,
    name: null,
    params: null,
    noOpacity: !0,
    _charCanvas: null,
    _fontDefine: null,
    getString: function () {
        return this.str
    },
    setString: function (a) {
        this.str = "" + a;
        this._updateStr()
    },
    getGapScale: function () {
        return this.gapScale
    },
    setGapScale: function (a) {
        a != this.gapScale && (this.gapScale = a, this.str && this._updateStr())
    },
    setFontName: function (a) {
        if (null != a && (null == this.fontName || this.fontName != a)) {
            this.fontName =
                a;
            this._fontDefine = lg.assetsManager.getFont(this.plistFile, this.fontName);
            if (null == this._fontDefine) throw "Can't find the font named: " + this.fontName;
            this.frames = lg.assetsManager.getFrameNames(this.plistFile, parseInt(this._fontDefine.start), parseInt(this._fontDefine.end));
            this.chars = this._fontDefine.chars;
            this.fontSize = parseInt(this._fontDefine.size)
        }
    },
    _updateStr: function () {
        if (null == this._charCanvas) {
            var a = this.plistFile.replace("." + lg.getFileExtension(this.plistFile), ".png");
            this._charCanvas = new cc.SpriteBatchNode(a,
                this.str.length);
            this.addChild(this._charCanvas)
        }
        this._charCanvas.removeAllChildren();
        for (a = this.mlHeight = this.mlWidth = 0; a < this.str.length; a++) {
            var b = this.str[a];
            if ("\n" != b)
                if (" " == b) this.mlWidth += SPACE_CHAR_GAP;
                else {
                    for (var c = -1, d = 0; d < this.chars.length; d++)
                        if (this.chars[d] == b) {
                            c = d;
                            break
                        } - 1 == c ? cc.log("Not found the char: " + b + " in the fonts: " + this.fontName) : (b = cc.Sprite.create(cc.spriteFrameCache.getSpriteFrame(this.frames[c])), b.anchorX = this._fontDefine.anchorX, b.anchorY = this._fontDefine.anchorY,
                        c = b.getContentSize(), b.x = this.mlWidth, b.y = 0, this.mlWidth += c.width * this.gapScale, this.mlHeight = c.height > this.mlHeight ? c.height : this.mlHeight, this._charCanvas.addChild(b))
                }
        }
        if (this.params)
            for (a = Math.max(this.mlWidth / this.params.width, this.mlHeight / this.params.height), b = 0, 1 < a && (c = 1 / a, this._charCanvas.scale = c, b = this.mlHeight * (1 - 1 / a) * a, this.mlWidth *= c, this.mlHeight *= c), c = (this.params.width - this.mlWidth) / 2, a = this._charCanvas.childrenCount, d = null; a--;) d = this._charCanvas.children[a], "center" == this.params.align &&
                (d.x += c), d.y -= b;
        this._charCanvas.setContentSize(this.mlWidth, this.mlHeight);
        this.setContentSize(this.mlWidth, this.mlHeight);
        this.setOpacity(0)
    },
    getRect: function (a) {
        a = !1 !== a;
        var b = cc.rect(0.5 * this.width / this.str.length, -this.params.height, this.width, this.height + 2);
        b.y += (this.params.height - this.height) / 2 - 1;
        if (!a) return b;
        a = b.width;
        var c = b.height,
            b = cc.p(b.x, b.y),
            b = this.convertToWorldSpace(b);
        return cc.rect(b.x, b.y, a, c)
    },
    destroy: function () {
        this.removeFromParent()
    }
});
lg.Label.create = function (a, b) {
    var c = new lg.Label;
    c.plistFile = a;
    lg.assetsManager.addPlist(a);
    c.setFontName(b);
    c.setAnchorPoint(0, 0);
    return c
};
var lg = lg || {},
    ButtonState = {
        UP: "up",
        OVER: "over",
        DOWN: "down",
        SELECTED: "selected",
        SELECTED_OVER: "selected_over",
        SELECTED_DOWN: "selected_down",
        DISABLED: "disabled"
    };
lg._buttonDefine = {
    name: null,
    _state: null,
    onEnter: function () {
        this._super()
    },
    onExit: function () {
        this._super()
    },
    setState: function (a) {
        this._state != a && (this._state = a, this.gotoAndStop(this._state) || (a = this.isSelected() ? ButtonState.SELECTED : ButtonState.UP, this.gotoAndStop(a) || this.gotoAndStop(0)))
    },
    getState: function () {
        return this._state
    },
    isSelected: function () {
        return this._state == ButtonState.SELECTED || this._state == ButtonState.SELECTED_OVER || this._state == ButtonState.SELECTED_DOWN
    },
    isSelectable: function () {
        return this.hasLabel(ButtonState.SELECTED)
    },
    setMouseEnabled: function (a) {
        if (this.isMouseEnabled() == a) return !1;
        this.setState(a ? ButtonState.UP : ButtonState.DISABLED);
        return !0
    },
    isMouseEnabled: function () {
        return this._state != ButtonState.DISABLED
    }
};
lg.SimpleButton = lg.Animator.extend(lg._buttonDefine);
lg.SimpleButton.create = function (a, b) {
    var c = new lg.SimpleButton(a, b);
    c.clsName = "lg.SimpleButton";
    c.setState(ButtonState.UP);
    return c
};
lg.Button = lg.MovieClip.extend(lg._buttonDefine);
lg.Button.create = function (a, b) {
    var c = new lg.Button(a, b);
    c.clsName = "lg.Button";
    c.setState(ButtonState.UP);
    return c
};
lg.isButton = function (a) {
    return a instanceof lg.SimpleButton || a instanceof lg.Button
};
lg = lg || {};
lg.TiledImage = cc.SpriteBatchNode.extend({
    tileMap: null,
    tileWidthOffset: -1,
    tileHeightOffset: -1,
    _plistFile: null,
    _taID: null,
    _minWidth: 0,
    _minHeight: 0,
    _pool: null,
    init: function (a, b) {
        this._super(a, b);
        this.tileMap = lg.TileMap.create("tile_image_" + lg.randInt(0, 1E3));
        return !0
    },
    setTileSource: function (a, b) {
        if (this._plistFile != a || this._taID != b) {
            this._plistFile = a;
            this._taID = b;
            this._pool = lg.ObjectPool.get(a, "lg.Animator");
            var c = lg.assetsManager.createDisplay(this._plistFile, this._taID).getContentSize();
            this.tileMap.setTileSize(c.width +
                this.tileWidthOffset, c.height + this.tileHeightOffset);
            0 < this._minWidth * this._minHeight && (0 < this._children.length ? this._updateTileImg() : this._updateSize())
        }
    },
    setMinSize: function (a, b) {
        0 != (a - this._minWidth) * (b - this._minHeight) && (this._minWidth = a, this._minHeight = b, this._plistFile && this._updateSize())
    },
    _updateTileImg: function () {
        for (var a = null, b = this._children.length, c = -1; ++c < b;) a = this._children[c], a.setPlist(this._plistFile, this._taID)
    },
    _updateSize: function () {
        var a = this.tileMap.setMapSizePixel(this._minWidth,
                this._minHeight),
            b, c = a[0].length;
        if (0 < c) {
            var d;
            for (b = -1; ++b < c;) d = a[0][b], d.destroy()
        }
        c = a[1].length;
        if (0 < c)
            for (b = -1; ++b < c;) this._createTile(a[1][b][0], a[1][b][1]);
        this.setContentSize(this.tileMap.getPixelSize())
    },
    _createTile: function (a, b) {
        var c = this._pool.fetch(this._taID, this);
        c.setAnchorPoint(0.5, 0.5);
        this.tileMap.addObject(c, a, b);
        this.tileMap.snapToTile(c, a, b);
        return c
    }
});
lg.TiledImage.create = function (a, b, c, d) {
    var e = new lg.TiledImage,
        f = a.replace("." + lg.getFileExtension(a), ".png");
    return e.init(f, 10) ? (e.setTileSource(a, b), isNaN(c) || (c = cc.visibleRect.width), isNaN(d) || (d = cc.visibleRect.height), e.setMinSize(c, d), e) : null
};
lg = lg || {};
lg.ScrollingBG = cc.Node.extend({
    source: null,
    assetID: null,
    bg0: null,
    bg1: null,
    _isTiled: null,
    _scrolling: !1,
    _paused: !1,
    _speedX: 0,
    _speedY: 0,
    _d: 1,
    _size: null,
    init: function () {
        if (this._super()) {
            if (null == this.source) return cc.log("Please give a source!"), !1;
            if (null != this.assetID)!0 !== this._isTiled ? (this.bg0 = lg.assetsManager.createDisplay(this.source, this.assetID), this.bg1 = lg.assetsManager.createDisplay(this.source, this.assetID)) : (this.bg0 = lg.TiledImage.create(this.source, this.assetID), this.bg1 = lg.TiledImage.create(this.source, this.assetID));
            else if (this.source)
                if (lg.isImageFile(this.source)) this.bg0 = cc.Sprite.create(this.source), this.bg1 = cc.Sprite.create(this.source);
                else return cc.log("Not support source type!"), !1;
            this.bg0.setAnchorPoint(0, 0);
            this.bg1.setAnchorPoint(0, 0);
            this.addChild(this.bg0);
            this.addChild(this.bg1);
            this._size = this.bg0.getContentSize();
            return !0
        }
        return !1
    },
    startXScroll: function (a) {
        0 == a || this._scrolling || (this._scrolling = !0, this._speedX = a, this._speedY = 0, this._d = 0 < this._speedX ? 1 : -1, this._resetScroll(), this._doScroll())
    },
    startYScroll: function (a) {
        0 == a || this._scrolling || (this._scrolling = !0, this._speedY = a, this._speedX = 0, this._d = 0 < this._speedY ? 1 : -1, this._resetScroll(), this._doScroll())
    },
    pauseScroll: function () {
        this._scrolling && !this._paused && (this._paused = !0, this.bg0.stopAllActions(), this.bg1.stopAllActions(), this.unscheduleAllCallbacks())
    },
    resumeScroll: function () {
        this._scrolling && this._paused && (this._paused = !1, 0 != this._speedX ? this._doScroll(this._size.width - Math.abs(this.bg0.x)) : 0 != this._speedY && this._doScroll(this._size.height -
            Math.abs(this.bg0.y)))
    },
    _resetScroll: function () {
        this.bg0.setPosition(0, 0);
        0 != this._speedX ? this.bg1.x = -this._d * (this._size.width - 1) : this.bg1.y = -this._d * (this._size.height - 1)
    },
    _doScroll: function (a) {
        if (0 != a) {
            var b = 0 != this._speedX;
            null == a && (a = b ? this._size.width : this._size.height);
            var c = a / Math.abs(b ? this._speedX : this._speedY);
            a *= this._d;
            this.bg0.runAction(cc.MoveBy.create(c, cc.p(b ? a : 0, b ? 0 : a)));
            this.bg1.runAction(cc.MoveBy.create(c, cc.p(b ? a : 0, b ? 0 : a)));
            this.scheduleOnce(function () {
                if (this._scrolling && !this._paused) {
                    var a =
                        this.bg0;
                    this.bg0 = this.bg1;
                    this.bg1 = a;
                    this._resetScroll();
                    this._doScroll()
                }
            }, c)
        }
    }
});
lg.ScrollingBG.create = function (a, b, c) {
    var d = new lg.ScrollingBG;
    d.source = a;
    d.assetID = b;
    d._isTiled = c;
    return d.init() ? d : null
};
lg = lg || {};
lg.ObjectPool = cc.Class.extend({
    maxCount: 100,
    _clsName: null,
    _cls: null,
    _plistFile: null,
    _pool: null,
    _extraID: "",
    init: function (a, b, c) {
        if (this._plistFile && this._cls) return cc.log("The pool has been inited with cls: " + this._cls), !1;
        this._clsName = b;
        this._cls = lg.nameToObject(b);
        if (null == this._cls) return cc.log("There is no class named: " + b), !1;
        this._plistFile = a;
        this._pool = [];
        void 0 !== c && (this.maxCount = c);
        return !0
    },
    fetch: function (a, b, c) {
        if (null == a) return cc.log("Please give me a assetID to fetch a object!"), null;
        var d = null;
        0 < this._pool.length ? (d = this._pool.shift(), d.setPlist(this._plistFile, a)) : d = this._cls.create(this._plistFile, a);
        d.__pool__id__ = this._extraID;
        d.clsName = this._clsName;
        d.autoRecycle = !0;
        d.visible = !0;
        c ? "undefined" === typeof c.zIndex && (c.zIndex = 0) : c = {
            zIndex: 0
        };
        d.attr(c);
        b && b.addChild(d);
        return d
    },
    recycle: function (a) {
        if (!(a instanceof this._cls)) cc.log("The object to recycle is not the same type with this pool: " + this._cls);
        else if (this._pool.length < this.maxCount) {
            if (a.onRecycle) a.onRecycle();
            this._pool.push(a)
        }
    },
    release: function () {
        this._pool.length = 0
    }
});
lg.ObjectPool.all = {};
lg.ObjectPool.create = function (a, b, c) {
    var d = new lg.ObjectPool;
    return d.init(a, b, c) ? d : null
};
lg.ObjectPool.get = function (a, b, c) {
    null == b && (b = "lg.Animator");
    null == c && (c = "");
    var d = a + b + c,
        e = lg.ObjectPool.all[d];
    null == e && (e = lg.ObjectPool.create(a, b), e._extraID = c, lg.ObjectPool.all[d] = e);
    return e
};
lg.ObjectPool.release = function () {
    for (var a in lg.ObjectPool.all) lg.ObjectPool.all[a].release(), delete lg.ObjectPool.all[a]
};
lg = lg || {};
lg.GunParam = cc.Class.extend({
    bulletPlist: null,
    bulletID: null,
    targetMap: null,
    damage: 1,
    damageRadius: 0,
    speed: 600,
    interval: 0.15,
    count: 1,
    angleGap: 5,
    waveInterval: 0,
    countInWave: 6,
    fireSound: null,
    fireEffectID: null,
    hitEffectID: null,
    alwaysLive: !1,
    bulletPlayOnce: !1,
    isMissle: !1
});
lg.GunParam.create = function (a) {
    var b = new lg.GunParam;
    lg.copyProperties(a, b);
    return b
};
lg.Gun = cc.Node.extend({
    owner: null,
    param: null,
    _firing: !1,
    _pool: null,
    _waveTime: 0,
    _maxShootDistance: 0,
    _targetMap: null,
    init: function () {
        this._super()
    },
    start: function () {
        this._firing || (this._firing = !0, this._pool = lg.ObjectPool.get(this.param.bulletPlist, "lg.Animator", "___bullet"), this._waveTime = this.param.interval * this.param.countInWave + this.param.waveInterval, this._maxShootDistance = 1.5 * Math.max(cc.visibleRect.width, cc.visibleRect.height), 0 >= this.param.waveInterval || 1 >= this.param.countInWave ? (this.schedule(this._createBullet,
            this.param.interval), this._createBullet()) : this._waveFire())
    },
    end: function () {
        this._firing && (this._firing = !1, this.unschedule(this._createBullet), this.unschedule(this._createWave))
    },
    updateParam: function (a) {
        null != a && (lg.copyProperties(a, this.param), this.end(), this.start())
    },
    isFiring: function () {
        return this._firing
    },
    _waveFire: function () {
        this._firing && (this._createWave(), this.schedule(this._createWave, this._waveTime, cc.REPEAT_FOREVER))
    },
    _createBullet: function () {
        if (null == lg.bulletCanvas) cc.log("Pls set batch canvas for me to show the bullet: lg.bulletCanvas!");
        else {
            for (var a = this.parent.convertToWorldSpace(this.getPosition()), a = lg.bulletCanvas.convertToNodeSpace(a), b = lg.getRotation(this, !0), c = null, d = -1, e = 0, c = 0, f = lg.createDInts(this.param.count); ++d < this.param.count;) {
                c = f[d];
                e = b + c * this.param.angleGap;
                c = this._pool.fetch(this.param.bulletID, lg.bulletCanvas);
                c.owner = this.owner;
                c.param = this.param;
                c.targetMap = lg.getTileMap(this.param.targetMap);
                c.gotoAndPlay(0);
                c.autoStopWhenOver = this.param.bulletPlayOnce;
                c.setPosition(a);
                c.setRotation(e);
                var g = this.param.damage;
                g instanceof Array && (1 == g.length ? g = g[0] : 2 <= g.length && (g = lg.randInt(g[0], g[1])));
                c.damage = g;
                c.__speed = this.param.speed;
                c.__moveRotation = e;
                lg.bulletCanvas._bullets.push(c)
            }
            this._showFireEffect(a, e);
            this.param.fireSound && lg.playSound(this.param.fireSound)
        }
    },
    _createWave: function () {
        this.schedule(this._createBullet, this.param.interval, this.param.countInWave - 1)
    },
    _showFireEffect: function (a, b) {
        if (null != this.param.fireEffectID && "" != this.param.fireEffectID) {
            var c = lg.assetsManager.createDisplay(this.param.bulletPlist,
                this.param.fireEffectID, null, !0, lg.bulletCanvas);
            c.zIndex = 999;
            c.autoDestroyWhenOver = !0;
            c.setPosition(a);
            c.setRotation(b);
            c.gotoAndPlay(0)
        }
    }
});
lg.BulletCanvas = cc.SpriteBatchNode.extend({
    _bullets: null,
    _stageRect: null,
    onEnter: function () {
        this._super();
        this._bullets = [];
        this._stageRect = cc.rect(0, 0, cc.visibleRect.width, cc.visibleRect.height);
        this.scheduleUpdate()
    },
    update: function (a) {
        var b = this._bullets.length;
        if (0 != b)
            for (var c = null, d = null, e = -1, e = null, f = !1, g = f = null; b--;) {
                c = this._bullets[b];
                d = c.__speed * a;
                c.setPosition(cc.pAdd(c.getPosition(), lg.getPointOnCircle(d, c.__moveRotation)));
                e = lg.getRect(c, !0);
                f = !1;
                d = null;
                cc.rectIntersectsRect(this._stageRect,
                    e) ? d = this._checkHittedTarget(c, e, !1) : f = !0;
                if (d && d.length) {
                    f = lg.getPosition(c, !0);
                    g = lg.getRotation(c, !0);
                    e = c.param.damageRadius;
                    0 < e && (e = cc.rect(f.x - e / 2, f.y - e / 2, e, e), d = this._checkHittedTarget(c, e, !0));
                    for (var h, e = d.length; e--;) h = d[e], h.onHit && (h.dead = h.onHit(c));
                    this._showHitEffect(c, f, g);
                    f = !0
                }
                f && !c.param.alwaysLive && (c.destroy(), this._bullets.splice(b, 1))
            }
    },
    _checkHittedTarget: function (a, b, c) {
        var d = [],
            e = null,
            e = a.targetMap ? a.targetMap.getCoveredTiles1(b, !0) : a.owner.targets;
        if (!e || !e.length) return d;
        for (b = -1; ++b < e.length;)
            if (target = e[b], !(target == a.owner || !0 === target.dead || a.owner && target.camp == a.owner.camp) && a.mainCollider.checkCollision(target.mainCollider)) {
                if (!c) return [target];
                d.push(target)
            }
        return d
    },
    _showHitEffect: function (a, b, c) {
        null != a.param.hitEffectID && "" != a.param.hitEffectID && (a = lg.assetsManager.createDisplay(a.param.bulletPlist, a.param.hitEffectID, null, !0, this), a.zIndex = 999, a.autoDestroyWhenOver = !0, a.setPosition(b), a.setRotation(c), a.gotoAndPlay(0))
    }
});
lg.BulletCanvas.create = function (a) {
    return new lg.BulletCanvas(a, 100)
};
lg.Gun.create = function (a) {
    if (null == a) return cc.log("Please give me a param defiled like: lg.GunParam!"), null;
    a = lg.GunParam.create(a);
    var b = new lg.Gun;
    b.param = a;
    b.init();
    return b
};
var Global = Global || {};
Global.bing = !1;
Global.BingDate = 5;
Global.BingMove = 20;
Global.ZombiePause = !1;
Global.PauseDate = 5;
Global.Blood = 400;
Global.ShieldBool = !1;
Global.Shield = 10;
Global.earthPositon = 635;
Global.bombCollidSize = 30;
Global.maxHealth = 500;
Global.health = 500;
Global.maxTime = 180;
Global.time = 180;
Global.level = 1;
Global.level2 = 1;
Global.score = 99E3;
Global.bestScore = 0;
Global.gameOver = !1;
Global.gamePause = !1;
Global.bombSlotGap = 50;
Global.zombies = [];
Global.onZombieDead = null;
USER_INFO_KEY = "zomibe_attack_player";
LINK_WIDTH = 3;
FRUIT_COME_IN_TIME = 0.01;
MAX_FAULT_TIMES = 6;
MAX_THINKING_TIME_MS = 4E3;
ScoreKey = "ScoreKey";
LevelKey = "LevelKey";
KOOOO = 0;
BOMBS_PROP = {
    Bomb0: {
        damage: 25,
        killNow: !0,
        isIce: !1,
        isBounce: !1,
        splash: !1
    },
    Bomb1: {
        damage: 50,
        killNow: !0,
        isIce: !1,
        isBounce: !1,
        splash: !1
    },
    Bomb2: {
        damage: 75,
        killNow: !0,
        isIce: !1,
        isBounce: !1,
        splash: !1
    },
    Bomb3: {
        damage: 100,
        killNow: !0,
        isIce: !1,
        isBounce: !1,
        splash: !1
    },
    Bomb4: {
        damage: 125,
        killNow: !1,
        isIce: !1,
        isBounce: !1,
        splash: !1
    },
    Bomb5: {
        damage: 150,
        killNow: !1,
        isIce: !1,
        isBounce: !1,
        splash: !1
    },
    Bomb6: {
        damage: 175,
        killNow: !0,
        isIce: !1,
        isBounce: !1,
        splash: !1
    },
    Bomb7: {
        damage: 200,
        killNow: !0,
        isIce: !1,
        isBounce: !1,
        splash: !1
    },
    Bomb8: {
        damage: 225,
        killNow: !0,
        isIce: !1,
        isBounce: !1,
        splash: !1
    },
    Bomb9: {
        damage: 250,
        killNow: !0,
        isIce: !1,
        isBounce: !1,
        splash: !1
    },
    Bomb10: {
        damage: 275,
        killNow: !0,
        isIce: !1,
        isBounce: !1,
        splash: !1
    },
    Bomb11: {
        damage: 275,
        killNow: !0,
        isIce: !1,
        isBounce: !1,
        splash: !1
    },
    Bomb12: {
        damage: 275,
        killNow: !0,
        isIce: !1,
        isBounce: !1,
        splash: !1
    },
    Bomb13: {
        damage: 275,
        killNow: !0,
        isIce: !1,
        isBounce: !1,
        splash: !1
    },
    Bomb14: {
        damage: 0,
        killNow: !1,
        isIce: !1,
        isBounce: !0,
        splash: !1
    }
};
ZOMBIES0 = [{
    health: 25,
    damage: 25,
    speed: 50,
    interval: 6
}, {
    health: 25,
    damage: 25,
    speed: 50,
    interval: 6
}, {
    health: 25,
    damage: 25,
    speed: 60,
    interval: 6
}, {
    health: 50,
    damage: 50,
    speed: 60,
    interval: 6
}, {
    health: 50,
    damage: 50,
    speed: 100,
    interval: 5
}, {
    health: 75,
    damage: 75,
    speed: 100,
    interval: 5
}, {
    health: 75,
    damage: 75,
    speed: 100,
    interval: 5
}, {
    health: 100,
    damage: 100,
    speed: 100,
    interval: 5
}, {
    health: 100,
    damage: 100,
    speed: 100,
    interval: 5
}, {
    health: 125,
    damage: 125,
    speed: 100,
    interval: 4.5
}, {
    health: 125,
    damage: 125,
    speed: 120,
    interval: 4.5
}, {
    health: 150,
    damage: 150,
    speed: 120,
    interval: 4.5
}, {
    health: 150,
    damage: 150,
    speed: 120,
    interval: 4.5
}, {
    health: 175,
    damage: 175,
    speed: 140,
    interval: 4
}, {
    health: 175,
    damage: 175,
    speed: 140,
    interval: 4
}, {
    health: 200,
    damage: 200,
    speed: 180,
    interval: 4
}, {
    health: 200,
    damage: 200,
    speed: 180,
    interval: 3.5
}, {
    health: 225,
    damage: 225,
    speed: 180,
    interval: 3.5
}, {
    health: 225,
    damage: 225,
    speed: 200,
    interval: 3.5
}, {
    health: 225,
    damage: 225,
    speed: 200,
    interval: 3
}];
ZOMBIES1 = [{
    health: 25,
    damage: 25,
    speed: 100,
    interval: 3
}, {
    health: 25,
    damage: 25,
    speed: 100,
    interval: 3
}, {
    health: 25,
    damage: 25,
    speed: 100,
    interval: 3
}, {
    health: 25,
    damage: 50,
    speed: 150,
    interval: 3
}, {
    health: 25,
    damage: 50,
    speed: 150,
    interval: 2.5
}, {
    health: 25,
    damage: 75,
    speed: 150,
    interval: 2.5
}, {
    health: 25,
    damage: 75,
    speed: 150,
    interval: 2.5
}, {
    health: 25,
    damage: 100,
    speed: 150,
    interval: 2.5
}, {
    health: 25,
    damage: 100,
    speed: 200,
    interval: 2.5
}, {
    health: 25,
    damage: 125,
    speed: 200,
    interval: 2.5
}, {
    health: 25,
    damage: 125,
    speed: 200,
    interval: 2.5
}, {
    health: 25,
    damage: 150,
    speed: 200,
    interval: 2.5
}, {
    health: 25,
    damage: 150,
    speed: 250,
    interval: 2.5
}, {
    health: 25,
    damage: 175,
    speed: 250,
    interval: 2.5
}, {
    health: 25,
    damage: 175,
    speed: 250,
    interval: 2.5
}, {
    health: 25,
    damage: 200,
    speed: 250,
    interval: 2.5
}, {
    health: 25,
    damage: 200,
    speed: 300,
    interval: 2
}, {
    health: 25,
    damage: 225,
    speed: 300,
    interval: 2
}, {
    health: 25,
    damage: 225,
    speed: 350,
    interval: 2
}, {
    health: 25,
    damage: 225,
    speed: 400,
    interval: 2
}];
Global.zEnemies = [{
    coins: 10,
    maxHealth: 10,
    damage: 5,
    speed: 100,
    walkFPS: 10,
    lost: 1,
    assetID: "BombZombie"
}, {
    coins: 10,
    maxHealth: 20,
    damage: 10,
    speed: 75,
    walkFPS: 10,
    lost: 1,
    assetID: "Zombie0"
}, {
    coins: 20,
    maxHealth: 20,
    damage: 10,
    speed: 75,
    walkFPS: 10,
    lost: 2,
    assetID: "Zombie1"
}, {
    coins: 20,
    maxHealth: 20,
    damage: 15,
    speed: 50,
    walkFPS: 10,
    lost: 2,
    assetID: "Zombie2"
}, {
    coins: 20,
    maxHealth: 30,
    damage: 20,
    speed: 40,
    walkFPS: 10,
    lost: 2,
    assetID: "Zombie3"
}, {
    coins: 20,
    maxHealth: 30,
    damage: 20,
    speed: 40,
    walkFPS: 10,
    lost: 2,
    assetID: "Zombie4"
}, {
    coins: 20,
    maxHealth: 40,
    damage: 25,
    speed: 25,
    walkFPS: 10,
    lost: 2,
    assetID: "Zombie5"
}, {
    coins: 20,
    maxHealth: 50,
    damage: 25,
    speed: 25,
    walkFPS: 10,
    lost: 2,
    assetID: "Zombie6"
}, {
    coins: 20,
    maxHealth: 60,
    damage: 30,
    speed: 15,
    walkFPS: 10,
    lost: 2,
    assetID: "Zombie7"
}, {
    coins: 20,
    maxHealth: 70,
    damage: 30,
    speed: 15,
    walkFPS: 10,
    lost: 2,
    assetID: "Zombie8"
}, {
    coins: 20,
    maxHealth: 100,
    damage: 50,
    speed: 10,
    walkFPS: 10,
    lost: 2,
    assetID: "Zombie9"
}];
Global.zWaves = [{
    type: "1,2",
    count: 8,
    interval: "2,3",
    waveInterval: 5
}, {
    type: "1,2,3",
    count: 10,
    interval: "2,3",
    waveInterval: 5
}, {
    type: "1,2,4",
    count: 10,
    interval: "2,3",
    waveInterval: 5
}, {
    type: "3,4",
    count: 10,
    interval: "2,3",
    waveInterval: 4
}, {
    type: "3,5",
    count: 10,
    interval: "2,3",
    waveInterval: 4
}, {
    type: "4,5",
    count: 15,
    interval: "2,3",
    waveInterval: 3
}, {
    type: "4,6",
    count: 15,
    interval: "2,3",
    waveInterval: 3
}, {
    type: "8,9,10",
    count: 20,
    interval: "2,3",
    waveInterval: 2
}, {
    type: "11",
    count: 1,
    interval: "1,2",
    waveInterval: 1
}];
Global.zLevels = [
    [1, 1, 1, 1, 1],
    [1, 2, 1, 2, 1],
    [2, 1, 2, 1, 2],
    [2, 2, 2, 2, 2],
    [1, 1, 1, 3, 3],
    [2, 2, 2, 3, 3],
    [1, 4, 1, 2, 3],
    [2, 4, 2, 3, 3],
    [2, 4, 3, 1, 4],
    [3, 4, 1, 3, 4],
    [4, 3, 2, 2, 5],
    [4, 4, 3, 3, 5],
    [4, 1, 5, 1, 5],
    [4, 2, 5, 2, 5],
    [4, 3, 5, 3, 6],
    [5, 3, 3, 6, 4, 6],
    [6, 3, 3, 6, 4, 6],
    [6, 4, 3, 6, 4, 6],
    [6, 4, 5, 6, 4, 6],
    [5, 1, 3, 3, 6, 1, 4, 6],
    [5, 1, 3, 3, 6, 1, 4, 7],
    [6, 5, 1, 3, 3, 6, 1, 7, 7],
    [6, 5, 1, 3, 3, 6, 1, 6, 1, 7, 8],
    [6, 5, 1, 3, 3, 6, 1, 6, 1, 7, 9, 1]
];
Global.PropsLevel = [
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3,
            5
        ],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500,
            5
        ]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ],
    [
        [800, 5],
        [1E3, 5],
        [500, 5],
        [5E3, 5],
        [2500, 5],
        [2500, 5]
    ]
];
BOMBS = "Bomb0 Bomb1 Bomb2 Bomb3 Bomb4 Bomb5 Bomb6 Bomb7 Bomb8 Bomb9 Bomb10 Bomb11 Bomb12 Bomb13 Bomb14 Bomb15 Bomb16 Bomb17".split(" ");
LEVELS = [
    [3, 3, 2, 0, 3],
    [3, 3, 4, 0, 3],
    [3, 3, 8, 0, 3],
    [4, 4, 10, 0, 4],
    [6, 6, 30, 0, 5],
    [5, 5, 14, 0, 6],
    [5, 5, 16, 0, 7],
    [6, 6, 18, 0, 8],
    [6, 6, 20, 0, 9],
    [6, 6, 22, 0, 10],
    [6, 6, 24, 0, 11],
    [6, 6, 26, 0, 11],
    [6, 6, 28, 0, 11],
    [6, 6, 30, 0, 11],
    [6, 6, 32, 0, 11],
    [6, 6, 34, 0, 11],
    [6, 6, 36, 0, 11],
    [6, 6, 36, 0, 11],
    [6, 6, 36, 0, 11],
    [6, 6, 36, 0, 11],
    [6, 6, 36, 0, 11],
    [6, 6, 36, 0, 11],
    [6, 6, 36, 0, 11],
    [6, 6, 36, 0, 11]
];
Global.zBomb = {
    Bomb0: {
        type: 0,
        damage: 10
    },
    Bomb1: {
        type: 1,
        damage: 10
    },
    Bomb2: {
        type: 2,
        damage: 10
    },
    Bomb3: {
        type: 3,
        damage: 20
    },
    Bomb4: {
        type: 4,
        damage: 20
    },
    Bomb5: {
        type: 5,
        damage: 30
    },
    Bomb6: {
        type: 6,
        damage: 30
    },
    Bomb7: {
        type: 7,
        damage: 40
    },
    Bomb8: {
        type: 8,
        damage: 40
    },
    Bomb9: {
        type: 9,
        damage: 50
    },
    Bomb10: {
        type: 10,
        damage: 60
    },
    Bomb11: {
        type: 11,
        damage: 100
    },
    Bomb12: {
        type: 12
    },
    Bomb13: {
        type: 13
    },
    Bomb14: {
        type: 14
    },
    Bomb15: {
        type: 15,
        damage: 50
    },
    Bomb16: {
        type: 16
    },
    Bomb17: {
        type: 17
    }
};
Global.DateLevel = [150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150];
Global.data = [
    [15, 15, 15, 15], null
];
var music = {
        ready: "res/music/menu.mp3",
        battle: "res/music/zombies.mp3",
        explosion: "res/music/explosion.mp3",
        gameover: "res/music/end.mp3"
    },
    res;
MAX_IDLE_TIME = 1E5;
var PlayCover = lg.MovieClip.extend({
    _instance: null,
    onEnter: function () {
        this._super();
        lg.inputManager.addListener(this, this.onItemTouched)
    },
    onItemTouched: function (a, b) {
        "resumeBtn" == b.name && (Global.gamePause = !1, this.setVisible(!1), ControlBar.getInstance().pauseBtn.setState(ButtonState.SELECTED))
    },
    show: function () {
        null == this.getParent() && lg.currentScene.addChild(this, 999999);
        this.setVisible(!0)
    }
});
PlayCover.create = function () {
    return new PlayCover(res.ui_plist, "PlayCover")
};
PlayCover.getInstance = function () {
    null == this._instance && (this._instance = PlayCover.create());
    return this._instance
};
var ControlBar = lg.MovieClip.extend({
    soundBtn: null,
    pauseBtn: null,
    moreBtn: null,
    lastActionTime: -1,
    inIdle: !1,
    _soundBeforePause: !0,
    _intstacne: null,
    onEnter: function () {
        this._super();
        this.soundBtn = this.getChildByName("soundBtn");
        this.pauseBtn = this.getChildByName("pauseBtn");
        this.bg.visible = !1;
        this.continu.visible = !1;
        this.menu1.visible = !1;
        this.moress.visible = !1;
        this.label__6.visible = !1;
        lg.inputManager.addListener(this.moress, function (a, b) {
            //window.open("http://m.softgames.de")
            Sg.redirectToPortal();
        });
        var a = this;
        lg.inputManager.addListener(this.continu,
            function (b, d) {
                a.pauseBtn.setState(ButtonState.SELECTED);
                a.onPause(a)
            });
        lg.inputManager.addListener(this.menu1, function (b, d) {
            a.pauseBtn.setState(ButtonState.SELECTED);
            a.onPause(a);
            lg.replaceScene("mainMenu")
        });
        lg.inputManager.addListener(this.pauseBtn, function (b, d) {
            a.onPause(a)
        });
        var b = this.soundBtn;
        lg.inputManager.addListener(this.soundBtn, function (a, d) {
            lg.setSoundEnabled(!b.isSelected())
        });
        lg.getSoundEnabled() || this.soundBtn.setState(ButtonState.SELECTED);
        this.pauseBtn.setVisible("mainGame" == lg.currentSceneName);
        "mainGame" == lg.currentSceneName && this.pauseBtn.setState(ButtonState.SELECTED)
    },
    onPause: function (a) {
        Global.gamePause = !a.pauseBtn.isSelected();
        Global.gamePause ? (a10Enabled && GameAPI.GameBreak.request(function () {
            cc.log("start ad")
        }, function () {
            cc.log("end ad")
        }), cc.director.pause(), this.bg.visible = !0, this.continu.visible = !0, this.menu1.visible = !0, this.moress.visible = !0, this.label__6.visible = !0, a._soundBeforePause = lg.getSoundEnabled(), lg.setSoundEnabled(!1)) : (cc.director.resume(), this.bg.visible = !1, this.continu.visible = !1, this.menu1.visible = !1, this.moress.visible = !1, this.label__6.visible = !1, lg.setSoundEnabled(a._soundBeforePause));
        lg.getSoundEnabled() ? a.soundBtn.setState(ButtonState.UP) : a.soundBtn.setState(ButtonState.SELECTED)
    }
});
ControlBar.create = function () {
    var a = new ControlBar(res.ui2_plist, "ControlBar");
    return this._instance = a
};
ControlBar.getInstance = function () {
    return this._instance
};
var MainMenu = lg.MovieClip.extend({
    _startBtn: null,
    onEnter: function () {
        this._super();
        this._startBtn = this.getChildByName("startBtn");
        lg.playMusic(music.battle, !0);
        lg.inputManager.addListener(this.getChildByName("startBtn"), function () {
            lg.replaceScene("mainLevel")
        });
        lg.inputManager.addListener(this.getChildByName("moreBtn"), function () {
          //  window.open("http://m.softgames.de")
        })
    }
});
MainMenu.create = function (a, b) {
    return new MainMenu(a, b)
};
MainMenu.scene = function () {
    var a = cc.Scene.create(),
        b = MainMenu.create(res.ui3_plist, "MainMenu");
    a.addChild(b, 1);
    a.addChild(ControlBar.create(), 2);
    return a
};
var LinkFinder = {
    map: null,
    blocks: null,
    findLink: function (a, b, c, d) {
        var e = null,
            e = a == c || b == d ? LinkFinder._checkDirectLink(a, b, c, d) : LinkFinder._checkOneLink(a, b, c, d);
        null == e && (e = LinkFinder._checkTwoLink(a, b, c, d));
        return e
    },
    shuffle: function (a) {
        var b = this.map.getAllObjects(),
            c = b.concat(),
            d = -1;
        if (this.blocks && this.blocks.length)
            for (c = []; ++d < b.length;) {
                var e = b[d]; - 1 == this.blocks.indexOf(e) && c.push(e)
            }
        c.shuffle();
        d = -1;
        for (b = c.length / 2; ++d < b;) {
            var e = c[d],
                f = c[d + b],
                g = cc.p(e.getPosition());
            !1 !== a ? (e.runAction(cc.MoveTo.create(0.2,
                f.getPosition())), f.runAction(cc.MoveTo.create(0.2, g))) : (e.setPosition(f.getPosition()), f.setPosition(g))
        }
    },
    findAvailableLink: function (a) {
        var b = this.map.getAllObjects(),
            c = b.length;
        if (0 == c) return null;
        for (var d, e, f = null, g = [], h = null, k = 0; k < c - 1; k++)
            if (d = b[k], !(this.blocks && -1 < this.blocks.indexOf(d))) {
                var m = 0 == g.length;
                null == h && (h = d);
                for (var n = k + 1; n < c; n++)
                    if (e = b[n], !(this.blocks && -1 < this.blocks.indexOf(e)))
                        if (e.assetID == d.assetID) {
                            if (LinkFinder.findLink(d.tx, d.ty, e.tx, e.ty)) return [d, e];
                            m && g.push(e)
                        } else m &&
                            null == f && LinkFinder.findLink(d.tx, d.ty, e.tx, e.ty) && (f = e)
            }
        if (0 == g.length) return null;
        b = g[Math.floor(g.length * Math.random())];
        c = cc.p(b.getPosition());
        if (null == f) {
            f = this._findEmptyNeighbor(h.tx, h.ty);
            if (null == f) throw "Dead map!!!!";
            c = cc.p(this.map.getTiledPositionX(f.x), this.map.getTiledPositionY(f.y));
            b.parent && (c = b.parent.convertToNodeSpace(c));
            !0 === a ? b.runAction(cc.MoveTo.create(0.2, c)) : b.setPosition(c)
        } else !0 === a ? (b.runAction(cc.MoveTo.create(0.2, f.getPosition())), f.runAction(cc.MoveTo.create(0.2,
            c))) : (b.setPosition(f.getPosition()), f.setPosition(c));
        return [h, b]
    },
    _findEmptyNeighbor: function (a, b) {
        for (var c = null, d = 0; 4 > d && (c = EIGHT_DIRECTIONS[d], c = cc.p(a + c[0], b + c[1]), !this.map.isEmptyTile(c.x, c.y)); d++);
        return c
    },
    _checkDirectLink: function (a, b, c, d) {
        if (a == c && b == d) return null;
        if (a == c) {
            for (var e = !0, f = 0 < d - b ? 1 : -1, g = b + f; g != d;) {
                if (!this.map.isEmptyTile(a, g)) {
                    e = !1;
                    break
                }
                g += f
            }
            if (e) return [new cc.p(a, b), new cc.p(c, d)]
        }
        if (b == d) {
            e = !0;
            f = 0 < c - a ? 1 : -1;
            for (g = a + f; g != c;) {
                if (!this.map.isEmptyTile(g, b)) {
                    e = !1;
                    break
                }
                g +=
                    f
            }
            if (e) return [new cc.p(a, b), new cc.p(c, d)]
        }
        return null
    },
    _checkOneLink: function (a, b, c, d) {
        if (a == c || b == d) return null;
        if (this.map.isEmptyTile(a, d)) {
            var e = LinkFinder._checkDirectLink(a, b, a, d);
            if (e && (e = LinkFinder._checkDirectLink(a, d, c, d))) return [new cc.p(a, b), new cc.p(a, d), new cc.p(c, d)]
        }
        return this.map.isEmptyTile(c, b) && (e = LinkFinder._checkDirectLink(a, b, c, b)) && (e = LinkFinder._checkDirectLink(c, b, c, d)) ? [new cc.p(a, b), new cc.p(c, b), new cc.p(c, d)] : null
    },
    _checkTwoLink: function (a, b, c, d) {
        if (a == c && b == d) return null;
        var e = 0 <= c - a ? 1 : -1,
            f = 0 <= d - b ? 1 : -1,
            g = LinkFinder._twoLinkSearch(a, b, c, d, e, f);
        null == g && (g = LinkFinder._twoLinkSearch(a, b, c, d, -e, -f));
        null != g && g.unshift(new cc.p(a, b));
        return g
    },
    _twoLinkSearch: function (a, b, c, d, e, f) {
        for (var g = null, h = a + e, k = b + f, m = !1, n = !1; !m || !n;) {
            if (!m && (m = !this.map.isEmptyTile(h, b), !m)) {
                g = LinkFinder._checkOneLink(h, b, c, d);
                if (null != g) break;
                h += e
            }
            if (!n && (n = !this.map.isEmptyTile(a, k), !n)) {
                g = LinkFinder._checkOneLink(a, k, c, d);
                if (null != g) break;
                k += f
            }
        }
        return g
    }
};
var Zombie = lg.MovieClip.extend({
    prop: null,
    health: 100,
    speed: 40,
    damage: 25,
    coins: 20,
    bomber: !1,
    dead: !1,
    startX: 0,
    thisFPS: 25,
    inAttacking: !1,
    walkAction: null,
    onEnter: function (a) {
        firtsTime = !0 === a;
        lg.copyProperties(this.prop, this);
        this.autoPlayChildren = !0;
        this.inAttacking = this.dead = !1;
        this._super();
        this.setPosition(this.startX, Global.earthPositon);
        this.setScaleX(-1);
        this.setScaleY(1);
        this.gotoAndPlay("walk");
        if (Global.bing) this.onGo(!0);
        else this.onGo(!1)
    },
    onGo: function (a) {
        this.stopAllActions();
        var b;
        a ? (this.setFPS(this.thisFPS /
            2), a = (cc.visibleRect.width - this.x) / Global.BingMove, b = 0.5) : (this.setFPS(this.thisFPS), a = (cc.visibleRect.width - this.x) / this.speed, b = 1);
        a = cc.MoveTo.create(a, cc.p(cc.visibleRect.width - 100 - 40 * Math.random(), Global.earthPositon));
        var c = cc.CallFunc.create(function () {
            if ("BombZombie" == this.assetID) {
                this.attack();
                this.dead = !0;
                this._explode();
                var a = Global.zombies.indexOf(this); - 1 < a && Global.zombies.splice(a, 1);
                this.destroy()
            } else this.dead || Global.gamePause || Global.gameOver || (this.inAttacking = !0, this.gotoAndPlay("attack"),
                this.schedule(this.attack, b, cc.REPEAT_FOREVER))
        }, this);
        this.walkAction = cc.Sequence.create(a, c);
        this.runAction(this.walkAction)
    },
    onRecycle: function () {
        this._super();
        Global.onZombieDead.dispatch(this)
    },
    attack: function () {
        Global.ShieldBool || this.dead || Global.ZombiePause || (Global.health -= this.damage)
    },
    hit: function (a) {
        a && this._explode(a);
        try {
            if (this.dead) return !0;
            var b = a.damage;
            0 < b && (this.health -= b, this.bomber || this._playDamageTxt("-" + b), 0 >= this.health && (this.health = 0, this.dead = !0, this.scheduleOnce(function () {
                this._playDeathAnim();
                this.destroy();
                var a = Global.zombies.indexOf(this); - 1 < a && Global.zombies.splice(a, 1);
                Global.score += this.coins
            }, 0.3)))
        } catch (c) {
            alert(c, "aaa")
        }
        return this.dead
    },
    _playDamageTxt: function (a) {
        try {
            var b = lg.assetsManager.createDisplay(res.effect_plist, "DamageAnim", null, !0, this, {
                zIndex: 100
            });
            b.autoDestroyWhenOver = !0;
            b.setPosition(cc.pAdd(this.getPosition(), cc.p(0, 50)));
            b.gotoAndPlay(0);
            b.setLabelText("txt", a, !0)
        } catch (c) {
            alert(c, "ccc")
        }
    },
    _playDeathAnim: function () {
        try {
            var a = lg.assetsManager.createDisplay(res.zombies_plist,
                "deathAnim01", null, !0, this._parent, {
                    zIndex: this.zIndex + 1,
                    autoPlayChildren: !0
                });
            a.setScaleX(this.getScaleX());
            a.setScaleY(this.getScaleY());
            a.setPosition(cc.pAdd(this.getPosition(), cc.p(0, 0)));
            a.setFPS(50);
            a.play();
            a.autoDestroyWhenOver = !0
        } catch (b) {
            alert(b, "bbb")
        }
    },
    _explode: function (a) {
        try {
            if (null == a || 15 != a.type) {
                lg.playSound(music.explosion);
                var b = lg.assetsManager.createDisplay(res.effect_plist, "explode1", null, !0, this._parent, {
                    zIndex: 1E3
                });
                b.setScale(this.getScaleY());
                a ? (b.setPosition(a.getPosition()),
                    a.destroy()) : b.setPosition(cc.pAdd(this.getPosition(), cc.p(0, 30)));
                b.play();
                b.autoDestroyWhenOver = !0
            }
        } catch (c) {
            alert(c, "aacaafsd")
        }
    }
});
Zombie.create = function (a, b) {
    var c = new Zombie(a, b);
    c.clsName = "Zombie";
    return c
};
var ZombieWave = cc.Node.extend({
    stopping: !0,
    typeArr: null,
    newLevel: 1,
    sumZombie: 0,
    fun: null,
    init: function (a, b) {
        this._super();
        var c, d;
        this.typeArr = [];
        this.fun = a;
        var e;
        e = null == b ? Global.zLevels : Global.zLevels.slice(b - 1, b);
        for (var f, g, h, k = 0; k < e.length; k++) {
            c = e[k];
            for (var m = 0; m < c.length; m++)
                for (d = Global.zWaves[c[m] - 1], f = d.count; 1 <= f;) g = d.interval.split(","), g = lg.randInt(parseInt(g[0]), parseInt(g[1])), 1 == d.count && (g += d.waveInterval), h = d.type.split(","), h = parseInt(lg.getRandomInArray(h)) - 1, this.typeArr.push({
                    type: Global.zEnemies[h],
                    date: g
                }), f--
        }
        this.sumZombie = this.typeArr.length
    },
    start: function () {
        this.stopping && (this.stopping = !1, this.nextZombie())
    },
    stop: function () {
        this.stopping || (this.stopping = !0)
    },
    nextZombie: function () {
        if (Global.gameOver || Global.gamePause) this.scheduleOnce(function () {
            this.nextZombie()
        }, 2);
        else if (!(this.stopping || 0 >= this.typeArr.length)) {
            var a = this.typeArr.shift();
            null != this.fun && this.fun(a.type);
            this.scheduleOnce(function () {
                this.nextZombie()
            }, a.date)
        }
    },
    addZ: function (a) {}
});
ZombieWave.create = function (a, b) {
    var c = new ZombieWave;
    c.init(a, b);
    return c
};
var NewBombs = cc.Node.extend({
    init: function (a) {
        this.nextLevel(a)
    },
    nextLevel: function (a, b) {
        try {
            for (var c = LEVELS[a - 1], d = c[0], e = c[1], f = c[3], g = c[4], h = [], k = 4 - Math.round(d / 2), m = 4 - Math.round(e / 2), n = k; n <= k + d - 1; n++)
                for (var p = m; p <= m + e - 1; p++) h.push([n, p]);
            h.shuffle();
            for (var r = h.slice(0, c[2]), q = c[2] / 2, d = [], s, t, e = e = 0; e < c[2] / 2; e++) t = Math.round(Math.random() * q), s = null != b && 0 < b.length && 1 >= t ? b.shift() : Math.round(f + Math.random() * (g - f)), d.push(s), d.push(s);
            d.shuffle();
            for (var x = [], e = 0; e < c[2]; e++) x.push([d[e], r[e]])
        } catch (y) {
            alert(y,
                fuck)
        }
        return x
    }
});
NewBombs.create = function (a) {
    var b = new NewBombs;
    b.init(a);
    return b
};
var SelectLevel = lg.MovieClip.extend({
    onEnter: function () {
        this._super();
        lg.inputManager.addListener(this.backssss, function (a, b) {
            lg.replaceScene("mainMenu")
        });
        for (var a = 1, b; 24 >= a;) b = this.getChildByName("a" + a), a <= Global.level2 ? (lg.inputManager.addListener(b, function (a, b) {
            Global.level = parseInt(this.name.substring(1, this.name.length));
            lg.replaceScene("mainShop")
        }), b.setState(ButtonState.UP)) : b.setState(ButtonState.SELECTED), a++
    }
});
SelectLevel.create = function (a, b) {
    return new SelectLevel(a, b)
};
SelectLevel.scene = function () {
    var a = cc.Scene.create(),
        b = SelectLevel.create(res.ui2_plist, "SelectLevel");
    a.addChild(b);
    return a
};
var ShopWin = lg.MovieClip.extend({
    buy: null,
    listbg: null,
    BuyMove: !1,
    bar: null,
    onEnter: function () {
        this._super();
        this.buy = lg.MovieClip.create(res.ui_plist, "buyPandel");
        this.buy.y = -190;
        lg.inputManager.addListener(this.buy, this.onBuyBGDown, InputType.press);
        this.bar = lg.MovieClip.create(res.ui_plist, "ShopBar");
        this.bar.y = 680;
        this.bar.x = 610;
        this.addChild(this.bar, 100);
        var a = this.bar,
            b = this.buy;
        lg.inputManager.addListener(this.buy, function (b, c) {
            if (BuyMove) {
                var d = this.y += b.getDelta().y;
                this.y = 10 < d ? 10 : -190 > d ? -190 :
                    d;
                a.y = this.y * -((this.height - 190) / (660 - a.height)) + 630 - a.height
            }
        }, InputType.move);
        lg.inputManager.addListener(this.buy, this.onBuyBGUp, InputType.up);
        this.addChild(this.buy, 1);
        lg.inputManager.addListener(this.bar, this.onBuyBGDown, InputType.press);
        lg.inputManager.addListener(this.bar, this.onBuyBGUp, InputType.up);
        lg.inputManager.addListener(this.bar, function (a, c) {
            if (BuyMove) {
                var d = this.y += a.getDelta().y;
                this.y = 670 < d ? 670 : 325 > d ? 325 : d;
                b.y = this.y * -((660 - this.height) / (b.height - 170)) + b.height - 660
            }
        }, InputType.move);
        var c = 1,
            d = Global.PropsLevel[Global.level - 1],
            e = [];
        Global.data = [];
        for (var f = this.buy, g = this; 6 >= c;) {
            var h = d[c - 1];
            this.buy.setLabelText("scoreTxt" + c, h[0]);
            this.buy.getChildByName("buy" + c);
            e.push(h[1]);
            this.buy.setLabelText("scoreTxtg" + c, 0);
            lg.inputManager.addListener(this.buy.getChildByName("buy" + c), function (a, b) {
                var c = this.name.substr(3, 1),
                    d = f.getLabelText("scoreTxt" + c),
                    h = parseInt(f.getLabelText("scoreTxtg" + c));
                if (Global.score >= 1 * d) e[c - 1] -= 1, Global.score -= 1 * d, f.setLabelText("scoreTxtg" + c, 1 + h), d = lg.assetsManager.createDisplay(res.effect_plist,
                    "LinkEffect", null, !0), f.addChild(d, 1E3), d.autoDestroyWhenOver = !0, d.setPosition(f["scoreTxtg" + c].getPosition()), d.x += 10, d.y -= 10, d.play(), k.setLabelText("scoreTxt", Global.score), Global.data.push(parseInt(this.name.substr(3, 1)) + 11);
                else g.onPlayeffects("win1")
            });
            c++
        }
        this.listbg = lg.assetsManager.createDisplay(res.ui3_plist, "Listbg", null, !0);
        this.listbg.y -= 5;
        var k = this.listbg;
        lg.inputManager.addListener(this.listbg.back, function (a, b) {
            SG_Hooks.start();
            lg.replaceScene("mainGame")
        });
        this.listbg.setLabelText("scoreTxt",
            Global.score);
        this.addChild(this.listbg, 2)
    },
    onPlayeffects: function (a) {
        a = lg.assetsManager.createDisplay(res.effect_plist, a, null, !0);
        this.addChild(a, 1E3);
        a.setFPS(10);
        a.autoDestroyWhenOver = !0;
        a.setPosition(cc.p(cc.visibleRect.width / 2, cc.visibleRect.height / 2));
        a.play()
    },
    onBuyBGDown: function (a, b) {
        BuyMove = !0
    },
    onBuyBGUp: function (a, b) {
        BuyMove = !1
    }
});
ShopWin.create = function (a, b) {
    return new ShopWin(a, b)
};
ShopWin.scene = function () {
    var a = cc.Scene.create(),
        b = ShopWin.create(res.ui3_plist, "ShopWin");
    b.x = -5;
    a.addChild(b, 1);
    a.addChild(ControlBar.create(), 2);
    return a
};
LINK_COLOR = cc.color(255, 255, 255, 200);
var Game = cc.Layer.extend({
    onLevelInit: null,
    ui: null,
    _house: null,
    _healthBar: null,
    _bombs: null,
    _bomb0: null,
    _bomb1: null,
    _tileMap: null,
    _clickRect: null,
    _maxBombs: 0,
    _totalBombs: 0,
    _bombsLeft: 0,
    _pathCanvas: null,
    _mapCenter: null,
    _lastClickTime: -1,
    _faultTimes: 0,
    _needCheckDead: !1,
    _hint0: null,
    _hint1: null,
    _showingHint: !1,
    _textAnim: null,
    _basket: null,
    _allBombTypes: null,
    _fruitsPool: null,
    _zombieWave: null,
    _newBombs: null,
    _dian: null,
    onEnter: function () {
        this._super();
        this._zombieWave = ZombieWave.create(this.addZombies, Global.level);
        this.addChild(this._zombieWave);
        this._newBombs = NewBombs.create(Global.level);
        lg.inputManager.addListener(this, this.handleSimpleTouch);
        this._tileMap = lg.getTileMap("bombs");
        LinkFinder.map = this._tileMap;
        this._maxBombs = this._tileMap._mapWidth * this._tileMap._mapHeight;
        if (this.ui) {
            var a = lg.Animator.create(res.effect_plist, "hahahaha");
            this.addChild(a);
            a.setPosition(513, 918);
            a.play();
            this._house = this.ui.getChildByName("house");
            this._healthBar = this.ui.getChildByName("healthBar");
            a = this.ui.getChildByName("plat");
            a.removeFromParent(!1);
            this.addChild(a, 4);
            this.ui.setLabelText("scoreTxt", Global.score + "")
        }
        this._pathCanvas = cc.DrawNode.create();
        this.addChild(this._pathCanvas, 99);
        this._mapCenter = cc.p(Math.floor(this._tileMap._mapWidth / 2), Math.floor(this._tileMap._mapHeight / 2));
        Global.zombies = [];
        this._bombs = [null, null, null, null, null, null, null, null, null, null];
        Global.gameOver = !1;
        Global.ShieldBool = !1;
        Global.ZombiePause = !1;
        Global.bing = !1;
        this.resetGame(!0);
        this._zombieWave.start();
        Global.health = Global.maxHealth;
        Global.onZombieDead =
            new signals.Signal;
        Global.onZombieDead.add(this._removeZombie, this);
        this.schedule(function () {
            this.ui.healthBar2.setScaleX(this._zombieWave.typeArr.length / this._zombieWave.sumZombie);
            this.ui.g.x = this._zombieWave.typeArr.length / this._zombieWave.sumZombie * this.ui.healthBar2.width + 190
        }, 1);
        this.scheduleUpdate()
    },
    onExit: function () {
        this._super();
        Global.onZombieDead.remove(this._removeZombie, this)
    },
    update: function (a) {
        if (!Global.gamePause && !Global.gameOver) try {
            this.ui.setLabelText("scoreTxt", Global.score);
            var b = this._findTargetZombie();
            if (null == b && 0 == this._zombieWave.typeArr.length) this.stopAllActions(), Global.gameOver || this.ShowNextWin();
            else {
                if (Global.zombies.length) {
                    var b = null,
                        c;
                    a = -1;
                    for (var d = 0, e; ++a < Global.zombies.length;) b = Global.zombies[a], c = b.getPosition(), d = Math.floor((c.x - Global.bombSlotGap) / Global.bombSlotGap), d < this._bombs.length && (e = this._bombs[d]) && e.__ready__to__kill && cc.pDistance(c, e.getPosition()) < Global.bombCollidSize && (this._doKill(e, b), this._bombs[a] = null)
                }
                0 >= Global.health && (Global.health =
                    0, this._gameOver(!0));
                this._healthBar.setScaleX(Global.health / Global.maxHealth)
            }
        } catch (f) {
            alert(f, "\u554a\u554a\u554a")
        }
    },
    resetGame: function (a) {
        try {
            this._tileMap.clear(!0);
            this._hint0 = this._hint1 = null;
            Global.level > LEVELS.length && (Global.level = LEVELS.length);
            this._needCheckDead = !0;
            if (this.onLevelInit) this.onLevelInit();
            var b = LEVELS[Global.level - 1],
                c = Math.min(this._tileMap._mapWidth - 2, b[0]),
                d = Math.min(this._tileMap._mapHeight - 2, b[1]);
            this._bombsLeft = this._totalBombs = Math.min(c * d, b[2]);
            var e = this._bombsLeft *
                FRUIT_COME_IN_TIME + 0.1;
            this._bomb0 = this._bomb1 = null;
            var f = Global.data;
            f.shuffle();
            var g = null != f ? this._newBombs.nextLevel(Global.level, f) : this._newBombs.nextLevel(Global.level);
            this.schedule(function () {
                var a = g.shift();
                null == a && alert("1\u7a7a");
                this.addBomb(BOMBS[a[0]], a[1][0], a[1][1])
            }, FRUIT_COME_IN_TIME, this._totalBombs - 1);
            this.scheduleOnce(function () {
                this._ShowTip()
            }, e)
        } catch (h) {
            alert(h, "\x3d,\x3d")
        }
    },
    addZombies: function (a) {
        null == a && alert("2\u7a7a");
        if (!Global.gameOver && !Global.gamePause) try {
            var b =
                lg.assetsManager.createDisplay(res.zombies_plist, a.assetID, "Zombie", !0, this, {
                    zIndex: 10,
                    startX: 0,
                    thisFPS: a.walkFPS,
                    bomber: "BombZombie" == a.assetID ? !0 : !1,
                    prop: a,
                    coins: a.coins,
                    health: a.maxHealth,
                    damage: a.damage,
                    speed: a.speed,
                    zIndex: 10,
                    startX: 0
                });
            b.setFPS(a.walkFPS);
            b.setScaleX(-0.7);
            b.setScaleY(0.7);
            b.y = Global.earthPositon;
            Global.zombies.push(b)
        } catch (c) {
            alert(c, "fu")
        }
    },
    addBomb: function (a, b, c) {
        try {
            var d = lg.assetsManager.createDisplay(res.bombs_plist, a, null, !0, this, {
                zIndex: 100
            });
            d.setFPS(24);
            d.gotoAndStop("static");
            this._tileMap.snapToTile(d, b, c, !0);
            d.setScale(0.9)
        } catch (e) {
            alert(e)
        }
    },
    ShowNextWin: function () {
        try {
            Global.gameOver = !0;
            this._freezeZombies();
            this.stopAllActions();
            this._hideHint();
            var a = lg.assetsManager.createDisplay(res.effect_plist, "LevelConmplete", null, !0);
            this.addChild(a, 1E3);
            a.setPosition(cc.p(cc.visibleRect.width + 180, cc.visibleRect.height / 2));
            a.autoStopWhenOver = !0;
            a.play();
            this.scheduleOnce(function () {
                var a = lg.assetsManager.createDisplay(res.ui2_plist, "WinPanel", null, !0);
                this.addChild(a, 1E4);
                a.setLabelText("scoreTxt", Global.score + "");
                lg.inputManager.addListener(a.moressa, function () {
                    //window.open("http://m.softgames.de")
                    SG.redirectToPortal();
                });
                Global.level2 = Global.level + 1;
                cc.sys.localStorage.setItem(LevelKey, Global.level2);
                cc.sys.localStorage.setItem(ScoreKey, Global.score);
                SG_Hooks.levelUp(Global.level, Global.score);
                24 > Global.level ? (lg.inputManager.addListener(a.replayBtn, function () {
                        lg.replaceScene("mainGame")
                    }), lg.inputManager.addListener(a.nextBtn, function () {
                        Global.level += 1;
                        lg.replaceScene("mainShop")
                    })) :
                    (lg.inputManager.addListener(a.replayBtn, function () {
                        lg.replaceScene("mainGame")
                    }), a.nextBtn.visible = !1)
            }, 1.5)
        } catch (b) {
            alert(b, 274)
        }
    },
    boss: null,
    handleSimpleTouch: function (a, b) {
        if (Global.gameOver || Global.gamePause) return !0;
        try {
            var c = a.getLocation(),
                d = this._tileMap.getObjects1(c.x, c.y);
            if (0 == d.length) return !1;
            this._lastClickTime = Date.now();
            var e = d[0];
            e != this._hint0 && e != this._hint1 || this._hideHint();
            null == this._bomb0 ? (this._bomb0 = e, this._showSelectedEffect()) : this._bomb0 != e && (this._bomb1 = e, c = null, this._bomb0.assetID ==
                this._bomb1.assetID && (c = LinkFinder.findLink(this._bomb0.tx, this._bomb0.ty, this._bomb1.tx, this._bomb1.ty), null != c && (this._showLinkedPath(c), this._showBombAnim(), this._bombsLeft -= 2, 0 == this._bombsLeft && this._gameOver(!1), this._needCheckDead = !0, this._faultTimes = 0, this._hideHint(), this.checkDeadMap(), this._ShowTip())), null == c ? (this._clickRect.setPosition(this._bomb1.getPosition()), this._bomb0 = this._bomb1, ++this._faultTimes >= MAX_FAULT_TIMES && (this._faultTimes = 0, this._showHint())) : (this._clickRect.setVisible(!1),
                    this._bomb0 = null), this._bomb1 = null)
        } catch (f) {
            alert(f, 335)
        }
        return !0
    },
    _ShowTip: function () {
        this.checkDeadMap();
        try {
            2 >= KOOOO && null != this._hint0 && null != this._hint1 ? (null != this._dian && this.removeChild(this._dian), this._dian = lg.assetsManager.createDisplay(res.effect_plist, "dian", null, !0), this.addChild(this._dian, 999990), this._dian.setPosition(this._hint0.getPosition()), this._dian.play(), this._dian.runAction(cc.RepeatForever.create(cc.Sequence.create(cc.MoveTo.create(1, this._hint1.getPosition()), cc.MoveTo.create(1,
                this._hint0.getPosition())))), KOOOO++) : (this.removeChild(this._dian), cc.sys.localStorage.setItem("KO", KOOOO))
        } catch (a) {
            alert(a)
        }
    },
    addZombie0: function () {
        if (!(Global.gameOver || Global.gamePause || Global.ZombiePause)) {
            var a = lg.assetsManager.createDisplay(res.zombies_plist, "Zombie0", "Zombie", !0, this, {
                zIndex: 10,
                startX: 0,
                bomber: !1,
                prop: ZOMBIES0[Global.level - 1]
            });
            Global.zombies.push(a);
            return a
        }
    },
    addZombie1: function () {
        if (Global.gameOver || Global.gamePause || Global.ZombiePause) return null;
        try {
            var a = Global.zEnemies[0],
                b = lg.assetsManager.createDisplay(res.zombies_plist, a.assetID, "Zombie", !1, this, {
                    zIndex: 10,
                    startX: 0,
                    thisFPS: a.walkFPS,
                    bomber: !0,
                    prop: a,
                    coins: a.coins,
                    health: a.maxHealth,
                    damage: a.damage,
                    speed: a.speed,
                    zIndex: 10,
                    startX: 0
                });
            b.setScaleX(-0.7);
            b.setScaleY(0.7);
            Global.zombies.push(b)
        } catch (c) {
            alert(c, 379)
        }
        return b
    },
    checkDeadMap: function () {
        var a = LinkFinder.findAvailableLink(!1);
        a && (this._hint0 = a[0], this._hint1 = a[1])
    },
    _showHint: function () {
        if (!this._showingHint && this._hint0 && this._hint1) {
            this._showingHint = !0;
            var a = cc.RepeatForever.create(cc.Sequence.create(cc.FadeOut.create(0.2), cc.FadeIn.create(0.3)));
            this._hint0.runAction(a);
            a = cc.RepeatForever.create(cc.Sequence.create(cc.FadeOut.create(0.2), cc.FadeIn.create(0.3)));
            this._hint1.runAction(a)
        }
    },
    _hideHint: function () {
        this._showingHint && (this._showingHint = !1, this._hint0 && (this._hint0.setOpacity(255), this._hint0.stopAllActions()), this._hint1 && (this._hint1.setOpacity(255), this._hint1.stopAllActions()), this._hint1 = this._hint0 = null)
    },
    _gameOver: function (a) {
        if (!Global.gameOver) {
            Global.gameOver =
                a;
            this._hideHint();
            this.stopAllActions();
            this._clickRect && this._clickRect.setVisible(!1);
            var b = this;
            a ? (a = lg.assetsManager.createDisplay(res.ui2_plist, "ResultPanel", null, !0), this.addChild(a, 1E4), cc.sys.localStorage.setItem(ScoreKey, Global.score), a.setLabelText("scoreTxt", Global.score + ""), SG_Hooks.gameOver(Global.level, Global.score), lg.inputManager.addListener(a.getChildByName("Menu"), function () {
                    lg.replaceScene("mainMenu")
                }), lg.inputManager.addListener(a.replayBtn, function () {
                    lg.replaceScene("mainShop")
                }),
                lg.inputManager.addListener(a.moreBtn, function () {
                  //  window.open("http://m.softgames.de")
                }), this._freezeZombies()) : this.scheduleOnce(function () {
                b.resetGame(!1)
            }, 0.5)
        }
    },
    _showTextAnim: function (a) {
        null == this._textAnim && (this._textAnim = lg.assetsManager.createDisplay(res.effect_plist, "TextAnim", null, !0), this.addChild(this._textAnim, 3E4), this._textAnim.setPosition(cc.visibleRect.center), this._textAnim.setFPS(24), this._textAnim.autoStopWhenOver = !0);
        this._textAnim.gotoAndPlay(1);
        this._textAnim.replaceChild("text",
            a);
        "ReadyText" == a ? lg.playSound(music.ready) : "GameOverText" == a && lg.playSound(music.gameover)
    },
    _showSparkleEffect: function (a, b) {
        this.scheduleOnce(function () {
            var b = lg.assetsManager.createDisplay(res.effect_plist, "LinkEffect", null, !0);
            this.addChild(b, 1E3);
            b.setFPS(40);
            b.autoDestroyWhenOver = !0;
            b.setPosition(a);
            b.play()
        }, b)
    },
    _showSelectedEffect: function () {
        if (null == this._clickRect) {
            this._clickRect = lg.assetsManager.createDisplay(res.effect_plist, "ClickRect", null, !0);
            this.addChild(this._clickRect, 1E3);
            var a =
                cc.ScaleTo.create(0.3, 2.2, 2.2),
                b = cc.ScaleTo.create(0.3, 2, 2);
            this._clickRect.runAction(cc.RepeatForever.create(cc.Sequence.create(a, b)))
        }
        this._clickRect.setVisible(!0);
        this._clickRect.setPosition(this._bomb0.getPosition())
    },
    _showLinkedPath: function (a) {
        var b = cc.Sprite.create();
        this.addChild(b);
        for (var c, d, b = 1; b <= a.length - 1; b++) c = a[b - 1], d = a[b], c = cc.p(this._tileMap.getTiledPositionX(c.x), this._tileMap.getTiledPositionY(c.y)), d = cc.p(this._tileMap.getTiledPositionX(d.x), this._tileMap.getTiledPositionY(d.y)),
            this._linksss(c, d)
    },
    _linksss: function (a, b) {
        var c, d;
        if (a.x == b.x)
            if (c = a.y - b.y, d = parseInt(Math.abs(c) / 90), 0 > c)
                for (var e = 0; e < d; e++) c = lg.assetsManager.createDisplay(res.effect_plist, "links", null, !0), c.rotation = 180, c.autoDestroyWhenOver = !0, c.setFPS(30), c.setPosition(cc.p(a.x, a.y + 95 * e)), c.play(), this.addChild(c);
            else
                for (e = 0; e < d; e++) c = lg.assetsManager.createDisplay(res.effect_plist, "links", null, !0), c.autoDestroyWhenOver = !0, c.setFPS(30), c.setPosition(cc.p(a.x, a.y - 95 * e)), c.play(), this.addChild(c);
        else if (c =
            a.x - b.x, d = parseInt(Math.abs(c) / 90), 0 < c)
            for (e = 0; e < d; e++) c = lg.assetsManager.createDisplay(res.effect_plist, "links", null, !0), c.rotation = 90, c.autoDestroyWhenOver = !0, c.setFPS(30), c.setPosition(cc.p(a.x - 95 * e, a.y)), c.play(), this.addChild(c);
        else
            for (e = 0; e < d; e++) c = lg.assetsManager.createDisplay(res.effect_plist, "links", null, !0), c.rotation = 270, c.autoDestroyWhenOver = !0, c.setFPS(30), c.setPosition(cc.p(a.x + 95 * e, a.y)), c.play(), this.addChild(c)
    },
    _showBombAnim: function () {
        if (!Global.gameOver) try {
            this._bomb0.setTileMap(null);
            this._bomb0.zIndex = 1001;
            this._bomb1.setTileMap(null);
            this._bomb1.zindex = 1001;
            var a = new cc.Point((this._bomb0.getPositionX() + this._bomb1.getPositionX()) / 2, (this._bomb0.getPositionY() + this._bomb1.getPositionY()) / 2),
                b = this._bomb0,
                c = this._bomb1;
            this._showSparkleEffect(a, 0);
            var d = lg.assetsManager.createDisplay(res.bombs_plist, b.assetID + "_", null, !0, this, {
                zIndex: 900,
                __ready__to__kill: !1
            });
            lg.copyProperties(Global.zBomb[b.assetID], d);
            d.prop = Global.zBomb[b.assetID];
            d.gotoAndStop(0);
            d.setPosition(a);
            this._collectBomb(d);
            b.destroy();
            c.destroy()
        } catch (e) {
            alert(e, "629")
        }
    },
    _collectBomb: function (a) {
        try {
            var b = this._findTargetZombie(),
                c = null;
            if (4 == a.type || 5 == a.type || 14 == a.type || null == b) {
                for (var d = -1, e = null, f; ++d < this._bombs.length;)
                    if (f = (d + 1) * Global.bombSlotGap, null == this._bombs[d]) {
                        if (null == b || b.getPositionX() + 0.6 * b.speed < f - Global.bombCollidSize) {
                            c = cc.p(f, Global.earthPositon);
                            this._bombs[d] = a;
                            break
                        }
                        null == e && (e = d)
                    }
                null == c && null != e && (c = cc.p((e + 1) * Global.bombSlotGap, Global.earthPositon), this._bombs[e] = a);
                b = null == c ? this.addZombie1(!0) :
                    null
            } else 12 == a.type ? c = cc.p(cc.visibleRect.width / 2 - 30, b.getPositionY()) : 13 == a.type ? c = cc.p(cc.visibleRect.width / 2 - 30, b.getPositionY() + 20) : 15 == a.type ? c = cc.p(cc.visibleRect.width / 2, b.getPositionY() + 20) : 16 == a.type ? c = cc.p(cc.visibleRect.width, b.getPositionY()) : 17 == a.type && (c = cc.p(cc.visibleRect.width - 100, b.getPositionY() + 100));
            b && (c = cc.pAdd(b.getPosition(), cc.p(0.6 * b.speed - 20, 100 * b.getScaleY())), b.__in__kill = !0);
            null == c ? a && a.destroy() : (a.setScale(0.6), a.runAction(cc.MoveTo.create(0.6, c)), this.scheduleOnce(function () {
                a.__ready__to__kill = !0;
                b ? this._doKill(a, b, c) : a.zIndex = 3
            }, 0.6))
        } catch (g) {
            alert(g, "751")
        }
    },
    _doKill: function (a, b, c) {
        try {
            if (b.__in__kill = !1, 14 == a.type) a.setFPS(50), a.gotoAndPlay(0), a.autoDestroyWhenOver = !0, this.scheduleOnce(function () {
                b.zIndex = 1E3;
                var a = cc.RotateBy.create(1, 1080),
                    c = cc.MoveTo.create(0.5, cc.p(b.getPositionX() + 50, b.getPositionY() + 100)),
                    d = cc.MoveTo.create(0.5, cc.p(b.getPositionX() + 250, b.getPositionY() + 300)),
                    e = cc.CallFunc.create(b.destroy, b);
                b.runAction(cc.Sequence.create(cc.Spawn.create(a, c, d), e))
            }, 0.2), this._removeZombie(b);
            else if (12 == a.type) {
                Global.bing = !0;
                for (var d = Global.zombies.length; d--;) Global.zombies[d].play(), Global.zombies[d].onGo(!0);
                Global.ZombiePause = !1;
                this.scheduleOnce(function () {
                    if (Global.bing && !Global.gameOver && !Global.ZombiePause) {
                        for (var a = Global.zombies.length; a--;) Global.zombies[a].onGo(!1), Global.zombies[a].play();
                        Global.bing = !1
                    }
                }, Global.BingDate);
                this._playBoEffect("Bomb12flash", c);
                a && a.destroy()
            } else if (13 == a.type) Global.ZombiePause = !0, this._freezeZombies(), Global.bing = !1, this.scheduleOnce(function () {
                if (Global.ZombiePause &&
                    !Global.gameOver && !Global.bing) {
                    for (var a = Global.zombies.length; a--;) Global.zombies[a].onGo(!1), Global.zombies[a].play();
                    Global.ZombiePause = !1
                }
            }, Global.PauseDate), this._playBoEffect("Bomb13flash", c), a && a.destroy();
            else if (15 == a.type) {
                for (d = Global.zombies.length; d--;) Global.zombies[d].hit(a);
                this._playBoEffect("Bomb15flash", c);
                a && a.destroy()
            } else if (16 == a.type) Global.ShieldBool = !0, this.scheduleOnce(function () {
                Global.ShieldBool = !1
            }, Global.Shield), this._playBoEffect("Bomb16flash", c), a && a.destroy();
            else if (17 ==
                a.type) {
                Global.health = Global.health + Global.Blood > Global.maxHealth ? Global.maxHealth : Global.health + Global.Blood;
                var e = lg.assetsManager.createDisplay(res.effect_plist, "Bomb17flash", null, !0, this, {
                    zIndex: 100
                });
                e.autoDestroyWhenOver = !0;
                e.setPosition(c);
                e.gotoAndPlay(0);
                e.txtMc.setLabelText("txt", Global.Blood, !0);
                a && a.destroy()
            } else b.hit(a)
        } catch (f) {
            alert(f, 819)
        }
    },
    _playBoEffect: function (a, b) {
        var c = lg.assetsManager.createDisplay(res.effect_plist, a, null, !0);
        this.addChild(c, 1E3);
        c.setFPS(40);
        c.autoDestroyWhenOver = !0;
        c.setPosition(b);
        c.play()
    },
    _removeZombie: function (a) {
        a = Global.zombies.indexOf(a); - 1 < a && Global.zombies.splice(a, 1)
    },
    _findTargetZombie: function () {
        if (0 == Global.zombies.length) return null;
        for (var a = null, b, c = Global.zombies.length; c--;)
            if (b = Global.zombies[c], null == a || b.getPositionX() > a.getPositionX()) a = b;
        return a
    },
    _freezeZombies: function () {
        for (var a = Global.zombies.length; a--;) Global.zombies[a].stopAllActions(), Global.zombies[a].stop()
    }
});
Game.create = function (a) {
    var b = new Game;
    b.ui = a;
    return b && b.init() ? b : null
};
Game.scene = function () {
    var a = cc.Scene.create(),
        b = lg.MovieClip.create(res.ui2_plist, "BattlePanel");
    a.addChild(b);
    b = Game.create(b);
    a.addChild(b);
    a.game = b;
    a.addChild(ControlBar.create(), 3);
    lg.assetsManager.addPlist(res.zombies_plist);
    lg.assetsManager.addPlist(res.bombs_plist);
    lg.assetsManager.addPlist(res.effect_plist);
    return a
};
var AppVersion = 5.8,
    compress = !1,
    a10Enabled = !1,
    a10Remote = !1,
    whiteBackground = !1,
    backgroundColor = whiteBackground ? [255, 255, 255] : [0, 0, 0],
    logoSrc = a10Enabled ? "res/a10/a10_logo_3.png" : "res/logo1.png",
    logoW = 289,
    logoH = a10Enabled ? 90 : 77,
    logoOnCenter = !1,
    myLanguage = "en de es ru fr it tr pt".split(" ");
if (a10Enabled) try {
    GameAPI.loadAPI(function (a) {
        console.log("A10 api loaded!")
    })
} catch (err$$18) {
    console.log(err$$18)
}
//window.attachEvent ? window.attachEvent("onload", initSoftgames) : window.addEventListener("load", initSoftgames, !0);
var sgLanguage = null;

function initSoftgames() {
    cc.log("init softgames api!");
    sgLanguage = SG.lang; //SG_Hooks.getLanguage(myLanguage);
    cc.game.run()
}
cc.game.onStart = function () {
    SG_Hooks.setOrientationHandler(lg._checkDeviceOrientation);
    SG_Hooks.setResizeHandler(lg._checkDeviceOrientation);
    lg.language = sgLanguage;
    for (var a = 0; a < myLanguage.length;) myLanguage[a] == lg.language && (lg.languageIndex = a), a++;
    cc.log(myLanguage.join(""), lg.language, lg.languageIndex);
    res = {
        bombs_plist: "res/en/bombs1.json",
        bombs_png: "res/en/bombs1.png",
        effect_plist: "res/en/effect.json",
        effect_png: "res/en/effect.png",
        zombies_plist: "res/en/zombies.json",
        zombies_png: "res/en/zombies.png",
        ui_plist: "res/en/ui1.json",
        ui_png: "res/en/ui1.png",
        ui2_plist: "res/en/ui2.json",
        ui2_png: "res/en/ui2.png",
        ui3_plist: "res/en/ui3.json",
        ui3_png: "res/en/ui3.png",
        logo: "res/logo1.png"
    };
    var b = [res.ui_plist, res.ui_png, res.ui2_plist, res.ui2_png, res.ui3_plist, res.ui3_png],
        c = [res.bombs_plist, res.bombs_png, res.effect_plist, res.effect_png, res.zombies_plist, res.zombies_png],
        a = b.concat(c),
        d = document.getElementById("gameCanvas");
    cc.view.setDesignResolutionSize(d.width, d.height, cc.ResolutionPolicy.SHOW_ALL);
    cc.view.resizeWithBrowserSize(!0);
    lg.registerScene("mainMenu", MainMenu.scene, b);
    lg.registerScene("mainGame", Game.scene, c);
    lg.registerScene("mainLevel", SelectLevel.scene, b);
    lg.registerScene("mainShop", ShopWin.scene, b);
    Global.score = null == cc.sys.localStorage.getItem(ScoreKey) ? 0 : parseInt(cc.sys.localStorage.getItem(ScoreKey));
    Global.level2 = null == cc.sys.localStorage.getItem(LevelKey) ? 1 : parseInt(cc.sys.localStorage.getItem(LevelKey));
    KOOOO = null == cc.sys.localStorage.getItem("KO") ? 0 : parseInt(cc.sys.localStorage.getItem("KO"));
    b = lg.TileMap.create("bombs");
    b.setTileSize(98, 98);
    b.setMapSize(8, 8);
    b.offsetX = -72;
    b.offsetY = -92;
    lg.registerTileMap(b);
    startWithScene("mainMenu", a)
};

function startWithScene(a, b) {
    lg.init();
    lg.preload(b, function () {
        var b = !1;
        if (a10Enabled)
            if (a10Remote) {
                var d = GameAPI.Branding.getSplashScreen();
                d.show && (showSplash(d.action, a), b = !0)
            } else showSplash(goMoreGame, a), b = !0;
        b || lg.replaceScene(a)
    })
};