! function(f, e) {
	"function" === typeof define && define.amd ? define(e) : "object" === typeof exports ? module.exports = e() : f.Phaser = e()
}(this, function() {
	function f(a) {
		return [(a >> 16 & 255) / 255, (a >> 8 & 255) / 255, (a & 255) / 255]
	}

	function f(a) {
		return [(a >> 16 & 255) / 255, (a >> 8 & 255) / 255, (a & 255) / 255]
	}
	var e = e || {},
		c = c || {
			VERSION: "1.1.3",
			DEV_VERSION: "1.1.3",
			GAMES: [],
			AUTO: 0,
			CANVAS: 1,
			WEBGL: 2,
			HEADLESS: 3,
			SPRITE: 0,
			BUTTON: 1,
			BULLET: 2,
			GRAPHICS: 3,
			TEXT: 4,
			TILESPRITE: 5,
			BITMAPTEXT: 6,
			GROUP: 7,
			RENDERTEXTURE: 8,
			TILEMAP: 9,
			TILEMAPLAYER: 10,
			EMITTER: 11,
			POLYGON: 12,
			BITMAPDATA: 13,
			CANVAS_FILTER: 14,
			WEBGL_FILTER: 15,
			NONE: 0,
			LEFT: 1,
			RIGHT: 2,
			UP: 3,
			DOWN: 4
		};
	e.InteractionManager = function(a) {};
	c.Utils = {
		shuffle: function(a) {
			for (var b = a.length - 1; 0 < b; b--) {
				var d = Math.floor(Math.random() * (b + 1)),
					x = a[b];
				a[b] = a[d];
				a[d] = x
			}
			return a
		},
		pad: function(a, b, d, x) {
			"undefined" == typeof b && (b = 0);
			"undefined" == typeof d && (d = " ");
			"undefined" == typeof x && (x = 3);
			var c = 0;
			if (b + 1 >= a.length) switch (x) {
				case 1:
					a = Array(b + 1 - a.length).join(d) + a;
					break;
				case 3:
					b = Math.ceil((c = b - a.length) / 2);
					a = Array(c - b + 1).join(d) + a +
						Array(b + 1).join(d);
					break;
				default:
					a += Array(b + 1 - a.length).join(d)
			}
			return a
		},
		isPlainObject: function(a) {
			if ("object" !== typeof a || a.nodeType || a === a.window) return !1;
			try {
				if (a.constructor && !hasOwn.call(a.constructor.prototype, "isPrototypeOf")) return !1
			} catch (b) {
				return !1
			}
			return !0
		},
		extend: function() {
			var a, b, d, x, e, g = arguments[0] || {},
				f = 1,
				m = arguments.length,
				u = !1;
			"boolean" === typeof g && (u = g, g = arguments[1] || {}, f = 2);
			m === f && (g = this, --f);
			for (; f < m; f++)
				if (null != (a = arguments[f]))
					for (b in a) d = g[b], x = a[b], g !== x && (u && x && (c.Utils.isPlainObject(x) ||
						(e = Array.isArray(x))) ? (e ? (e = !1, d = d && Array.isArray(d) ? d : []) : d = d && c.Utils.isPlainObject(d) ? d : {}, g[b] = c.Utils.extend(u, d, x)) : void 0 !== x && (g[b] = x));
			return g
		}
	};
	(function() {
		void 0 === window.console && (window.console = {
			debug: function() {
				return !0
			},
			info: function() {
				return !1
			},
			warn: function() {
				return !1
			},
			log: function() {
				return !1
			}
		});
		debug = function(a) {
			window.console.debug(a)
		};
		info = function(a) {
			window.console.info(a)
		};
		warn = function(a) {
			window.console.warn(a)
		};
		log = function(a) {
			window.console.log(a)
		}
	})();
	"function" != typeof Function.prototype.bind &&
		(Function.prototype.bind = function() {
		var a = Array.prototype.slice;
		return function(b) {
			function d() {
				var e = c.concat(a.call(arguments));
				x.apply(this instanceof d ? this : b, e)
			}
			var x = this,
				c = a.call(arguments, 1);
			if ("function" != typeof x) throw new TypeError;
			d.prototype = function k(a) {
				a && (k.prototype = a);
				if (!(this instanceof k)) return new k
			}(x.prototype);
			return d
		}
	}());
	e.Matrix = "undefined" !== typeof Float32Array ? Float32Array : Array;
	e.mat3 = {};
	e.mat3.create = function() {
		var a = new e.Matrix(9);
		a[0] = 1;
		a[1] = 0;
		a[2] = 0;
		a[3] = 0;
		a[4] =
			1;
		a[5] = 0;
		a[6] = 0;
		a[7] = 0;
		a[8] = 1;
		return a
	};
	e.mat3.identity = function(a) {
		a[0] = 1;
		a[1] = 0;
		a[2] = 0;
		a[3] = 0;
		a[4] = 1;
		a[5] = 0;
		a[6] = 0;
		a[7] = 0;
		a[8] = 1;
		return a
	};
	e.mat4 = {};
	e.mat4.create = function() {
		var a = new e.Matrix(16);
		a[0] = 1;
		a[1] = 0;
		a[2] = 0;
		a[3] = 0;
		a[4] = 0;
		a[5] = 1;
		a[6] = 0;
		a[7] = 0;
		a[8] = 0;
		a[9] = 0;
		a[10] = 1;
		a[11] = 0;
		a[12] = 0;
		a[13] = 0;
		a[14] = 0;
		a[15] = 1;
		return a
	};
	e.mat3.multiply = function(a, b, d) {
		d || (d = a);
		var x = a[0],
			c = a[1],
			e = a[2],
			f = a[3],
			m = a[4],
			u = a[5],
			l = a[6],
			q = a[7];
		a = a[8];
		var t = b[0],
			p = b[1],
			v = b[2],
			n = b[3],
			z = b[4],
			A = b[5],
			y = b[6],
			B = b[7];
		b = b[8];
		d[0] = t * x + p * f + v * l;
		d[1] = t * c + p * m + v * q;
		d[2] = t * e + p * u + v * a;
		d[3] = n * x + z * f + A * l;
		d[4] = n * c + z * m + A * q;
		d[5] = n * e + z * u + A * a;
		d[6] = y * x + B * f + b * l;
		d[7] = y * c + B * m + b * q;
		d[8] = y * e + B * u + b * a;
		return d
	};
	e.mat3.clone = function(a) {
		var b = new e.Matrix(9);
		b[0] = a[0];
		b[1] = a[1];
		b[2] = a[2];
		b[3] = a[3];
		b[4] = a[4];
		b[5] = a[5];
		b[6] = a[6];
		b[7] = a[7];
		b[8] = a[8];
		return b
	};
	e.mat3.transpose = function(a, b) {
		if (!b || a === b) {
			var d = a[1],
				x = a[2],
				c = a[5];
			a[1] = a[3];
			a[2] = a[6];
			a[3] = d;
			a[5] = a[7];
			a[6] = x;
			a[7] = c;
			return a
		}
		b[0] = a[0];
		b[1] = a[3];
		b[2] = a[6];
		b[3] = a[1];
		b[4] = a[4];
		b[5] = a[7];
		b[6] =
			a[2];
		b[7] = a[5];
		b[8] = a[8];
		return b
	};
	e.mat3.toMat4 = function(a, b) {
		b || (b = e.mat4.create());
		b[15] = 1;
		b[14] = 0;
		b[13] = 0;
		b[12] = 0;
		b[11] = 0;
		b[10] = a[8];
		b[9] = a[7];
		b[8] = a[6];
		b[7] = 0;
		b[6] = a[5];
		b[5] = a[4];
		b[4] = a[3];
		b[3] = 0;
		b[2] = a[2];
		b[1] = a[1];
		b[0] = a[0];
		return b
	};
	e.mat4.create = function() {
		var a = new e.Matrix(16);
		a[0] = 1;
		a[1] = 0;
		a[2] = 0;
		a[3] = 0;
		a[4] = 0;
		a[5] = 1;
		a[6] = 0;
		a[7] = 0;
		a[8] = 0;
		a[9] = 0;
		a[10] = 1;
		a[11] = 0;
		a[12] = 0;
		a[13] = 0;
		a[14] = 0;
		a[15] = 1;
		return a
	};
	e.mat4.transpose = function(a, b) {
		if (!b || a === b) {
			var d = a[1],
				x = a[2],
				c = a[3],
				e = a[6],
				f = a[7],
				m = a[11];
			a[1] = a[4];
			a[2] = a[8];
			a[3] = a[12];
			a[4] = d;
			a[6] = a[9];
			a[7] = a[13];
			a[8] = x;
			a[9] = e;
			a[11] = a[14];
			a[12] = c;
			a[13] = f;
			a[14] = m;
			return a
		}
		b[0] = a[0];
		b[1] = a[4];
		b[2] = a[8];
		b[3] = a[12];
		b[4] = a[1];
		b[5] = a[5];
		b[6] = a[9];
		b[7] = a[13];
		b[8] = a[2];
		b[9] = a[6];
		b[10] = a[10];
		b[11] = a[14];
		b[12] = a[3];
		b[13] = a[7];
		b[14] = a[11];
		b[15] = a[15];
		return b
	};
	e.mat4.multiply = function(a, b, d) {
		d || (d = a);
		var x = a[0],
			c = a[1],
			e = a[2],
			f = a[3],
			m = a[4],
			u = a[5],
			l = a[6],
			q = a[7],
			t = a[8],
			p = a[9],
			n = a[10],
			w = a[11],
			z = a[12],
			A = a[13],
			y = a[14];
		a = a[15];
		var B = b[0],
			C = b[1],
			s = b[2],
			r = b[3];
		d[0] = B * x + C * m + s * t + r * z;
		d[1] = B * c + C * u + s * p + r * A;
		d[2] = B * e + C * l + s * n + r * y;
		d[3] = B * f + C * q + s * w + r * a;
		B = b[4];
		C = b[5];
		s = b[6];
		r = b[7];
		d[4] = B * x + C * m + s * t + r * z;
		d[5] = B * c + C * u + s * p + r * A;
		d[6] = B * e + C * l + s * n + r * y;
		d[7] = B * f + C * q + s * w + r * a;
		B = b[8];
		C = b[9];
		s = b[10];
		r = b[11];
		d[8] = B * x + C * m + s * t + r * z;
		d[9] = B * c + C * u + s * p + r * A;
		d[10] = B * e + C * l + s * n + r * y;
		d[11] = B * f + C * q + s * w + r * a;
		B = b[12];
		C = b[13];
		s = b[14];
		r = b[15];
		d[12] = B * x + C * m + s * t + r * z;
		d[13] = B * c + C * u + s * p + r * A;
		d[14] = B * e + C * l + s * n + r * y;
		d[15] = B * f + C * q + s * w + r * a;
		return d
	};
	e.Point = function(a, b) {
		this.x = a || 0;
		this.y = b || 0
	};
	e.Point.prototype.clone =
		function() {
			return new e.Point(this.x, this.y)
	};
	e.Point.prototype.constructor = e.Point;
	e.Rectangle = function(a, b, d, x) {
		this.x = a || 0;
		this.y = b || 0;
		this.width = d || 0;
		this.height = x || 0
	};
	e.Rectangle.prototype.clone = function() {
		return new e.Rectangle(this.x, this.y, this.width, this.height)
	};
	e.Rectangle.prototype.contains = function(a, b) {
		if (0 >= this.width || 0 >= this.height) return !1;
		var d = this.x;
		return a >= d && a <= d + this.width && (d = this.y, b >= d && b <= d + this.height) ? !0 : !1
	};
	e.Rectangle.prototype.constructor = e.Rectangle;
	e.Polygon = function(a) {
		a instanceof
		Array || (a = Array.prototype.slice.call(arguments));
		if ("number" === typeof a[0]) {
			for (var b = [], d = 0, x = a.length; d < x; d += 2) b.push(new e.Point(a[d], a[d + 1]));
			a = b
		}
		this.points = a
	};
	e.Polygon.prototype.clone = function() {
		for (var a = [], b = 0; b < this.points.length; b++) a.push(this.points[b].clone());
		return new e.Polygon(a)
	};
	e.Polygon.prototype.contains = function(a, b) {
		for (var d = !1, x = 0, c = this.points.length - 1; x < this.points.length; c = x++) {
			var e = this.points[x].x,
				f = this.points[x].y,
				m = this.points[c].x,
				c = this.points[c].y;
			f > b != c > b &&
				a < (m - e) * (b - f) / (c - f) + e && (d = !d)
		}
		return d
	};
	e.Polygon.prototype.constructor = e.Polygon;
	e.DisplayObject = function() {
		this.last = this;
		this.first = this;
		this.position = new e.Point;
		this.scale = new e.Point(1, 1);
		this.pivot = new e.Point(0, 0);
		this.rotation = 0;
		this.alpha = 1;
		this.visible = !0;
		this.hitArea = null;
		this.renderable = this.buttonMode = !1;
		this.stage = this.parent = null;
		this.worldAlpha = 1;
		this._interactive = !1;
		this.worldTransform = e.mat3.create();
		this.localTransform = e.mat3.create();
		this.color = [];
		this.dynamic = !0;
		this._sr = 0;
		this._cr =
			1;
		this.filterArea = new e.Rectangle(0, 0, 1, 1)
	};
	e.DisplayObject.prototype.constructor = e.DisplayObject;
	e.DisplayObject.prototype.setInteractive = function(a) {
		this.interactive = a
	};
	Object.defineProperty(e.DisplayObject.prototype, "interactive", {
		get: function() {
			return this._interactive
		},
		set: function(a) {
			this._interactive = a;
			this.stage && (this.stage.dirty = !0)
		}
	});
	Object.defineProperty(e.DisplayObject.prototype, "mask", {
		get: function() {
			return this._mask
		},
		set: function(a) {
			a ? this._mask ? (a.start = this._mask.start, a.end = this._mask.end) :
				(this.addFilter(a), a.renderable = !1) : (this.removeFilter(this._mask), this._mask.renderable = !0);
			this._mask = a
		}
	});
	Object.defineProperty(e.DisplayObject.prototype, "filters", {
		get: function() {
			return this._filters
		},
		set: function(a) {
			if (a) {
				this._filters && this.removeFilter(this._filters);
				this.addFilter(a);
				for (var b = [], d = 0; d < a.length; d++)
					for (var x = a[d].passes, c = 0; c < x.length; c++) b.push(x[c]);
				a.start.filterPasses = b
			} else this._filters && this.removeFilter(this._filters);
			this._filters = a
		}
	});
	e.DisplayObject.prototype.addFilter =
		function(a) {
			var b = new e.FilterBlock,
				d = new e.FilterBlock;
			a.start = b;
			a.end = d;
			b.data = a;
			d.data = a;
			b.first = b.last = this;
			d.first = d.last = this;
			b.open = !0;
			b.target = this;
			var x = a = b,
				c, g;
			(g = this.first._iPrev) ? (c = g._iNext, a._iPrev = g, g._iNext = a) : c = this;
			c && (c._iPrev = x, x._iNext = c);
			x = a = d;
			g = this.last;
			if (c = g._iNext) c._iPrev = x, x._iNext = c;
			a._iPrev = g;
			g._iNext = a;
			a = this;
			for (x = this.last; a;) a.last == x && (a.last = d), a = a.parent;
			this.first = b;
			this.__renderGroup && this.__renderGroup.addFilterBlocks(b, d)
	};
	e.DisplayObject.prototype.removeFilter =
		function(a) {
			console.log("YUOIO");
			var b = a.start,
				d = b._iNext,
				c = b._iPrev;
			d && (d._iPrev = c);
			c && (c._iNext = d);
			this.first = b._iNext;
			a = a.end;
			d = a._iNext;
			c = a._iPrev;
			d && (d._iPrev = c);
			c._iNext = d;
			d = a._iPrev;
			for (c = this; c.last == a && (c.last = d, c = c.parent, c););
			this.__renderGroup && this.__renderGroup.removeFilterBlocks(b, a)
	};
	e.DisplayObject.prototype.updateTransform = function() {
		this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation));
		var a = this.localTransform,
			b = this.parent.worldTransform,
			d = this.worldTransform;
		a[0] = this._cr * this.scale.x;
		a[1] = -this._sr * this.scale.y;
		a[3] = this._sr * this.scale.x;
		a[4] = this._cr * this.scale.y;
		var c = this.pivot.x,
			h = this.pivot.y,
			g = a[0],
			f = a[1],
			m = this.position.x - a[0] * c - h * a[1],
			u = a[3],
			l = a[4],
			c = this.position.y - a[4] * h - c * a[3],
			h = b[0],
			q = b[1],
			t = b[2],
			p = b[3],
			n = b[4],
			b = b[5];
		a[2] = m;
		a[5] = c;
		d[0] = h * g + q * u;
		d[1] = h * f + q * l;
		d[2] = h * m + q * c + t;
		d[3] = p * g + n * u;
		d[4] = p * f + n * l;
		d[5] = p * m + n * c + b;
		this.worldAlpha = this.alpha * this.parent.worldAlpha;
		this.vcount = e.visibleCount
	};
	e.visibleCount = 0;
	e.DisplayObjectContainer = function() {
		e.DisplayObject.call(this);
		this.children = []
	};
	e.DisplayObjectContainer.prototype = Object.create(e.DisplayObject.prototype);
	e.DisplayObjectContainer.prototype.constructor = e.DisplayObjectContainer;
	e.DisplayObjectContainer.prototype.addChild = function(a) {
		void 0 != a.parent && a.parent.removeChild(a);
		a.parent = this;
		this.children.push(a);
		if (this.stage) {
			var b = a;
			do b.interactive && (this.stage.dirty = !0), b.stage = this.stage, b = b._iNext; while (b)
		}
		var b = a.first,
			d = a.last,
			c, e;
		e = this._filters || this._mask ? this.last._iPrev : this.last;
		c = e._iNext;
		for (var g = this; g;) g.last == e && (g.last = a.last), g = g.parent;
		c && (c._iPrev = d, d._iNext = c);
		b._iPrev = e;
		e._iNext = b;
		this.__renderGroup && (a.__renderGroup && a.__renderGroup.removeDisplayObjectAndChildren(a), this.__renderGroup.addDisplayObjectAndChildren(a))
	};
	e.DisplayObjectContainer.prototype.addChildAt = function(a, b) {
		if (0 <= b && b <= this.children.length) {
			void 0 != a.parent && a.parent.removeChild(a);
			a.parent = this;
			if (this.stage) {
				var d = a;
				do d.interactive &&
					(this.stage.dirty = !0), d.stage = this.stage, d = d._iNext; while (d)
			}
			var d = a.first,
				c = a.last,
				e, g;
			if (b == this.children.length) {
				g = this.last;
				e = this;
				for (var f = this.last; e;) e.last == f && (e.last = a.last), e = e.parent
			} else g = 0 === b ? this : this.children[b - 1].last; if (e = g._iNext) e._iPrev = c, c._iNext = e;
			d._iPrev = g;
			g._iNext = d;
			this.children.splice(b, 0, a);
			this.__renderGroup && (a.__renderGroup && a.__renderGroup.removeDisplayObjectAndChildren(a), this.__renderGroup.addDisplayObjectAndChildren(a))
		} else throw Error(a + " The index " + b + " supplied is out of bounds " +
			this.children.length);
	};
	e.DisplayObjectContainer.prototype.swapChildren = function(a, b) {};
	e.DisplayObjectContainer.prototype.getChildAt = function(a) {
		if (0 <= a && a < this.children.length) return this.children[a];
		throw Error(child + " Both the supplied DisplayObjects must be a child of the caller " + this);
	};
	e.DisplayObjectContainer.prototype.removeChild = function(a) {
		var b = this.children.indexOf(a);
		if (-1 !== b) {
			var d = a.first,
				c = a.last,
				e = c._iNext,
				g = d._iPrev;
			e && (e._iPrev = g);
			g._iNext = e;
			if (this.last == c)
				for (e = d._iPrev, g =
					this; g.last == c.last && (g.last = e, g = g.parent, g););
			c._iNext = null;
			d._iPrev = null;
			if (this.stage) {
				d = a;
				do d.interactive && (this.stage.dirty = !0), d.stage = null, d = d._iNext; while (d)
			}
			a.__renderGroup && a.__renderGroup.removeDisplayObjectAndChildren(a);
			a.parent = void 0;
			this.children.splice(b, 1)
		} else throw Error(a + " The supplied DisplayObject must be a child of the caller " + this);
	};
	e.DisplayObjectContainer.prototype.updateTransform = function() {
		if (this.visible) {
			e.DisplayObject.prototype.updateTransform.call(this);
			for (var a =
				0, b = this.children.length; a < b; a++) this.children[a].updateTransform()
		}
	};
	e.blendModes = {};
	e.blendModes.NORMAL = 0;
	e.blendModes.SCREEN = 1;
	e.Sprite = function(a) {
		e.DisplayObjectContainer.call(this);
		this.anchor = new e.Point;
		this.texture = a;
		this.blendMode = e.blendModes.NORMAL;
		this._height = this._width = 0;
		a.baseTexture.hasLoaded ? this.updateFrame = !0 : (this.onTextureUpdateBind = this.onTextureUpdate.bind(this), this.texture.addEventListener("update", this.onTextureUpdateBind));
		this.renderable = !0
	};
	e.Sprite.prototype = Object.create(e.DisplayObjectContainer.prototype);
	e.Sprite.prototype.constructor = e.Sprite;
	Object.defineProperty(e.Sprite.prototype, "width", {
		get: function() {
			return this.scale.x * this.texture.frame.width
		},
		set: function(a) {
			this.scale.x = a / this.texture.frame.width;
			this._width = a
		}
	});
	Object.defineProperty(e.Sprite.prototype, "height", {
		get: function() {
			return this.scale.y * this.texture.frame.height
		},
		set: function(a) {
			this.scale.y = a / this.texture.frame.height;
			this._height = a
		}
	});
	e.Sprite.prototype.setTexture = function(a) {
		this.texture.baseTexture != a.baseTexture ? (this.textureChange = !0, this.texture = a, this.__renderGroup && this.__renderGroup.updateTexture(this)) : this.texture = a;
		this.updateFrame = !0
	};
	e.Sprite.prototype.onTextureUpdate = function(a) {
		this._width && (this.scale.x = this._width / this.texture.frame.width);
		this._height && (this.scale.y = this._height / this.texture.frame.height);
		this.updateFrame = !0
	};
	e.Sprite.fromFrame = function(a) {
		var b = e.TextureCache[a];
		if (!b) throw Error("The frameId '" + a + "' does not exist in the texture cache" + this);
		return new e.Sprite(b)
	};
	e.Sprite.fromImage = function(a) {
		a =
			e.Texture.fromImage(a);
		return new e.Sprite(a)
	};
	e.Stage = function(a) {
		e.DisplayObjectContainer.call(this);
		this.worldTransform = e.mat3.create();
		this.interactive = !0;
		this.interactionManager = new e.InteractionManager(this);
		this.dirty = !0;
		this.__childrenAdded = [];
		this.__childrenRemoved = [];
		this.stage = this;
		this.stage.hitArea = new e.Rectangle(0, 0, 1E5, 1E5);
		this.setBackgroundColor(a);
		this.worldVisible = !0
	};
	e.Stage.prototype = Object.create(e.DisplayObjectContainer.prototype);
	e.Stage.prototype.constructor = e.Stage;
	e.Stage.prototype.setInteractionDelegate =
		function(a) {
			this.interactionManager.setTargetDomElement(a)
	};
	e.Stage.prototype.updateTransform = function() {
		this.worldAlpha = 1;
		this.vcount = e.visibleCount;
		for (var a = 0, b = this.children.length; a < b; a++) this.children[a].updateTransform();
		this.dirty && (this.dirty = !1, this.interactionManager.dirty = !0);
		this.interactive && this.interactionManager.update()
	};
	e.Stage.prototype.setBackgroundColor = function(a) {
		this.backgroundColor = a || 0;
		this.backgroundColorSplit = f(this.backgroundColor);
		a = this.backgroundColor.toString(16);
		a = "000000".substr(0, 6 - a.length) + a;
		this.backgroundColorString = "#" + a
	};
	e.Stage.prototype.getMousePosition = function() {
		return this.interactionManager.mouse.global
	};
	e.CustomRenderable = function() {
		e.DisplayObject.call(this);
		this.renderable = !0
	};
	e.CustomRenderable.prototype = Object.create(e.DisplayObject.prototype);
	e.CustomRenderable.prototype.constructor = e.CustomRenderable;
	e.CustomRenderable.prototype.renderCanvas = function(a) {};
	e.CustomRenderable.prototype.initWebGL = function(a) {};
	e.CustomRenderable.prototype.renderWebGL =
		function(a, b) {};
	e.Strip = function(a, b, d) {
		e.DisplayObjectContainer.call(this);
		this.texture = a;
		this.blendMode = e.blendModes.NORMAL;
		try {
			this.uvs = new Float32Array([0, 1, 1, 1, 1, 0, 0, 1]), this.verticies = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0]), this.colors = new Float32Array([1, 1, 1, 1]), this.indices = new Uint16Array([0, 1, 2, 3])
		} catch (c) {
			this.uvs = [0, 1, 1, 1, 1, 0, 0, 1], this.verticies = [0, 0, 0, 0, 0, 0, 0, 0, 0], this.colors = [1, 1, 1, 1], this.indices = [0, 1, 2, 3]
		}
		this.width = b;
		this.height = d;
		a.baseTexture.hasLoaded ? (this.width = this.texture.frame.width,
			this.height = this.texture.frame.height, this.updateFrame = !0) : (this.onTextureUpdateBind = this.onTextureUpdate.bind(this), this.texture.addEventListener("update", this.onTextureUpdateBind));
		this.renderable = !0
	};
	e.Strip.prototype = Object.create(e.DisplayObjectContainer.prototype);
	e.Strip.prototype.constructor = e.Strip;
	e.Strip.prototype.setTexture = function(a) {
		this.texture = a;
		this.width = a.frame.width;
		this.height = a.frame.height;
		this.updateFrame = !0
	};
	e.Strip.prototype.onTextureUpdate = function(a) {
		this.updateFrame = !0
	};
	e.Rope = function(a, b) {
		e.Strip.call(this, a);
		this.points = b;
		try {
			this.verticies = new Float32Array(4 * b.length), this.uvs = new Float32Array(4 * b.length), this.colors = new Float32Array(2 * b.length), this.indices = new Uint16Array(2 * b.length)
		} catch (d) {
			this.verticies = verticies, this.uvs = uvs, this.colors = colors, this.indices = indices
		}
		this.refresh()
	};
	e.Rope.prototype = Object.create(e.Strip.prototype);
	e.Rope.prototype.constructor = e.Rope;
	e.Rope.prototype.refresh = function() {
		var a = this.points;
		if (!(1 > a.length)) {
			var b = this.uvs,
				d = this.indices,
				c = this.colors;
			this.count -= 0.2;
			b[0] = 0;
			b[1] = 1;
			b[2] = 0;
			b[3] = 1;
			c[0] = 1;
			c[1] = 1;
			d[0] = 0;
			d[1] = 1;
			for (var a = a.length, e = 1; e < a; e++) {
				var g = 4 * e,
					f = e / (a - 1);
				b[g] = f;
				b[g + 1] = 0;
				b[g + 2] = f;
				b[g + 3] = 1;
				g = 2 * e;
				c[g] = 1;
				c[g + 1] = 1;
				g = 2 * e;
				d[g] = g;
				d[g + 1] = g + 1
			}
		}
	};
	e.Rope.prototype.updateTransform = function() {
		var a = this.points;
		if (!(1 > a.length)) {
			var b = this.verticies,
				d = a[0],
				c, h = c = 0,
				g = a[0];
			this.count -= 0.2;
			b[0] = g.x + c;
			b[1] = g.y + h;
			b[2] = g.x - c;
			b[3] = g.y - h;
			for (var f = a.length, m = 1; m < f; m++) {
				var g = a[m],
					u = 4 * m;
				c = m < a.length - 1 ? a[m + 1] : g;
				h = -(c.x - d.x);
				c = c.y - d.y;
				var d = Math.sqrt(c * c + h * h),
					l = this.texture.height / 2;
				c /= d;
				h /= d;
				c *= l;
				h *= l;
				b[u] = g.x + c;
				b[u + 1] = g.y + h;
				b[u + 2] = g.x - c;
				b[u + 3] = g.y - h;
				d = g
			}
			e.DisplayObjectContainer.prototype.updateTransform.call(this)
		}
	};
	e.Rope.prototype.setTexture = function(a) {
		this.texture = a;
		this.updateFrame = !0
	};
	e.TilingSprite = function(a, b, d) {
		e.DisplayObjectContainer.call(this);
		this.texture = a;
		this.width = b;
		this.height = d;
		this.tileScale = new e.Point(1, 1);
		this.tilePosition = new e.Point(0, 0);
		this.renderable = !0;
		this.blendMode = e.blendModes.NORMAL
	};
	e.TilingSprite.prototype = Object.create(e.DisplayObjectContainer.prototype);
	e.TilingSprite.prototype.constructor = e.TilingSprite;
	e.TilingSprite.prototype.setTexture = function(a) {
		this.texture = a;
		this.updateFrame = !0
	};
	e.TilingSprite.prototype.onTextureUpdate = function(a) {
		this.updateFrame = !0
	};
	e.AbstractFilter = function(a, b) {
		this.passes = [this];
		this.dirty = !0;
		this.padding = 0;
		this.uniforms = b || {};
		this.fragmentSrc = a || []
	};
	e.FilterBlock = function() {
		this.renderable = this.visible = !0
	};
	e.Graphics = function() {
		e.DisplayObjectContainer.call(this);
		this.renderable = !0;
		this.fillAlpha = 1;
		this.lineWidth = 0;
		this.lineColor = "black";
		this.graphicsData = [];
		this.currentPath = {
			points: []
		}
	};
	e.Graphics.prototype = Object.create(e.DisplayObjectContainer.prototype);
	e.Graphics.prototype.constructor = e.Graphics;
	e.Graphics.prototype.lineStyle = function(a, b, d) {
		0 === this.currentPath.points.length && this.graphicsData.pop();
		this.lineWidth = a || 0;
		this.lineColor = b || 0;
		this.lineAlpha = void 0 == d ? 1 : d;
		this.currentPath = {
			lineWidth: this.lineWidth,
			lineColor: this.lineColor,
			lineAlpha: this.lineAlpha,
			fillColor: this.fillColor,
			fillAlpha: this.fillAlpha,
			fill: this.filling,
			points: [],
			type: e.Graphics.POLY
		};
		this.graphicsData.push(this.currentPath)
	};
	e.Graphics.prototype.moveTo = function(a, b) {
		0 === this.currentPath.points.length && this.graphicsData.pop();
		this.currentPath = this.currentPath = {
			lineWidth: this.lineWidth,
			lineColor: this.lineColor,
			lineAlpha: this.lineAlpha,
			fillColor: this.fillColor,
			fillAlpha: this.fillAlpha,
			fill: this.filling,
			points: [],
			type: e.Graphics.POLY
		};
		this.currentPath.points.push(a, b);
		this.graphicsData.push(this.currentPath)
	};
	e.Graphics.prototype.lineTo = function(a, b) {
		this.currentPath.points.push(a, b);
		this.dirty = !0
	};
	e.Graphics.prototype.beginFill = function(a, b) {
		this.filling = !0;
		this.fillColor = a || 0;
		this.fillAlpha = void 0 == b ? 1 : b
	};
	e.Graphics.prototype.endFill = function() {
		this.filling = !1;
		this.fillColor = null;
		this.fillAlpha = 1
	};
	e.Graphics.prototype.drawRect = function(a, b, d, c) {
		0 === this.currentPath.points.length && this.graphicsData.pop();
		this.currentPath = {
			lineWidth: this.lineWidth,
			lineColor: this.lineColor,
			lineAlpha: this.lineAlpha,
			fillColor: this.fillColor,
			fillAlpha: this.fillAlpha,
			fill: this.filling,
			points: [a, b, d, c],
			type: e.Graphics.RECT
		};
		this.graphicsData.push(this.currentPath);
		this.dirty = !0
	};
	e.Graphics.prototype.drawCircle = function(a, b, d) {
		0 === this.currentPath.points.length && this.graphicsData.pop();
		this.currentPath = {
			lineWidth: this.lineWidth,
			lineColor: this.lineColor,
			lineAlpha: this.lineAlpha,
			fillColor: this.fillColor,
			fillAlpha: this.fillAlpha,
			fill: this.filling,
			points: [a, b, d, d],
			type: e.Graphics.CIRC
		};
		this.graphicsData.push(this.currentPath);
		this.dirty = !0
	};
	e.Graphics.prototype.drawElipse = function(a, b, d, c) {
		0 === this.currentPath.points.length && this.graphicsData.pop();
		this.currentPath = {
			lineWidth: this.lineWidth,
			lineColor: this.lineColor,
			lineAlpha: this.lineAlpha,
			fillColor: this.fillColor,
			fillAlpha: this.fillAlpha,
			fill: this.filling,
			points: [a, b, d, c],
			type: e.Graphics.ELIP
		};
		this.graphicsData.push(this.currentPath);
		this.dirty = !0
	};
	e.Graphics.prototype.clear = function() {
		this.lineWidth = 0;
		this.filling = !1;
		this.clearDirty = this.dirty = !0;
		this.graphicsData = [];
		this.bounds = null
	};
	e.Graphics.prototype.updateFilterBounds = function() {
		if (!this.bounds) {
			for (var a = Infinity, b = -Infinity, d = Infinity, c = -Infinity, h, g, f, m = 0; m < this.graphicsData.length; m++) {
				f = this.graphicsData[m];
				g = f.type;
				var u = f.lineWidth;
				h = f.points;
				if (g === e.Graphics.RECT) {
					g = h.x - u / 2;
					f = h.y - u / 2;
					var l = h.width + u,
						u = h.height + u,
						a = g < a ? g : a,
						b = g + l > b ? g + l : b,
						d = f < d ? g : d,
						c = f + u > c ? f + u : c
				} else if (g === e.Graphics.CIRC || g === e.Graphics.ELIP) g = h.x, f = h.y, u = h.radius + u / 2, a = g - u < a ? g - u : a, b = g + u > b ? g + u : b, d = f - u < d ? f - u : d, c = f + u > c ? f + u : c;
				else
					for (l = 0; l < h.length; l +=
						2) g = h[l], f = h[l + 1], a = g - u < a ? g - u : a, b = g + u > b ? g + u : b, d = f - u < d ? f - u : d, c = f + u > c ? f + u : c
			}
			this.bounds = new e.Rectangle(a, d, b - a, c - d)
		}
	};
	e.Graphics.POLY = 0;
	e.Graphics.RECT = 1;
	e.Graphics.CIRC = 2;
	e.Graphics.ELIP = 3;
	e.CanvasGraphics = function() {};
	e.CanvasGraphics.renderGraphics = function(a, b) {
		for (var d = a.worldAlpha, c = 0; c < a.graphicsData.length; c++) {
			var h = a.graphicsData[c],
				g = h.points;
			b.strokeStyle = color = "#" + ("00000" + (h.lineColor | 0).toString(16)).substr(-6);
			b.lineWidth = h.lineWidth;
			if (h.type == e.Graphics.POLY) {
				b.beginPath();
				b.moveTo(g[0],
					g[1]);
				for (var f = 1; f < g.length / 2; f++) b.lineTo(g[2 * f], g[2 * f + 1]);
				g[0] == g[g.length - 2] && g[1] == g[g.length - 1] && b.closePath();
				h.fill && (b.globalAlpha = h.fillAlpha * d, b.fillStyle = color = "#" + ("00000" + (h.fillColor | 0).toString(16)).substr(-6), b.fill());
				h.lineWidth && (b.globalAlpha = h.lineAlpha * d, b.stroke())
			} else if (h.type == e.Graphics.RECT) {
				if (h.fillColor || 0 === h.fillColor) b.globalAlpha = h.fillAlpha * d, b.fillStyle = color = "#" + ("00000" + (h.fillColor | 0).toString(16)).substr(-6), b.fillRect(g[0], g[1], g[2], g[3]);
				h.lineWidth && (b.globalAlpha =
					h.lineAlpha * d, b.strokeRect(g[0], g[1], g[2], g[3]))
			} else if (h.type == e.Graphics.CIRC) b.beginPath(), b.arc(g[0], g[1], g[2], 0, 2 * Math.PI), b.closePath(), h.fill && (b.globalAlpha = h.fillAlpha * d, b.fillStyle = color = "#" + ("00000" + (h.fillColor | 0).toString(16)).substr(-6), b.fill()), h.lineWidth && (b.globalAlpha = h.lineAlpha * d, b.stroke());
			else if (h.type == e.Graphics.ELIP) {
				var m = h.points,
					u = 2 * m[2],
					f = 2 * m[3],
					g = m[0] - u / 2,
					m = m[1] - f / 2;
				b.beginPath();
				var l = u / 2 * 0.5522848,
					q = f / 2 * 0.5522848,
					n = g + u,
					p = m + f,
					u = g + u / 2,
					f = m + f / 2;
				b.moveTo(g, f);
				b.bezierCurveTo(g,
					f - q, u - l, m, u, m);
				b.bezierCurveTo(u + l, m, n, f - q, n, f);
				b.bezierCurveTo(n, f + q, u + l, p, u, p);
				b.bezierCurveTo(u - l, p, g, f + q, g, f);
				b.closePath();
				h.fill && (b.globalAlpha = h.fillAlpha * d, b.fillStyle = color = "#" + ("00000" + (h.fillColor | 0).toString(16)).substr(-6), b.fill());
				h.lineWidth && (b.globalAlpha = h.lineAlpha * d, b.stroke())
			}
		}
	};
	e.CanvasGraphics.renderGraphicsMask = function(a, b) {
		var d = a.graphicsData.length;
		if (0 !== d)
			for (1 < d && console.log("Pixi.js warning: masks in canvas can only mask using the first path in the graphics object"),
				d = 0; 1 > d; d++) {
				var c = a.graphicsData[d],
					h = c.points;
				if (c.type == e.Graphics.POLY) {
					b.beginPath();
					b.moveTo(h[0], h[1]);
					for (c = 1; c < h.length / 2; c++) b.lineTo(h[2 * c], h[2 * c + 1]);
					h[0] == h[h.length - 2] && h[1] == h[h.length - 1] && b.closePath()
				} else if (c.type == e.Graphics.RECT) b.beginPath(), b.rect(h[0], h[1], h[2], h[3]), b.closePath();
				else if (c.type == e.Graphics.CIRC) b.beginPath(), b.arc(h[0], h[1], h[2], 0, 2 * Math.PI), b.closePath();
				else if (c.type == e.Graphics.ELIP) {
					var g = c.points,
						f = 2 * g[2],
						c = 2 * g[3],
						h = g[0] - f / 2,
						g = g[1] - c / 2;
					b.beginPath();
					var m = f / 2 * 0.5522848,
						u = c / 2 * 0.5522848,
						l = h + f,
						q = g + c,
						f = h + f / 2,
						c = g + c / 2;
					b.moveTo(h, c);
					b.bezierCurveTo(h, c - u, f - m, g, f, g);
					b.bezierCurveTo(f + m, g, l, c - u, l, c);
					b.bezierCurveTo(l, c + u, f + m, q, f, q);
					b.bezierCurveTo(f - m, q, h, c + u, h, c);
					b.closePath()
				}
			}
	};
	e.CanvasRenderer = function(a, b, d, c) {
		this.transparent = c;
		this.width = a || 800;
		this.height = b || 600;
		this.view = d || document.createElement("canvas");
		this.context = this.view.getContext("2d");
		this.refresh = !0;
		this.view.width = this.width;
		this.view.height = this.height;
		this.count = 0
	};
	e.CanvasRenderer.prototype.constructor =
		e.CanvasRenderer;
	e.CanvasRenderer.prototype.render = function(a) {
		e.texturesToUpdate = [];
		e.texturesToDestroy = [];
		e.visibleCount++;
		a.updateTransform();
		this.view.style.backgroundColor == a.backgroundColorString || this.transparent || (this.view.style.backgroundColor = a.backgroundColorString);
		this.context.setTransform(1, 0, 0, 1, 0, 0);
		this.context.clearRect(0, 0, this.width, this.height);
		this.renderDisplayObject(a);
		a.interactive && !a._interactiveEventsAdded && (a._interactiveEventsAdded = !0, a.interactionManager.setTarget(this));
		0 < e.Texture.frameUpdates.length && (e.Texture.frameUpdates = [])
	};
	e.CanvasRenderer.prototype.resize = function(a, b) {
		this.width = a;
		this.height = b;
		this.view.width = a;
		this.view.height = b
	};
	e.CanvasRenderer.prototype.renderDisplayObject = function(a) {
		var b, d = this.context;
		d.globalCompositeOperation = "source-over";
		var c = a.last._iNext;
		a = a.first;
		do
			if (b = a.worldTransform, a.visible) {
				if (a.renderable)
					if (a instanceof e.Sprite) {
						var h = a.texture.frame;
						h && h.width && h.height && (d.globalAlpha = a.worldAlpha, d.setTransform(b[0], b[3],
							b[1], b[4], b[2], b[5]), d.drawImage(a.texture.baseTexture.source, h.x, h.y, h.width, h.height, a.anchor.x * -h.width, a.anchor.y * -h.height, h.width, h.height))
					} else if (a instanceof e.Strip) d.setTransform(b[0], b[3], b[1], b[4], b[2], b[5]), this.renderStrip(a);
				else if (a instanceof e.TilingSprite) d.setTransform(b[0], b[3], b[1], b[4], b[2], b[5]), this.renderTilingSprite(a);
				else if (a instanceof e.CustomRenderable) d.setTransform(b[0], b[3], b[1], b[4], b[2], b[5]), a.renderCanvas(this);
				else if (a instanceof e.Graphics) d.setTransform(b[0],
					b[3], b[1], b[4], b[2], b[5]), e.CanvasGraphics.renderGraphics(a, d);
				else if (a instanceof e.FilterBlock && a.data instanceof e.Graphics)
					if (b = a.data, a.open) {
						d.save();
						var h = b.alpha,
							g = b.worldTransform;
						d.setTransform(g[0], g[3], g[1], g[4], g[2], g[5]);
						b.worldAlpha = 0.5;
						d.worldAlpha = 0;
						e.CanvasGraphics.renderGraphicsMask(b, d);
						d.clip();
						b.worldAlpha = h
					} else d.restore();
				a = a._iNext
			} else a = a.last._iNext;
		while (a != c)
	};
	e.CanvasRenderer.prototype.renderStripFlat = function(a) {
		var b = this.context;
		a = a.verticies;
		var d = a.length / 2;
		this.count++;
		b.beginPath();
		for (var c = 1; c < d - 2; c++) {
			var e = 2 * c,
				g = a[e + 2],
				f = a[e + 4],
				m = a[e + 3],
				l = a[e + 5];
			b.moveTo(a[e], a[e + 1]);
			b.lineTo(g, m);
			b.lineTo(f, l)
		}
		b.fillStyle = "#FF0000";
		b.fill();
		b.closePath()
	};
	e.CanvasRenderer.prototype.renderTilingSprite = function(a) {
		var b = this.context;
		b.globalAlpha = a.worldAlpha;
		a.__tilePattern || (a.__tilePattern = b.createPattern(a.texture.baseTexture.source, "repeat"));
		b.beginPath();
		var d = a.tilePosition,
			c = a.tileScale;
		b.scale(c.x, c.y);
		b.translate(d.x, d.y);
		b.fillStyle = a.__tilePattern;
		b.fillRect(-d.x, -d.y, a.width / c.x, a.height / c.y);
		b.scale(1 / c.x, 1 / c.y);
		b.translate(-d.x, -d.y);
		b.closePath()
	};
	e.CanvasRenderer.prototype.renderStrip = function(a) {
		var b = this.context,
			d = a.verticies,
			c = a.uvs,
			e = d.length / 2;
		this.count++;
		for (var g = 1; g < e - 2; g++) {
			var f = 2 * g,
				m = d[f],
				l = d[f + 2],
				n = d[f + 4],
				q = d[f + 1],
				t = d[f + 3],
				p = d[f + 5],
				v = c[f] * a.texture.width,
				w = c[f + 2] * a.texture.width,
				z = c[f + 4] * a.texture.width,
				A = c[f + 1] * a.texture.height,
				y = c[f + 3] * a.texture.height,
				f = c[f + 5] * a.texture.height;
			b.save();
			b.beginPath();
			b.moveTo(m, q);
			b.lineTo(l, t);
			b.lineTo(n,
				p);
			b.closePath();
			b.clip();
			var B = v * y + A * z + w * f - y * z - A * w - v * f;
			b.transform((m * y + A * n + l * f - y * n - A * l - m * f) / B, (q * y + A * p + t * f - y * p - A * t - q * f) / B, (v * l + m * z + w * n - l * z - m * w - v * n) / B, (v * t + q * z + w * p - t * z - q * w - v * p) / B, (v * y * n + A * l * z + m * w * f - m * y * z - A * w * n - v * l * f) / B, (v * y * p + A * t * z + q * w * f - q * y * z - A * w * p - v * t * f) / B);
			b.drawImage(a.texture.baseTexture.source, 0, 0);
			b.restore()
		}
	};
	e.PixiShader = function() {
		this.program;
		this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {",
			"gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;", "}"
		];
		this.textureCount = 0
	};
	e.PixiShader.prototype.init = function() {
		var a = e.compileProgram(this.vertexSrc || e.PixiShader.defaultVertexSrc, this.fragmentSrc),
			b = e.gl;
		b.useProgram(a);
		this.uSampler = b.getUniformLocation(a, "uSampler");
		this.projectionVector = b.getUniformLocation(a, "projectionVector");
		this.offsetVector = b.getUniformLocation(a, "offsetVector");
		this.dimensions = b.getUniformLocation(a, "dimensions");
		this.aVertexPosition = b.getAttribLocation(a,
			"aVertexPosition");
		this.colorAttribute = b.getAttribLocation(a, "aColor");
		this.aTextureCoord = b.getAttribLocation(a, "aTextureCoord");
		for (var d in this.uniforms) this.uniforms[d].uniformLocation = b.getUniformLocation(a, d);
		this.initUniforms();
		this.program = a
	};
	e.PixiShader.prototype.initUniforms = function() {
		this.textureCount = 1;
		var a, b;
		for (b in this.uniforms) {
			a = this.uniforms[b];
			var d = a.type;
			"sampler2D" == d ? (a._init = !1, null !== a.value && this.initSampler2D(a)) : "mat2" == d || "mat3" == d || "mat4" == d ? (a.glMatrix = !0, a.glValueLength =
				1, "mat2" == d ? a.glFunc = e.gl.uniformMatrix2fv : "mat3" == d ? a.glFunc = e.gl.uniformMatrix3fv : "mat4" == d && (a.glFunc = e.gl.uniformMatrix4fv)) : (a.glFunc = e.gl["uniform" + d], a.glValueLength = "2f" == d || "2i" == d ? 2 : "3f" == d || "3i" == d ? 3 : "4f" == d || "4i" == d ? 4 : 1)
		}
	};
	e.PixiShader.prototype.initSampler2D = function(a) {
		if (a.value && a.value.baseTexture && a.value.baseTexture.hasLoaded) {
			e.gl.activeTexture(e.gl["TEXTURE" + this.textureCount]);
			e.gl.bindTexture(e.gl.TEXTURE_2D, a.value.baseTexture._glTexture);
			if (a.textureData) {
				var b = a.textureData,
					d = b.magFilter ? b.magFilter : e.gl.LINEAR,
					c = b.minFilter ? b.minFilter : e.gl.LINEAR,
					h = b.wrapS ? b.wrapS : e.gl.CLAMP_TO_EDGE,
					f = b.wrapT ? b.wrapT : e.gl.CLAMP_TO_EDGE,
					k = b.luminance ? e.gl.LUMINANCE : e.gl.RGBA;
				b.repeat && (f = h = e.gl.REPEAT);
				e.gl.pixelStorei(e.gl.UNPACK_FLIP_Y_WEBGL, !1);
				b.width ? e.gl.texImage2D(e.gl.TEXTURE_2D, 0, k, b.width ? b.width : 512, b.height ? b.height : 2, b.border ? b.border : 0, k, e.gl.UNSIGNED_BYTE, null) : e.gl.texImage2D(e.gl.TEXTURE_2D, 0, k, e.gl.RGBA, e.gl.UNSIGNED_BYTE, a.value.baseTexture.source);
				e.gl.texParameteri(e.gl.TEXTURE_2D,
					e.gl.TEXTURE_MAG_FILTER, d);
				e.gl.texParameteri(e.gl.TEXTURE_2D, e.gl.TEXTURE_MIN_FILTER, c);
				e.gl.texParameteri(e.gl.TEXTURE_2D, e.gl.TEXTURE_WRAP_S, h);
				e.gl.texParameteri(e.gl.TEXTURE_2D, e.gl.TEXTURE_WRAP_T, f)
			}
			e.gl.uniform1i(a.uniformLocation, this.textureCount);
			a._init = !0;
			this.textureCount++
		}
	};
	e.PixiShader.prototype.syncUniforms = function() {
		this.textureCount = 1;
		var a, b;
		for (b in this.uniforms) a = this.uniforms[b], 1 == a.glValueLength ? !0 === a.glMatrix ? a.glFunc.call(e.gl, a.uniformLocation, a.transpose, a.value) : a.glFunc.call(e.gl,
			a.uniformLocation, a.value) : 2 == a.glValueLength ? a.glFunc.call(e.gl, a.uniformLocation, a.value.x, a.value.y) : 3 == a.glValueLength ? a.glFunc.call(e.gl, a.uniformLocation, a.value.x, a.value.y, a.value.z) : 4 == a.glValueLength ? a.glFunc.call(e.gl, a.uniformLocation, a.value.x, a.value.y, a.value.z, a.value.w) : "sampler2D" == a.type && (a._init ? (e.gl.activeTexture(e.gl["TEXTURE" + this.textureCount]), e.gl.bindTexture(e.gl.TEXTURE_2D, a.value.baseTexture._glTexture), e.gl.uniform1i(a.uniformLocation, this.textureCount), this.textureCount++) :
			this.initSampler2D(a))
	};
	e.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "vTextureCoord = aTextureCoord;", "vColor = aColor;", "}"];
	e.PrimitiveShader = function() {
		this.program;
		this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "gl_FragColor = vColor;", "}"];
		this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "varying vec4 vColor;", "void main(void) {", "vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "v -= offsetVector.xyx;", "gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);",
			"vColor = aColor  * alpha;", "}"
		]
	};
	e.PrimitiveShader.prototype.init = function() {
		var a = e.compileProgram(this.vertexSrc, this.fragmentSrc),
			b = e.gl;
		b.useProgram(a);
		this.projectionVector = b.getUniformLocation(a, "projectionVector");
		this.offsetVector = b.getUniformLocation(a, "offsetVector");
		this.aVertexPosition = b.getAttribLocation(a, "aVertexPosition");
		this.colorAttribute = b.getAttribLocation(a, "aColor");
		this.translationMatrix = b.getUniformLocation(a, "translationMatrix");
		this.alpha = b.getUniformLocation(a, "alpha");
		this.program = a
	};
	e.StripShader = function() {
		this.program;
		this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));", "gl_FragColor = gl_FragColor * alpha;", "}"];
		this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;",
			"varying vec2 vTextureCoord;", "varying vec2 offsetVector;", "varying float vColor;", "void main(void) {", "vec3 v = translationMatrix * vec3(aVertexPosition, 1.0);", "v -= offsetVector.xyx;", "gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / projectionVector.y + 1.0 , 0.0, 1.0);", "vTextureCoord = aTextureCoord;", "vColor = aColor;", "}"
		]
	};
	e.StripShader.prototype.init = function() {
		var a = e.compileProgram(this.vertexSrc, this.fragmentSrc),
			b = e.gl;
		b.useProgram(a);
		this.uSampler = b.getUniformLocation(a, "uSampler");
		this.projectionVector = b.getUniformLocation(a, "projectionVector");
		this.offsetVector = b.getUniformLocation(a, "offsetVector");
		this.colorAttribute = b.getAttribLocation(a, "aColor");
		this.aVertexPosition = b.getAttribLocation(a, "aVertexPosition");
		this.aTextureCoord = b.getAttribLocation(a, "aTextureCoord");
		this.translationMatrix = b.getUniformLocation(a, "translationMatrix");
		this.alpha = b.getUniformLocation(a, "alpha");
		this.program = a
	};
	e._batchs = [];
	e._getBatch = function(a) {
		return 0 === e._batchs.length ? new e.WebGLBatch(a) :
			e._batchs.pop()
	};
	e._returnBatch = function(a) {
		a.clean();
		e._batchs.push(a)
	};
	e._restoreBatchs = function(a) {
		for (var b = 0; b < e._batchs.length; b++) e._batchs[b].restoreLostContext(a)
	};
	e.WebGLBatch = function(a) {
		this.gl = a;
		this.size = 0;
		this.vertexBuffer = a.createBuffer();
		this.indexBuffer = a.createBuffer();
		this.uvBuffer = a.createBuffer();
		this.colorBuffer = a.createBuffer();
		this.blendMode = e.blendModes.NORMAL;
		this.dynamicSize = 1
	};
	e.WebGLBatch.prototype.constructor = e.WebGLBatch;
	e.WebGLBatch.prototype.clean = function() {
		this.verticies =
			[];
		this.uvs = [];
		this.indices = [];
		this.colors = [];
		this.dynamicSize = 1;
		this.last = this.texture = null;
		this.size = 0;
		this.head;
		this.tail
	};
	e.WebGLBatch.prototype.restoreLostContext = function(a) {
		this.gl = a;
		this.vertexBuffer = a.createBuffer();
		this.indexBuffer = a.createBuffer();
		this.uvBuffer = a.createBuffer();
		this.colorBuffer = a.createBuffer()
	};
	e.WebGLBatch.prototype.init = function(a) {
		a.batch = this;
		this.dirty = !0;
		this.blendMode = a.blendMode;
		this.texture = a.texture.baseTexture;
		this.tail = this.head = a;
		this.size = 1;
		this.growBatch()
	};
	e.WebGLBatch.prototype.insertBefore = function(a, b) {
		this.size++;
		a.batch = this;
		this.dirty = !0;
		var d = b.__prev;
		b.__prev = a;
		a.__next = b;
		d ? (a.__prev = d, d.__next = a) : this.head = a
	};
	e.WebGLBatch.prototype.insertAfter = function(a, b) {
		this.size++;
		a.batch = this;
		this.dirty = !0;
		var d = b.__next;
		b.__next = a;
		a.__prev = b;
		d ? (a.__next = d, d.__prev = a) : this.tail = a
	};
	e.WebGLBatch.prototype.remove = function(a) {
		this.size--;
		0 === this.size ? (a.batch = null, a.__prev = null, a.__next = null) : (a.__prev ? a.__prev.__next = a.__next : (this.head = a.__next, this.head.__prev =
			null), a.__next ? a.__next.__prev = a.__prev : (this.tail = a.__prev, this.tail.__next = null), a.batch = null, a.__next = null, a.__prev = null, this.dirty = !0)
	};
	e.WebGLBatch.prototype.split = function(a) {
		this.dirty = !0;
		var b = new e.WebGLBatch(this.gl);
		b.init(a);
		b.texture = this.texture;
		b.tail = this.tail;
		this.tail = a.__prev;
		this.tail.__next = null;
		a.__prev = null;
		for (var d = 0; a;) d++, a.batch = b, a = a.__next;
		b.size = d;
		this.size -= d;
		return b
	};
	e.WebGLBatch.prototype.merge = function(a) {
		this.dirty = !0;
		this.tail.__next = a.head;
		a.head.__prev = this.tail;
		this.size += a.size;
		this.tail = a.tail;
		for (a = a.head; a;) a.batch = this, a = a.__next
	};
	e.WebGLBatch.prototype.growBatch = function() {
		var a = this.gl;
		this.dynamicSize = 1 == this.size ? 1 : 1.5 * this.size;
		this.verticies = new Float32Array(8 * this.dynamicSize);
		a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
		a.bufferData(a.ARRAY_BUFFER, this.verticies, a.DYNAMIC_DRAW);
		this.uvs = new Float32Array(8 * this.dynamicSize);
		a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer);
		a.bufferData(a.ARRAY_BUFFER, this.uvs, a.DYNAMIC_DRAW);
		this.dirtyUVS = !0;
		this.colors =
			new Float32Array(4 * this.dynamicSize);
		a.bindBuffer(a.ARRAY_BUFFER, this.colorBuffer);
		a.bufferData(a.ARRAY_BUFFER, this.colors, a.DYNAMIC_DRAW);
		this.dirtyColors = !0;
		this.indices = new Uint16Array(6 * this.dynamicSize);
		for (var b = this.indices.length / 6, d = 0; d < b; d++) {
			var c = 6 * d,
				e = 4 * d;
			this.indices[c + 0] = e + 0;
			this.indices[c + 1] = e + 1;
			this.indices[c + 2] = e + 2;
			this.indices[c + 3] = e + 0;
			this.indices[c + 4] = e + 2;
			this.indices[c + 5] = e + 3
		}
		a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
		a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices,
			a.STATIC_DRAW)
	};
	e.WebGLBatch.prototype.refresh = function() {
		this.dynamicSize < this.size && this.growBatch();
		for (var a = 0, b, d = this.head; d;) {
			b = 8 * a;
			var c = d.texture,
				e = c.frame,
				f = c.baseTexture.width,
				c = c.baseTexture.height;
			this.uvs[b + 0] = e.x / f;
			this.uvs[b + 1] = e.y / c;
			this.uvs[b + 2] = (e.x + e.width) / f;
			this.uvs[b + 3] = e.y / c;
			this.uvs[b + 4] = (e.x + e.width) / f;
			this.uvs[b + 5] = (e.y + e.height) / c;
			this.uvs[b + 6] = e.x / f;
			this.uvs[b + 7] = (e.y + e.height) / c;
			d.updateFrame = !1;
			colorIndex = 4 * a;
			this.colors[colorIndex] = this.colors[colorIndex + 1] = this.colors[colorIndex +
				2] = this.colors[colorIndex + 3] = d.worldAlpha;
			d = d.__next;
			a++
		}
		this.dirtyColors = this.dirtyUVS = !0
	};
	e.WebGLBatch.prototype.update = function() {
		for (var a, b, d, c, h, f, k, m, l, n, q, t = 0, p = this.head, v = this.verticies, w = this.uvs, z = this.colors; p;) {
			if (p.vcount === e.visibleCount) {
				b = p.texture.frame.width;
				d = p.texture.frame.height;
				c = p.anchor.x;
				h = p.anchor.y;
				f = b * (1 - c);
				b *= -c;
				c = d * (1 - h);
				h = d * -h;
				d = 8 * t;
				a = p.worldTransform;
				k = a[0];
				m = a[3];
				l = a[1];
				n = a[4];
				q = a[2];
				a = a[5];
				v[d + 0] = k * b + l * h + q;
				v[d + 1] = n * h + m * b + a;
				v[d + 2] = k * f + l * h + q;
				v[d + 3] = n * h + m * f + a;
				v[d +
					4] = k * f + l * c + q;
				v[d + 5] = n * c + m * f + a;
				v[d + 6] = k * b + l * c + q;
				v[d + 7] = n * c + m * b + a;
				if (p.updateFrame || p.texture.updateFrame) this.dirtyUVS = !0, c = p.texture, f = c.frame, b = c.baseTexture.width, c = c.baseTexture.height, w[d + 0] = f.x / b, w[d + 1] = f.y / c, w[d + 2] = (f.x + f.width) / b, w[d + 3] = f.y / c, w[d + 4] = (f.x + f.width) / b, w[d + 5] = (f.y + f.height) / c, w[d + 6] = f.x / b, w[d + 7] = (f.y + f.height) / c, p.updateFrame = !1;
				p.cacheAlpha != p.worldAlpha && (p.cacheAlpha = p.worldAlpha, f = 4 * t, z[f] = z[f + 1] = z[f + 2] = z[f + 3] = p.worldAlpha, this.dirtyColors = !0)
			} else d = 8 * t, v[d + 0] = v[d + 1] = v[d +
				2] = v[d + 3] = v[d + 4] = v[d + 5] = v[d + 6] = v[d + 7] = 0;
			t++;
			p = p.__next
		}
	};
	e.WebGLBatch.prototype.render = function(a, b) {
		a = a || 0;
		void 0 == b && (b = this.size);
		this.dirty && (this.refresh(), this.dirty = !1);
		if (0 !== this.size) {
			this.update();
			var d = this.gl,
				c = e.defaultShader;
			d.bindBuffer(d.ARRAY_BUFFER, this.vertexBuffer);
			d.bufferSubData(d.ARRAY_BUFFER, 0, this.verticies);
			d.vertexAttribPointer(c.aVertexPosition, 2, d.FLOAT, !1, 0, 0);
			d.bindBuffer(d.ARRAY_BUFFER, this.uvBuffer);
			this.dirtyUVS && (this.dirtyUVS = !1, d.bufferSubData(d.ARRAY_BUFFER,
				0, this.uvs));
			d.vertexAttribPointer(c.aTextureCoord, 2, d.FLOAT, !1, 0, 0);
			d.activeTexture(d.TEXTURE0);
			d.bindTexture(d.TEXTURE_2D, this.texture._glTexture);
			d.bindBuffer(d.ARRAY_BUFFER, this.colorBuffer);
			this.dirtyColors && (this.dirtyColors = !1, d.bufferSubData(d.ARRAY_BUFFER, 0, this.colors));
			d.vertexAttribPointer(c.colorAttribute, 1, d.FLOAT, !1, 0, 0);
			d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
			d.drawElements(d.TRIANGLES, 6 * (b - a), d.UNSIGNED_SHORT, 12 * a)
		}
	};
	e.WebGLFilterManager = function(a) {
		this.transparent =
			a;
		this.filterStack = [];
		this.texturePool = [];
		this.offsetY = this.offsetX = 0;
		this.initShaderBuffers()
	};
	e.WebGLFilterManager.prototype.begin = function(a, b) {
		this.width = 2 * a.x;
		this.height = 2 * -a.y;
		this.buffer = b
	};
	e.WebGLFilterManager.prototype.pushFilter = function(a) {
		var b = e.gl;
		this.filterStack.push(a);
		var d = a.filterPasses[0];
		this.offsetX += a.target.filterArea.x;
		this.offsetY += a.target.filterArea.y;
		var c = this.texturePool.pop();
		c || (c = new e.FilterTexture(this.width, this.height));
		b.bindTexture(b.TEXTURE_2D, c.texture);
		this.getBounds(a.target);
		var h = a.target.filterArea,
			d = d.padding;
		h.x -= d;
		h.y -= d;
		h.width += 2 * d;
		h.height += 2 * d;
		0 > h.x && (h.x = 0);
		h.width > this.width && (h.width = this.width);
		0 > h.y && (h.y = 0);
		h.height > this.height && (h.height = this.height);
		b.bindFramebuffer(b.FRAMEBUFFER, c.frameBuffer);
		b.viewport(0, 0, h.width, h.height);
		e.projection.x = h.width / 2;
		e.projection.y = -h.height / 2;
		e.offset.x = -h.x;
		e.offset.y = -h.y;
		b.uniform2f(e.defaultShader.projectionVector, h.width / 2, -h.height / 2);
		b.uniform2f(e.defaultShader.offsetVector, -h.x, -h.y);
		b.colorMask(!0, !0, !0, !0);
		b.clearColor(0, 0, 0, 0);
		b.clear(b.COLOR_BUFFER_BIT);
		a._glFilterTexture = c
	};
	e.WebGLFilterManager.prototype.popFilter = function() {
		var a = e.gl,
			b = this.filterStack.pop(),
			d = b.target.filterArea,
			c = b._glFilterTexture;
		if (1 < b.filterPasses.length) {
			a.viewport(0, 0, d.width, d.height);
			a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
			this.vertexArray[0] = 0;
			this.vertexArray[1] = d.height;
			this.vertexArray[2] = d.width;
			this.vertexArray[3] = d.height;
			this.vertexArray[4] = 0;
			this.vertexArray[5] = 0;
			this.vertexArray[6] =
				d.width;
			this.vertexArray[7] = 0;
			a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray);
			a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer);
			this.uvArray[2] = d.width / this.width;
			this.uvArray[5] = d.height / this.height;
			this.uvArray[6] = d.width / this.width;
			this.uvArray[7] = d.height / this.height;
			a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray);
			var h = this.texturePool.pop();
			h || (h = new e.FilterTexture(this.width, this.height));
			a.bindFramebuffer(a.FRAMEBUFFER, h.frameBuffer);
			a.clear(a.COLOR_BUFFER_BIT);
			a.disable(a.BLEND);
			for (var f = 0; f <
				b.filterPasses.length - 1; f++) {
				var k = b.filterPasses[f];
				a.bindFramebuffer(a.FRAMEBUFFER, h.frameBuffer);
				a.activeTexture(a.TEXTURE0);
				a.bindTexture(a.TEXTURE_2D, c.texture);
				this.applyFilterPass(k, d, d.width, d.height);
				k = c;
				c = h;
				h = k
			}
			a.enable(a.BLEND);
			this.texturePool.push(h)
		}
		h = b.filterPasses[b.filterPasses.length - 1];
		this.offsetX -= d.x;
		this.offsetY -= d.y;
		var f = this.width,
			k = this.height,
			m = 0,
			l = 0,
			n = this.buffer;
		0 === this.filterStack.length ? a.colorMask(!0, !0, !0, this.transparent) : (n = this.filterStack[this.filterStack.length -
			1], d = n.target.filterArea, f = d.width, k = d.height, m = d.x, l = d.y, n = n._glFilterTexture.frameBuffer);
		e.projection.x = f / 2;
		e.projection.y = -k / 2;
		e.offset.x = m;
		e.offset.y = l;
		var d = b.target.filterArea,
			q = d.x - m,
			t = d.y - l;
		a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
		this.vertexArray[0] = q;
		this.vertexArray[1] = t + d.height;
		this.vertexArray[2] = q + d.width;
		this.vertexArray[3] = t + d.height;
		this.vertexArray[4] = q;
		this.vertexArray[5] = t;
		this.vertexArray[6] = q + d.width;
		this.vertexArray[7] = t;
		a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray);
		a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer);
		this.uvArray[2] = d.width / this.width;
		this.uvArray[5] = d.height / this.height;
		this.uvArray[6] = d.width / this.width;
		this.uvArray[7] = d.height / this.height;
		a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray);
		a.viewport(0, 0, f, k);
		a.bindFramebuffer(a.FRAMEBUFFER, n);
		a.activeTexture(a.TEXTURE0);
		a.bindTexture(a.TEXTURE_2D, c.texture);
		this.applyFilterPass(h, d, f, k);
		a.useProgram(e.defaultShader.program);
		a.uniform2f(e.defaultShader.projectionVector, f / 2, -k / 2);
		a.uniform2f(e.defaultShader.offsetVector, -m, -l);
		this.texturePool.push(c);
		b._glFilterTexture = null
	};
	e.WebGLFilterManager.prototype.applyFilterPass = function(a, b, d, c) {
		b = e.gl;
		if (!a.shader) {
			var h = new e.PixiShader;
			h.fragmentSrc = a.fragmentSrc;
			h.uniforms = a.uniforms;
			h.init();
			a.shader = h
		}
		h = a.shader;
		b.useProgram(h.program);
		b.uniform2f(h.projectionVector, d / 2, -c / 2);
		b.uniform2f(h.offsetVector, 0, 0);
		a.uniforms.dimensions && (a.uniforms.dimensions.value[0] = this.width, a.uniforms.dimensions.value[1] = this.height, a.uniforms.dimensions.value[2] = this.vertexArray[0],
			a.uniforms.dimensions.value[3] = this.vertexArray[5]);
		h.syncUniforms();
		b.bindBuffer(b.ARRAY_BUFFER, this.vertexBuffer);
		b.vertexAttribPointer(h.aVertexPosition, 2, b.FLOAT, !1, 0, 0);
		b.bindBuffer(b.ARRAY_BUFFER, this.uvBuffer);
		b.vertexAttribPointer(h.aTextureCoord, 2, b.FLOAT, !1, 0, 0);
		b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
		b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0)
	};
	e.WebGLFilterManager.prototype.initShaderBuffers = function() {
		var a = e.gl;
		this.vertexBuffer = a.createBuffer();
		this.uvBuffer = a.createBuffer();
		this.indexBuffer = a.createBuffer();
		this.vertexArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
		a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
		a.bufferData(a.ARRAY_BUFFER, this.vertexArray, a.STATIC_DRAW);
		this.uvArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
		a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer);
		a.bufferData(a.ARRAY_BUFFER, this.uvArray, a.STATIC_DRAW);
		a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
		a.bufferData(a.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), a.STATIC_DRAW)
	};
	e.WebGLFilterManager.prototype.getBounds =
		function(a) {
			var b, d, c, h, f, k, m, l, n, q, t, p, v, w, z, A, y = a.first,
				B = a.last._iNext,
				C = -Infinity,
				s = -Infinity,
				r = Infinity,
				D = Infinity;
			do y.visible && (y instanceof e.Sprite ? (d = y.texture.frame.width, c = y.texture.frame.height, h = y.anchor.x, f = y.anchor.y, k = d * (1 - h), d *= -h, h = c * (1 - f), c *= -f, f = !0) : y instanceof e.Graphics && (y.updateFilterBounds(), c = y.bounds, k = c.x, d = c.x + c.width, h = c.y, c = c.y + c.height, f = !0)), f && (b = y.worldTransform, m = b[0], f = b[3], l = b[1], n = b[4], q = b[2], t = b[5], b = m * d + l * c + q, w = n * c + f * d + t, p = m * k + l * c + q, z = n * c + f * k + t, v = m * k + l * h +
				q, A = n * h + f * k + t, m = m * d + l * h + q, f = n * h + f * d + t, r = b < r ? b : r, r = p < r ? p : r, r = v < r ? v : r, r = m < r ? m : r, D = w < D ? w : D, D = z < D ? z : D, D = A < D ? A : D, D = f < D ? f : D, C = b > C ? b : C, C = p > C ? p : C, C = v > C ? v : C, C = m > C ? m : C, s = w > s ? w : s, s = z > s ? z : s, s = A > s ? A : s, s = f > s ? f : s), f = !1, y = y._iNext; while (y != B);
			a.filterArea.x = r;
			a.filterArea.y = D;
			a.filterArea.width = C - r;
			a.filterArea.height = s - D
	};
	e.FilterTexture = function(a, b) {
		var d = e.gl;
		this.frameBuffer = d.createFramebuffer();
		this.texture = d.createTexture();
		d.bindTexture(d.TEXTURE_2D, this.texture);
		d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER,
			d.LINEAR);
		d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.LINEAR);
		d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE);
		d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE);
		d.bindFramebuffer(d.FRAMEBUFFER, this.framebuffer);
		d.bindFramebuffer(d.FRAMEBUFFER, this.frameBuffer);
		d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, this.texture, 0);
		this.resize(a, b)
	};
	e.FilterTexture.prototype.resize = function(a, b) {
		this.width = a;
		this.height = b;
		var d = e.gl;
		d.bindTexture(d.TEXTURE_2D,
			this.texture);
		d.texImage2D(d.TEXTURE_2D, 0, d.RGBA, a, b, 0, d.RGBA, d.UNSIGNED_BYTE, null)
	};
	e.WebGLGraphics = function() {};
	e.WebGLGraphics.renderGraphics = function(a, b) {
		var d = e.gl;
		a._webGL || (a._webGL = {
			points: [],
			indices: [],
			lastIndex: 0,
			buffer: d.createBuffer(),
			indexBuffer: d.createBuffer()
		});
		a.dirty && (a.dirty = !1, a.clearDirty && (a.clearDirty = !1, a._webGL.lastIndex = 0, a._webGL.points = [], a._webGL.indices = []), e.WebGLGraphics.updateGraphics(a));
		e.activatePrimitiveShader();
		var c = e.mat3.clone(a.worldTransform);
		e.mat3.transpose(c);
		d.blendFunc(d.ONE, d.ONE_MINUS_SRC_ALPHA);
		d.uniformMatrix3fv(e.primitiveShader.translationMatrix, !1, c);
		d.uniform2f(e.primitiveShader.projectionVector, b.x, -b.y);
		d.uniform2f(e.primitiveShader.offsetVector, -e.offset.x, -e.offset.y);
		d.uniform1f(e.primitiveShader.alpha, a.worldAlpha);
		d.bindBuffer(d.ARRAY_BUFFER, a._webGL.buffer);
		d.vertexAttribPointer(e.primitiveShader.aVertexPosition, 2, d.FLOAT, !1, 24, 0);
		d.vertexAttribPointer(e.primitiveShader.colorAttribute, 4, d.FLOAT, !1, 24, 8);
		d.bindBuffer(d.ELEMENT_ARRAY_BUFFER,
			a._webGL.indexBuffer);
		d.drawElements(d.TRIANGLE_STRIP, a._webGL.indices.length, d.UNSIGNED_SHORT, 0);
		e.deactivatePrimitiveShader()
	};
	e.WebGLGraphics.updateGraphics = function(a) {
		for (var b = a._webGL.lastIndex; b < a.graphicsData.length; b++) {
			var d = a.graphicsData[b];
			d.type == e.Graphics.POLY ? (d.fill && 3 < d.points.length && e.WebGLGraphics.buildPoly(d, a._webGL), 0 < d.lineWidth && e.WebGLGraphics.buildLine(d, a._webGL)) : d.type == e.Graphics.RECT ? e.WebGLGraphics.buildRectangle(d, a._webGL) : d.type != e.Graphics.CIRC && d.type != e.Graphics.ELIP ||
				e.WebGLGraphics.buildCircle(d, a._webGL)
		}
		a._webGL.lastIndex = a.graphicsData.length;
		b = e.gl;
		a._webGL.glPoints = new Float32Array(a._webGL.points);
		b.bindBuffer(b.ARRAY_BUFFER, a._webGL.buffer);
		b.bufferData(b.ARRAY_BUFFER, a._webGL.glPoints, b.STATIC_DRAW);
		a._webGL.glIndicies = new Uint16Array(a._webGL.indices);
		b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, a._webGL.indexBuffer);
		b.bufferData(b.ELEMENT_ARRAY_BUFFER, a._webGL.glIndicies, b.STATIC_DRAW)
	};
	e.WebGLGraphics.buildRectangle = function(a, b) {
		var d = a.points,
			c = d[0],
			h = d[1],
			g = d[2],
			d = d[3];
		if (a.fill) {
			var k = f(a.fillColor),
				m = a.fillAlpha,
				l = k[0] * m,
				n = k[1] * m,
				k = k[2] * m,
				q = b.points,
				t = b.indices,
				p = q.length / 6;
			q.push(c, h);
			q.push(l, n, k, m);
			q.push(c + g, h);
			q.push(l, n, k, m);
			q.push(c, h + d);
			q.push(l, n, k, m);
			q.push(c + g, h + d);
			q.push(l, n, k, m);
			t.push(p, p, p + 1, p + 2, p + 3, p + 3)
		}
		a.lineWidth && (a.points = [c, h, c + g, h, c + g, h + d, c, h + d, c, h], e.WebGLGraphics.buildLine(a, b))
	};
	e.WebGLGraphics.buildCircle = function(a, b) {
		var d = a.points,
			c = d[0],
			h = d[1],
			g = d[2],
			d = d[3],
			k = 2 * Math.PI / 40;
		if (a.fill) {
			var m = f(a.fillColor),
				l = a.fillAlpha,
				n = m[0] * l,
				q = m[1] * l,
				m = m[2] * l,
				t = b.points,
				p = b.indices,
				v = t.length / 6;
			p.push(v);
			for (var w = 0; 41 > w; w++) t.push(c, h, n, q, m, l), t.push(c + Math.sin(k * w) * g, h + Math.cos(k * w) * d, n, q, m, l), p.push(v++, v++);
			p.push(v - 1)
		}
		if (a.lineWidth) {
			a.points = [];
			for (w = 0; 41 > w; w++) a.points.push(c + Math.sin(k * w) * g, h + Math.cos(k * w) * d);
			e.WebGLGraphics.buildLine(a, b)
		}
	};
	e.WebGLGraphics.buildLine = function(a, b) {
		var d = a.points;
		if (0 !== d.length) {
			if (a.lineWidth % 2)
				for (var c = 0; c < d.length; c++) d[c] += 0.5;
			var h = new e.Point(d[0], d[1]),
				g = new e.Point(d[d.length -
					2], d[d.length - 1]);
			if (h.x == g.x && h.y == g.y) {
				d.pop();
				d.pop();
				var g = new e.Point(d[d.length - 2], d[d.length - 1]),
					k = g.x + 0.5 * (h.x - g.x),
					h = g.y + 0.5 * (h.y - g.y);
				d.unshift(k, h);
				d.push(k, h)
			}
			var k = b.points,
				h = b.indices,
				g = d.length / 2,
				m = d.length,
				l = k.length / 6,
				n = a.lineWidth / 2,
				c = f(a.lineColor),
				q = a.lineAlpha,
				t = c[0] * q,
				p = c[1] * q,
				v = c[2] * q,
				w, z, A, y, B, C, s, r, D, G, E, H, I;
			w = d[0];
			z = d[1];
			A = d[2];
			y = d[3];
			s = -(z - y);
			r = w - A;
			E = Math.sqrt(s * s + r * r);
			s = s / E * n;
			r = r / E * n;
			k.push(w - s, z - r, t, p, v, q);
			k.push(w + s, z + r, t, p, v, q);
			for (c = 1; c < g - 1; c++) w = d[2 * (c - 1)], z = d[2 * (c -
				1) + 1], A = d[2 * c], y = d[2 * c + 1], B = d[2 * (c + 1)], C = d[2 * (c + 1) + 1], s = -(z - y), r = w - A, E = Math.sqrt(s * s + r * r), s /= E, r /= E, s *= n, r *= n, D = -(y - C), G = A - B, E = Math.sqrt(D * D + G * G), D /= E, G /= E, D *= n, G *= n, E = -r + z - (-r + y), H = -s + A - (-s + w), w = (-s + w) * (-r + y) - (-s + A) * (-r + z), z = -G + C - (-G + y), I = -D + A - (-D + B), B = (-D + B) * (-G + y) - (-D + A) * (-G + C), C = E * I - z * H, 0.1 > Math.abs(C) ? (k.push(A - s, y - r, t, p, v, q), k.push(A + s, y + r, t, p, v, q)) : (px = (H * B - I * w) / C, py = (z * w - E * B) / C, E = (px - A) * (px - A) + (py - y) + (py - y), 19600 < E ? (s -= D, r -= G, E = Math.sqrt(s * s + r * r), s /= E, r /= E, s *= n, r *= n, k.push(A - s, y - r), k.push(t,
				p, v, q), k.push(A + s, y + r), k.push(t, p, v, q), k.push(A - s, y - r), k.push(t, p, v, q), m++) : (k.push(px, py), k.push(t, p, v, q), k.push(A - (px - A), y - (py - y)), k.push(t, p, v, q)));
			w = d[2 * (g - 2)];
			z = d[2 * (g - 2) + 1];
			A = d[2 * (g - 1)];
			y = d[2 * (g - 1) + 1];
			s = -(z - y);
			r = w - A;
			E = Math.sqrt(s * s + r * r);
			s /= E;
			r /= E;
			s *= n;
			r *= n;
			k.push(A - s, y - r);
			k.push(t, p, v, q);
			k.push(A + s, y + r);
			k.push(t, p, v, q);
			h.push(l);
			for (c = 0; c < m; c++) h.push(l++);
			h.push(l - 1)
		}
	};
	e.WebGLGraphics.buildPoly = function(a, b) {
		var d = a.points;
		if (!(6 > d.length)) {
			for (var c = b.points, h = b.indices, g = d.length / 2, k = f(a.fillColor),
				m = a.fillAlpha, l = k[0] * m, n = k[1] * m, k = k[2] * m, q = e.PolyK.Triangulate(d), t = c.length / 6, p = 0; p < q.length; p += 3) h.push(q[p] + t), h.push(q[p] + t), h.push(q[p + 1] + t), h.push(q[p + 2] + t), h.push(q[p + 2] + t);
			for (p = 0; p < g; p++) c.push(d[2 * p], d[2 * p + 1], l, n, k, m)
		}
	};
	e._defaultFrame = new e.Rectangle(0, 0, 1, 1);
	e.gl;
	e.WebGLRenderer = function(a, b, d, c, h) {
		this.transparent = !!c;
		this.width = a || 800;
		this.height = b || 600;
		this.view = d || document.createElement("canvas");
		this.view.width = this.width;
		this.view.height = this.height;
		var f = this;
		this.view.addEventListener("webglcontextlost",
			function(a) {
				f.handleContextLost(a)
			}, !1);
		this.view.addEventListener("webglcontextrestored", function(a) {
			f.handleContextRestored(a)
		}, !1);
		this.batchs = [];
		a = {
			alpha: this.transparent,
			antialias: !!h,
			premultipliedAlpha: !1,
			stencil: !0
		};
		try {
			e.gl = this.gl = this.view.getContext("experimental-webgl", a)
		} catch (k) {
			try {
				e.gl = this.gl = this.view.getContext("webgl", a)
			} catch (m) {
				throw Error(" This browser does not support webGL. Try using the canvas renderer" + this);
			}
		}
		e.initDefaultShaders();
		a = this.gl;
		a.useProgram(e.defaultShader.program);
		e.WebGLRenderer.gl = a;
		this.batch = new e.WebGLBatch(a);
		a.disable(a.DEPTH_TEST);
		a.disable(a.CULL_FACE);
		a.enable(a.BLEND);
		a.colorMask(!0, !0, !0, this.transparent);
		e.projection = new e.Point(400, 300);
		e.offset = new e.Point(0, 0);
		this.resize(this.width, this.height);
		this.contextLost = !1;
		this.stageRenderGroup = new e.WebGLRenderGroup(this.gl, this.transparent)
	};
	e.WebGLRenderer.prototype.constructor = e.WebGLRenderer;
	e.WebGLRenderer.getBatch = function() {
		return 0 === e._batchs.length ? new e.WebGLBatch(e.WebGLRenderer.gl) : e._batchs.pop()
	};
	e.WebGLRenderer.returnBatch = function(a) {
		a.clean();
		e._batchs.push(a)
	};
	e.WebGLRenderer.prototype.render = function(a) {
		if (!this.contextLost) {
			this.__stage !== a && (this.__stage = a, this.stageRenderGroup.setRenderable(a));
			e.WebGLRenderer.updateTextures();
			e.visibleCount++;
			a.updateTransform();
			var b = this.gl;
			b.colorMask(!0, !0, !0, this.transparent);
			b.viewport(0, 0, this.width, this.height);
			b.bindFramebuffer(b.FRAMEBUFFER, null);
			b.clearColor(a.backgroundColorSplit[0], a.backgroundColorSplit[1], a.backgroundColorSplit[2], !this.transparent);
			b.clear(b.COLOR_BUFFER_BIT);
			this.stageRenderGroup.backgroundColor = a.backgroundColorSplit;
			e.projection.x = this.width / 2;
			e.projection.y = -this.height / 2;
			this.stageRenderGroup.render(e.projection);
			a.interactive && !a._interactiveEventsAdded && (a._interactiveEventsAdded = !0, a.interactionManager.setTarget(this));
			if (0 < e.Texture.frameUpdates.length) {
				for (a = 0; a < e.Texture.frameUpdates.length; a++) e.Texture.frameUpdates[a].updateFrame = !1;
				e.Texture.frameUpdates = []
			}
		}
	};
	e.WebGLRenderer.updateTextures =
		function() {
			for (var a = 0; a < e.texturesToUpdate.length; a++) e.WebGLRenderer.updateTexture(e.texturesToUpdate[a]);
			for (a = 0; a < e.texturesToDestroy.length; a++) e.WebGLRenderer.destroyTexture(e.texturesToDestroy[a]);
			e.texturesToUpdate = [];
			e.texturesToDestroy = []
	};
	e.WebGLRenderer.updateTexture = function(a) {
		var b = e.gl;
		a._glTexture || (a._glTexture = b.createTexture());
		a.hasLoaded && (b.bindTexture(b.TEXTURE_2D, a._glTexture), b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE,
			a.source), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.LINEAR), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR), a._powerOf2 ? (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.REPEAT), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.REPEAT)) : (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE)), b.bindTexture(b.TEXTURE_2D, null))
	};
	e.WebGLRenderer.destroyTexture = function(a) {
		var b = e.gl;
		a._glTexture && (a._glTexture =
			b.createTexture(), b.deleteTexture(b.TEXTURE_2D, a._glTexture))
	};
	e.WebGLRenderer.prototype.resize = function(a, b) {
		this.width = a;
		this.height = b;
		this.view.width = a;
		this.view.height = b;
		this.gl.viewport(0, 0, this.width, this.height);
		e.projection.x = this.width / 2;
		e.projection.y = -this.height / 2
	};
	e.WebGLRenderer.prototype.handleContextLost = function(a) {
		a.preventDefault();
		this.contextLost = !0
	};
	e.WebGLRenderer.prototype.handleContextRestored = function(a) {
		this.gl = this.view.getContext("experimental-webgl", {
			alpha: !0
		});
		this.initShaders();
		for (var b in e.TextureCache) a = e.TextureCache[b].baseTexture, a._glTexture = null, e.WebGLRenderer.updateTexture(a);
		for (b = 0; b < this.batchs.length; b++) this.batchs[b].restoreLostContext(this.gl), this.batchs[b].dirty = !0;
		e._restoreBatchs(this.gl);
		this.contextLost = !1
	};
	e.WebGLRenderGroup = function(a, b) {
		this.gl = a;
		this.root;
		this.backgroundColor;
		this.transparent = void 0 == b ? !0 : b;
		this.batchs = [];
		this.toRemove = [];
		this.filterManager = new e.WebGLFilterManager(this.transparent)
	};
	e.WebGLRenderGroup.prototype.constructor = e.WebGLRenderGroup;
	e.WebGLRenderGroup.prototype.setRenderable = function(a) {
		this.root && this.removeDisplayObjectAndChildren(this.root);
		a.worldVisible = a.visible;
		this.root = a;
		this.addDisplayObjectAndChildren(a)
	};
	e.WebGLRenderGroup.prototype.render = function(a, b) {
		e.WebGLRenderer.updateTextures();
		var d = this.gl;
		d.uniform2f(e.defaultShader.projectionVector, a.x, a.y);
		this.filterManager.begin(a, b);
		d.blendFunc(d.ONE, d.ONE_MINUS_SRC_ALPHA);
		for (var c = 0; c < this.batchs.length; c++) d = this.batchs[c], d instanceof e.WebGLBatch ? this.batchs[c].render() :
			this.renderSpecial(d, a)
	};
	e.WebGLRenderGroup.prototype.renderSpecific = function(a, b, d) {
		e.WebGLRenderer.updateTextures();
		this.gl.uniform2f(e.defaultShader.projectionVector, b.x, b.y);
		this.filterManager.begin(b, d);
		for (var c, h, f, k = a.first; k._iNext && (!k.renderable || !k.__renderGroup);) k = k._iNext;
		d = k.batch;
		if (k instanceof e.Sprite)
			if (d = k.batch, h = d.head, h == k) c = 0;
			else
				for (c = 1; h.__next != k;) c++, h = h.__next;
		else d = k;
		for (a = a.last; a._iPrev && (!a.renderable || !a.__renderGroup);) a = a._iNext;
		if (a instanceof e.Sprite)
			if (endBatch =
				a.batch, h = endBatch.head, h == a) f = 0;
			else
				for (f = 1; h.__next != a;) f++, h = h.__next;
		else endBatch = a; if (d == endBatch) d instanceof e.WebGLBatch ? d.render(c, f + 1) : this.renderSpecial(d, b);
		else {
			h = this.batchs.indexOf(d);
			a = this.batchs.indexOf(endBatch);
			d instanceof e.WebGLBatch ? d.render(c) : this.renderSpecial(d, b);
			for (c = h + 1; c < a; c++) renderable = this.batchs[c], renderable instanceof e.WebGLBatch ? this.batchs[c].render() : this.renderSpecial(renderable, b);
			endBatch instanceof e.WebGLBatch ? endBatch.render(0, f + 1) : this.renderSpecial(endBatch,
				b)
		}
	};
	e.WebGLRenderGroup.prototype.renderSpecial = function(a, b) {
		var d = a.vcount === e.visibleCount;
		a instanceof e.TilingSprite ? d && this.renderTilingSprite(a, b) : a instanceof e.Strip ? d && this.renderStrip(a, b) : a instanceof e.CustomRenderable ? d && a.renderWebGL(this, b) : a instanceof e.Graphics ? d && a.renderable && e.WebGLGraphics.renderGraphics(a, b) : a instanceof e.FilterBlock && this.handleFilterBlock(a, b)
	};
	flip = !1;
	var l = [],
		n = 0;
	e.WebGLRenderGroup.prototype.handleFilterBlock = function(a, b) {
		var d = e.gl;
		if (a.open) a.data instanceof
		Array ? this.filterManager.pushFilter(a) : (n++, l.push(a), d.enable(d.STENCIL_TEST), d.colorMask(!1, !1, !1, !1), d.stencilFunc(d.ALWAYS, 1, 1), d.stencilOp(d.KEEP, d.KEEP, d.INCR), e.WebGLGraphics.renderGraphics(a.data, b), d.colorMask(!0, !0, !0, !0), d.stencilFunc(d.NOTEQUAL, 0, l.length), d.stencilOp(d.KEEP, d.KEEP, d.KEEP));
		else if (a.data instanceof Array) this.filterManager.popFilter();
		else {
			var c = l.pop(a);
			c && (d.colorMask(!1, !1, !1, !1), d.stencilFunc(d.ALWAYS, 1, 1), d.stencilOp(d.KEEP, d.KEEP, d.DECR), e.WebGLGraphics.renderGraphics(c.data,
				b), d.colorMask(!0, !0, !0, !0), d.stencilFunc(d.NOTEQUAL, 0, l.length), d.stencilOp(d.KEEP, d.KEEP, d.KEEP));
			d.disable(d.STENCIL_TEST)
		}
	};
	e.WebGLRenderGroup.prototype.updateTexture = function(a) {
		this.removeObject(a);
		for (var b = a.first; b != this.root && (b = b._iPrev, !b.renderable || !b.__renderGroup););
		for (var d = a.last; d._iNext && (d = d._iNext, !d.renderable || !d.__renderGroup););
		this.insertObject(a, b, d)
	};
	e.WebGLRenderGroup.prototype.addFilterBlocks = function(a, b) {
		a.__renderGroup = this;
		b.__renderGroup = this;
		for (var d = a; d != this.root.first &&
			(d = d._iPrev, !d.renderable || !d.__renderGroup););
		this.insertAfter(a, d);
		for (d = b; d != this.root.first && (d = d._iPrev, !d.renderable || !d.__renderGroup););
		this.insertAfter(b, d)
	};
	e.WebGLRenderGroup.prototype.removeFilterBlocks = function(a, b) {
		this.removeObject(a);
		this.removeObject(b)
	};
	e.WebGLRenderGroup.prototype.addDisplayObjectAndChildren = function(a) {
		a.__renderGroup && a.__renderGroup.removeDisplayObjectAndChildren(a);
		for (var b = a.first; b != this.root.first && (b = b._iPrev, !b.renderable || !b.__renderGroup););
		for (var d =
			a.last; d._iNext && (d = d._iNext, !d.renderable || !d.__renderGroup););
		var c = a.first;
		a = a.last._iNext;
		do c.__renderGroup = this, c.renderable && (this.insertObject(c, b, d), b = c), c = c._iNext; while (c != a)
	};
	e.WebGLRenderGroup.prototype.removeDisplayObjectAndChildren = function(a) {
		if (a.__renderGroup == this) {
			do a.__renderGroup = null, a.renderable && this.removeObject(a), a = a._iNext; while (a)
		}
	};
	e.WebGLRenderGroup.prototype.insertObject = function(a, b, d) {
		if (a instanceof e.Sprite) {
			var c;
			if (b instanceof e.Sprite) {
				if ((c = b.batch) && c.texture ==
					a.texture.baseTexture && c.blendMode == a.blendMode) {
					c.insertAfter(a, b);
					return
				}
			} else c = b; if (d && d instanceof e.Sprite && (b = d.batch)) {
				if (b.texture == a.texture.baseTexture && b.blendMode == a.blendMode) {
					b.insertBefore(a, d);
					return
				}
				if (b == c) {
					d = c.split(d);
					b = e.WebGLRenderer.getBatch();
					c = this.batchs.indexOf(c);
					b.init(a);
					this.batchs.splice(c + 1, 0, b, d);
					return
				}
			}
			b = e.WebGLRenderer.getBatch();
			b.init(a);
			c ? (c = this.batchs.indexOf(c), this.batchs.splice(c + 1, 0, b)) : this.batchs.push(b)
		} else a instanceof e.TilingSprite ? this.initTilingSprite(a) :
			a instanceof e.Strip && this.initStrip(a), this.insertAfter(a, b)
	};
	e.WebGLRenderGroup.prototype.insertAfter = function(a, b) {
		if (b instanceof e.Sprite) {
			var d = b.batch;
			if (d)
				if (d.tail == b) d = this.batchs.indexOf(d), this.batchs.splice(d + 1, 0, a);
				else {
					var c = d.split(b.__next),
						d = this.batchs.indexOf(d);
					this.batchs.splice(d + 1, 0, a, c)
				} else this.batchs.push(a)
		} else d = this.batchs.indexOf(b), this.batchs.splice(d + 1, 0, a)
	};
	e.WebGLRenderGroup.prototype.removeObject = function(a) {
		var b;
		if (a instanceof e.Sprite) {
			var d = a.batch;
			if (!d) return;
			d.remove(a);
			0 == d.size && (b = d)
		} else b = a;
		b && (a = this.batchs.indexOf(b), -1 != a && (0 !== a && a != this.batchs.length - 1 && this.batchs[a - 1] instanceof e.WebGLBatch && this.batchs[a + 1] instanceof e.WebGLBatch && this.batchs[a - 1].texture == this.batchs[a + 1].texture && this.batchs[a - 1].blendMode == this.batchs[a + 1].blendMode ? (this.batchs[a - 1].merge(this.batchs[a + 1]), b instanceof e.WebGLBatch && e.WebGLRenderer.returnBatch(b), e.WebGLRenderer.returnBatch(this.batchs[a + 1]), this.batchs.splice(a, 2)) : (this.batchs.splice(a, 1), b instanceof e.WebGLBatch && e.WebGLRenderer.returnBatch(b))))
	};
	e.WebGLRenderGroup.prototype.initTilingSprite = function(a) {
		var b = this.gl;
		a.verticies = new Float32Array([0, 0, a.width, 0, a.width, a.height, 0, a.height]);
		a.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
		a.colors = new Float32Array([1, 1, 1, 1]);
		a.indices = new Uint16Array([0, 1, 3, 2]);
		a._vertexBuffer = b.createBuffer();
		a._indexBuffer = b.createBuffer();
		a._uvBuffer = b.createBuffer();
		a._colorBuffer = b.createBuffer();
		b.bindBuffer(b.ARRAY_BUFFER, a._vertexBuffer);
		b.bufferData(b.ARRAY_BUFFER,
			a.verticies, b.STATIC_DRAW);
		b.bindBuffer(b.ARRAY_BUFFER, a._uvBuffer);
		b.bufferData(b.ARRAY_BUFFER, a.uvs, b.DYNAMIC_DRAW);
		b.bindBuffer(b.ARRAY_BUFFER, a._colorBuffer);
		b.bufferData(b.ARRAY_BUFFER, a.colors, b.STATIC_DRAW);
		b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, a._indexBuffer);
		b.bufferData(b.ELEMENT_ARRAY_BUFFER, a.indices, b.STATIC_DRAW);
		a.texture.baseTexture._glTexture && (b.bindTexture(b.TEXTURE_2D, a.texture.baseTexture._glTexture), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.REPEAT), b.texParameteri(b.TEXTURE_2D,
			b.TEXTURE_WRAP_T, b.REPEAT));
		a.texture.baseTexture._powerOf2 = !0
	};
	e.WebGLRenderGroup.prototype.renderStrip = function(a, b) {
		var d = this.gl;
		e.activateStripShader();
		var c = e.stripShader,
			h = e.mat3.clone(a.worldTransform);
		e.mat3.transpose(h);
		d.uniformMatrix3fv(c.translationMatrix, !1, h);
		d.uniform2f(c.projectionVector, b.x, b.y);
		d.uniform2f(c.offsetVector, -e.offset.x, -e.offset.y);
		d.uniform1f(c.alpha, a.worldAlpha);
		a.dirty ? (a.dirty = !1, d.bindBuffer(d.ARRAY_BUFFER, a._vertexBuffer), d.bufferData(d.ARRAY_BUFFER, a.verticies,
				d.STATIC_DRAW), d.vertexAttribPointer(c.aVertexPosition, 2, d.FLOAT, !1, 0, 0), d.bindBuffer(d.ARRAY_BUFFER, a._uvBuffer), d.bufferData(d.ARRAY_BUFFER, a.uvs, d.STATIC_DRAW), d.vertexAttribPointer(c.aTextureCoord, 2, d.FLOAT, !1, 0, 0), d.activeTexture(d.TEXTURE0), d.bindTexture(d.TEXTURE_2D, a.texture.baseTexture._glTexture), d.bindBuffer(d.ARRAY_BUFFER, a._colorBuffer), d.bufferData(d.ARRAY_BUFFER, a.colors, d.STATIC_DRAW), d.vertexAttribPointer(c.colorAttribute, 1, d.FLOAT, !1, 0, 0), d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, a._indexBuffer),
			d.bufferData(d.ELEMENT_ARRAY_BUFFER, a.indices, d.STATIC_DRAW)) : (d.bindBuffer(d.ARRAY_BUFFER, a._vertexBuffer), d.bufferSubData(d.ARRAY_BUFFER, 0, a.verticies), d.vertexAttribPointer(c.aVertexPosition, 2, d.FLOAT, !1, 0, 0), d.bindBuffer(d.ARRAY_BUFFER, a._uvBuffer), d.vertexAttribPointer(c.aTextureCoord, 2, d.FLOAT, !1, 0, 0), d.activeTexture(d.TEXTURE0), d.bindTexture(d.TEXTURE_2D, a.texture.baseTexture._glTexture), d.bindBuffer(d.ARRAY_BUFFER, a._colorBuffer), d.vertexAttribPointer(c.colorAttribute, 1, d.FLOAT, !1, 0, 0), d.bindBuffer(d.ELEMENT_ARRAY_BUFFER,
			a._indexBuffer));
		d.drawElements(d.TRIANGLE_STRIP, a.indices.length, d.UNSIGNED_SHORT, 0);
		e.deactivateStripShader()
	};
	e.WebGLRenderGroup.prototype.renderTilingSprite = function(a, b) {
		var d = this.gl,
			c = a.tilePosition,
			e = a.tileScale,
			f = c.x / a.texture.baseTexture.width,
			c = c.y / a.texture.baseTexture.height,
			k = a.width / a.texture.baseTexture.width / e.x,
			e = a.height / a.texture.baseTexture.height / e.y;
		a.uvs[0] = 0 - f;
		a.uvs[1] = 0 - c;
		a.uvs[2] = 1 * k - f;
		a.uvs[3] = 0 - c;
		a.uvs[4] = 1 * k - f;
		a.uvs[5] = 1 * e - c;
		a.uvs[6] = 0 - f;
		a.uvs[7] = 1 * e - c;
		d.bindBuffer(d.ARRAY_BUFFER,
			a._uvBuffer);
		d.bufferSubData(d.ARRAY_BUFFER, 0, a.uvs);
		this.renderStrip(a, b)
	};
	e.WebGLRenderGroup.prototype.initStrip = function(a) {
		var b = this.gl;
		a._vertexBuffer = b.createBuffer();
		a._indexBuffer = b.createBuffer();
		a._uvBuffer = b.createBuffer();
		a._colorBuffer = b.createBuffer();
		b.bindBuffer(b.ARRAY_BUFFER, a._vertexBuffer);
		b.bufferData(b.ARRAY_BUFFER, a.verticies, b.DYNAMIC_DRAW);
		b.bindBuffer(b.ARRAY_BUFFER, a._uvBuffer);
		b.bufferData(b.ARRAY_BUFFER, a.uvs, b.STATIC_DRAW);
		b.bindBuffer(b.ARRAY_BUFFER, a._colorBuffer);
		b.bufferData(b.ARRAY_BUFFER, a.colors, b.STATIC_DRAW);
		b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, a._indexBuffer);
		b.bufferData(b.ELEMENT_ARRAY_BUFFER, a.indices, b.STATIC_DRAW)
	};
	e.initDefaultShaders = function() {
		e.primitiveShader = new e.PrimitiveShader;
		e.primitiveShader.init();
		e.stripShader = new e.StripShader;
		e.stripShader.init();
		e.defaultShader = new e.PixiShader;
		e.defaultShader.init();
		var a = e.gl;
		a.useProgram(e.defaultShader.program);
		a.enableVertexAttribArray(e.defaultShader.aVertexPosition);
		a.enableVertexAttribArray(e.defaultShader.colorAttribute);
		a.enableVertexAttribArray(e.defaultShader.aTextureCoord)
	};
	e.activatePrimitiveShader = function() {
		var a = e.gl;
		a.useProgram(e.primitiveShader.program);
		a.disableVertexAttribArray(e.defaultShader.aVertexPosition);
		a.disableVertexAttribArray(e.defaultShader.colorAttribute);
		a.disableVertexAttribArray(e.defaultShader.aTextureCoord);
		a.enableVertexAttribArray(e.primitiveShader.aVertexPosition);
		a.enableVertexAttribArray(e.primitiveShader.colorAttribute)
	};
	e.deactivatePrimitiveShader = function() {
		var a = e.gl;
		a.useProgram(e.defaultShader.program);
		a.disableVertexAttribArray(e.primitiveShader.aVertexPosition);
		a.disableVertexAttribArray(e.primitiveShader.colorAttribute);
		a.enableVertexAttribArray(e.defaultShader.aVertexPosition);
		a.enableVertexAttribArray(e.defaultShader.colorAttribute);
		a.enableVertexAttribArray(e.defaultShader.aTextureCoord)
	};
	e.activateStripShader = function() {
		e.gl.useProgram(e.stripShader.program)
	};
	e.deactivateStripShader = function() {
		e.gl.useProgram(e.defaultShader.program)
	};
	e.CompileVertexShader = function(a, b) {
		return e._CompileShader(a,
			b, a.VERTEX_SHADER)
	};
	e.CompileFragmentShader = function(a, b) {
		return e._CompileShader(a, b, a.FRAGMENT_SHADER)
	};
	e._CompileShader = function(a, b, d) {
		b = b.join("\n");
		d = a.createShader(d);
		a.shaderSource(d, b);
		a.compileShader(d);
		return a.getShaderParameter(d, a.COMPILE_STATUS) ? d : (console.log(a.getShaderInfoLog(d)), null)
	};
	e.compileProgram = function(a, b) {
		var d = e.gl,
			c = e.CompileFragmentShader(d, b),
			h = e.CompileVertexShader(d, a),
			f = d.createProgram();
		d.attachShader(f, h);
		d.attachShader(f, c);
		d.linkProgram(f);
		d.getProgramParameter(f,
			d.LINK_STATUS) || console.log("Could not initialise shaders");
		return f
	};
	e.BitmapText = function(a, b) {
		e.DisplayObjectContainer.call(this);
		this.setText(a);
		this.setStyle(b);
		this.updateText();
		this.dirty = !1
	};
	e.BitmapText.prototype = Object.create(e.DisplayObjectContainer.prototype);
	e.BitmapText.prototype.constructor = e.BitmapText;
	e.BitmapText.prototype.setText = function(a) {
		this.text = a || " ";
		this.dirty = !0
	};
	e.BitmapText.prototype.setStyle = function(a) {
		a = a || {};
		a.align = a.align || "left";
		this.style = a;
		a = a.font.split(" ");
		this.fontName = a[a.length - 1];
		this.fontSize = 2 <= a.length ? parseInt(a[a.length - 2], 10) : e.BitmapText.fonts[this.fontName].size;
		this.dirty = !0
	};
	e.BitmapText.prototype.updateText = function() {
		for (var a = e.BitmapText.fonts[this.fontName], b = new e.Point, d = null, c = [], h = 0, f = [], k = 0, m = this.fontSize / a.size, l = 0; l < this.text.length; l++) {
			var n = this.text.charCodeAt(l);
			if (/(?:\r\n|\r|\n)/.test(this.text.charAt(l))) f.push(b.x), h = Math.max(h, b.x), k++, b.x = 0, b.y += a.lineHeight, d = null;
			else {
				var q = a.chars[n];
				q && (d && q[d] && (b.x += q.kerning[d]),
					c.push({
						texture: q.texture,
						line: k,
						charCode: n,
						position: new e.Point(b.x + q.xOffset, b.y + q.yOffset)
					}), b.x += q.xAdvance, d = n)
			}
		}
		f.push(b.x);
		h = Math.max(h, b.x);
		d = [];
		for (l = 0; l <= k; l++) n = 0, "right" == this.style.align ? n = h - f[l] : "center" == this.style.align && (n = (h - f[l]) / 2), d.push(n);
		for (l = 0; l < c.length; l++) h = new e.Sprite(c[l].texture), h.position.x = (c[l].position.x + d[c[l].line]) * m, h.position.y = c[l].position.y * m, h.scale.x = h.scale.y = m, this.addChild(h);
		this.width = b.x * m;
		this.height = (b.y + a.lineHeight) * m
	};
	e.BitmapText.prototype.updateTransform =
		function() {
			if (this.dirty) {
				for (; 0 < this.children.length;) this.removeChild(this.getChildAt(0));
				this.updateText();
				this.dirty = !1
			}
			e.DisplayObjectContainer.prototype.updateTransform.call(this)
	};
	e.BitmapText.fonts = {};
	e.Text = function(a, b) {
		this.canvas = document.createElement("canvas");
		this.context = this.canvas.getContext("2d");
		e.Sprite.call(this, e.Texture.fromCanvas(this.canvas));
		this.setText(a);
		this.setStyle(b);
		this.updateText();
		this.dirty = !1
	};
	e.Text.prototype = Object.create(e.Sprite.prototype);
	e.Text.prototype.constructor =
		e.Text;
	e.Text.prototype.setStyle = function(a) {
		a = a || {};
		a.font = a.font || "bold 20pt Arial";
		a.fill = a.fill || "black";
		a.align = a.align || "left";
		a.stroke = a.stroke || "black";
		a.strokeThickness = a.strokeThickness || 0;
		a.wordWrap = a.wordWrap || !1;
		a.wordWrapWidth = a.wordWrapWidth || 100;
		this.style = a;
		this.dirty = !0
	};
	e.Text.prototype.setText = function(a) {
		this.text = a.toString() || " ";
		this.dirty = !0
	};
	e.Text.prototype.updateText = function() {
		this.context.font = this.style.font;
		var a = this.text;
		this.style.wordWrap && (a = this.wordWrap(this.text));
		for (var a = a.split(/(?:\r\n|\r|\n)/), b = [], d = 0, c = 0; c < a.length; c++) {
			var h = this.context.measureText(a[c]).width;
			b[c] = h;
			d = Math.max(d, h)
		}
		this.canvas.width = d + this.style.strokeThickness;
		h = this.determineFontHeight("font: " + this.style.font + ";") + this.style.strokeThickness;
		this.canvas.height = h * a.length;
		this.context.fillStyle = this.style.fill;
		this.context.font = this.style.font;
		this.context.strokeStyle = this.style.stroke;
		this.context.lineWidth = this.style.strokeThickness;
		this.context.textBaseline = "top";
		for (c = 0; c < a.length; c++) {
			var f =
				new e.Point(this.style.strokeThickness / 2, this.style.strokeThickness / 2 + c * h);
			"right" == this.style.align ? f.x += d - b[c] : "center" == this.style.align && (f.x += (d - b[c]) / 2);
			this.style.stroke && this.style.strokeThickness && this.context.strokeText(a[c], f.x, f.y);
			this.style.fill && this.context.fillText(a[c], f.x, f.y)
		}
		this.updateTexture()
	};
	e.Text.prototype.updateTexture = function() {
		this.texture.baseTexture.width = this.canvas.width;
		this.texture.baseTexture.height = this.canvas.height;
		this.texture.frame.width = this.canvas.width;
		this.texture.frame.height = this.canvas.height;
		this._width = this.canvas.width;
		this._height = this.canvas.height;
		e.texturesToUpdate.push(this.texture.baseTexture)
	};
	e.Text.prototype.updateTransform = function() {
		this.dirty && (this.updateText(), this.dirty = !1);
		e.Sprite.prototype.updateTransform.call(this)
	};
	e.Text.prototype.determineFontHeight = function(a) {
		var b = e.Text.heightCache[a];
		if (!b) {
			var d = document.getElementsByTagName("body")[0],
				c = document.createElement("div"),
				b = document.createTextNode("M");
			c.appendChild(b);
			c.setAttribute("style", a + ";position:absolute;top:0;left:0");
			d.appendChild(c);
			b = c.offsetHeight;
			e.Text.heightCache[a] = b;
			d.removeChild(c)
		}
		return b
	};
	e.Text.prototype.wordWrap = function(a) {
		var b = "";
		a = a.split("\n");
		for (var d = 0; d < a.length; d++) {
			for (var c = this.style.wordWrapWidth, e = a[d].split(" "), f = 0; f < e.length; f++) {
				var k = this.context.measureText(e[f]).width,
					m = k + this.context.measureText(" ").width;
				m > c ? (0 < f && (b += "\n"), b += e[f] + " ", c = this.style.wordWrapWidth - k) : (c -= m, b += e[f] + " ")
			}
			b += "\n"
		}
		return b
	};
	e.Text.prototype.destroy =
		function(a) {
			a && this.texture.destroy()
	};
	e.Text.heightCache = {};
	e.BaseTextureCache = {};
	e.texturesToUpdate = [];
	e.texturesToDestroy = [];
	e.BaseTexture = function(a) {
		e.EventTarget.call(this);
		this.height = this.width = 100;
		this.hasLoaded = !1;
		if (this.source = a) {
			if (this.source instanceof Image || this.source instanceof HTMLImageElement)
				if (this.source.complete) this.hasLoaded = !0, this.width = this.source.width, this.height = this.source.height, e.texturesToUpdate.push(this);
				else {
					var b = this;
					this.source.onload = function() {
						b.hasLoaded = !0;
						b.width = b.source.width;
						b.height = b.source.height;
						e.texturesToUpdate.push(b);
						b.dispatchEvent({
							type: "loaded",
							content: b
						})
					}
				} else this.hasLoaded = !0, this.width = this.source.width, this.height = this.source.height, e.texturesToUpdate.push(this);
			this._powerOf2 = !1
		}
	};
	e.BaseTexture.prototype.constructor = e.BaseTexture;
	e.BaseTexture.prototype.destroy = function() {
		this.source instanceof Image && (this.source.src = null);
		this.source = null;
		e.texturesToDestroy.push(this)
	};
	e.BaseTexture.fromImage = function(a, b) {
		var d = e.BaseTextureCache[a];
		d || (d = new Image, b && (d.crossOrigin = ""), d.src = a, d = new e.BaseTexture(d), e.BaseTextureCache[a] = d);
		return d
	};
	e.TextureCache = {};
	e.FrameCache = {};
	e.Texture = function(a, b) {
		e.EventTarget.call(this);
		b || (this.noFrame = !0, b = new e.Rectangle(0, 0, 1, 1));
		a instanceof e.Texture && (a = a.baseTexture);
		this.baseTexture = a;
		this.frame = b;
		this.trim = new e.Point;
		this.scope = this;
		if (a.hasLoaded) this.noFrame && (b = new e.Rectangle(0, 0, a.width, a.height)), this.setFrame(b);
		else {
			var d = this;
			a.addEventListener("loaded", function() {
				d.onBaseTextureLoaded()
			})
		}
	};
	e.Texture.prototype.constructor = e.Texture;
	e.Texture.prototype.onBaseTextureLoaded = function(a) {
		a = this.baseTexture;
		a.removeEventListener("loaded", this.onLoaded);
		this.noFrame && (this.frame = new e.Rectangle(0, 0, a.width, a.height));
		this.noFrame = !1;
		this.width = this.frame.width;
		this.height = this.frame.height;
		this.scope.dispatchEvent({
			type: "update",
			content: this
		})
	};
	e.Texture.prototype.destroy = function(a) {
		a && this.baseTexture.destroy()
	};
	e.Texture.prototype.setFrame = function(a) {
		this.frame = a;
		this.width = a.width;
		this.height =
			a.height;
		if (a.x + a.width > this.baseTexture.width || a.y + a.height > this.baseTexture.height) throw Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
		this.updateFrame = !0;
		e.Texture.frameUpdates.push(this)
	};
	e.Texture.fromImage = function(a, b) {
		var d = e.TextureCache[a];
		d || (d = new e.Texture(e.BaseTexture.fromImage(a, b)), e.TextureCache[a] = d);
		return d
	};
	e.Texture.fromFrame = function(a) {
		var b = e.TextureCache[a];
		if (!b) throw Error("The frameId '" + a + "' does not exist in the texture cache " +
			this);
		return b
	};
	e.Texture.fromCanvas = function(a) {
		a = new e.BaseTexture(a);
		return new e.Texture(a)
	};
	e.Texture.addTextureToCache = function(a, b) {
		e.TextureCache[b] = a
	};
	e.Texture.removeTextureFromCache = function(a) {
		var b = e.TextureCache[a];
		e.TextureCache[a] = null;
		return b
	};
	e.Texture.frameUpdates = [];
	e.RenderTexture = function(a, b) {
		e.EventTarget.call(this);
		this.width = a || 100;
		this.height = b || 100;
		this.indetityMatrix = e.mat3.create();
		this.frame = new e.Rectangle(0, 0, this.width, this.height);
		e.gl ? this.initWebGL() : this.initCanvas()
	};
	e.RenderTexture.prototype = Object.create(e.Texture.prototype);
	e.RenderTexture.prototype.constructor = e.RenderTexture;
	e.RenderTexture.prototype.initWebGL = function() {
		var a = e.gl;
		this.glFramebuffer = a.createFramebuffer();
		a.bindFramebuffer(a.FRAMEBUFFER, this.glFramebuffer);
		this.glFramebuffer.width = this.width;
		this.glFramebuffer.height = this.height;
		this.baseTexture = new e.BaseTexture;
		this.baseTexture.width = this.width;
		this.baseTexture.height = this.height;
		this.baseTexture._glTexture = a.createTexture();
		a.bindTexture(a.TEXTURE_2D,
			this.baseTexture._glTexture);
		a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, this.width, this.height, 0, a.RGBA, a.UNSIGNED_BYTE, null);
		a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR);
		a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR);
		a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE);
		a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE);
		this.baseTexture.isRender = !0;
		a.bindFramebuffer(a.FRAMEBUFFER, this.glFramebuffer);
		a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0,
			a.TEXTURE_2D, this.baseTexture._glTexture, 0);
		this.projection = new e.Point(this.width / 2, -this.height / 2);
		this.render = this.renderWebGL
	};
	e.RenderTexture.prototype.resize = function(a, b) {
		this.width = a;
		this.height = b;
		if (e.gl) {
			this.projection.x = this.width / 2;
			this.projection.y = -this.height / 2;
			var d = e.gl;
			d.bindTexture(d.TEXTURE_2D, this.baseTexture._glTexture);
			d.texImage2D(d.TEXTURE_2D, 0, d.RGBA, this.width, this.height, 0, d.RGBA, d.UNSIGNED_BYTE, null)
		} else this.frame.width = this.width, this.frame.height = this.height, this.renderer.resize(this.width,
			this.height)
	};
	e.RenderTexture.prototype.initCanvas = function() {
		this.renderer = new e.CanvasRenderer(this.width, this.height, null, 0);
		this.baseTexture = new e.BaseTexture(this.renderer.view);
		this.frame = new e.Rectangle(0, 0, this.width, this.height);
		this.render = this.renderCanvas
	};
	e.RenderTexture.prototype.renderWebGL = function(a, b, d) {
		var c = e.gl;
		c.colorMask(!0, !0, !0, !0);
		c.viewport(0, 0, this.width, this.height);
		c.bindFramebuffer(c.FRAMEBUFFER, this.glFramebuffer);
		d && (c.clearColor(0, 0, 0, 0), c.clear(c.COLOR_BUFFER_BIT));
		var h = a.children;
		d = a.worldTransform;
		a.worldTransform = e.mat3.create();
		a.worldTransform[4] = -1;
		a.worldTransform[5] = -2 * this.projection.y;
		b && (a.worldTransform[2] = b.x, a.worldTransform[5] -= b.y);
		e.visibleCount++;
		a.vcount = e.visibleCount;
		b = 0;
		for (var f = h.length; b < f; b++) h[b].updateTransform();
		(h = a.__renderGroup) ? a == h.root ? h.render(this.projection, this.glFramebuffer) : h.renderSpecific(a, this.projection, this.glFramebuffer) : (this.renderGroup || (this.renderGroup = new e.WebGLRenderGroup(c)), this.renderGroup.setRenderable(a),
			this.renderGroup.render(this.projection, this.glFramebuffer));
		a.worldTransform = d
	};
	e.RenderTexture.prototype.renderCanvas = function(a, b, d) {
		var c = a.children;
		a.worldTransform = e.mat3.create();
		b && (a.worldTransform[2] = b.x, a.worldTransform[5] = b.y);
		b = 0;
		for (var h = c.length; b < h; b++) c[b].updateTransform();
		d && this.renderer.context.clearRect(0, 0, this.width, this.height);
		this.renderer.renderDisplayObject(a);
		this.renderer.context.setTransform(1, 0, 0, 1, 0, 0)
	};
	e.EventTarget = function() {
		var a = {};
		this.addEventListener = this.on =
			function(b, d) {
				void 0 === a[b] && (a[b] = []); - 1 === a[b].indexOf(d) && a[b].push(d)
		};
		this.dispatchEvent = this.emit = function(b) {
			if (a[b.type] && a[b.type].length)
				for (var d = 0, c = a[b.type].length; d < c; d++) a[b.type][d](b)
		};
		this.removeEventListener = this.off = function(b, d) {
			var c = a[b].indexOf(d); - 1 !== c && a[b].splice(c, 1)
		}
	};
	e.PolyK = {};
	e.PolyK.Triangulate = function(a) {
		var b = !0,
			d = a.length >> 1;
		if (3 > d) return [];
		for (var c = [], h = [], f = 0; f < d; f++) h.push(f);
		for (var f = 0, k = d; 3 < k;) {
			var m = h[(f + 0) % k],
				l = h[(f + 1) % k],
				n = h[(f + 2) % k],
				q = a[2 * m],
				t = a[2 *
					m + 1],
				p = a[2 * l],
				v = a[2 * l + 1],
				w = a[2 * n],
				z = a[2 * n + 1],
				A = !1;
			if (e.PolyK._convex(q, t, p, v, w, z, b))
				for (var A = !0, y = 0; y < k; y++) {
					var B = h[y];
					if (B != m && B != l && B != n && e.PolyK._PointInTriangle(a[2 * B], a[2 * B + 1], q, t, p, v, w, z)) {
						A = !1;
						break
					}
				}
			if (A) c.push(m, l, n), h.splice((f + 1) % k, 1), k--, f = 0;
			else if (f++ > 3 * k)
				if (b) {
					c = [];
					h = [];
					for (f = 0; f < d; f++) h.push(f);
					f = 0;
					k = d;
					b = !1
				} else return console.log("PIXI Warning: shape too complex to fill"), []
		}
		c.push(h[0], h[1], h[2]);
		return c
	};
	e.PolyK._PointInTriangle = function(a, b, d, c, e, f, k, m) {
		k -= d;
		m -= c;
		e -= d;
		f -= c;
		a -= d;
		d = b - c;
		b = k * k + m * m;
		c = k * e + m * f;
		k = k * a + m * d;
		m = e * e + f * f;
		e = e * a + f * d;
		f = 1 / (b * m - c * c);
		m = (m * k - c * e) * f;
		k = (b * e - c * k) * f;
		return 0 <= m && 0 <= k && 1 > m + k
	};
	e.PolyK._convex = function(a, b, d, c, e, f, k) {
		return 0 <= (b - c) * (e - d) + (d - a) * (f - c) == k
	};
	c.Camera = function(a, b, d, e, h, f) {
		this.game = a;
		this.world = a.world;
		this.id = 0;
		this.view = new c.Rectangle(d, e, h, f);
		this.screenView = new c.Rectangle(d, e, h, f);
		this.bounds = new c.Rectangle(d, e, h, f);
		this.deadzone = null;
		this.visible = !0;
		this.atLimit = {
			x: !1,
			y: !1
		};
		this.target = null;
		this._edge = 0;
		this.displayObject =
			null
	};
	c.Camera.FOLLOW_LOCKON = 0;
	c.Camera.FOLLOW_PLATFORMER = 1;
	c.Camera.FOLLOW_TOPDOWN = 2;
	c.Camera.FOLLOW_TOPDOWN_TIGHT = 3;
	c.Camera.prototype = {
		follow: function(a, b) {
			"undefined" === typeof b && (b = c.Camera.FOLLOW_LOCKON);
			this.target = a;
			var d;
			switch (b) {
				case c.Camera.FOLLOW_PLATFORMER:
					d = this.width / 8;
					var e = this.height / 3;
					this.deadzone = new c.Rectangle((this.width - d) / 2, (this.height - e) / 2 - 0.25 * e, d, e);
					break;
				case c.Camera.FOLLOW_TOPDOWN:
					d = Math.max(this.width, this.height) / 4;
					this.deadzone = new c.Rectangle((this.width - d) /
						2, (this.height - d) / 2, d, d);
					break;
				case c.Camera.FOLLOW_TOPDOWN_TIGHT:
					d = Math.max(this.width, this.height) / 8;
					this.deadzone = new c.Rectangle((this.width - d) / 2, (this.height - d) / 2, d, d);
					break;
				case c.Camera.FOLLOW_LOCKON:
					this.deadzone = null;
					break;
				default:
					this.deadzone = null
			}
		},
		focusOn: function(a) {
			this.setPosition(Math.round(a.x - this.view.halfWidth), Math.round(a.y - this.view.halfHeight))
		},
		focusOnXY: function(a, b) {
			this.setPosition(Math.round(a - this.view.halfWidth), Math.round(b - this.view.halfHeight))
		},
		update: function() {
			this.target &&
				this.updateTarget();
			this.bounds && this.checkBounds();
			this.displayObject.position.x = -this.view.x;
			this.displayObject.position.y = -this.view.y
		},
		updateTarget: function() {
			this.deadzone ? (this._edge = this.target.x - this.deadzone.x, this.view.x > this._edge && (this.view.x = this._edge), this._edge = this.target.x + this.target.width - this.deadzone.x - this.deadzone.width, this.view.x < this._edge && (this.view.x = this._edge), this._edge = this.target.y - this.deadzone.y, this.view.y > this._edge && (this.view.y = this._edge), this._edge = this.target.y +
				this.target.height - this.deadzone.y - this.deadzone.height, this.view.y < this._edge && (this.view.y = this._edge)) : this.focusOnXY(this.target.x, this.target.y)
		},
		setBoundsToWorld: function() {
			this.bounds.setTo(this.game.world.x, this.game.world.y, this.game.world.width, this.game.world.height)
		},
		checkBounds: function() {
			this.atLimit.x = !1;
			this.atLimit.y = !1;
			this.view.x < this.bounds.x && (this.atLimit.x = !0, this.view.x = this.bounds.x);
			this.view.x > this.bounds.right - this.width && (this.atLimit.x = !0, this.view.x = this.bounds.right -
				this.width + 1);
			this.view.y < this.bounds.top && (this.atLimit.y = !0, this.view.y = this.bounds.top);
			this.view.y > this.bounds.bottom - this.height && (this.atLimit.y = !0, this.view.y = this.bounds.bottom - this.height + 1);
			this.view.floor()
		},
		setPosition: function(a, b) {
			this.view.x = a;
			this.view.y = b;
			this.bounds && this.checkBounds()
		},
		setSize: function(a, b) {
			this.view.width = a;
			this.view.height = b
		}
	};
	Object.defineProperty(c.Camera.prototype, "x", {
		get: function() {
			return this.view.x
		},
		set: function(a) {
			this.view.x = a;
			this.bounds && this.checkBounds()
		}
	});
	Object.defineProperty(c.Camera.prototype, "y", {
		get: function() {
			return this.view.y
		},
		set: function(a) {
			this.view.y = a;
			this.bounds && this.checkBounds()
		}
	});
	Object.defineProperty(c.Camera.prototype, "width", {
		get: function() {
			return this.view.width
		},
		set: function(a) {
			this.view.width = a
		}
	});
	Object.defineProperty(c.Camera.prototype, "height", {
		get: function() {
			return this.view.height
		},
		set: function(a) {
			this.view.height = a
		}
	});
	c.State = function() {
		this.physics = this.particles = this.world = this.tweens = this.time = this.stage = this.sound =
			this.math = this.load = this.input = this.cache = this.camera = this.add = this.game = null
	};
	c.State.prototype = {
		preload: function() {},
		loadUpdate: function() {},
		loadRender: function() {},
		create: function() {},
		update: function() {},
		render: function() {},
		paused: function() {},
		destroy: function() {}
	};
	c.StateManager = function(a, b) {
		this.game = a;
		this.states = {};
		this._pendingState = null;
		null !== b && (this._pendingState = b);
		this._created = !1;
		this.current = "";
		this.onShutDownCallback = this.onPausedCallback = this.onLoadRenderCallback = this.onLoadUpdateCallback =
			this.onPreRenderCallback = this.onRenderCallback = this.onUpdateCallback = this.onCreateCallback = this.onPreloadCallback = this.onInitCallback = null
	};
	c.StateManager.prototype = {
		boot: function() {
			this.game.onPause.add(this.pause, this);
			this.game.onResume.add(this.resume, this);
			null !== this._pendingState && ("string" === typeof this._pendingState ? this.start(this._pendingState, !1, !1) : this.add("default", this._pendingState, !0))
		},
		add: function(a, b, d) {
			"undefined" === typeof d && (d = !1);
			var e;
			b instanceof c.State ? e = b : "object" ===
				typeof b ? (e = b, e.game = this.game) : "function" === typeof b && (e = new b(this.game));
			this.states[a] = e;
			d && (this.game.isBooted ? this.start(a) : this._pendingState = a);
			return e
		},
		remove: function(a) {
			this.current == a && (this.onDestroyCallback = this.onPausedCallback = this.onRenderCallback = this.onUpdateCallback = this.onCreateCallback = this.onLoadUpdateCallback = this.onLoadRenderCallback = this.onPreloadCallback = this.onShutDownCallback = this.onInitCallback = this.callbackContext = null);
			delete this.states[a]
		},
		start: function(a, b, d) {
			"undefined" ===
				typeof b && (b = !0);
			"undefined" === typeof d && (d = !1);
			!1 === this.game.isBooted ? this._pendingState = a : !1 !== this.checkState(a) && (this.current && this.onShutDownCallback.call(this.callbackContext, this.game), b && (this.game.tweens.removeAll(), this.game.world.destroy(), !0 === d && this.game.cache.destroy()), this.setCurrentState(a), this.onPreloadCallback ? (this.game.load.reset(), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() ? this.game.loadComplete() : this.game.load.start()) :
				this.game.loadComplete())
		},
		dummy: function() {},
		checkState: function(a) {
			if (this.states[a]) {
				var b = !1;
				this.states[a].preload && (b = !0);
				!1 === b && this.states[a].loadRender && (b = !0);
				!1 === b && this.states[a].loadUpdate && (b = !0);
				!1 === b && this.states[a].create && (b = !0);
				!1 === b && this.states[a].update && (b = !0);
				!1 === b && this.states[a].preRender && (b = !0);
				!1 === b && this.states[a].render && (b = !0);
				!1 === b && this.states[a].paused && (b = !0);
				return !1 === b ? (console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions."), !1) : !0
			}
			console.warn("Phaser.StateManager - No state found with the key: " + a);
			return !1
		},
		link: function(a) {
			this.states[a].game = this.game;
			this.states[a].add = this.game.add;
			this.states[a].camera = this.game.camera;
			this.states[a].cache = this.game.cache;
			this.states[a].input = this.game.input;
			this.states[a].load = this.game.load;
			this.states[a].math = this.game.math;
			this.states[a].sound = this.game.sound;
			this.states[a].stage = this.game.stage;
			this.states[a].time = this.game.time;
			this.states[a].tweens = this.game.tweens;
			this.states[a].world =
				this.game.world;
			this.states[a].particles = this.game.particles;
			this.states[a].physics = this.game.physics;
			this.states[a].rnd = this.game.rnd
		},
		setCurrentState: function(a) {
			this.callbackContext = this.states[a];
			this.link(a);
			this.onInitCallback = this.states[a].init || this.dummy;
			this.onPreloadCallback = this.states[a].preload || null;
			this.onLoadRenderCallback = this.states[a].loadRender || null;
			this.onLoadUpdateCallback = this.states[a].loadUpdate || null;
			this.onCreateCallback = this.states[a].create || null;
			this.onUpdateCallback =
				this.states[a].update || null;
			this.onPreRenderCallback = this.states[a].preRender || null;
			this.onRenderCallback = this.states[a].render || null;
			this.onPausedCallback = this.states[a].paused || null;
			this.onShutDownCallback = this.states[a].shutdown || this.dummy;
			this.current = a;
			this._created = !1;
			this.onInitCallback.call(this.callbackContext, this.game)
		},
		loadComplete: function() {
			!1 === this._created && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
		},
		pause: function() {
			this._created &&
				this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game, !0)
		},
		resume: function() {
			this._created && this.onre && this.onPausedCallback.call(this.callbackContext, this.game, !1)
		},
		update: function() {
			this._created && this.onUpdateCallback ? this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
		},
		preRender: function() {
			this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game)
		},
		render: function() {
			this._created && this.onRenderCallback ? (this.game.renderType === c.CANVAS && (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0)), this.onRenderCallback.call(this.callbackContext, this.game), this.game.renderType === c.CANVAS && this.game.context.restore()) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
		},
		destroy: function() {
			this.game = this.onDestroyCallback = this.onPausedCallback = this.onRenderCallback = this.onUpdateCallback = this.onCreateCallback =
				this.onLoadUpdateCallback = this.onLoadRenderCallback = this.onPreloadCallback = this.onShutDownCallback = this.onInitCallback = this.callbackContext = null;
			this.states = {};
			this._pendingState = null
		}
	};
	c.LinkedList = function() {
		this.last = this.first = this.prev = this.next = null;
		this.total = 0
	};
	c.LinkedList.prototype = {
		add: function(a) {
			if (0 === this.total && null == this.first && null == this.last) return this.next = this.last = this.first = a, a.prev = this, this.total++, a;
			this.last.next = a;
			a.prev = this.last;
			this.last = a;
			this.total++;
			return a
		},
		remove: function(a) {
			a ==
				this.first ? this.first = this.first.next : a == this.last && (this.last = this.last.prev);
			a.prev && (a.prev.next = a.next);
			a.next && (a.next.prev = a.prev);
			a.next = a.prev = null;
			null == this.first && (this.last = null);
			this.total--
		},
		callAll: function(a) {
			if (this.first && this.last) {
				var b = this.first;
				do b && b[a] && b[a].call(b), b = b.next; while (b != this.last.next)
			}
		}
	};
	c.Signal = function() {
		this._bindings = [];
		this._prevParams = null;
		var a = this;
		this.dispatch = function() {
			c.Signal.prototype.dispatch.apply(a, arguments)
		}
	};
	c.Signal.prototype = {
		memorize: !1,
		_shouldPropagate: !0,
		active: !0,
		validateListener: function(a, b) {
			if ("function" !== typeof a) throw Error("listener is a required param of {fn}() and should be a Function.".replace("{fn}", b));
		},
		_registerListener: function(a, b, d, e) {
			var h = this._indexOfListener(a, d);
			if (-1 !== h) {
				if (a = this._bindings[h], a.isOnce() !== b) throw Error("You cannot add" + (b ? "" : "Once") + "() then add" + (b ? "Once" : "") + "() the same listener without removing the relationship first.");
			} else a = new c.SignalBinding(this, a, b, d, e), this._addBinding(a);
			this.memorize && this._prevParams && a.execute(this._prevParams);
			return a
		},
		_addBinding: function(a) {
			var b = this._bindings.length;
			do --
			b;
			while (this._bindings[b] && a._priority <= this._bindings[b]._priority);
			this._bindings.splice(b + 1, 0, a)
		},
		_indexOfListener: function(a, b) {
			for (var d = this._bindings.length, c; d--;)
				if (c = this._bindings[d], c._listener === a && c.context === b) return d;
			return -1
		},
		has: function(a, b) {
			return -1 !== this._indexOfListener(a, b)
		},
		add: function(a, b, d) {
			this.validateListener(a, "add");
			return this._registerListener(a, !1, b, d)
		},
		addOnce: function(a, b, d) {
			this.validateListener(a, "addOnce");
			return this._registerListener(a, !0, b, d)
		},
		remove: function(a, b) {
			this.validateListener(a, "remove");
			var d = this._indexOfListener(a, b); - 1 !== d && (this._bindings[d]._destroy(), this._bindings.splice(d, 1));
			return a
		},
		removeAll: function() {
			for (var a = this._bindings.length; a--;) this._bindings[a]._destroy();
			this._bindings.length = 0
		},
		getNumListeners: function() {
			return this._bindings.length
		},
		halt: function() {
			this._shouldPropagate = !1
		},
		dispatch: function() {
			if (this.active) {
				var a =
					Array.prototype.slice.call(arguments),
					b = this._bindings.length,
					d;
				this.memorize && (this._prevParams = a);
				if (b) {
					d = this._bindings.slice();
					this._shouldPropagate = !0;
					do b--; while (d[b] && this._shouldPropagate && !1 !== d[b].execute(a))
				}
			}
		},
		forget: function() {
			this._prevParams = null
		},
		dispose: function() {
			this.removeAll();
			delete this._bindings;
			delete this._prevParams
		},
		toString: function() {
			return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
		}
	};
	c.SignalBinding = function(a, b, d, c, e) {
		this._listener =
			b;
		this._isOnce = d;
		this.context = c;
		this._signal = a;
		this._priority = e || 0
	};
	c.SignalBinding.prototype = {
		active: !0,
		params: null,
		execute: function(a) {
			var b;
			this.active && this._listener && (a = this.params ? this.params.concat(a) : a, b = this._listener.apply(this.context, a), this._isOnce && this.detach());
			return b
		},
		detach: function() {
			return this.isBound() ? this._signal.remove(this._listener, this.context) : null
		},
		isBound: function() {
			return !!this._signal && !!this._listener
		},
		isOnce: function() {
			return this._isOnce
		},
		getListener: function() {
			return this._listener
		},
		getSignal: function() {
			return this._signal
		},
		_destroy: function() {
			delete this._signal;
			delete this._listener;
			delete this.context
		},
		toString: function() {
			return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
		}
	};
	c.Filter = function(a, b, d) {
		this.game = a;
		this.type = c.WEBGL_FILTER;
		this.passes = [this];
		this.dirty = !0;
		this.padding = 0;
		this.uniforms = {
			time: {
				type: "1f",
				value: 0
			},
			resolution: {
				type: "2f",
				value: {
					x: 256,
					y: 256
				}
			},
			mouse: {
				type: "2f",
				value: {
					x: 0,
					y: 0
				}
			}
		};
		this.fragmentSrc = d ||
			[]
	};
	c.Filter.prototype = {
		init: function() {},
		setResolution: function(a, b) {
			this.uniforms.resolution.value.x = a;
			this.uniforms.resolution.value.y = b
		},
		update: function(a) {
			"undefined" !== typeof a && (0 < a.x && (this.uniforms.mouse.x = a.x.toFixed(2)), 0 < a.y && (this.uniforms.mouse.y = a.y.toFixed(2)));
			this.uniforms.time.value = this.game.time.totalElapsedSeconds()
		},
		destroy: function() {
			this.game = null
		}
	};
	Object.defineProperty(c.Filter.prototype, "width", {
		get: function() {
			return this.uniforms.resolution.value.x
		},
		set: function(a) {
			this.uniforms.resolution.value.x =
				a
		}
	});
	Object.defineProperty(c.Filter.prototype, "height", {
		get: function() {
			return this.uniforms.resolution.value.y
		},
		set: function(a) {
			this.uniforms.resolution.value.y = a
		}
	});
	c.Plugin = function(a, b) {
		"undefined" === typeof b && (b = null);
		this.game = a;
		this.parent = b;
		this.hasPostRender = this.hasRender = this.hasPostUpdate = this.hasUpdate = this.hasPreUpdate = this.visible = this.active = !1
	};
	c.Plugin.prototype = {
		preUpdate: function() {},
		update: function() {},
		render: function() {},
		postRender: function() {},
		destroy: function() {
			this.parent =
				this.game = null;
			this.visible = this.active = !1
		}
	};
	c.PluginManager = function(a, b) {
		this.game = a;
		this._parent = b;
		this.plugins = [];
		this._pluginsLength = 0
	};
	c.PluginManager.prototype = {
		add: function(a) {
			var b = !1;
			"function" === typeof a ? a = new a(this.game, this._parent) : (a.game = this.game, a.parent = this._parent);
			"function" === typeof a.preUpdate && (b = a.hasPreUpdate = !0);
			"function" === typeof a.update && (b = a.hasUpdate = !0);
			"function" === typeof a.postUpdate && (b = a.hasPostUpdate = !0);
			"function" === typeof a.render && (b = a.hasRender = !0);
			"function" ===
				typeof a.postRender && (b = a.hasPostRender = !0);
			if (b) {
				if (a.hasPreUpdate || a.hasUpdate || a.hasPostUpdate) a.active = !0;
				if (a.hasRender || a.hasPostRender) a.visible = !0;
				this._pluginsLength = this.plugins.push(a);
				"function" === typeof a.init && a.init();
				return a
			}
			return null
		},
		remove: function(a) {
			if (0 !== this._pluginsLength)
				for (this._p = 0; this._p < this._pluginsLength; this._p++)
					if (this.plugins[this._p] === a) {
						a.destroy();
						this.plugins.splice(this._p, 1);
						this._pluginsLength--;
						break
					}
		},
		removeAll: function() {
			for (this._p = 0; this._p < this._pluginsLength; this._p++) this.plugins[this._p].destroy();
			this._pluginsLength = this.plugins.length = 0
		},
		preUpdate: function() {
			if (0 !== this._pluginsLength)
				for (this._p = 0; this._p < this._pluginsLength; this._p++) this.plugins[this._p].active && this.plugins[this._p].hasPreUpdate && this.plugins[this._p].preUpdate()
		},
		update: function() {
			if (0 !== this._pluginsLength)
				for (this._p = 0; this._p < this._pluginsLength; this._p++) this.plugins[this._p].active && this.plugins[this._p].hasUpdate && this.plugins[this._p].update()
		},
		postUpdate: function() {
			if (0 !== this._pluginsLength)
				for (this._p = 0; this._p <
					this._pluginsLength; this._p++) this.plugins[this._p].active && this.plugins[this._p].hasPostUpdate && this.plugins[this._p].postUpdate()
		},
		render: function() {
			if (0 !== this._pluginsLength)
				for (this._p = 0; this._p < this._pluginsLength; this._p++) this.plugins[this._p].visible && this.plugins[this._p].hasRender && this.plugins[this._p].render()
		},
		postRender: function() {
			if (0 !== this._pluginsLength)
				for (this._p = 0; this._p < this._pluginsLength; this._p++) this.plugins[this._p].visible && this.plugins[this._p].hasPostRender && this.plugins[this._p].postRender()
		},
		destroy: function() {
			this._pluginsLength = this.plugins.length = 0;
			this._parent = this.game = null
		}
	};
	c.Stage = function(a, b, d) {
		this.game = a;
		this._backgroundColor = "rgb(0,0,0)";
		this.offset = new c.Point;
		this.canvas = c.Canvas.create(b, d);
		this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%";
		this._stage = new e.Stage(0, !1);
		this._stage.name = "_stage_root";
		this._stage.interactive = !1;
		this.scaleMode = c.StageScaleMode.NO_SCALE;
		this.scale = new c.StageScaleMode(this.game, b, d);
		this.aspectRatio = b / d;
		this._nextOffsetCheck =
			0;
		this.checkOffsetInterval = 2500
	};
	c.Stage.prototype = {
		boot: function() {
			c.Canvas.getOffset(this.canvas, this.offset);
			this.bounds = new c.Rectangle(this.offset.x, this.offset.y, this.game.width, this.game.height);
			var a = this;
			this._onChange = function(b) {
				return a.visibilityChange(b)
			};
			c.Canvas.setUserSelect(this.canvas, "none");
			c.Canvas.setTouchAction(this.canvas, "none");
			this.backgroundColor = "#000";
			document.addEventListener("visibilitychange", this._onChange, !1);
			document.addEventListener("webkitvisibilitychange", this._onChange, !1);
			document.addEventListener("pagehide", this._onChange, !1);
			document.addEventListener("pageshow", this._onChange, !1);
			window.onblur = this._onChange;
			window.onfocus = this._onChange
		},
		update: function() {
			!1 !== this.checkOffsetInterval && this.game.time.now > this._nextOffsetCheck && (c.Canvas.getOffset(this.canvas, this.offset), this._nextOffsetCheck = this.game.time.now + this.checkOffsetInterval)
		},
		visibilityChange: function(a) {
			this.disableVisibilityChange || (this.game.paused = "pagehide" == a.type || "blur" == a.type || !0 === document.hidden ||
				!0 === document.webkitHidden ? !0 : !1)
		}
	};
	Object.defineProperty(c.Stage.prototype, "backgroundColor", {
		get: function() {
			return this._backgroundColor
		},
		set: function(a) {
			this._backgroundColor = a;
			!1 === this.game.transparent && (this.game.renderType == c.CANVAS ? this.game.canvas.style.backgroundColor = a : ("string" === typeof a && (a = c.Color.hexToRGB(a)), this._stage.setBackgroundColor(a)))
		}
	});
	c.Group = function(a, b, d, x) {
		if ("undefined" === typeof b || null === typeof b) b = a.world;
		"undefined" === typeof x && (x = !1);
		this.game = a;
		this.name = d ||
			"group";
		x ? this._container = this.game.stage._stage : (this._container = new e.DisplayObjectContainer, this._container.name = this.name, b ? b instanceof c.Group ? (b._container.addChild(this._container), b._container.updateTransform()) : (b.addChild(this._container), b.updateTransform()) : (this.game.stage._stage.addChild(this._container), this.game.stage._stage.updateTransform()));
		this.type = c.GROUP;
		this.exists = !0;
		this.scale = new c.Point(1, 1);
		this.cursor = null
	};
	c.Group.RETURN_NONE = 0;
	c.Group.RETURN_TOTAL = 1;
	c.Group.RETURN_CHILD =
		2;
	c.Group.SORT_ASCENDING = -1;
	c.Group.SORT_DESCENDING = 1;
	c.Group.prototype = {
		add: function(a) {
			a.group !== this && (a.group = this, a.events && a.events.onAddedToGroup.dispatch(a, this), this._container.addChild(a), a.updateTransform(), null === this.cursor && (this.cursor = a));
			return a
		},
		addAt: function(a, b) {
			a.group !== this && (a.group = this, a.events && a.events.onAddedToGroup.dispatch(a, this), this._container.addChildAt(a, b), a.updateTransform(), null === this.cursor && (this.cursor = a));
			return a
		},
		getAt: function(a) {
			return this._container.getChildAt(a)
		},
		create: function(a, b, d, e, h) {
			"undefined" == typeof h && (h = !0);
			a = new c.Sprite(this.game, a, b, d, e);
			a.group = this;
			a.exists = h;
			a.visible = h;
			a.alive = h;
			a.events && a.events.onAddedToGroup.dispatch(a, this);
			this._container.addChild(a);
			a.updateTransform();
			null === this.cursor && (this.cursor = a);
			return a
		},
		createMultiple: function(a, b, d, e) {
			"undefined" == typeof e && (e = !1);
			for (var h = 0; h < a; h++) {
				var f = new c.Sprite(this.game, 0, 0, b, d);
				f.group = this;
				f.exists = e;
				f.visible = e;
				f.alive = e;
				f.events && f.events.onAddedToGroup.dispatch(f, this);
				this._container.addChild(f);
				f.updateTransform();
				null === this.cursor && (this.cursor = f)
			}
		},
		next: function() {
			this.cursor && (this.cursor = this.cursor == this._container.last ? this._container._iNext : this.cursor._iNext)
		},
		previous: function() {
			this.cursor && (this.cursor = this.cursor == this._container._iNext ? this._container.last : this.cursor._iPrev)
		},
		childTest: function(a, b) {
			var d = a + " next: ",
				d = b._iNext ? d + b._iNext.name : d + "-null-",
				d = d + " " + a + " prev: ",
				d = b._iPrev ? d + b._iPrev.name : d + "-null-";
			console.log(d)
		},
		swapIndex: function(a,
			b) {
			var d = this.getAt(a),
				c = this.getAt(b);
			console.log("swapIndex ", a, " with ", b);
			this.swap(d, c)
		},
		swap: function(a, b) {
			if (a === b || !a.parent || !b.parent || a.group !== this || b.group !== this) return !1;
			var d = a._iPrev,
				c = a._iNext,
				e = b._iPrev,
				f = b._iNext,
				k = this._container.last._iNext,
				m = this.game.stage._stage;
			do m !== a && m !== b && (m.first === a ? m.first = b : m.first === b && (m.first = a), m.last === a ? m.last = b : m.last === b && (m.last = a)), m = m._iNext; while (m != k);
			if (a._iNext == b) {
				a._iNext = f;
				a._iPrev = b;
				b._iNext = a;
				if (b._iPrev = d) d._iNext = b;
				f && (f._iPrev =
					a)
			} else if (b._iNext == a) a._iNext = b, a._iPrev = e, b._iNext = c, b._iPrev = a, e && (e._iNext = a), c && (c._iPrev = b);
			else {
				a._iNext = f;
				a._iPrev = e;
				b._iNext = c;
				if (b._iPrev = d) d._iNext = b;
				c && (c._iPrev = b);
				e && (e._iNext = a);
				f && (f._iPrev = a)
			}
			a.__renderGroup && a.__renderGroup.updateTexture(a);
			b.__renderGroup && b.__renderGroup.updateTexture(b);
			return !0
		},
		bringToTop: function(a) {
			a.group === this && (this.remove(a), this.add(a));
			return a
		},
		getIndex: function(a) {
			return this._container.children.indexOf(a)
		},
		replace: function(a, b) {
			if (this._container.first._iNext) {
				var d =
					this.getIndex(a); - 1 != d && (void 0 !== b.parent && (b.events.onRemovedFromGroup.dispatch(b, this), b.parent.removeChild(b)), this._container.removeChild(a), this._container.addChildAt(b, d), b.events.onAddedToGroup.dispatch(b, this), b.updateTransform(), this.cursor == a && (this.cursor = this._container._iNext))
			}
		},
		setProperty: function(a, b, d, c) {
			c = c || 0;
			var e = b.length;
			1 == e ? 0 === c ? a[b[0]] = d : 1 == c ? a[b[0]] += d : 2 == c ? a[b[0]] -= d : 3 == c ? a[b[0]] *= d : 4 == c && (a[b[0]] /= d) : 2 == e ? 0 === c ? a[b[0]][b[1]] = d : 1 == c ? a[b[0]][b[1]] += d : 2 == c ? a[b[0]][b[1]] -=
				d : 3 == c ? a[b[0]][b[1]] *= d : 4 == c && (a[b[0]][b[1]] /= d) : 3 == e ? 0 === c ? a[b[0]][b[1]][b[2]] = d : 1 == c ? a[b[0]][b[1]][b[2]] += d : 2 == c ? a[b[0]][b[1]][b[2]] -= d : 3 == c ? a[b[0]][b[1]][b[2]] *= d : 4 == c && (a[b[0]][b[1]][b[2]] /= d) : 4 == e && (0 === c ? a[b[0]][b[1]][b[2]][b[3]] = d : 1 == c ? a[b[0]][b[1]][b[2]][b[3]] += d : 2 == c ? a[b[0]][b[1]][b[2]][b[3]] -= d : 3 == c ? a[b[0]][b[1]][b[2]][b[3]] *= d : 4 == c && (a[b[0]][b[1]][b[2]][b[3]] /= d))
		},
		setAll: function(a, b, d, c, e) {
			a = a.split(".");
			"undefined" === typeof d && (d = !1);
			"undefined" === typeof c && (c = !1);
			e = e || 0;
			if (0 < this._container.children.length &&
				this._container.first._iNext) {
				var f = this._container.first._iNext;
				do(!1 === d || d && f.alive) && (!1 === c || c && f.visible) && this.setProperty(f, a, b, e), f = f._iNext; while (f != this._container.last._iNext)
			}
		},
		addAll: function(a, b, d, c) {
			this.setAll(a, b, d, c, 1)
		},
		subAll: function(a, b, d, c) {
			this.setAll(a, b, d, c, 2)
		},
		multiplyAll: function(a, b, d, c) {
			this.setAll(a, b, d, c, 3)
		},
		divideAll: function(a, b, d, c) {
			this.setAll(a, b, d, c, 4)
		},
		callAllExists: function(a, b) {
			var d = Array.prototype.splice.call(arguments, 2);
			if (0 < this._container.children.length &&
				this._container.first._iNext) {
				var c = this._container.first._iNext;
				do c.exists == b && c[a] && c[a].apply(c, d), c = c._iNext; while (c != this._container.last._iNext)
			}
		},
		callbackFromArray: function(a, b, d) {
			if (1 == d) {
				if (a[b[0]]) return a[b[0]]
			} else if (2 == d) {
				if (a[b[0]][b[1]]) return a[b[0]][b[1]]
			} else if (3 == d) {
				if (a[b[0]][b[1]][b[2]]) return a[b[0]][b[1]][b[2]]
			} else if (4 == d) {
				if (a[b[0]][b[1]][b[2]][b[3]]) return a[b[0]][b[1]][b[2]][b[3]]
			} else if (a[b]) return a[b];
			return !1
		},
		callAll: function(a, b) {
			if ("undefined" !== typeof a) {
				a =
					a.split(".");
				var d = a.length;
				if ("undefined" === typeof b) b = null;
				else if ("string" === typeof b) {
					b = b.split(".");
					var c = b.length
				}
				var e = Array.prototype.splice.call(arguments, 2),
					f = null,
					k = null;
				if (0 < this._container.children.length && this._container.first._iNext) {
					var m = this._container.first._iNext;
					do f = this.callbackFromArray(m, a, d), b && f ? (k = this.callbackFromArray(m, b, c), f && f.apply(k, e)) : f && f.apply(m, e), m = m._iNext; while (m != this._container.last._iNext)
				}
			}
		},
		forEach: function(a, b, d) {
			"undefined" === typeof d && (d = !1);
			var c =
				Array.prototype.splice.call(arguments, 3);
			c.unshift(null);
			if (0 < this._container.children.length && this._container.first._iNext) {
				var e = this._container.first._iNext;
				do {
					if (!1 === d || d && e.exists) c[0] = e, a.apply(b, c);
					e = e._iNext
				} while (e != this._container.last._iNext)
			}
		},
		forEachExists: function(a, b) {
			var d = Array.prototype.splice.call(arguments, 2);
			d.unshift(null);
			this.iterate("exists", !0, c.Group.RETURN_TOTAL, a, b, d)
		},
		forEachAlive: function(a, b) {
			var d = Array.prototype.splice.call(arguments, 2);
			d.unshift(null);
			this.iterate("alive", !0, c.Group.RETURN_TOTAL, a, b, d)
		},
		forEachDead: function(a, b) {
			var d = Array.prototype.splice.call(arguments, 2);
			d.unshift(null);
			this.iterate("alive", !1, c.Group.RETURN_TOTAL, a, b, d)
		},
		sort: function(a, b) {
			"undefined" === typeof a && (a = "y");
			"undefined" === typeof b && (b = c.Group.SORT_ASCENDING);
			var d;
			do {
				d = !1;
				for (var e = 0, f = this._container.children.length - 1; e < f; e++) b == c.Group.SORT_ASCENDING ? this._container.children[e][a] > this._container.children[e + 1][a] && (this.swap(this.getAt(e), this.getAt(e + 1)), d = this._container.children[e],
					this._container.children[e] = this._container.children[e + 1], this._container.children[e + 1] = d, d = !0) : this._container.children[e][a] < this._container.children[e + 1][a] && (this.swap(this.getAt(e), this.getAt(e + 1)), d = this._container.children[e], this._container.children[e] = this._container.children[e + 1], this._container.children[e + 1] = d, d = !0)
			} while (d)
		},
		iterate: function(a, b, d, e, f, g) {
			if (d == c.Group.RETURN_TOTAL && 0 === this._container.children.length) return -1;
			"undefined" === typeof e && (e = !1);
			var k = 0;
			if (0 < this._container.children.length &&
				this._container.first._iNext) {
				var m = this._container.first._iNext;
				do {
					if (m[a] === b && (k++, e && (g[0] = m, e.apply(f, g)), d == c.Group.RETURN_CHILD)) return m;
					m = m._iNext
				} while (m != this._container.last._iNext)
			}
			if (d == c.Group.RETURN_TOTAL) return k;
			if (d == c.Group.RETURN_CHILD) return null
		},
		getFirstExists: function(a) {
			"boolean" !== typeof a && (a = !0);
			return this.iterate("exists", a, c.Group.RETURN_CHILD)
		},
		getFirstAlive: function() {
			return this.iterate("alive", !0, c.Group.RETURN_CHILD)
		},
		getFirstDead: function() {
			return this.iterate("alive", !1, c.Group.RETURN_CHILD)
		},
		countLiving: function() {
			return this.iterate("alive", !0, c.Group.RETURN_TOTAL)
		},
		countDead: function() {
			return this.iterate("alive", !1, c.Group.RETURN_TOTAL)
		},
		getRandom: function(a, b) {
			if (0 === this._container.children.length) return null;
			b = b || this._container.children.length;
			return this.game.math.getRandom(this._container.children, a || 0, b)
		},
		remove: function(a) {
			if (a.group !== this) return !1;
			a.events && a.events.onRemovedFromGroup.dispatch(a, this);
			a.parent === this._container && this._container.removeChild(a);
			this.cursor == a && (this.cursor = this._container._iNext ? this._container._iNext : null);
			a.group = null;
			return !0
		},
		removeAll: function() {
			if (0 !== this._container.children.length) {
				do this._container.children[0].events && this._container.children[0].events.onRemovedFromGroup.dispatch(this._container.children[0], this), this._container.removeChild(this._container.children[0]); while (0 < this._container.children.length);
				this.cursor = null
			}
		},
		removeBetween: function(a, b) {
			if (0 !== this._container.children.length) {
				if (a > b || 0 > a || b >
					this._container.children.length) return !1;
				for (var d = a; d < b; d++) {
					var c = this._container.children[d];
					c.events.onRemovedFromGroup.dispatch(c, this);
					this._container.removeChild(c);
					this.cursor == c && (this.cursor = this._container._iNext ? this._container._iNext : null)
				}
			}
		},
		destroy: function() {
			this.removeAll();
			this._container.parent.removeChild(this._container);
			this.game = this._container = null;
			this.exists = !1;
			this.cursor = null
		},
		validate: function() {
			var a = this.game.stage._stage.last._iNext,
				b = this.game.stage._stage,
				d = null,
				c = null,
				e = 0;
			do {
				if (0 < e) {
					if (b !== d) return console.log("check next fail"), !1;
					if (b._iPrev !== c) return console.log("check previous fail"), !1
				}
				d = b._iNext;
				c = b;
				b = b._iNext;
				e++
			} while (b != a);
			return !0
		},
		dump: function(a) {
			"undefined" == typeof a && (a = !1);
			var b = "\n" + c.Utils.pad("Node", 20) + "|" + c.Utils.pad("Next", 20) + "|" + c.Utils.pad("Previous", 20) + "|" + c.Utils.pad("First", 20) + "|" + c.Utils.pad("Last", 20);
			console.log(b);
			b = c.Utils.pad("----------", 20) + "|" + c.Utils.pad("----------", 20) + "|" + c.Utils.pad("----------", 20) + "|" + c.Utils.pad("----------",
				20) + "|" + c.Utils.pad("----------", 20);
			console.log(b);
			if (a) {
				a = this.game.stage._stage.last._iNext;
				var d = this.game.stage._stage
			} else a = this._container.last._iNext, d = this._container;
			do {
				b = d.name || "*";
				this.cursor == d && (b = "> " + b);
				var e = "-",
					f = "-",
					g = "-",
					k = "-";
				d._iNext && (e = d._iNext.name);
				d._iPrev && (f = d._iPrev.name);
				d.first && (g = d.first.name);
				d.last && (k = d.last.name);
				"undefined" === typeof e && (e = "-");
				"undefined" === typeof f && (f = "-");
				"undefined" === typeof g && (g = "-");
				"undefined" === typeof k && (k = "-");
				b = c.Utils.pad(b, 20) +
					"|" + c.Utils.pad(e, 20) + "|" + c.Utils.pad(f, 20) + "|" + c.Utils.pad(g, 20) + "|" + c.Utils.pad(k, 20);
				console.log(b);
				d = d._iNext
			} while (d != a)
		}
	};
	Object.defineProperty(c.Group.prototype, "total", {
		get: function() {
			return this.iterate("exists", !0, c.Group.RETURN_TOTAL)
		}
	});
	Object.defineProperty(c.Group.prototype, "length", {
		get: function() {
			return this.iterate("exists", !0, c.Group.RETURN_TOTAL)
		}
	});
	Object.defineProperty(c.Group.prototype, "x", {
		get: function() {
			return this._container.position.x
		},
		set: function(a) {
			this._container.position.x =
				a
		}
	});
	Object.defineProperty(c.Group.prototype, "y", {
		get: function() {
			return this._container.position.y
		},
		set: function(a) {
			this._container.position.y = a
		}
	});
	Object.defineProperty(c.Group.prototype, "angle", {
		get: function() {
			return c.Math.radToDeg(this._container.rotation)
		},
		set: function(a) {
			this._container.rotation = c.Math.degToRad(a)
		}
	});
	Object.defineProperty(c.Group.prototype, "rotation", {
		get: function() {
			return this._container.rotation
		},
		set: function(a) {
			this._container.rotation = a
		}
	});
	Object.defineProperty(c.Group.prototype,
		"visible", {
			get: function() {
				return this._container.visible
			},
			set: function(a) {
				this._container.visible = a
			}
		});
	Object.defineProperty(c.Group.prototype, "alpha", {
		get: function() {
			return this._container.alpha
		},
		set: function(a) {
			this._container.alpha = a
		}
	});
	c.World = function(a) {
		c.Group.call(this, a, null, "__world", !1);
		this.scale = new c.Point(1, 1);
		this.bounds = new c.Rectangle(0, 0, a.width, a.height);
		this.camera = null;
		this.currentRenderOrderID = 0
	};
	c.World.prototype = Object.create(c.Group.prototype);
	c.World.prototype.constructor =
		c.World;
	c.World.prototype.boot = function() {
		this.camera = new c.Camera(this.game, 0, 0, 0, this.game.width, this.game.height);
		this.camera.displayObject = this._container;
		this.game.camera = this.camera
	};
	c.World.prototype.update = function() {
		this.currentRenderOrderID = 0;
		if (this.game.stage._stage.first._iNext) {
			var a = this.game.stage._stage.first._iNext,
				b;
			do b = !1, a.preUpdate && (b = !1 === a.preUpdate()), a.update && (b = !1 === a.update() || b), a = b ? a.last._iNext : a._iNext; while (a != this.game.stage._stage.last._iNext)
		}
	};
	c.World.prototype.postUpdate =
		function() {
			if (this.game.stage._stage.first._iNext) {
				var a = this.game.stage._stage.first._iNext;
				do a.postUpdate && a.postUpdate(), a = a._iNext; while (a != this.game.stage._stage.last._iNext)
			}
			this.camera.update()
	};
	c.World.prototype.setBounds = function(a, b, d, c) {
		this.bounds.setTo(a, b, d, c);
		this.camera.bounds && this.camera.bounds.setTo(a, b, d, c)
	};
	c.World.prototype.destroy = function() {
		this.camera.x = 0;
		this.camera.y = 0;
		this.game.input.reset(!0);
		this.removeAll()
	};
	Object.defineProperty(c.World.prototype, "width", {
		get: function() {
			return this.bounds.width
		},
		set: function(a) {
			this.bounds.width = a
		}
	});
	Object.defineProperty(c.World.prototype, "height", {
		get: function() {
			return this.bounds.height
		},
		set: function(a) {
			this.bounds.height = a
		}
	});
	Object.defineProperty(c.World.prototype, "centerX", {
		get: function() {
			return this.bounds.halfWidth
		}
	});
	Object.defineProperty(c.World.prototype, "centerY", {
		get: function() {
			return this.bounds.halfHeight
		}
	});
	Object.defineProperty(c.World.prototype, "randomX", {
		get: function() {
			return 0 > this.bounds.x ? this.game.rnd.integerInRange(this.bounds.x, this.bounds.width -
				Math.abs(this.bounds.x)) : this.game.rnd.integerInRange(this.bounds.x, this.bounds.width)
		}
	});
	Object.defineProperty(c.World.prototype, "randomY", {
		get: function() {
			return 0 > this.bounds.y ? this.game.rnd.integerInRange(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.integerInRange(this.bounds.y, this.bounds.height)
		}
	});
	Object.defineProperty(c.World.prototype, "visible", {
		get: function() {
			return this._container.visible
		},
		set: function(a) {
			this._container.visible = a
		}
	});
	c.Game = function(a, b, d, e, f,
		g, k) {
		a = a || 800;
		b = b || 600;
		d = d || c.AUTO;
		e = e || "";
		f = f || null;
		"undefined" == typeof g && (g = !1);
		"undefined" == typeof k && (k = !0);
		this.id = c.GAMES.push(this) - 1;
		this.parent = e;
		this.width = a;
		this.height = b;
		this.transparent = g;
		this.antialias = k;
		this.renderer = null;
		this.state = new c.StateManager(this, f);
		this._paused = !1;
		this.renderType = d;
		this.isRunning = this.isBooted = this._loadComplete = !1;
		this.particles = this.debug = this.context = this.canvas = this.camera = this.device = this.rnd = this.physics = this.world = this.tweens = this.time = this.stage =
			this.sound = this.net = this.math = this.load = this.input = this.cache = this.add = this.raf = null;
		var m = this;
		this._onBoot = function() {
			return m.boot()
		};
		"complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(this._onBoot, 0) : (document.addEventListener("DOMContentLoaded", this._onBoot, !1), window.addEventListener("load", this._onBoot, !1));
		return this
	};
	c.Game.prototype = {
		boot: function() {
			this.isBooted || (document.body ? (document.removeEventListener("DOMContentLoaded", this._onBoot), window.removeEventListener("load",
					this._onBoot), this.onPause = new c.Signal, this.onResume = new c.Signal, this.isBooted = !0, this.device = new c.Device, this.math = c.Math, this.rnd = new c.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.stage = new c.Stage(this, this.width, this.height), this.setUpRenderer(), this.world = new c.World(this), this.add = new c.GameObjectFactory(this), this.cache = new c.Cache(this), this.load = new c.Loader(this), this.time = new c.Time(this), this.tweens = new c.TweenManager(this), this.input = new c.Input(this), this.sound =
				new c.SoundManager(this), this.physics = new c.Physics.Arcade(this), this.particles = new c.Particles(this), this.plugins = new c.PluginManager(this, this), this.net = new c.Net(this), this.debug = new c.Utils.Debug(this), this.stage.boot(), this.world.boot(), this.input.boot(), this.sound.boot(), this.state.boot(), this.load.onLoadComplete.add(this.loadComplete, this), this.showDebugHeader(), this.isRunning = !0, this._loadComplete = !1, this.raf = new c.RequestAnimationFrame(this), this.device.android && (this.raf.forceSetTimeOut = !0), this.raf.start()) : window.setTimeout(this._onBoot, 20))
		},
		showDebugHeader: function() {
			var a = c.DEV_VERSION,
				b = "Canvas",
				d = "HTML Audio";
			this.renderType == c.WEBGL ? b = "WebGL" : this.renderType == c.HEADLESS && (b = "Headless");
			this.device.webAudio && (d = "WebAudio");
			this.device.chrome ? console.log.apply(console, ["%c %c %c  Phaser v" + a + " - Renderer: " + b + " - Audio: " + d + "  %c %c ", "background: #00bff3", "background: #0072bc", "color: #ffffff; background: #003471", "background: #0072bc", "background: #00bff3"]) : console.log("Phaser v" +
				a + " - Renderer: " + b + " - Audio: " + d)
		},
		setUpRenderer: function() {
			if (this.renderType === c.HEADLESS || this.renderType === c.CANVAS || this.renderType === c.AUTO && !1 === this.device.webGL)
				if (this.device.canvas) this.renderType === c.AUTO && (this.renderType = c.CANVAS), this.renderer = new e.CanvasRenderer(this.width, this.height, this.stage.canvas, this.transparent), c.Canvas.setSmoothingEnabled(this.renderer.context, this.antialias), this.canvas = this.renderer.view, this.context = this.renderer.context;
				else throw Error("Phaser.Game - cannot create Canvas or WebGL context, aborting.");
			else this.renderType = c.WEBGL, this.renderer = new e.WebGLRenderer(this.width, this.height, this.stage.canvas, this.transparent, this.antialias), this.canvas = this.renderer.view, this.context = null;
			c.Canvas.addToDOM(this.renderer.view, this.parent, !0);
			c.Canvas.setTouchAction(this.renderer.view)
		},
		loadComplete: function() {
			this._loadComplete = !0;
			this.state.loadComplete()
		},
		update: function(a) {
			this.time.update(a);
			this._paused ? (this.renderer.render(this.stage._stage), this.plugins.render(), this.state.render()) : (this.plugins.preUpdate(),
				this.physics.preUpdate(), this.stage.update(), this.input.update(), this.tweens.update(), this.sound.update(), this.world.update(), this.particles.update(), this.state.update(), this.plugins.update(), this.world.postUpdate(), this.plugins.postUpdate(), this.renderType !== c.HEADLESS && (this.renderer.render(this.stage._stage), this.plugins.render(), this.state.render(), this.plugins.postRender()))
		},
		destroy: function() {
			this.raf.stop();
			this.input.destroy();
			this.state.destroy();
			this.world = this.time = this.stage = this.sound =
				this.load = this.input = this.cache = this.state = null;
			this.isBooted = !1
		}
	};
	Object.defineProperty(c.Game.prototype, "paused", {
		get: function() {
			return this._paused
		},
		set: function(a) {
			!0 === a ? !1 === this._paused && (this._paused = !0, this.onPause.dispatch(this)) : this._paused && (this._paused = !1, this.onResume.dispatch(this))
		}
	});
	c.Input = function(a) {
		this.game = a;
		this.hitContext = this.hitCanvas = null
	};
	c.Input.MOUSE_OVERRIDES_TOUCH = 0;
	c.Input.TOUCH_OVERRIDES_MOUSE = 1;
	c.Input.MOUSE_TOUCH_COMBINE = 2;
	c.Input.prototype = {
		pollRate: 0,
		_pollCounter: 0,
		_oldPosition: null,
		_x: 0,
		_y: 0,
		disabled: !1,
		multiInputOverride: c.Input.MOUSE_TOUCH_COMBINE,
		position: null,
		speed: null,
		circle: null,
		scale: null,
		maxPointers: 10,
		currentPointers: 0,
		tapRate: 200,
		doubleTapRate: 300,
		holdRate: 2E3,
		justPressedRate: 200,
		justReleasedRate: 200,
		recordPointerHistory: !1,
		recordRate: 100,
		recordLimit: 100,
		pointer1: null,
		pointer2: null,
		pointer3: null,
		pointer4: null,
		pointer5: null,
		pointer6: null,
		pointer7: null,
		pointer8: null,
		pointer9: null,
		pointer10: null,
		activePointer: null,
		mousePointer: null,
		mouse: null,
		keyboard: null,
		touch: null,
		mspointer: null,
		onDown: null,
		onUp: null,
		onTap: null,
		onHold: null,
		interactiveItems: new c.LinkedList,
		boot: function() {
			this.mousePointer = new c.Pointer(this.game, 0);
			this.pointer1 = new c.Pointer(this.game, 1);
			this.pointer2 = new c.Pointer(this.game, 2);
			this.mouse = new c.Mouse(this.game);
			this.keyboard = new c.Keyboard(this.game);
			this.touch = new c.Touch(this.game);
			this.mspointer = new c.MSPointer(this.game);
			this.onDown = new c.Signal;
			this.onUp = new c.Signal;
			this.onTap = new c.Signal;
			this.onHold = new c.Signal;
			this.scale =
				new c.Point(1, 1);
			this.speed = new c.Point;
			this.position = new c.Point;
			this._oldPosition = new c.Point;
			this.circle = new c.Circle(0, 0, 44);
			this.activePointer = this.mousePointer;
			this.currentPointers = 0;
			this.hitCanvas = document.createElement("canvas");
			this.hitCanvas.width = 1;
			this.hitCanvas.height = 1;
			this.hitContext = this.hitCanvas.getContext("2d");
			this.mouse.start();
			this.keyboard.start();
			this.touch.start();
			this.mspointer.start();
			this.mousePointer.active = !0
		},
		destroy: function() {
			this.mouse.stop();
			this.keyboard.stop();
			this.touch.stop();
			this.mspointer.stop()
		},
		addPointer: function() {
			for (var a = 0, b = 10; 0 < b; b--) null === this["pointer" + b] && (a = b);
			if (0 === a) return console.warn("You can only have 10 Pointer objects"), null;
			this["pointer" + a] = new c.Pointer(this.game, a);
			return this["pointer" + a]
		},
		update: function() {
			0 < this.pollRate && this._pollCounter < this.pollRate ? this._pollCounter++ : (this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(),
				this.pointer1.update(), this.pointer2.update(), this.pointer3 && this.pointer3.update(), this.pointer4 && this.pointer4.update(), this.pointer5 && this.pointer5.update(), this.pointer6 && this.pointer6.update(), this.pointer7 && this.pointer7.update(), this.pointer8 && this.pointer8.update(), this.pointer9 && this.pointer9.update(), this.pointer10 && this.pointer10.update(), this._pollCounter = 0)
		},
		reset: function(a) {
			if (!1 !== this.game.isBooted) {
				"undefined" == typeof a && (a = !1);
				this.keyboard.reset();
				this.mousePointer.reset();
				for (var b =
					1; 10 >= b; b++) this["pointer" + b] && this["pointer" + b].reset();
				this.currentPointers = 0;
				this.game.stage.canvas.style.cursor = "default";
				!0 === a && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new c.Signal, this.onUp = new c.Signal, this.onTap = new c.Signal, this.onHold = new c.Signal, this.interactiveItems.callAll("reset"));
				this._pollCounter = 0
			}
		},
		resetSpeed: function(a, b) {
			this._oldPosition.setTo(a, b);
			this.speed.setTo(0, 0)
		},
		startPointer: function(a) {
			if (10 > this.maxPointers &&
				this.totalActivePointers == this.maxPointers) return null;
			if (!1 === this.pointer1.active) return this.pointer1.start(a);
			if (!1 === this.pointer2.active) return this.pointer2.start(a);
			for (var b = 3; 10 >= b; b++)
				if (this["pointer" + b] && !1 === this["pointer" + b].active) return this["pointer" + b].start(a);
			return null
		},
		updatePointer: function(a) {
			if (this.pointer1.active && this.pointer1.identifier == a.identifier) return this.pointer1.move(a);
			if (this.pointer2.active && this.pointer2.identifier == a.identifier) return this.pointer2.move(a);
			for (var b = 3; 10 >= b; b++)
				if (this["pointer" + b] && this["pointer" + b].active && this["pointer" + b].identifier == a.identifier) return this["pointer" + b].move(a);
			return null
		},
		stopPointer: function(a) {
			if (this.pointer1.active && this.pointer1.identifier == a.identifier) return this.pointer1.stop(a);
			if (this.pointer2.active && this.pointer2.identifier == a.identifier) return this.pointer2.stop(a);
			for (var b = 3; 10 >= b; b++)
				if (this["pointer" + b] && this["pointer" + b].active && this["pointer" + b].identifier == a.identifier) return this["pointer" +
					b].stop(a);
			return null
		},
		getPointer: function(a) {
			a = a || !1;
			if (this.pointer1.active == a) return this.pointer1;
			if (this.pointer2.active == a) return this.pointer2;
			for (var b = 3; 10 >= b; b++)
				if (this["pointer" + b] && this["pointer" + b].active == a) return this["pointer" + b];
			return null
		},
		getPointerFromIdentifier: function(a) {
			if (this.pointer1.identifier == a) return this.pointer1;
			if (this.pointer2.identifier == a) return this.pointer2;
			for (var b = 3; 10 >= b; b++)
				if (this["pointer" + b] && this["pointer" + b].identifier == a) return this["pointer" + b];
			return null
		}
	};
	Object.defineProperty(c.Input.prototype, "x", {
		get: function() {
			return this._x
		},
		set: function(a) {
			this._x = Math.floor(a)
		}
	});
	Object.defineProperty(c.Input.prototype, "y", {
		get: function() {
			return this._y
		},
		set: function(a) {
			this._y = Math.floor(a)
		}
	});
	Object.defineProperty(c.Input.prototype, "pollLocked", {
		get: function() {
			return 0 < this.pollRate && this._pollCounter < this.pollRate
		}
	});
	Object.defineProperty(c.Input.prototype, "totalInactivePointers", {
		get: function() {
			return 10 - this.currentPointers
		}
	});
	Object.defineProperty(c.Input.prototype,
		"totalActivePointers", {
			get: function() {
				this.currentPointers = 0;
				for (var a = 1; 10 >= a; a++) this["pointer" + a] && this["pointer" + a].active && this.currentPointers++;
				return this.currentPointers
			}
		});
	Object.defineProperty(c.Input.prototype, "worldX", {
		get: function() {
			return this.game.camera.view.x + this.x
		}
	});
	Object.defineProperty(c.Input.prototype, "worldY", {
		get: function() {
			return this.game.camera.view.y + this.y
		}
	});
	c.Key = function(a, b) {
		this.game = a;
		this.shiftKey = this.ctrlKey = this.altKey = this.isUp = this.isDown = !1;
		this.repeats =
			this.timeUp = this.duration = this.timeDown = 0;
		this.keyCode = b;
		this.onDown = new c.Signal;
		this.onUp = new c.Signal
	};
	c.Key.prototype = {
		processKeyDown: function(a) {
			this.altKey = a.altKey;
			this.ctrlKey = a.ctrlKey;
			this.shiftKey = a.shiftKey;
			this.isDown ? (this.duration = a.timeStamp - this.timeDown, this.repeats++) : (this.isDown = !0, this.isUp = !1, this.timeDown = a.timeStamp, this.repeats = this.duration = 0, this.onDown.dispatch(this))
		},
		processKeyUp: function(a) {
			this.isDown = !1;
			this.isUp = !0;
			this.timeUp = a.timeStamp;
			this.onUp.dispatch(this)
		},
		justPressed: function(a) {
			"undefined" === typeof a && (a = 250);
			return this.isDown && this.duration < a
		},
		justReleased: function(a) {
			"undefined" === typeof a && (a = 250);
			return !1 === this.isDown && this.game.time.now - this.timeUp < a
		}
	};
	c.Keyboard = function(a) {
		this.game = a;
		this._keys = {};
		this._hotkeys = {};
		this._capture = {};
		this.disabled = !1;
		this._onKeyUp = this._onKeyDown = null;
		this.callbackContext = this;
		this.onUpCallback = this.onDownCallback = null
	};
	c.Keyboard.prototype = {
		addCallbacks: function(a, b, d) {
			this.callbackContext = a;
			this.onDownCallback =
				b;
			"undefined" !== typeof d && (this.onUpCallback = d)
		},
		addKey: function(a) {
			this._hotkeys[a] = new c.Key(this.game, a);
			this.addKeyCapture(a);
			return this._hotkeys[a]
		},
		removeKey: function(a) {
			delete this._hotkeys[a]
		},
		createCursorKeys: function() {
			return {
				up: this.addKey(c.Keyboard.UP),
				down: this.addKey(c.Keyboard.DOWN),
				left: this.addKey(c.Keyboard.LEFT),
				right: this.addKey(c.Keyboard.RIGHT)
			}
		},
		start: function() {
			var a = this;
			this._onKeyDown = function(b) {
				return a.processKeyDown(b)
			};
			this._onKeyUp = function(b) {
				return a.processKeyUp(b)
			};
			window.addEventListener("keydown", this._onKeyDown, !1);
			window.addEventListener("keyup", this._onKeyUp, !1)
		},
		stop: function() {
			window.removeEventListener("keydown", this._onKeyDown);
			window.removeEventListener("keyup", this._onKeyUp)
		},
		addKeyCapture: function(a) {
			if ("object" === typeof a)
				for (var b in a) this._capture[a[b]] = !0;
			else this._capture[a] = !0
		},
		removeKeyCapture: function(a) {
			delete this._capture[a]
		},
		clearCaptures: function() {
			this._capture = {}
		},
		processKeyDown: function(a) {
			this.game.input.disabled || this.disabled ||
				(this._capture[a.keyCode] && a.preventDefault(), this.onDownCallback && this.onDownCallback.call(this.callbackContext, a), this._keys[a.keyCode] && this._keys[a.keyCode].isDown ? this._keys[a.keyCode].duration = this.game.time.now - this._keys[a.keyCode].timeDown : this._keys[a.keyCode] ? (this._keys[a.keyCode].isDown = !0, this._keys[a.keyCode].timeDown = this.game.time.now, this._keys[a.keyCode].duration = 0) : this._keys[a.keyCode] = {
				isDown: !0,
				timeDown: this.game.time.now,
				timeUp: 0,
				duration: 0
			}, this._hotkeys[a.keyCode] && this._hotkeys[a.keyCode].processKeyDown(a))
		},
		processKeyUp: function(a) {
			this.game.input.disabled || this.disabled || (this._capture[a.keyCode] && a.preventDefault(), this.onUpCallback && this.onUpCallback.call(this.callbackContext, a), this._hotkeys[a.keyCode] && this._hotkeys[a.keyCode].processKeyUp(a), this._keys[a.keyCode] ? (this._keys[a.keyCode].isDown = !1, this._keys[a.keyCode].timeUp = this.game.time.now) : this._keys[a.keyCode] = {
				isDown: !1,
				timeDown: this.game.time.now,
				timeUp: this.game.time.now,
				duration: 0
			})
		},
		reset: function() {
			for (var a in this._keys) this._keys[a].isDown = !1
		},
		justPressed: function(a, b) {
			"undefined" === typeof b && (b = 250);
			return this._keys[a] && this._keys[a].isDown && this._keys[a].duration < b ? !0 : !1
		},
		justReleased: function(a, b) {
			"undefined" === typeof b && (b = 250);
			return this._keys[a] && !1 === this._keys[a].isDown && this.game.time.now - this._keys[a].timeUp < b ? !0 : !1
		},
		isDown: function(a) {
			return this._keys[a] ? this._keys[a].isDown : !1
		}
	};
	c.Keyboard.A = 65;
	c.Keyboard.B = 66;
	c.Keyboard.C = 67;
	c.Keyboard.D = 68;
	c.Keyboard.E = 69;
	c.Keyboard.F = 70;
	c.Keyboard.G = 71;
	c.Keyboard.H = 72;
	c.Keyboard.I =
		73;
	c.Keyboard.J = 74;
	c.Keyboard.K = 75;
	c.Keyboard.L = 76;
	c.Keyboard.M = 77;
	c.Keyboard.N = 78;
	c.Keyboard.O = 79;
	c.Keyboard.P = 80;
	c.Keyboard.Q = 81;
	c.Keyboard.R = 82;
	c.Keyboard.S = 83;
	c.Keyboard.T = 84;
	c.Keyboard.U = 85;
	c.Keyboard.V = 86;
	c.Keyboard.W = 87;
	c.Keyboard.X = 88;
	c.Keyboard.Y = 89;
	c.Keyboard.Z = 90;
	c.Keyboard.ZERO = 48;
	c.Keyboard.ONE = 49;
	c.Keyboard.TWO = 50;
	c.Keyboard.THREE = 51;
	c.Keyboard.FOUR = 52;
	c.Keyboard.FIVE = 53;
	c.Keyboard.SIX = 54;
	c.Keyboard.SEVEN = 55;
	c.Keyboard.EIGHT = 56;
	c.Keyboard.NINE = 57;
	c.Keyboard.NUMPAD_0 = 96;
	c.Keyboard.NUMPAD_1 =
		97;
	c.Keyboard.NUMPAD_2 = 98;
	c.Keyboard.NUMPAD_3 = 99;
	c.Keyboard.NUMPAD_4 = 100;
	c.Keyboard.NUMPAD_5 = 101;
	c.Keyboard.NUMPAD_6 = 102;
	c.Keyboard.NUMPAD_7 = 103;
	c.Keyboard.NUMPAD_8 = 104;
	c.Keyboard.NUMPAD_9 = 105;
	c.Keyboard.NUMPAD_MULTIPLY = 106;
	c.Keyboard.NUMPAD_ADD = 107;
	c.Keyboard.NUMPAD_ENTER = 108;
	c.Keyboard.NUMPAD_SUBTRACT = 109;
	c.Keyboard.NUMPAD_DECIMAL = 110;
	c.Keyboard.NUMPAD_DIVIDE = 111;
	c.Keyboard.F1 = 112;
	c.Keyboard.F2 = 113;
	c.Keyboard.F3 = 114;
	c.Keyboard.F4 = 115;
	c.Keyboard.F5 = 116;
	c.Keyboard.F6 = 117;
	c.Keyboard.F7 = 118;
	c.Keyboard.F8 =
		119;
	c.Keyboard.F9 = 120;
	c.Keyboard.F10 = 121;
	c.Keyboard.F11 = 122;
	c.Keyboard.F12 = 123;
	c.Keyboard.F13 = 124;
	c.Keyboard.F14 = 125;
	c.Keyboard.F15 = 126;
	c.Keyboard.COLON = 186;
	c.Keyboard.EQUALS = 187;
	c.Keyboard.UNDERSCORE = 189;
	c.Keyboard.QUESTION_MARK = 191;
	c.Keyboard.TILDE = 192;
	c.Keyboard.OPEN_BRACKET = 219;
	c.Keyboard.BACKWARD_SLASH = 220;
	c.Keyboard.CLOSED_BRACKET = 221;
	c.Keyboard.QUOTES = 222;
	c.Keyboard.BACKSPACE = 8;
	c.Keyboard.TAB = 9;
	c.Keyboard.CLEAR = 12;
	c.Keyboard.ENTER = 13;
	c.Keyboard.SHIFT = 16;
	c.Keyboard.CONTROL = 17;
	c.Keyboard.ALT =
		18;
	c.Keyboard.CAPS_LOCK = 20;
	c.Keyboard.ESC = 27;
	c.Keyboard.SPACEBAR = 32;
	c.Keyboard.PAGE_UP = 33;
	c.Keyboard.PAGE_DOWN = 34;
	c.Keyboard.END = 35;
	c.Keyboard.HOME = 36;
	c.Keyboard.LEFT = 37;
	c.Keyboard.UP = 38;
	c.Keyboard.RIGHT = 39;
	c.Keyboard.DOWN = 40;
	c.Keyboard.INSERT = 45;
	c.Keyboard.DELETE = 46;
	c.Keyboard.HELP = 47;
	c.Keyboard.NUM_LOCK = 144;
	c.Mouse = function(a) {
		this.callbackContext = this.game = a;
		this.mouseUpCallback = this.mouseMoveCallback = this.mouseDownCallback = null;
		this.capture = !1;
		this.button = -1;
		this.locked = this.disabled = !1;
		this.pointerLock =
			new c.Signal;
		this._onMouseUp = this._onMouseMove = this._onMouseDown = this.event = null
	};
	c.Mouse.NO_BUTTON = -1;
	c.Mouse.LEFT_BUTTON = 0;
	c.Mouse.MIDDLE_BUTTON = 1;
	c.Mouse.RIGHT_BUTTON = 2;
	c.Mouse.prototype = {
		start: function() {
			var a = this;
			this.game.device.android && !1 === this.game.device.chrome || (this._onMouseDown = function(b) {
				return a.onMouseDown(b)
			}, this._onMouseMove = function(b) {
				return a.onMouseMove(b)
			}, this._onMouseUp = function(b) {
				return a.onMouseUp(b)
			}, document.addEventListener("mousedown", this._onMouseDown, !0), document.addEventListener("mousemove",
				this._onMouseMove, !0), document.addEventListener("mouseup", this._onMouseUp, !0))
		},
		onMouseDown: function(a) {
			this.event = a;
			this.capture && a.preventDefault();
			this.button = a.which;
			this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, a);
			this.game.input.disabled || this.disabled || (a.identifier = 0, this.game.input.mousePointer.start(a))
		},
		onMouseMove: function(a) {
			this.event = a;
			this.capture && a.preventDefault();
			this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, a);
			this.game.input.disabled ||
				this.disabled || (a.identifier = 0, this.game.input.mousePointer.move(a))
		},
		onMouseUp: function(a) {
			this.event = a;
			this.capture && a.preventDefault();
			this.button = c.Mouse.NO_BUTTON;
			this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, a);
			this.game.input.disabled || this.disabled || (a.identifier = 0, this.game.input.mousePointer.stop(a))
		},
		requestPointerLock: function() {
			if (this.game.device.pointerLock) {
				var a = this.game.stage.canvas;
				a.requestPointerLock = a.requestPointerLock || a.mozRequestPointerLock || a.webkitRequestPointerLock;
				a.requestPointerLock();
				var b = this;
				this._pointerLockChange = function(a) {
					return b.pointerLockChange(a)
				};
				document.addEventListener("pointerlockchange", this._pointerLockChange, !0);
				document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0);
				document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
			}
		},
		pointerLockChange: function(a) {
			var b = this.game.stage.canvas;
			document.pointerLockElement === b || document.mozPointerLockElement === b || document.webkitPointerLockElement === b ? (this.locked = !0, this.pointerLock.dispatch(!0, a)) : (this.locked = !1, this.pointerLock.dispatch(!1, a))
		},
		releasePointerLock: function() {
			document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
			document.exitPointerLock();
			document.removeEventListener("pointerlockchange", this._pointerLockChange, !0);
			document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0);
			document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
		},
		stop: function() {
			document.removeEventListener("mousedown",
				this._onMouseDown, !0);
			document.removeEventListener("mousemove", this._onMouseMove, !0);
			document.removeEventListener("mouseup", this._onMouseUp, !0)
		}
	};
	c.MSPointer = function(a) {
		this.callbackContext = this.game = a;
		this.disabled = !1;
		this._onMSPointerUp = this._onMSPointerMove = this._onMSPointerDown = null
	};
	c.MSPointer.prototype = {
		start: function() {
			var a = this;
			!0 === this.game.device.mspointer && (this._onMSPointerDown = function(b) {
					return a.onPointerDown(b)
				}, this._onMSPointerMove = function(b) {
					return a.onPointerMove(b)
				}, this._onMSPointerUp =
				function(b) {
					return a.onPointerUp(b)
				}, this.game.renderer.view.addEventListener("MSPointerDown", this._onMSPointerDown, !1), this.game.renderer.view.addEventListener("MSPointerMove", this._onMSPointerMove, !1), this.game.renderer.view.addEventListener("MSPointerUp", this._onMSPointerUp, !1), this.game.renderer.view.addEventListener("pointerDown", this._onMSPointerDown, !1), this.game.renderer.view.addEventListener("pointerMove", this._onMSPointerMove, !1), this.game.renderer.view.addEventListener("pointerUp", this._onMSPointerUp, !1), this.game.renderer.view.style["-ms-content-zooming"] = "none", this.game.renderer.view.style["-ms-touch-action"] = "none")
		},
		onPointerDown: function(a) {
			this.game.input.disabled || this.disabled || (a.preventDefault(), a.identifier = a.pointerId, this.game.input.startPointer(a))
		},
		onPointerMove: function(a) {
			this.game.input.disabled || this.disabled || (a.preventDefault(), a.identifier = a.pointerId, this.game.input.updatePointer(a))
		},
		onPointerUp: function(a) {
			this.game.input.disabled || this.disabled || (a.preventDefault(),
				a.identifier = a.pointerId, this.game.input.stopPointer(a))
		},
		stop: function() {
			this.game.stage.canvas.removeEventListener("MSPointerDown", this._onMSPointerDown);
			this.game.stage.canvas.removeEventListener("MSPointerMove", this._onMSPointerMove);
			this.game.stage.canvas.removeEventListener("MSPointerUp", this._onMSPointerUp);
			this.game.stage.canvas.removeEventListener("pointerDown", this._onMSPointerDown);
			this.game.stage.canvas.removeEventListener("pointerMove", this._onMSPointerMove);
			this.game.stage.canvas.removeEventListener("pointerUp",
				this._onMSPointerUp)
		}
	};
	c.Pointer = function(a, b) {
		this.game = a;
		this.id = b;
		this._holdSent = !1;
		this._history = [];
		this._nextDrop = 0;
		this.withinGame = this._stateReset = !1;
		this.y = this.x = this.screenY = this.screenX = this.pageY = this.pageX = this.clientY = this.clientX = -1;
		this.isDown = this.isMouse = !1;
		this.isUp = !0;
		this.totalTouches = this.previousTapTime = this.timeUp = this.timeDown = 0;
		this.msSinceLastClick = Number.MAX_VALUE;
		this.targetObject = null;
		this.active = !1;
		this.position = new c.Point;
		this.positionDown = new c.Point;
		this.circle =
			new c.Circle(0, 0, 44);
		0 === b && (this.isMouse = !0)
	};
	c.Pointer.prototype = {
		start: function(a) {
			this.identifier = a.identifier;
			this.target = a.target;
			"undefined" !== typeof a.button && (this.button = a.button);
			if (!0 === this.game.paused && !1 === this.game.stage.scale.incorrectOrientation) return this.game.paused = !1, this;
			this._history.length = 0;
			this.isDown = this.withinGame = this.active = !0;
			this.isUp = !1;
			this.msSinceLastClick = this.game.time.now - this.timeDown;
			this.timeDown = this.game.time.now;
			this._holdSent = !1;
			this.move(a);
			this.positionDown.setTo(this.x,
				this.y);
			if (this.game.input.multiInputOverride == c.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride == c.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride == c.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.currentPointers) this.game.input.x = this.x, this.game.input.y = this.y, this.game.input.position.setTo(this.x, this.y), this.game.input.onDown.dispatch(this, a), this.game.input.resetSpeed(this.x, this.y);
			this._stateReset = !1;
			this.totalTouches++;
			!1 === this.isMouse && this.game.input.currentPointers++;
			null !== this.targetObject && this.targetObject._touchedHandler(this);
			return this
		},
		update: function() {
			this.active && (!1 === this._holdSent && this.duration >= this.game.input.holdRate && ((this.game.input.multiInputOverride == c.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride == c.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride == c.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.currentPointers) && this.game.input.onHold.dispatch(this), this._holdSent = !0), this.game.input.recordPointerHistory &&
				this.game.time.now >= this._nextDrop && (this._nextDrop = this.game.time.now + this.game.input.recordRate, this._history.push({
					x: this.position.x,
					y: this.position.y
				}), this._history.length > this.game.input.recordLimit && this._history.shift()))
		},
		move: function(a) {
			if (!this.game.input.pollLocked) {
				"undefined" !== typeof a.button && (this.button = a.button);
				this.clientX = a.clientX;
				this.clientY = a.clientY;
				this.pageX = a.pageX;
				this.pageY = a.pageY;
				this.screenX = a.screenX;
				this.screenY = a.screenY;
				this.x = (this.pageX - this.game.stage.offset.x) *
					this.game.input.scale.x;
				this.y = (this.pageY - this.game.stage.offset.y) * this.game.input.scale.y;
				this.position.setTo(this.x, this.y);
				this.circle.x = this.x;
				this.circle.y = this.y;
				if (this.game.input.multiInputOverride == c.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride == c.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride == c.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.currentPointers) this.game.input.activePointer = this, this.game.input.x = this.x, this.game.input.y = this.y, this.game.input.position.setTo(this.game.input.x,
					this.game.input.y), this.game.input.circle.x = this.game.input.x, this.game.input.circle.y = this.game.input.y;
				if (this.game.paused) return this;
				if (null !== this.targetObject && !0 === this.targetObject.isDragged) return !1 === this.targetObject.update(this) && (this.targetObject = null), this;
				this._highestRenderOrderID = -1;
				this._highestRenderObject = null;
				this._highestInputPriorityID = -1;
				if (0 < this.game.input.interactiveItems.total) {
					a = this.game.input.interactiveItems.next;
					do(a.pixelPerfect || a.priorityID > this._highestInputPriorityID ||
						a.priorityID == this._highestInputPriorityID && a.sprite.renderOrderID > this._highestRenderOrderID) && a.checkPointerOver(this) && (this._highestRenderOrderID = a.sprite.renderOrderID, this._highestInputPriorityID = a.priorityID, this._highestRenderObject = a), a = a.next; while (null != a)
				}
				null == this._highestRenderObject ? this.targetObject && (this.targetObject._pointerOutHandler(this), this.targetObject = null) : null == this.targetObject ? (this.targetObject = this._highestRenderObject, this._highestRenderObject._pointerOverHandler(this)) :
					this.targetObject == this._highestRenderObject ? !1 === this._highestRenderObject.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this), this.targetObject = this._highestRenderObject, this.targetObject._pointerOverHandler(this));
				return this
			}
		},
		leave: function(a) {
			this.withinGame = !1;
			this.move(a)
		},
		stop: function(a) {
			if (this._stateReset) a.preventDefault();
			else {
				this.timeUp = this.game.time.now;
				if (this.game.input.multiInputOverride == c.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride ==
					c.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride == c.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.currentPointers) this.game.input.onUp.dispatch(this, a), 0 <= this.duration && this.duration <= this.game.input.tapRate && (this.timeUp - this.previousTapTime < this.game.input.doubleTapRate ? this.game.input.onTap.dispatch(this, !0) : this.game.input.onTap.dispatch(this, !1), this.previousTapTime = this.timeUp);
				0 < this.id && (this.active = !1);
				this.isDown = this.withinGame = !1;
				this.isUp = !0;
				!1 === this.isMouse && this.game.input.currentPointers--;
				if (0 < this.game.input.interactiveItems.total) {
					a = this.game.input.interactiveItems.next;
					do a && a._releasedHandler(this), a = a.next; while (null != a)
				}
				this.targetObject && this.targetObject._releasedHandler(this);
				this.targetObject = null;
				return this
			}
		},
		justPressed: function(a) {
			a = a || this.game.input.justPressedRate;
			return !0 === this.isDown && this.timeDown + a > this.game.time.now
		},
		justReleased: function(a) {
			a = a || this.game.input.justReleasedRate;
			return !0 === this.isUp && this.timeUp + a > this.game.time.now
		},
		reset: function() {
			!1 === this.isMouse &&
				(this.active = !1);
			this.identifier = null;
			this.isDown = !1;
			this.isUp = !0;
			this.totalTouches = 0;
			this._holdSent = !1;
			this._history.length = 0;
			this._stateReset = !0;
			this.targetObject && this.targetObject._releasedHandler(this);
			this.targetObject = null
		}
	};
	Object.defineProperty(c.Pointer.prototype, "duration", {
		get: function() {
			return this.isUp ? -1 : this.game.time.now - this.timeDown
		}
	});
	Object.defineProperty(c.Pointer.prototype, "worldX", {
		get: function() {
			return this.game.world.camera.x + this.x
		}
	});
	Object.defineProperty(c.Pointer.prototype,
		"worldY", {
			get: function() {
				return this.game.world.camera.y + this.y
			}
		});
	c.Touch = function(a) {
		this.game = a;
		this.disabled = !1;
		this.callbackContext = this.game;
		this.touchCancelCallback = this.touchLeaveCallback = this.touchEnterCallback = this.touchEndCallback = this.touchMoveCallback = this.touchStartCallback = null;
		this.preventDefault = !0;
		this._onTouchMove = this._onTouchCancel = this._onTouchLeave = this._onTouchEnter = this._onTouchEnd = this._onTouchMove = this._onTouchStart = this.event = null
	};
	c.Touch.prototype = {
		start: function() {
			var a =
				this;
			this.game.device.touch && (this._onTouchStart = function(b) {
				return a.onTouchStart(b)
			}, this._onTouchMove = function(b) {
				return a.onTouchMove(b)
			}, this._onTouchEnd = function(b) {
				return a.onTouchEnd(b)
			}, this._onTouchEnter = function(b) {
				return a.onTouchEnter(b)
			}, this._onTouchLeave = function(b) {
				return a.onTouchLeave(b)
			}, this._onTouchCancel = function(b) {
				return a.onTouchCancel(b)
			}, this.game.renderer.view.addEventListener("touchstart", this._onTouchStart, !1), this.game.renderer.view.addEventListener("touchmove", this._onTouchMove, !1), this.game.renderer.view.addEventListener("touchend", this._onTouchEnd, !1), this.game.renderer.view.addEventListener("touchenter", this._onTouchEnter, !1), this.game.renderer.view.addEventListener("touchleave", this._onTouchLeave, !1), this.game.renderer.view.addEventListener("touchcancel", this._onTouchCancel, !1))
		},
		consumeDocumentTouches: function() {
			this._documentTouchMove = function(a) {
				a.preventDefault()
			};
			document.addEventListener("touchmove", this._documentTouchMove, !1)
		},
		onTouchStart: function(a) {
			this.event =
				a;
			this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, a);
			if (!this.game.input.disabled && !this.disabled) {
				this.preventDefault && a.preventDefault();
				for (var b = 0; b < a.changedTouches.length; b++) this.game.input.startPointer(a.changedTouches[b])
			}
		},
		onTouchCancel: function(a) {
			this.event = a;
			this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, a);
			if (!this.game.input.disabled && !this.disabled) {
				this.preventDefault && a.preventDefault();
				for (var b = 0; b < a.changedTouches.length; b++) this.game.input.stopPointer(a.changedTouches[b])
			}
		},
		onTouchEnter: function(a) {
			this.event = a;
			this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, a);
			this.game.input.disabled || this.disabled || this.preventDefault && a.preventDefault()
		},
		onTouchLeave: function(a) {
			this.event = a;
			this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, a);
			this.preventDefault && a.preventDefault()
		},
		onTouchMove: function(a) {
			this.event = a;
			this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, a);
			this.preventDefault && a.preventDefault();
			for (var b = 0; b < a.changedTouches.length; b++) this.game.input.updatePointer(a.changedTouches[b])
		},
		onTouchEnd: function(a) {
			this.event = a;
			this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, a);
			this.preventDefault && a.preventDefault();
			for (var b = 0; b < a.changedTouches.length; b++) this.game.input.stopPointer(a.changedTouches[b])
		},
		stop: function() {
			this.game.device.touch && (this.game.stage.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.stage.canvas.removeEventListener("touchmove",
				this._onTouchMove), this.game.stage.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.stage.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.stage.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.stage.canvas.removeEventListener("touchcancel", this._onTouchCancel))
		}
	};
	c.InputHandler = function(a) {
		this.sprite = a;
		this.game = a.game;
		this.enabled = !1;
		this.priorityID = 0;
		this.isDragged = this.useHandCursor = !1;
		this.allowVerticalDrag = this.allowHorizontalDrag = !0;
		this.bringToTop = !1;
		this.snapOffset = null;
		this.snapOnRelease = this.snapOnDrag = !1;
		this.snapY = this.snapX = 0;
		this.pixelPerfect = !1;
		this.pixelPerfectAlpha = 255;
		this.draggable = !1;
		this.boundsSprite = this.boundsRect = null;
		this.consumePointerEvent = !1;
		this._tempPoint = new c.Point;
		this._pointerData = [];
		this._pointerData.push({
			id: 0,
			x: 0,
			y: 0,
			isDown: !1,
			isUp: !1,
			isOver: !1,
			isOut: !1,
			timeOver: 0,
			timeOut: 0,
			timeDown: 0,
			timeUp: 0,
			downDuration: 0,
			isDragged: !1
		})
	};
	c.InputHandler.prototype = {
		start: function(a, b) {
			console.log("InputHandler start");
			a = a || 0;
			"undefined" == typeof b && (b = !1);
			if (!1 === this.enabled) {
				this.game.input.interactiveItems.add(this);
				this.useHandCursor = b;
				this.priorityID = a;
				for (var d = 0; 10 > d; d++) this._pointerData[d] = {
					id: d,
					x: 0,
					y: 0,
					isDown: !1,
					isUp: !1,
					isOver: !1,
					isOut: !1,
					timeOver: 0,
					timeOut: 0,
					timeDown: 0,
					timeUp: 0,
					downDuration: 0,
					isDragged: !1
				};
				this.snapOffset = new c.Point;
				this.enabled = !0;
				this.sprite.events && null == this.sprite.events.onInputOver && (this.sprite.events.onInputOver = new c.Signal, this.sprite.events.onInputOut = new c.Signal, this.sprite.events.onInputDown =
					new c.Signal, this.sprite.events.onInputUp = new c.Signal, this.sprite.events.onDragStart = new c.Signal, this.sprite.events.onDragStop = new c.Signal)
			}
			return this.sprite
		},
		reset: function() {
			this.enabled = !1;
			for (var a = 0; 10 > a; a++) this._pointerData[a] = {
				id: a,
				x: 0,
				y: 0,
				isDown: !1,
				isUp: !1,
				isOver: !1,
				isOut: !1,
				timeOver: 0,
				timeOut: 0,
				timeDown: 0,
				timeUp: 0,
				downDuration: 0,
				isDragged: !1
			}
		},
		stop: function() {
			!1 !== this.enabled && (this.enabled = !1, this.game.input.interactiveItems.remove(this))
		},
		destroy: function() {
			this.enabled && (this.enabled = !1, this.game.input.interactiveItems.remove(this), this.stop(), this.sprite = null)
		},
		pointerX: function(a) {
			return this._pointerData[a || 0].x
		},
		pointerY: function(a) {
			return this._pointerData[a || 0].y
		},
		pointerDown: function(a) {
			return this._pointerData[a || 0].isDown
		},
		pointerUp: function(a) {
			return this._pointerData[a || 0].isUp
		},
		pointerTimeDown: function(a) {
			return this._pointerData[a || 0].timeDown
		},
		pointerTimeUp: function(a) {
			return this._pointerData[a || 0].timeUp
		},
		pointerOver: function(a) {
			if (this.enabled)
				if ("undefined" ===
					typeof a)
					for (a = 0; 10 > a; a++) {
						if (this._pointerData[a].isOver) return !0
					} else return this._pointerData[a].isOver;
			return !1
		},
		pointerOut: function(a) {
			if (this.enabled)
				if ("undefined" === typeof a)
					for (a = 0; 10 > a; a++) {
						if (this._pointerData[a].isOut) return !0
					} else return this._pointerData[a].isOut;
			return !1
		},
		pointerTimeOver: function(a) {
			return this._pointerData[a || 0].timeOver
		},
		pointerTimeOut: function(a) {
			return this._pointerData[a || 0].timeOut
		},
		pointerDragged: function(a) {
			return this._pointerData[a || 0].isDragged
		},
		checkPointerOver: function(a) {
			if (!1 ===
				this.enabled || !1 === this.sprite.visible || this.sprite.group && !1 === this.sprite.group.visible) return !1;
			this.sprite.getLocalUnmodifiedPosition(this._tempPoint, a.x, a.y);
			if (0 <= this._tempPoint.x && this._tempPoint.x <= this.sprite.currentFrame.width && 0 <= this._tempPoint.y && this._tempPoint.y <= this.sprite.currentFrame.height) return this.pixelPerfect ? this.checkPixel(this._tempPoint.x, this._tempPoint.y) : !0
		},
		checkPixel: function(a, b) {
			return this.sprite.texture.baseTexture.source && (this.game.input.hitContext.clearRect(0,
				0, 1, 1), a += this.sprite.texture.frame.x, b += this.sprite.texture.frame.y, this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, a, b, 1, 1, 0, 0, 1, 1), this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha) ? !0 : !1
		},
		update: function(a) {
			if (!1 === this.enabled || !1 === this.sprite.visible || this.sprite.group && !1 === this.sprite.group.visible) return this._pointerOutHandler(a), !1;
			if (this.draggable && this._draggedPointerID == a.id) return this.updateDrag(a);
			if (!0 === this._pointerData[a.id].isOver) {
				if (this.checkPointerOver(a)) return this._pointerData[a.id].x =
					a.x - this.sprite.x, this._pointerData[a.id].y = a.y - this.sprite.y, !0;
				this._pointerOutHandler(a);
				return !1
			}
		},
		_pointerOverHandler: function(a) {
			!1 === this._pointerData[a.id].isOver && (this._pointerData[a.id].isOver = !0, this._pointerData[a.id].isOut = !1, this._pointerData[a.id].timeOver = this.game.time.now, this._pointerData[a.id].x = a.x - this.sprite.x, this._pointerData[a.id].y = a.y - this.sprite.y, this.useHandCursor && !1 === this._pointerData[a.id].isDragged && (this.game.stage.canvas.style.cursor = "pointer"), this.sprite.events.onInputOver.dispatch(this.sprite,
				a))
		},
		_pointerOutHandler: function(a) {
			this._pointerData[a.id].isOver = !1;
			this._pointerData[a.id].isOut = !0;
			this._pointerData[a.id].timeOut = this.game.time.now;
			this.useHandCursor && !1 === this._pointerData[a.id].isDragged && (this.game.stage.canvas.style.cursor = "default");
			this.sprite && this.sprite.events && this.sprite.events.onInputOut.dispatch(this.sprite, a)
		},
		_touchedHandler: function(a) {
			!1 === this._pointerData[a.id].isDown && !0 === this._pointerData[a.id].isOver && (this._pointerData[a.id].isDown = !0, this._pointerData[a.id].isUp = !1, this._pointerData[a.id].timeDown = this.game.time.now, this.sprite.events.onInputDown.dispatch(this.sprite, a), this.draggable && !1 === this.isDragged && this.startDrag(a), this.bringToTop && this.sprite.bringToTop());
			return this.consumePointerEvent
		},
		_releasedHandler: function(a) {
			this._pointerData[a.id].isDown && a.isUp && (this._pointerData[a.id].isDown = !1, this._pointerData[a.id].isUp = !0, this._pointerData[a.id].timeUp = this.game.time.now, this._pointerData[a.id].downDuration = this._pointerData[a.id].timeUp - this._pointerData[a.id].timeDown,
				this.checkPointerOver(a) ? this.sprite.events.onInputUp.dispatch(this.sprite, a) : this.useHandCursor && (this.game.stage.canvas.style.cursor = "default"), this.draggable && this.isDragged && this._draggedPointerID == a.id && this.stopDrag(a))
		},
		updateDrag: function(a) {
			if (a.isUp) return this.stopDrag(a), !1;
			this.allowHorizontalDrag && (this.sprite.x = a.x + this._dragPoint.x + this.dragOffset.x);
			this.allowVerticalDrag && (this.sprite.y = a.y + this._dragPoint.y + this.dragOffset.y);
			this.boundsRect && this.checkBoundsRect();
			this.boundsSprite &&
				this.checkBoundsSprite();
			this.snapOnDrag && (this.sprite.x = Math.round(this.sprite.x / this.snapX) * this.snapX, this.sprite.y = Math.round(this.sprite.y / this.snapY) * this.snapY);
			return !0
		},
		justOver: function(a, b) {
			a = a || 0;
			b = b || 500;
			return this._pointerData[a].isOver && this.overDuration(a) < b
		},
		justOut: function(a, b) {
			a = a || 0;
			return this._pointerData[a].isOut && this.game.time.now - this._pointerData[a].timeOut < (b || 500)
		},
		justPressed: function(a, b) {
			a = a || 0;
			b = b || 500;
			return this._pointerData[a].isDown && this.downDuration(a) < b
		},
		justReleased: function(a, b) {
			a = a || 0;
			return this._pointerData[a].isUp && this.game.time.now - this._pointerData[a].timeUp < (b || 500)
		},
		overDuration: function(a) {
			a = a || 0;
			return this._pointerData[a].isOver ? this.game.time.now - this._pointerData[a].timeOver : -1
		},
		downDuration: function(a) {
			a = a || 0;
			return this._pointerData[a].isDown ? this.game.time.now - this._pointerData[a].timeDown : -1
		},
		enableDrag: function(a, b, d, e, f, g) {
			"undefined" == typeof a && (a = !1);
			"undefined" == typeof b && (b = !1);
			"undefined" == typeof d && (d = !1);
			"undefined" ==
				typeof e && (e = 255);
			"undefined" == typeof f && (f = null);
			"undefined" == typeof g && (g = null);
			this._dragPoint = new c.Point;
			this.draggable = !0;
			this.bringToTop = b;
			this.dragOffset = new c.Point;
			this.dragFromCenter = a;
			this.pixelPerfect = d;
			this.pixelPerfectAlpha = e;
			f && (this.boundsRect = f);
			g && (this.boundsSprite = g)
		},
		disableDrag: function() {
			if (this._pointerData)
				for (var a = 0; 10 > a; a++) this._pointerData[a].isDragged = !1;
			this.isDragged = this.draggable = !1;
			this._draggedPointerID = -1
		},
		startDrag: function(a) {
			this.isDragged = !0;
			this._draggedPointerID =
				a.id;
			this._pointerData[a.id].isDragged = !0;
			this.dragFromCenter && this.sprite.centerOn(a.x, a.y);
			this._dragPoint.setTo(this.sprite.x - a.x, this.sprite.y - a.y);
			this.updateDrag(a);
			this.bringToTop && this.sprite.bringToTop();
			this.sprite.events.onDragStart.dispatch(this.sprite, a)
		},
		stopDrag: function(a) {
			this.isDragged = !1;
			this._draggedPointerID = -1;
			this._pointerData[a.id].isDragged = !1;
			this.snapOnRelease && (this.sprite.x = Math.round(this.sprite.x / this.snapX) * this.snapX, this.sprite.y = Math.round(this.sprite.y / this.snapY) *
				this.snapY);
			this.sprite.events.onDragStop.dispatch(this.sprite, a);
			this.sprite.events.onInputUp.dispatch(this.sprite, a);
			!1 === this.checkPointerOver(a) && this._pointerOutHandler(a)
		},
		setDragLock: function(a, b) {
			"undefined" == typeof a && (a = !0);
			"undefined" == typeof b && (b = !0);
			this.allowHorizontalDrag = a;
			this.allowVerticalDrag = b
		},
		enableSnap: function(a, b, d, c) {
			"undefined" == typeof d && (d = !0);
			"undefined" == typeof c && (c = !1);
			this.snapX = a;
			this.snapY = b;
			this.snapOnDrag = d;
			this.snapOnRelease = c
		},
		disableSnap: function() {
			this.snapOnRelease =
				this.snapOnDrag = !1
		},
		checkBoundsRect: function() {
			this.sprite.x < this.boundsRect.left ? this.sprite.x = this.boundsRect.x : this.sprite.x + this.sprite.width > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - this.sprite.width);
			this.sprite.y < this.boundsRect.top ? this.sprite.y = this.boundsRect.top : this.sprite.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - this.sprite.height)
		},
		checkBoundsSprite: function() {
			this.sprite.x < this.boundsSprite.x ? this.sprite.x = this.boundsSprite.x :
				this.sprite.x + this.sprite.width > this.boundsSprite.x + this.boundsSprite.width && (this.sprite.x = this.boundsSprite.x + this.boundsSprite.width - this.sprite.width);
			this.sprite.y < this.boundsSprite.y ? this.sprite.y = this.boundsSprite.y : this.sprite.y + this.sprite.height > this.boundsSprite.y + this.boundsSprite.height && (this.sprite.y = this.boundsSprite.y + this.boundsSprite.height - this.sprite.height)
		}
	};
	c.Events = function(a) {
		this.parent = a;
		this.onAddedToGroup = new c.Signal;
		this.onRemovedFromGroup = new c.Signal;
		this.onKilled =
			new c.Signal;
		this.onRevived = new c.Signal;
		this.onOutOfBounds = new c.Signal;
		this.onAnimationLoop = this.onAnimationComplete = this.onAnimationStart = this.onDragStop = this.onDragStart = this.onInputUp = this.onInputDown = this.onInputOut = this.onInputOver = null
	};
	c.Events.prototype = {
		destroy: function() {
			this.parent = null;
			this.onAddedToGroup.dispose();
			this.onRemovedFromGroup.dispose();
			this.onKilled.dispose();
			this.onRevived.dispose();
			this.onOutOfBounds.dispose();
			this.onInputOver && (this.onInputOver.dispose(), this.onInputOut.dispose(),
				this.onInputDown.dispose(), this.onInputUp.dispose(), this.onDragStart.dispose(), this.onDragStop.dispose());
			this.onAnimationStart && (this.onAnimationStart.dispose(), this.onAnimationComplete.dispose(), this.onAnimationLoop.dispose())
		}
	};
	c.GameObjectFactory = function(a) {
		this.game = a;
		this.world = this.game.world
	};
	c.GameObjectFactory.prototype = {
		existing: function(a) {
			return this.world.add(a)
		},
		sprite: function(a, b, d, c) {
			return this.world.create(a, b, d, c)
		},
		child: function(a, b, d, c, e) {
			return a.create(b, d, c, e)
		},
		tween: function(a) {
			return this.game.tweens.create(a)
		},
		group: function(a, b) {
			return new c.Group(this.game, a, b)
		},
		audio: function(a, b, d, c) {
			return this.game.sound.add(a, b, d, c)
		},
		tileSprite: function(a, b, d, e, f, g) {
			return this.world.add(new c.TileSprite(this.game, a, b, d, e, f, g))
		},
		text: function(a, b, d, e) {
			return this.world.add(new c.Text(this.game, a, b, d, e))
		},
		button: function(a, b, d, e, f, g, k, m) {
			return this.world.add(new c.Button(this.game, a, b, d, e, f, g, k, m))
		},
		graphics: function(a, b) {
			return this.world.add(new c.Graphics(this.game, a, b))
		},
		emitter: function(a, b, d) {
			return this.game.particles.add(new c.Particles.Arcade.Emitter(this.game,
				a, b, d))
		},
		bitmapText: function(a, b, d, e) {
			return this.world.add(new c.BitmapText(this.game, a, b, d, e))
		},
		tilemap: function(a) {
			return new c.Tilemap(this.game, a)
		},
		tileset: function(a) {
			return this.game.cache.getTileset(a)
		},
		tilemapLayer: function(a, b, d, e, f, g, k) {
			return this.world.add(new c.TilemapLayer(this.game, a, b, d, e, f, g, k))
		},
		renderTexture: function(a, b, d) {
			b = new c.RenderTexture(this.game, a, b, d);
			this.game.cache.addRenderTexture(a, b);
			return b
		},
		bitmapData: function(a, b) {
			return new c.BitmapData(this.game, a, b)
		},
		filter: function(a) {
			var b =
				Array.prototype.splice.call(arguments, 1);
			a = new c.Filter[a](this.game);
			a.init.apply(a, b);
			return a
		}
	};
	c.BitmapData = function(a, b, d) {
		"undefined" === typeof b && (b = 256);
		"undefined" === typeof d && (d = 256);
		this.game = a;
		this.name = "";
		this.width = b;
		this.height = d;
		this.canvas = c.Canvas.create(b, d);
		this.context = this.canvas.getContext("2d");
		this.imageData = this.context.getImageData(0, 0, b, d);
		this.pixels = this.imageData.data.buffer ? this.imageData.data.buffer : this.imageData.data;
		this.baseTexture = new e.BaseTexture(this.canvas);
		this.texture = new e.Texture(this.baseTexture);
		this.textureFrame = new c.Frame(0, 0, 0, b, d, "bitmapData", a.rnd.uuid());
		this.type = c.BITMAPDATA;
		this._dirty = !1
	};
	c.BitmapData.prototype = {
		add: function(a) {
			a.loadTexture(this)
		},
		addTo: function(a) {
			for (var b = 0; b < a.length; b++) a[b].texture && a[b].loadTexture(this)
		},
		clear: function() {
			this.context.clearRect(0, 0, this.width, this.height);
			this._dirty = !0
		},
		refreshBuffer: function() {
			this.imageData = this.context.getImageData(0, 0, this.width, this.height);
			this.pixels = new Int32Array(this.imageData.data.buffer)
		},
		setPixel32: function(a, b, d, c, e, f) {
			0 <= a && a <= this.width && 0 <= b && b <= this.height && (this.pixels[b * this.width + a] = f << 24 | e << 16 | c << 8 | d, this.context.putImageData(this.imageData, 0, 0), this._dirty = !0)
		},
		setPixel: function(a, b, d, c, e) {
			this.setPixel32(a, b, d, c, e, 255)
		},
		getPixel: function(a, b) {
			if (0 <= a && a <= this.width && 0 <= b && b <= this.height) return this.data32[b * this.width + a]
		},
		getPixel32: function(a, b) {
			if (0 <= a && a <= this.width && 0 <= b && b <= this.height) return this.data32[b * this.width + a]
		},
		getPixels: function(a) {
			return this.context.getImageData(a.x,
				a.y, a.width, a.height)
		},
		arc: function(a, b, d, c, e, f) {
			"undefined" === typeof f && (f = !1);
			this._dirty = !0;
			this.context.arc(a, b, d, c, e, f);
			return this
		},
		arcTo: function(a, b, d, c, e) {
			this._dirty = !0;
			this.context.arcTo(a, b, d, c, e);
			return this
		},
		beginFill: function(a) {
			this.fillStyle(a);
			return this
		},
		beginLinearGradientFill: function(a, b, d, c, e, f) {
			d = this.createLinearGradient(d, c, e, f);
			c = 0;
			for (e = a.length; c < e; c++) d.addColorStop(b[c], a[c]);
			this.fillStyle(d);
			return this
		},
		beginLinearGradientStroke: function(a, b, d, c, e, f) {
			d = this.createLinearGradient(d,
				c, e, f);
			c = 0;
			for (e = a.length; c < e; c++) d.addColorStop(b[c], a[c]);
			this.strokeStyle(d);
			return this
		},
		beginRadialGradientStroke: function(a, b, d, c, e, f, k, m) {
			d = this.createRadialGradient(d, c, e, f, k, m);
			c = 0;
			for (e = a.length; c < e; c++) d.addColorStop(b[c], a[c]);
			this.strokeStyle(d);
			return this
		},
		beginPath: function() {
			this.context.beginPath();
			return this
		},
		beginStroke: function(a) {
			this.strokeStyle(a);
			return this
		},
		bezierCurveTo: function(a, b, d, c, e, f) {
			this._dirty = !0;
			this.context.bezierCurveTo(a, b, d, c, e, f);
			return this
		},
		circle: function(a,
			b, d) {
			this.arc(a, b, d, 0, 2 * Math.PI);
			return this
		},
		clearRect: function(a, b, d, c) {
			this._dirty = !0;
			this.context.clearRect(a, b, d, c);
			return this
		},
		clip: function() {
			this._dirty = !0;
			this.context.clip();
			return this
		},
		closePath: function() {
			this._dirty = !0;
			this.context.closePath();
			return this
		},
		createLinearGradient: function(a, b, d, c) {
			return this.context.createLinearGradient(a, b, d, c)
		},
		createRadialGradient: function(a, b, d, c, e, f) {
			return this.context.createRadialGradient(a, b, d, c, e, f)
		},
		ellipse: function(a, b, d, c) {
			var e = d / 2 * 0.5522848,
				f = c / 2 * 0.5522848,
				k = a + d,
				m = b + c;
			d = a + d / 2;
			c = b + c / 2;
			this.moveTo(a, c);
			this.bezierCurveTo(a, c - f, d - e, b, d, b);
			this.bezierCurveTo(d + e, b, k, c - f, k, c);
			this.bezierCurveTo(k, c + f, d + e, m, d, m);
			this.bezierCurveTo(d - e, m, a, c + f, a, c);
			return this
		},
		fill: function() {
			this._dirty = !0;
			this.context.fill();
			return this
		},
		fillRect: function(a, b, d, c) {
			this._dirty = !0;
			this.context.fillRect(a, b, d, c);
			return this
		},
		fillStyle: function(a) {
			this.context.fillStyle = a;
			return this
		},
		font: function(a) {
			this.context.font = a;
			return this
		},
		globalAlpha: function(a) {
			this.context.globalAlpha =
				a;
			return this
		},
		globalCompositeOperation: function(a) {
			this.context.globalCompositeOperation = a;
			return this
		},
		lineCap: function(a) {
			this.context.lineCap = a;
			return this
		},
		lineDashOffset: function(a) {
			this.context.lineDashOffset = a;
			return this
		},
		lineJoin: function(a) {
			this.context.lineJoin = a;
			return this
		},
		lineWidth: function(a) {
			this.context.lineWidth = a;
			return this
		},
		miterLimit: function(a) {
			this.context.miterLimit = a;
			return this
		},
		lineTo: function(a, b) {
			this._dirty = !0;
			this.context.lineTo(a, b);
			return this
		},
		moveTo: function(a,
			b) {
			this.context.moveTo(a, b);
			return this
		},
		quadraticCurveTo: function(a, b, d, c) {
			this._dirty = !0;
			this.context.quadraticCurveTo(a, b, d, c);
			return this
		},
		rect: function(a, b, d, c) {
			this._dirty = !0;
			this.context.rect(a, b, d, c);
			return this
		},
		restore: function() {
			this._dirty = !0;
			this.context.restore();
			return this
		},
		rotate: function(a) {
			this._dirty = !0;
			this.context.rotate(a);
			return this
		},
		setStrokeStyle: function(a, b, d, c, e) {
			"undefined" === typeof a && (a = 1);
			"undefined" === typeof b && (b = "butt");
			"undefined" === typeof d && (d = "miter");
			"undefined" ===
				typeof c && (c = 10);
			this.lineWidth(a);
			this.lineCap(b);
			this.lineJoin(d);
			this.miterLimit(c);
			return this
		},
		save: function() {
			this._dirty = !0;
			this.context.save();
			return this
		},
		scale: function(a, b) {
			this._dirty = !0;
			this.context.scale(a, b);
			return this
		},
		scrollPathIntoView: function() {
			this._dirty = !0;
			this.context.scrollPathIntoView();
			return this
		},
		stroke: function() {
			this._dirty = !0;
			this.context.stroke();
			return this
		},
		strokeRect: function(a, b, d, c) {
			this._dirty = !0;
			this.context.strokeRect(a, b, d, c);
			return this
		},
		strokeStyle: function(a) {
			this.context.strokeStyle =
				a;
			return this
		},
		render: function() {
			this._dirty && (this.game.renderType == c.WEBGL && e.texturesToUpdate.push(this.baseTexture), this._dirty = !1)
		}
	};
	c.BitmapData.prototype.mt = c.BitmapData.prototype.moveTo;
	c.BitmapData.prototype.lt = c.BitmapData.prototype.lineTo;
	c.BitmapData.prototype.at = c.BitmapData.prototype.arcTo;
	c.BitmapData.prototype.bt = c.BitmapData.prototype.bezierCurveTo;
	c.BitmapData.prototype.qt = c.BitmapData.prototype.quadraticCurveTo;
	c.BitmapData.prototype.a = c.BitmapData.prototype.arc;
	c.BitmapData.prototype.r =
		c.BitmapData.prototype.rect;
	c.BitmapData.prototype.cp = c.BitmapData.prototype.closePath;
	c.BitmapData.prototype.c = c.BitmapData.prototype.clear;
	c.BitmapData.prototype.f = c.BitmapData.prototype.beginFill;
	c.BitmapData.prototype.lf = c.BitmapData.prototype.beginLinearGradientFill;
	c.BitmapData.prototype.rf = c.BitmapData.prototype.beginRadialGradientFill;
	c.BitmapData.prototype.ef = c.BitmapData.prototype.endFill;
	c.BitmapData.prototype.ss = c.BitmapData.prototype.setStrokeStyle;
	c.BitmapData.prototype.s = c.BitmapData.prototype.beginStroke;
	c.BitmapData.prototype.ls = c.BitmapData.prototype.beginLinearGradientStroke;
	c.BitmapData.prototype.rs = c.BitmapData.prototype.beginRadialGradientStroke;
	c.BitmapData.prototype.dr = c.BitmapData.prototype.rect;
	c.BitmapData.prototype.dc = c.BitmapData.prototype.circle;
	c.BitmapData.prototype.de = c.BitmapData.prototype.ellipse;
	c.Sprite = function(a, b, d, f, h) {
		b = b || 0;
		d = d || 0;
		f = f || null;
		h = h || null;
		this.game = a;
		this.alive = this.exists = !0;
		this.group = null;
		this.name = "";
		this.type = c.SPRITE;
		this.renderOrderID = -1;
		this.lifespan =
			0;
		this.events = new c.Events(this);
		this.animations = new c.AnimationManager(this);
		this.input = new c.InputHandler(this);
		this.key = f;
		this.currentFrame = null;
		f instanceof c.RenderTexture ? (e.Sprite.call(this, f), this.currentFrame = this.game.cache.getTextureFrame(f.name)) : f instanceof c.BitmapData ? (e.Sprite.call(this, f.texture, f.textureFrame), this.currentFrame = f.textureFrame) : f instanceof e.Texture ? (e.Sprite.call(this, f), this.currentFrame = h) : (null === f || "undefined" === typeof f ? this.key = f = "__default" : "string" === typeof f &&
			!1 === this.game.cache.checkImageKey(f) && (this.key = f = "__missing"), e.Sprite.call(this, e.TextureCache[f]), this.game.cache.isSpriteSheet(f) ? (this.animations.loadFrameData(this.game.cache.getFrameData(f)), null !== h && ("string" === typeof h ? this.frameName = h : this.frame = h)) : this.currentFrame = this.game.cache.getFrame(f));
		this.textureRegion = new c.Rectangle(this.texture.frame.x, this.texture.frame.y, this.texture.frame.width, this.texture.frame.height);
		this.anchor = new c.Point;
		this.x = b;
		this.y = d;
		this.position.x = b;
		this.position.y =
			d;
		this.world = new c.Point(b, d);
		this.autoCull = !1;
		this.scale = new c.Point(1, 1);
		this._cache = {
			dirty: !1,
			a00: -1,
			a01: -1,
			a02: -1,
			a10: -1,
			a11: -1,
			a12: -1,
			id: -1,
			i01: -1,
			i10: -1,
			idi: -1,
			left: null,
			right: null,
			top: null,
			bottom: null,
			prevX: b,
			prevY: d,
			x: -1,
			y: -1,
			scaleX: 1,
			scaleY: 1,
			width: this.currentFrame.sourceSizeW,
			height: this.currentFrame.sourceSizeH,
			halfWidth: Math.floor(this.currentFrame.sourceSizeW / 2),
			halfHeight: Math.floor(this.currentFrame.sourceSizeH / 2),
			calcWidth: -1,
			calcHeight: -1,
			frameID: -1,
			frameWidth: this.currentFrame.width,
			frameHeight: this.currentFrame.height,
			cameraVisible: !0,
			cropX: 0,
			cropY: 0,
			cropWidth: this.currentFrame.sourceSizeW,
			cropHeight: this.currentFrame.sourceSizeH
		};
		this.offset = new c.Point;
		this.center = new c.Point(b + Math.floor(this._cache.width / 2), d + Math.floor(this._cache.height / 2));
		this.topLeft = new c.Point(b, d);
		this.topRight = new c.Point(b + this._cache.width, d);
		this.bottomRight = new c.Point(b + this._cache.width, d + this._cache.height);
		this.bottomLeft = new c.Point(b, d + this._cache.height);
		this.bounds = new c.Rectangle(b,
			d, this._cache.width, this._cache.height);
		this.body = new c.Physics.Arcade.Body(this);
		this.health = 1;
		this.inWorld = c.Rectangle.intersects(this.bounds, this.game.world.bounds);
		this.inWorldThreshold = 0;
		this.fixedToCamera = this._outOfBoundsFired = this.outOfBoundsKill = !1;
		this.cameraOffset = new c.Point;
		this.crop = new c.Rectangle(0, 0, this._cache.width, this._cache.height);
		this.cropEnabled = !1;
		this.updateCache();
		this.updateBounds()
	};
	c.Sprite.prototype = Object.create(e.Sprite.prototype);
	c.Sprite.prototype.constructor = c.Sprite;
	c.Sprite.prototype.preUpdate = function() {
		if (!this.exists || this.group && !this.group.exists) return this.renderOrderID = -1, !1;
		if (0 < this.lifespan && (this.lifespan -= this.game.time.elapsed, 0 >= this.lifespan)) return this.kill(), !1;
		this._cache.dirty = !1;
		this.visible && (this.renderOrderID = this.game.world.currentRenderOrderID++);
		this.updateCache();
		this.updateAnimation();
		this.updateCrop();
		(this._cache.dirty || this.world.x !== this._cache.prevX || this.world.y !== this._cache.prevY) && this.updateBounds();
		this.body && this.body.preUpdate();
		return !0
	};
	c.Sprite.prototype.updateCache = function() {
		this._cache.prevX = this.world.x;
		this._cache.prevY = this.world.y;
		this.fixedToCamera && (this.x = this.game.camera.view.x + this.cameraOffset.x, this.y = this.game.camera.view.y + this.cameraOffset.y);
		this.world.setTo(this.game.camera.x + this.worldTransform[2], this.game.camera.y + this.worldTransform[5]);
		if (this.worldTransform[1] != this._cache.i01 || this.worldTransform[3] != this._cache.i10 || this.worldTransform[0] != this._cache.a00 || this.worldTransform[41] != this._cache.a11) this._cache.a00 =
			this.worldTransform[0], this._cache.a01 = this.worldTransform[1], this._cache.a10 = this.worldTransform[3], this._cache.a11 = this.worldTransform[4], this._cache.i01 = this.worldTransform[1], this._cache.i10 = this.worldTransform[3], this._cache.scaleX = Math.sqrt(this._cache.a00 * this._cache.a00 + this._cache.a01 * this._cache.a01), this._cache.scaleY = Math.sqrt(this._cache.a10 * this._cache.a10 + this._cache.a11 * this._cache.a11), this._cache.a01 *= -1, this._cache.a10 *= -1, this._cache.id = 1 / (this._cache.a00 * this._cache.a11 + this._cache.a01 *
				-this._cache.a10), this._cache.idi = 1 / (this._cache.a00 * this._cache.a11 + this._cache.i01 * -this._cache.i10), this._cache.dirty = !0;
		this._cache.a02 = this.worldTransform[2];
		this._cache.a12 = this.worldTransform[5]
	};
	c.Sprite.prototype.updateAnimation = function() {
		if (this.animations.update() || this.currentFrame && this.currentFrame.uuid != this._cache.frameID) this._cache.frameID = this.currentFrame.uuid, this._cache.frameWidth = this.texture.frame.width, this._cache.frameHeight = this.texture.frame.height, this._cache.width = this.currentFrame.width,
			this._cache.height = this.currentFrame.height, this._cache.halfWidth = Math.floor(this._cache.width / 2), this._cache.halfHeight = Math.floor(this._cache.height / 2), this._cache.dirty = !0
	};
	c.Sprite.prototype.updateCrop = function() {
		!this.cropEnabled || this.crop.width == this._cache.cropWidth && this.crop.height == this._cache.cropHeight && this.crop.x == this._cache.cropX && this.crop.y == this._cache.cropY || (this.crop.floorAll(), this._cache.cropX = this.crop.x, this._cache.cropY = this.crop.y, this._cache.cropWidth = this.crop.width,
			this._cache.cropHeight = this.crop.height, this.texture.frame = this.crop, this.texture.width = this.crop.width, this.texture.height = this.crop.height, this.texture.updateFrame = !0, e.Texture.frameUpdates.push(this.texture))
	};
	c.Sprite.prototype.updateBounds = function() {
		this.offset.setTo(this._cache.a02 - this.anchor.x * this.width, this._cache.a12 - this.anchor.y * this.height);
		this.getLocalPosition(this.center, this.offset.x + this.width / 2, this.offset.y + this.height / 2);
		this.getLocalPosition(this.topLeft, this.offset.x, this.offset.y);
		this.getLocalPosition(this.topRight, this.offset.x + this.width, this.offset.y);
		this.getLocalPosition(this.bottomLeft, this.offset.x, this.offset.y + this.height);
		this.getLocalPosition(this.bottomRight, this.offset.x + this.width, this.offset.y + this.height);
		this._cache.left = c.Math.min(this.topLeft.x, this.topRight.x, this.bottomLeft.x, this.bottomRight.x);
		this._cache.right = c.Math.max(this.topLeft.x, this.topRight.x, this.bottomLeft.x, this.bottomRight.x);
		this._cache.top = c.Math.min(this.topLeft.y, this.topRight.y, this.bottomLeft.y,
			this.bottomRight.y);
		this._cache.bottom = c.Math.max(this.topLeft.y, this.topRight.y, this.bottomLeft.y, this.bottomRight.y);
		this.bounds.setTo(this._cache.left, this._cache.top, this._cache.right - this._cache.left, this._cache.bottom - this._cache.top);
		this.updateFrame = !0;
		if (!1 === this.inWorld) {
			if (this.inWorld = c.Rectangle.intersects(this.bounds, this.game.world.bounds, this.inWorldThreshold)) this._outOfBoundsFired = !1
		} else this.inWorld = c.Rectangle.intersects(this.bounds, this.game.world.bounds, this.inWorldThreshold), !1 === this.inWorld && (this.events.onOutOfBounds.dispatch(this), this._outOfBoundsFired = !0, this.outOfBoundsKill && this.kill());
		this._cache.cameraVisible = c.Rectangle.intersects(this.game.world.camera.screenView, this.bounds, 0);
		this.autoCull && (this.renderable = this._cache.cameraVisible);
		this.body && this.body.updateBounds(this.center.x, this.center.y, this._cache.scaleX, this._cache.scaleY)
	};
	c.Sprite.prototype.getLocalPosition = function(a, b, d) {
		a.x = (this._cache.a11 * this._cache.id * b + -this._cache.a01 * this._cache.id *
			d + (this._cache.a12 * this._cache.a01 - this._cache.a02 * this._cache.a11) * this._cache.id) * this.scale.x + this._cache.a02;
		a.y = (this._cache.a00 * this._cache.id * d + -this._cache.a10 * this._cache.id * b + (-this._cache.a12 * this._cache.a00 + this._cache.a02 * this._cache.a10) * this._cache.id) * this.scale.y + this._cache.a12;
		return a
	};
	c.Sprite.prototype.getLocalUnmodifiedPosition = function(a, b, d) {
		a.x = this._cache.a11 * this._cache.idi * b + -this._cache.i01 * this._cache.idi * d + (this._cache.a12 * this._cache.i01 - this._cache.a02 * this._cache.a11) *
			this._cache.idi + this.anchor.x * this._cache.width;
		a.y = this._cache.a00 * this._cache.idi * d + -this._cache.i10 * this._cache.idi * b + (-this._cache.a12 * this._cache.a00 + this._cache.a02 * this._cache.i10) * this._cache.idi + this.anchor.y * this._cache.height;
		return a
	};
	c.Sprite.prototype.resetCrop = function() {
		this.crop = new c.Rectangle(0, 0, this._cache.width, this._cache.height);
		this.texture.setFrame(this.crop);
		this.cropEnabled = !1
	};
	c.Sprite.prototype.postUpdate = function() {
		this.key instanceof c.BitmapData && this.key._dirty &&
			this.key.render();
		this.exists && (this.body && this.body.postUpdate(), this.fixedToCamera ? (this._cache.x = this.game.camera.view.x + this.cameraOffset.x, this._cache.y = this.game.camera.view.y + this.cameraOffset.y) : (this._cache.x = this.x, this._cache.y = this.y), this.world.setTo(this.game.camera.x + this.worldTransform[2], this.game.camera.y + this.worldTransform[5]), this.position.x = this._cache.x, this.position.y = this._cache.y)
	};
	c.Sprite.prototype.loadTexture = function(a, b) {
		this.key = a;
		if (a instanceof c.RenderTexture) this.currentFrame =
			this.game.cache.getTextureFrame(a.name);
		else if (a instanceof c.BitmapData) this.setTexture(a.texture), this.currentFrame = a.textureFrame;
		else if (a instanceof e.Texture) this.currentFrame = b;
		else {
			if ("undefined" === typeof a || !1 === this.game.cache.checkImageKey(a)) this.key = a = "__default";
			this.game.cache.isSpriteSheet(a) ? (this.animations.loadFrameData(this.game.cache.getFrameData(a)), "undefined" !== typeof b && ("string" === typeof b ? this.frameName = b : this.frame = b)) : (this.currentFrame = this.game.cache.getFrame(a), this.setTexture(e.TextureCache[a]))
		}
	};
	c.Sprite.prototype.centerOn = function(a, b) {
		this.x = a + (this.x - this.center.x);
		this.y = b + (this.y - this.center.y);
		return this
	};
	c.Sprite.prototype.revive = function(a) {
		"undefined" === typeof a && (a = 1);
		this.visible = this.exists = this.alive = !0;
		this.health = a;
		this.events && this.events.onRevived.dispatch(this);
		return this
	};
	c.Sprite.prototype.kill = function() {
		this.visible = this.exists = this.alive = !1;
		this.events && this.events.onKilled.dispatch(this);
		return this
	};
	c.Sprite.prototype.destroy = function() {
		this.group && this.group.remove(this);
		this.input && this.input.destroy();
		this.events && this.events.destroy();
		this.animations && this.animations.destroy();
		this.visible = this.exists = this.alive = !1;
		this.game = null
	};
	c.Sprite.prototype.damage = function(a) {
		this.alive && (this.health -= a, 0 > this.health && this.kill());
		return this
	};
	c.Sprite.prototype.reset = function(a, b, d) {
		"undefined" === typeof d && (d = 1);
		this.x = a;
		this.y = b;
		this.position.x = this.x;
		this.position.y = this.y;
		this.renderable = this.visible = this.exists = this.alive = !0;
		this._outOfBoundsFired = !1;
		this.health =
			d;
		this.body && this.body.reset();
		return this
	};
	c.Sprite.prototype.bringToTop = function() {
		this.group ? this.group.bringToTop(this) : this.game.world.bringToTop(this);
		return this
	};
	c.Sprite.prototype.play = function(a, b, d, c) {
		if (this.animations) return this.animations.play(a, b, d, c)
	};
	Object.defineProperty(c.Sprite.prototype, "angle", {
		get: function() {
			return c.Math.wrapAngle(c.Math.radToDeg(this.rotation))
		},
		set: function(a) {
			this.rotation = c.Math.degToRad(c.Math.wrapAngle(a))
		}
	});
	Object.defineProperty(c.Sprite.prototype,
		"frame", {
			get: function() {
				return this.animations.frame
			},
			set: function(a) {
				this.animations.frame = a
			}
		});
	Object.defineProperty(c.Sprite.prototype, "frameName", {
		get: function() {
			return this.animations.frameName
		},
		set: function(a) {
			this.animations.frameName = a
		}
	});
	Object.defineProperty(c.Sprite.prototype, "inCamera", {
		get: function() {
			return this._cache.cameraVisible
		}
	});
	Object.defineProperty(c.Sprite.prototype, "width", {
		get: function() {
			return this.scale.x * this.currentFrame.width
		},
		set: function(a) {
			this.scale.x = a / this.currentFrame.width;
			this._cache.scaleX = a / this.currentFrame.width;
			this._width = a
		}
	});
	Object.defineProperty(c.Sprite.prototype, "height", {
		get: function() {
			return this.scale.y * this.currentFrame.height
		},
		set: function(a) {
			this.scale.y = a / this.currentFrame.height;
			this._cache.scaleY = a / this.currentFrame.height;
			this._height = a
		}
	});
	Object.defineProperty(c.Sprite.prototype, "inputEnabled", {
		get: function() {
			return this.input.enabled
		},
		set: function(a) {
			console.log("inputEnabled", a, this.input);
			a ? !1 === this.input.enabled && this.input.start() : this.input.enabled &&
				this.input.stop()
		}
	});
	c.TileSprite = function(a, b, d, f, h, g, k) {
		f = f || 256;
		h = h || 256;
		g = g || null;
		c.Sprite.call(this, a, b || 0, d || 0, g, k || null);
		this.texture = e.TextureCache[g];
		e.TilingSprite.call(this, this.texture, f, h);
		this.type = c.TILESPRITE;
		this.tileScale = new c.Point(1, 1);
		this.tilePosition = new c.Point(0, 0)
	};
	c.TileSprite.prototype = c.Utils.extend(!0, e.TilingSprite.prototype, c.Sprite.prototype);
	c.TileSprite.prototype.constructor = c.TileSprite;
	c.Text = function(a, b, d, f, h) {
		b = b || 0;
		d = d || 0;
		f = f || "";
		h = h || "";
		this.game = a;
		this.alive =
			this.exists = !0;
		this.group = null;
		this.name = "";
		this.type = c.TEXT;
		this._text = f;
		this._style = h;
		e.Text.call(this, f, h);
		this.position.x = this.x = b;
		this.position.y = this.y = d;
		this.anchor = new c.Point;
		this.scale = new c.Point(1, 1);
		this._cache = {
			dirty: !1,
			a00: 1,
			a01: 0,
			a02: b,
			a10: 0,
			a11: 1,
			a12: d,
			id: 1,
			x: -1,
			y: -1,
			scaleX: 1,
			scaleY: 1
		};
		this._cache.x = this.x;
		this._cache.y = this.y;
		this.renderable = !0
	};
	c.Text.prototype = Object.create(e.Text.prototype);
	c.Text.prototype.constructor = c.Text;
	c.Text.prototype.update = function() {
		this.exists && (this._cache.dirty = !1, this._cache.x = this.x, this._cache.y = this.y, this.position.x != this._cache.x || this.position.y != this._cache.y) && (this.position.x = this._cache.x, this.position.y = this._cache.y, this._cache.dirty = !0)
	};
	c.Text.prototype.destroy = function() {
		this.group && this.group.remove(this);
		this.canvas.parentNode ? this.canvas.parentNode.removeChild(this.canvas) : this.context = this.canvas = null;
		this.exists = !1;
		this.group = null
	};
	Object.defineProperty(c.Text.prototype, "angle", {
		get: function() {
			return c.Math.radToDeg(this.rotation)
		},
		set: function(a) {
			this.rotation = c.Math.degToRad(a)
		}
	});
	Object.defineProperty(c.Text.prototype, "x", {
		get: function() {
			return this.position.x
		},
		set: function(a) {
			this.position.x = a
		}
	});
	Object.defineProperty(c.Text.prototype, "y", {
		get: function() {
			return this.position.y
		},
		set: function(a) {
			this.position.y = a
		}
	});
	Object.defineProperty(c.Text.prototype, "content", {
		get: function() {
			return this._text
		},
		set: function(a) {
			a !== this._text && (this._text = a, this.setText(a))
		}
	});
	Object.defineProperty(c.Text.prototype, "font", {
		get: function() {
			return this._style
		},
		set: function(a) {
			a !== this._style && (this._style = a, this.setStyle(a))
		}
	});
	c.BitmapText = function(a, b, d, f, h) {
		b = b || 0;
		d = d || 0;
		this.game = a;
		this.alive = this.exists = !0;
		this.group = null;
		this.name = "";
		this.type = c.BITMAPTEXT;
		e.BitmapText.call(this, f || "", h || "");
		this.position.x = b;
		this.position.y = d;
		this.anchor = new c.Point;
		this.scale = new c.Point(1, 1);
		this._cache = {
			dirty: !1,
			a00: 1,
			a01: 0,
			a02: b,
			a10: 0,
			a11: 1,
			a12: d,
			id: 1,
			x: -1,
			y: -1,
			scaleX: 1,
			scaleY: 1
		};
		this._cache.x = this.x;
		this._cache.y = this.y;
		this.renderable = !0
	};
	c.BitmapText.prototype =
		Object.create(e.BitmapText.prototype);
	c.BitmapText.prototype.constructor = c.BitmapText;
	c.BitmapText.prototype.update = function() {
		if (this.exists) {
			this._cache.dirty = !1;
			this._cache.x = this.x;
			this._cache.y = this.y;
			if (this.position.x != this._cache.x || this.position.y != this._cache.y) this.position.x = this._cache.x, this.position.y = this._cache.y, this._cache.dirty = !0;
			this.pivot.x = this.anchor.x * this.width;
			this.pivot.y = this.anchor.y * this.height
		}
	};
	c.BitmapText.prototype.destroy = function() {
		this.group && this.group.remove(this);
		this.canvas && this.canvas.parentNode ? this.canvas.parentNode.removeChild(this.canvas) : this.context = this.canvas = null;
		this.exists = !1;
		this.group = null
	};
	Object.defineProperty(c.BitmapText.prototype, "angle", {
		get: function() {
			return c.Math.radToDeg(this.rotation)
		},
		set: function(a) {
			this.rotation = c.Math.degToRad(a)
		}
	});
	Object.defineProperty(c.BitmapText.prototype, "x", {
		get: function() {
			return this.position.x
		},
		set: function(a) {
			this.position.x = a
		}
	});
	Object.defineProperty(c.BitmapText.prototype, "y", {
		get: function() {
			return this.position.y
		},
		set: function(a) {
			this.position.y = a
		}
	});
	c.Button = function(a, b, d, e, f, g, k, m, l) {
		f = f || null;
		g = g || this;
		c.Sprite.call(this, a, b || 0, d || 0, e || null, m);
		this.type = c.BUTTON;
		this.onUpSound = this.onDownSound = this.onOutSound = this.onOverSound = this._onUpFrameID = this._onDownFrameID = this._onOutFrameID = this._onOverFrameID = this._onUpFrameName = this._onDownFrameName = this._onOutFrameName = this._onOverFrameName = null;
		this.onUpSoundMarker = this.onDownSoundMarker = this.onOutSoundMarker = this.onOverSoundMarker = "";
		this.onInputOver = new c.Signal;
		this.onInputOut = new c.Signal;
		this.onInputDown = new c.Signal;
		this.onInputUp = new c.Signal;
		this.freezeFrames = !1;
		this.forceOut = !0;
		this.setFrames(k, m, l);
		null !== f && this.onInputUp.add(f, g);
		this.input.start(0, !0);
		this.events.onInputOver.add(this.onInputOverHandler, this);
		this.events.onInputOut.add(this.onInputOutHandler, this);
		this.events.onInputDown.add(this.onInputDownHandler, this);
		this.events.onInputUp.add(this.onInputUpHandler, this)
	};
	c.Button.prototype = Object.create(c.Sprite.prototype);
	c.Button.prototype =
		c.Utils.extend(!0, c.Button.prototype, c.Sprite.prototype, e.Sprite.prototype);
	c.Button.prototype.constructor = c.Button;
	c.Button.prototype.setFrames = function(a, b, d) {
		null !== a && ("string" === typeof a ? (this._onOverFrameName = a, this.input.pointerOver() && (this.frameName = a)) : (this._onOverFrameID = a, this.input.pointerOver() && (this.frame = a)));
		null !== b && ("string" === typeof b ? (this._onUpFrameName = this._onOutFrameName = b, !1 === this.input.pointerOver() && (this.frameName = b)) : (this._onUpFrameID = this._onOutFrameID = b, !1 === this.input.pointerOver() &&
			(this.frame = b)));
		null !== d && ("string" === typeof d ? (this._onDownFrameName = d, this.input.pointerDown() && (this.frameName = d)) : (this._onDownFrameID = d, this.input.pointerDown() && (this.frame = d)))
	};
	c.Button.prototype.setSounds = function(a, b, d, c, e, f, k, m) {
		this.setOverSound(a, b);
		this.setOutSound(e, f);
		this.setUpSound(k, m);
		this.setDownSound(d, c)
	};
	c.Button.prototype.setOverSound = function(a, b) {
		this.onOverSound = null;
		this.onOverSoundMarker = "";
		a instanceof c.Sound && (this.onOverSound = a);
		"string" === typeof b && (this.onOverSoundMarker =
			b)
	};
	c.Button.prototype.setOutSound = function(a, b) {
		this.onOutSound = null;
		this.onOutSoundMarker = "";
		a instanceof c.Sound && (this.onOutSound = a);
		"string" === typeof b && (this.onOutSoundMarker = b)
	};
	c.Button.prototype.setUpSound = function(a, b) {
		this.onUpSound = null;
		this.onUpSoundMarker = "";
		a instanceof c.Sound && (this.onUpSound = a);
		"string" === typeof b && (this.onUpSoundMarker = b)
	};
	c.Button.prototype.setDownSound = function(a, b) {
		this.onDownSound = null;
		this.onDownSoundMarker = "";
		a instanceof c.Sound && (this.onDownSound = a);
		"string" ===
			typeof b && (this.onDownSoundMarker = b)
	};
	c.Button.prototype.onInputOverHandler = function(a) {
		!1 === this.freezeFrames && (null != this._onOverFrameName ? this.frameName = this._onOverFrameName : null != this._onOverFrameID && (this.frame = this._onOverFrameID));
		this.onOverSound && this.onOverSound.play(this.onOverSoundMarker);
		this.onInputOver && this.onInputOver.dispatch(this, a)
	};
	c.Button.prototype.onInputOutHandler = function(a) {
		!1 === this.freezeFrames && (null != this._onOutFrameName ? this.frameName = this._onOutFrameName : null != this._onOutFrameID &&
			(this.frame = this._onOutFrameID));
		this.onOutSound && this.onOutSound.play(this.onOutSoundMarker);
		this.onInputOut && this.onInputOut.dispatch(this, a)
	};
	c.Button.prototype.onInputDownHandler = function(a) {
		!1 === this.freezeFrames && (null != this._onDownFrameName ? this.frameName = this._onDownFrameName : null != this._onDownFrameID && (this.frame = this._onDownFrameID));
		this.onDownSound && this.onDownSound.play(this.onDownSoundMarker);
		this.onInputDown && this.onInputDown.dispatch(this, a)
	};
	c.Button.prototype.onInputUpHandler = function(a) {
		!1 ===
			this.freezeFrames && (null != this._onUpFrameName ? this.frameName = this._onUpFrameName : null != this._onUpFrameID && (this.frame = this._onUpFrameID));
		this.onUpSound && this.onUpSound.play(this.onUpSoundMarker);
		this.forceOut && !1 === this.freezeFrames && (null != this._onOutFrameName ? this.frameName = this._onOutFrameName : null != this._onOutFrameID && (this.frame = this._onOutFrameID));
		this.onInputUp && this.onInputUp.dispatch(this, a)
	};
	c.Graphics = function(a, b, d) {
		this.game = a;
		e.Graphics.call(this);
		this.type = c.GRAPHICS;
		this.position.x =
			b;
		this.position.y = d
	};
	c.Graphics.prototype = Object.create(e.Graphics.prototype);
	c.Graphics.prototype.constructor = c.Graphics;
	c.Graphics.prototype.destroy = function() {
		this.clear();
		this.group && this.group.remove(this);
		this.game = null
	};
	c.Graphics.prototype.drawPolygon = function(a) {
		this.moveTo(a.points[0].x, a.points[0].y);
		for (var b = 1; b < a.points.length; b += 1) this.lineTo(a.points[b].x, a.points[b].y);
		this.lineTo(a.points[0].x, a.points[0].y)
	};
	Object.defineProperty(c.Graphics.prototype, "angle", {
		get: function() {
			return c.Math.wrapAngle(c.Math.radToDeg(this.rotation))
		},
		set: function(a) {
			this.rotation = c.Math.degToRad(c.Math.wrapAngle(a))
		}
	});
	Object.defineProperty(c.Graphics.prototype, "x", {
		get: function() {
			return this.position.x
		},
		set: function(a) {
			this.position.x = a
		}
	});
	Object.defineProperty(c.Graphics.prototype, "y", {
		get: function() {
			return this.position.y
		},
		set: function(a) {
			this.position.y = a
		}
	});
	c.RenderTexture = function(a, b, d, f) {
		this.game = a;
		this.name = b;
		e.EventTarget.call(this);
		this.width = d || 100;
		this.height = f || 100;
		this.indetityMatrix = e.mat3.create();
		this.frame = new e.Rectangle(0,
			0, this.width, this.height);
		this.type = c.RENDERTEXTURE;
		this._tempPoint = {
			x: 0,
			y: 0
		};
		e.gl ? this.initWebGL() : this.initCanvas()
	};
	c.RenderTexture.prototype = Object.create(e.Texture.prototype);
	c.RenderTexture.prototype.constructor = e.RenderTexture;
	c.RenderTexture.prototype.render = function(a, b, d) {
		"undefined" === typeof b && (b = !1);
		"undefined" === typeof d && (d = !1);
		a instanceof c.Group && (a = a._container);
		e.gl ? this.renderWebGL(a, b, d) : this.renderCanvas(a, b, d)
	};
	c.RenderTexture.prototype.renderXY = function(a, b, d, c) {
		this._tempPoint.x =
			b;
		this._tempPoint.y = d;
		this.render(a, this._tempPoint, c)
	};
	c.RenderTexture.prototype.initWebGL = function() {
		var a = e.gl;
		this.glFramebuffer = a.createFramebuffer();
		a.bindFramebuffer(a.FRAMEBUFFER, this.glFramebuffer);
		this.glFramebuffer.width = this.width;
		this.glFramebuffer.height = this.height;
		this.baseTexture = new e.BaseTexture;
		this.baseTexture.width = this.width;
		this.baseTexture.height = this.height;
		this.baseTexture._glTexture = a.createTexture();
		a.bindTexture(a.TEXTURE_2D, this.baseTexture._glTexture);
		a.texImage2D(a.TEXTURE_2D,
			0, a.RGBA, this.width, this.height, 0, a.RGBA, a.UNSIGNED_BYTE, null);
		a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR);
		a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR);
		a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE);
		a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE);
		this.baseTexture.isRender = !0;
		a.bindFramebuffer(a.FRAMEBUFFER, this.glFramebuffer);
		a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, this.baseTexture._glTexture, 0);
		this.projection =
			new e.Point(this.width / 2, -this.height / 2)
	};
	c.RenderTexture.prototype.resize = function(a, b) {
		this.width = a;
		this.height = b;
		if (e.gl) {
			this.projection.x = this.width / 2;
			this.projection.y = -this.height / 2;
			var d = e.gl;
			d.bindTexture(d.TEXTURE_2D, this.baseTexture._glTexture);
			d.texImage2D(d.TEXTURE_2D, 0, d.RGBA, this.width, this.height, 0, d.RGBA, d.UNSIGNED_BYTE, null)
		} else this.frame.width = this.width, this.frame.height = this.height, this.renderer.resize(this.width, this.height)
	};
	c.RenderTexture.prototype.initCanvas = function() {
		this.renderer =
			new e.CanvasRenderer(this.width, this.height, null, 0);
		this.baseTexture = new e.BaseTexture(this.renderer.view);
		this.frame = new e.Rectangle(0, 0, this.width, this.height)
	};
	c.RenderTexture.prototype.renderWebGL = function(a, b, d) {
		var c = e.gl;
		c.colorMask(!0, !0, !0, !0);
		c.viewport(0, 0, this.width, this.height);
		c.bindFramebuffer(c.FRAMEBUFFER, this.glFramebuffer);
		d && (c.clearColor(0, 0, 0, 0), c.clear(c.COLOR_BUFFER_BIT));
		var f = a.children;
		d = a.worldTransform;
		a.worldTransform = e.mat3.create();
		a.worldTransform[4] = -1;
		a.worldTransform[5] = -2 * this.projection.y;
		b && (a.worldTransform[2] = b.x, a.worldTransform[5] -= b.y);
		e.visibleCount++;
		a.vcount = e.visibleCount;
		b = 0;
		for (var g = f.length; b < g; b++) f[b].updateTransform();
		(f = a.__renderGroup) ? a == f.root ? f.render(this.projection, this.glFramebuffer) : f.renderSpecific(a, this.projection, this.glFramebuffer) : (this.renderGroup || (this.renderGroup = new e.WebGLRenderGroup(c)), this.renderGroup.setRenderable(a), this.renderGroup.render(this.projection, this.glFramebuffer));
		a.worldTransform = d
	};
	c.RenderTexture.prototype.renderCanvas =
		function(a, b, d) {
			var c = a.children;
			a.worldTransform = e.mat3.create();
			b && (a.worldTransform[2] = b.x, a.worldTransform[5] = b.y);
			b = 0;
			for (var f = c.length; b < f; b++) c[b].updateTransform();
			d && this.renderer.context.clearRect(0, 0, this.width, this.height);
			this.renderer.renderDisplayObject(a);
			this.renderer.context.setTransform(1, 0, 0, 1, 0, 0)
	};
	c.Canvas = {
		create: function(a, b) {
			a = a || 256;
			b = b || 256;
			var d = document.createElement("canvas");
			d.width = a;
			d.height = b;
			d.style.display = "block";
			return d
		},
		getOffset: function(a, b) {
			b = b || new c.Point;
			var d = a.getBoundingClientRect(),
				e = a.clientTop || document.body.clientTop || 0,
				f = window.pageYOffset || a.scrollTop || document.body.scrollTop;
			b.x = d.left + (window.pageXOffset || a.scrollLeft || document.body.scrollLeft) - (a.clientLeft || document.body.clientLeft || 0);
			b.y = d.top + f - e;
			return b
		},
		getAspectRatio: function(a) {
			return a.width / a.height
		},
		setBackgroundColor: function(a, b) {
			a.style.backgroundColor = b || "rgb(0,0,0)";
			return a
		},
		setTouchAction: function(a, b) {
			b = b || "none";
			a.style.msTouchAction = b;
			a.style["ms-touch-action"] = b;
			a.style["touch-action"] = b;
			return a
		},
		setUserSelect: function(a, b) {
			b = b || "none";
			a.style["-webkit-touch-callout"] = b;
			a.style["-webkit-user-select"] = b;
			a.style["-khtml-user-select"] = b;
			a.style["-moz-user-select"] = b;
			a.style["-ms-user-select"] = b;
			a.style["user-select"] = b;
			a.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)";
			return a
		},
		addToDOM: function(a, b, d) {
			var c;
			"undefined" === typeof d && (d = !0);
			b && ("string" === typeof b ? c = document.getElementById(b) : "object" === typeof b && 1 === b.nodeType && (c = b), d && (c.style.overflow =
				"hidden"));
			c || (c = document.body);
			c.appendChild(a);
			return a
		},
		setTransform: function(a, b, d, c, e, f, k) {
			a.setTransform(c, f, k, e, b, d);
			return a
		},
		setSmoothingEnabled: function(a, b) {
			a.imageSmoothingEnabled = b;
			a.mozImageSmoothingEnabled = b;
			a.oImageSmoothingEnabled = b;
			a.webkitImageSmoothingEnabled = b;
			a.msImageSmoothingEnabled = b;
			return a
		},
		setImageRenderingCrisp: function(a) {
			a.style["image-rendering"] = "crisp-edges";
			a.style["image-rendering"] = "-moz-crisp-edges";
			a.style["image-rendering"] = "-webkit-optimize-contrast";
			a.style.msInterpolationMode =
				"nearest-neighbor";
			return a
		},
		setImageRenderingBicubic: function(a) {
			a.style["image-rendering"] = "auto";
			a.style.msInterpolationMode = "bicubic";
			return a
		}
	};
	c.StageScaleMode = function(a, b, d) {
		this.game = a;
		this.width = b;
		this.height = d;
		this.maxHeight = this.minHeight = this.maxWidth = this.minWidth = null;
		this._startHeight = 0;
		this.pageAlignVertically = this.pageAlignHorizontally = this.incorrectOrientation = this.forcePortrait = this.forceLandscape = !1;
		this._height = this._width = 0;
		this.maxIterations = 5;
		this.orientationSprite = null;
		this.enterLandscape =
			new c.Signal;
		this.enterPortrait = new c.Signal;
		this.enterIncorrectOrientation = new c.Signal;
		this.leaveIncorrectOrientation = new c.Signal;
		this.hasResized = new c.Signal;
		this.orientation = window.orientation ? window.orientation : window.outerWidth > window.outerHeight ? 90 : 0;
		this.scaleFactor = new c.Point(1, 1);
		this.scaleFactorInversed = new c.Point(1, 1);
		this.margin = new c.Point(0, 0);
		this.aspectRatio = 0;
		this.event = null;
		var e = this;
		window.addEventListener("orientationchange", function(a) {
			return e.checkOrientation(a)
		}, !1);
		window.addEventListener("resize",
			function(a) {
				return e.checkResize(a)
			}, !1);
		document.addEventListener("webkitfullscreenchange", function(a) {
			return e.fullScreenChange(a)
		}, !1);
		document.addEventListener("mozfullscreenchange", function(a) {
			return e.fullScreenChange(a)
		}, !1);
		document.addEventListener("fullscreenchange", function(a) {
			return e.fullScreenChange(a)
		}, !1)
	};
	c.StageScaleMode.EXACT_FIT = 0;
	c.StageScaleMode.NO_SCALE = 1;
	c.StageScaleMode.SHOW_ALL = 2;
	c.StageScaleMode.prototype = {
		startFullScreen: function(a) {
			this.isFullScreen || ("undefined" !== typeof a &&
				c.Canvas.setSmoothingEnabled(this.game.context, a), a = this.game.canvas, this._width = this.width, this._height = this.height, console.log("startFullScreen", this._width, this._height), a.requestFullScreen ? a.requestFullScreen() : a.mozRequestFullScreen ? a.mozRequestFullScreen() : a.webkitRequestFullScreen && a.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT))
		},
		stopFullScreen: function() {
			document.cancelFullScreen ? document.cancelFullScreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitCancelFullScreen &&
				document.webkitCancelFullScreen()
		},
		fullScreenChange: function(a) {
			this.event = a;
			this.isFullScreen ? (this.game.stage.canvas.style.width = "100%", this.game.stage.canvas.style.height = "100%", this.setMaximum()) : (this.game.stage.canvas.style.width = this.game.width + "px", this.game.stage.canvas.style.height = this.game.height + "px", this.width = this._width, this.height = this._height);
			this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height);
			this.aspectRatio = this.width / this.height;
			this.scaleFactor.x =
				this.game.width / this.width;
			this.scaleFactor.y = this.game.height / this.height
		},
		forceOrientation: function(a, b, d) {
			"undefined" === typeof b && (b = !1);
			this.forceLandscape = a;
			this.forcePortrait = b;
			if ("undefined" !== typeof d) {
				if (null == d || !1 === this.game.cache.checkImageKey(d)) d = "__default";
				this.orientationSprite = new e.Sprite(e.TextureCache[d]);
				this.orientationSprite.anchor.x = 0.5;
				this.orientationSprite.anchor.y = 0.5;
				this.orientationSprite.position.x = this.game.width / 2;
				this.orientationSprite.position.y = this.game.height /
					2;
				this.checkOrientationState();
				this.incorrectOrientation ? (this.orientationSprite.visible = !0, this.game.world.visible = !1) : (this.orientationSprite.visible = !1, this.game.world.visible = !0);
				this.game.stage._stage.addChild(this.orientationSprite)
			}
		},
		checkOrientationState: function() {
			if (this.incorrectOrientation) {
				if (this.forceLandscape && window.innerWidth > window.innerHeight || this.forcePortrait && window.innerHeight > window.innerWidth) this.incorrectOrientation = this.game.paused = !1, this.leaveIncorrectOrientation.dispatch(),
					this.orientationSprite && (this.orientationSprite.visible = !1, this.game.world.visible = !0), this.refresh()
			} else if (this.forceLandscape && window.innerWidth < window.innerHeight || this.forcePortrait && window.innerHeight < window.innerWidth) this.incorrectOrientation = this.game.paused = !0, this.enterIncorrectOrientation.dispatch(), this.orientationSprite && !1 === this.orientationSprite.visible && (this.orientationSprite.visible = !0, this.game.world.visible = !1), this.refresh()
		},
		checkOrientation: function(a) {
			this.event = a;
			this.orientation =
				window.orientation;
			this.isLandscape ? this.enterLandscape.dispatch(this.orientation, !0, !1) : this.enterPortrait.dispatch(this.orientation, !1, !0);
			this.game.stage.scaleMode !== c.StageScaleMode.NO_SCALE && this.refresh()
		},
		checkResize: function(a) {
			this.event = a;
			this.orientation = window.outerWidth > window.outerHeight ? 90 : 0;
			this.isLandscape ? this.enterLandscape.dispatch(this.orientation, !0, !1) : this.enterPortrait.dispatch(this.orientation, !1, !0);
			this.game.stage.scaleMode !== c.StageScaleMode.NO_SCALE && this.refresh();
			this.checkOrientationState()
		},
		refresh: function() {
			!1 === this.game.device.iPad && !1 === this.game.device.webApp && !1 === this.game.device.desktop && (this.game.device.android && !1 === this.game.device.chrome ? window.scrollTo(0, 1) : window.scrollTo(0, 0));
			if (null == this._check && 0 < this.maxIterations) {
				this._iterations = this.maxIterations;
				var a = this;
				this._check = window.setInterval(function() {
					return a.setScreenSize()
				}, 10);
				this.setScreenSize()
			}
		},
		setScreenSize: function(a) {
			"undefined" == typeof a && (a = !1);
			!1 === this.game.device.iPad && !1 === this.game.device.webApp &&
				!1 === this.game.device.desktop && (this.game.device.android && !1 === this.game.device.chrome ? window.scrollTo(0, 1) : window.scrollTo(0, 0));
			this._iterations--;
			if (a || window.innerHeight > this._startHeight || 0 > this._iterations) document.documentElement.style.minHeight = window.innerHeight + "px", !0 === this.incorrectOrientation ? this.setMaximum() : this.game.stage.scaleMode == c.StageScaleMode.EXACT_FIT ? this.setExactFit() : this.game.stage.scaleMode == c.StageScaleMode.SHOW_ALL && this.setShowAll(), this.setSize(), clearInterval(this._check),
				this._check = null
		},
		setSize: function() {
			!1 === this.incorrectOrientation && (this.maxWidth && this.width > this.maxWidth && (this.width = this.maxWidth), this.maxHeight && this.height > this.maxHeight && (this.height = this.maxHeight), this.minWidth && this.width < this.minWidth && (this.width = this.minWidth), this.minHeight && this.height < this.minHeight && (this.height = this.minHeight));
			this.game.canvas.style.width = this.width + "px";
			this.game.canvas.style.height = this.height + "px";
			this.game.input.scale.setTo(this.game.width / this.width, this.game.height /
				this.height);
			this.pageAlignHorizontally && (this.width < window.innerWidth && !1 === this.incorrectOrientation ? (this.margin.x = Math.round((window.innerWidth - this.width) / 2), this.game.canvas.style.marginLeft = this.margin.x + "px") : (this.margin.x = 0, this.game.canvas.style.marginLeft = "0px"));
			this.pageAlignVertically && (this.height < window.innerHeight && !1 === this.incorrectOrientation ? (this.margin.y = Math.round((window.innerHeight - this.height) / 2), this.game.canvas.style.marginTop = this.margin.y + "px") : (this.margin.y = 0, this.game.canvas.style.marginTop =
				"0px"));
			c.Canvas.getOffset(this.game.canvas, this.game.stage.offset);
			this.aspectRatio = this.width / this.height;
			this.scaleFactor.x = this.game.width / this.width;
			this.scaleFactor.y = this.game.height / this.height;
			this.scaleFactorInversed.x = this.width / this.game.width;
			this.scaleFactorInversed.y = this.height / this.game.height;
			this.hasResized.dispatch(this.width, this.height);
			this.checkOrientationState()
		},
		setMaximum: function() {
			this.width = window.innerWidth;
			this.height = window.innerHeight
		},
		setShowAll: function() {
			var a =
				Math.min(window.innerHeight / this.game.height, window.innerWidth / this.game.width);
			this.width = Math.round(this.game.width * a);
			this.height = Math.round(this.game.height * a)
		},
		setExactFit: function() {
			var a = window.innerWidth,
				b = window.innerHeight;
			this.width = this.maxWidth && a > this.maxWidth ? this.maxWidth : a;
			this.height = this.maxHeight && b > this.maxHeight ? this.maxHeight : b
		}
	};
	Object.defineProperty(c.StageScaleMode.prototype, "isFullScreen", {
		get: function() {
			return document.fullscreenElement || document.mozFullScreenElement ||
				document.webkitFullscreenElement
		}
	});
	Object.defineProperty(c.StageScaleMode.prototype, "isPortrait", {
		get: function() {
			return 0 === this.orientation || 180 == this.orientation
		}
	});
	Object.defineProperty(c.StageScaleMode.prototype, "isLandscape", {
		get: function() {
			return 90 === this.orientation || -90 === this.orientation
		}
	});
	c.Device = function() {
		this.ie = this.firefox = this.epiphany = this.chrome = this.arora = this.typedArray = this.pointerLock = this.css3D = this.mspointer = this.touch = this.worker = this.webGL = this.localStorage = this.fileSystem =
			this.file = this.canvas = this.windows = this.macOS = this.linux = this.chromeOS = this.android = this.cocoonJS = this.iOS = this.desktop = this.patchAndroidClearRectBug = !1;
		this.ieVersion = 0;
		this.iPad = this.iPhone4 = this.iPhone = this.webm = this.m4a = this.wav = this.mp3 = this.opus = this.ogg = this.webAudio = this.audioData = this.webApp = this.safari = this.opera = this.midori = this.mobileSafari = !1;
		this.pixelRatio = 0;
		this.littleEndian = !1;
		this._checkAudio();
		this._checkBrowser();
		this._checkCSS3D();
		this._checkDevice();
		this._checkFeatures();
		this._checkOS()
	};
	c.Device.prototype = {
		_checkOS: function() {
			var a = navigator.userAgent;
			/Android/.test(a) ? this.android = !0 : /CrOS/.test(a) ? this.chromeOS = !0 : /iP[ao]d|iPhone/i.test(a) ? this.iOS = !0 : /Linux/.test(a) ? this.linux = !0 : /Mac OS/.test(a) ? this.macOS = !0 : /Windows/.test(a) && (this.windows = !0);
			if (this.windows || this.macOS || this.linux) this.desktop = !0
		},
		_checkFeatures: function() {
			this.canvas = !!window.CanvasRenderingContext2D;
			try {
				this.localStorage = !!localStorage.getItem
			} catch (a) {
				this.localStorage = !1
			}
			this.file = !!window.File && !!window.FileReader &&
				!!window.FileList && !!window.Blob;
			this.fileSystem = !!window.requestFileSystem;
			var b;
			try {
				var d = document.createElement("canvas");
				b = !!window.WebGLRenderingContext && (d.getContext("webgl") || d.getContext("experimental-webgl"))
			} catch (c) {
				b = !1
			}
			this.webGL = b;
			this.webGL = null === this.webGL || !1 === this.webGL ? !1 : !0;
			this.worker = !!window.Worker;
			if ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && 1 < window.navigator.maxTouchPoints) this.touch = !0;
			if (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) this.mspointer = !0;
			this.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document
		},
		_checkBrowser: function() {
			var a = navigator.userAgent;
			/Arora/.test(a) ? this.arora = !0 : /Chrome/.test(a) ? this.chrome = !0 : /Epiphany/.test(a) ? this.epiphany = !0 : /Firefox/.test(a) ? this.firefox = !0 : /Mobile Safari/.test(a) ? this.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(a) ? (this.ie = !0, this.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(a) ? this.midori = !0 : /Opera/.test(a) ? this.opera = !0 : /Safari/.test(a) &&
				(this.safari = !0);
			navigator.standalone && (this.webApp = !0);
			navigator.isCocoonJS && (this.cocoonJS = !0)
		},
		_checkAudio: function() {
			this.audioData = !!window.Audio;
			this.webAudio = !(!window.webkitAudioContext && !window.AudioContext);
			var a = document.createElement("audio");
			try {
				if (a.canPlayType) {
					a.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (this.ogg = !0);
					a.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") && (this.opus = !0);
					a.canPlayType("audio/mpeg;").replace(/^no$/, "") && (this.mp3 = !0);
					a.canPlayType('audio/wav; codecs="1"').replace(/^no$/,
						"") && (this.wav = !0);
					if (a.canPlayType("audio/x-m4a;") || a.canPlayType("audio/aac;").replace(/^no$/, "")) this.m4a = !0;
					a.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (this.webm = !0)
				}
			} catch (b) {}
		},
		_checkDevice: function() {
			this.pixelRatio = window.devicePixelRatio || 1;
			this.iPhone = -1 != navigator.userAgent.toLowerCase().indexOf("iphone");
			this.iPhone4 = 2 == this.pixelRatio && this.iPhone;
			this.iPad = -1 != navigator.userAgent.toLowerCase().indexOf("ipad");
			"undefined" !== typeof Int8Array ? (this.littleEndian = 0 <
				(new Int8Array((new Int16Array([1])).buffer))[0], this.typedArray = !0) : this.typedArray = this.littleEndian = !1
		},
		_checkCSS3D: function() {
			var a = document.createElement("p"),
				b, d = {
					webkitTransform: "-webkit-transform",
					OTransform: "-o-transform",
					msTransform: "-ms-transform",
					MozTransform: "-moz-transform",
					transform: "transform"
				};
			document.body.insertBefore(a, null);
			for (var c in d) void 0 !== a.style[c] && (a.style[c] = "translate3d(1px,1px,1px)", b = window.getComputedStyle(a).getPropertyValue(d[c]));
			document.body.removeChild(a);
			this.css3D = void 0 !== b && 0 < b.length && "none" !== b
		},
		canPlayAudio: function(a) {
			return "mp3" == a && this.mp3 || "ogg" == a && (this.ogg || this.opus) || "m4a" == a && this.m4a || "wav" == a && this.wav || "webm" == a && this.webm ? !0 : !1
		},
		isConsoleOpen: function() {
			return window.console && window.console.firebug ? !0 : window.console ? (console.profile(), console.profileEnd(), console.clear && console.clear(), 0 < console.profiles.length) : !1
		}
	};
	c.RequestAnimationFrame = function(a) {
		this.game = a;
		this.forceSetTimeOut = this.isRunning = !1;
		a = ["ms", "moz", "webkit",
			"o"
		];
		for (var b = 0; b < a.length && !window.requestAnimationFrame; b++) window.requestAnimationFrame = window[a[b] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[a[b] + "CancelAnimationFrame"];
		this._isSetTimeOut = !1;
		this._timeOutID = this._onLoop = null
	};
	c.RequestAnimationFrame.prototype = {
		start: function() {
			this.isRunning = !0;
			var a = this;
			!window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() {
				return a.updateSetTimeout()
			}, this._timeOutID = window.setTimeout(this._onLoop,
				0)) : (this._isSetTimeOut = !1, this._onLoop = function(b) {
				return a.updateRAF(b)
			}, this._timeOutID = window.requestAnimationFrame(this._onLoop))
		},
		updateRAF: function(a) {
			this.game.update(a);
			this._timeOutID = window.requestAnimationFrame(this._onLoop)
		},
		updateSetTimeout: function() {
			this.game.update(Date.now());
			this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall)
		},
		stop: function() {
			this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID);
			this.isRunning = !1
		},
		isSetTimeOut: function() {
			return this._isSetTimeOut
		},
		isRAF: function() {
			return !1 === this._isSetTimeOut
		}
	};
	c.RandomDataGenerator = function(a) {
		"undefined" === typeof a && (a = []);
		this.c = 1;
		this.s2 = this.s1 = this.s0 = 0;
		this.sow(a)
	};
	c.RandomDataGenerator.prototype = {
		rnd: function() {
			var a = 2091639 * this.s0 + 2.3283064365386963E-10 * this.c;
			this.c = a | 0;
			this.s0 = this.s1;
			this.s1 = this.s2;
			return this.s2 = a - this.c
		},
		sow: function(a) {
			"undefined" === typeof a && (a = []);
			this.s0 = this.hash(" ");
			this.s1 = this.hash(this.s0);
			this.s2 = this.hash(this.s1);
			this.c = 1;
			for (var b, d = 0; b = a[d++];) this.s0 -= this.hash(b),
				this.s0 += ~~(0 > this.s0), this.s1 -= this.hash(b), this.s1 += ~~(0 > this.s1), this.s2 -= this.hash(b), this.s2 += ~~(0 > this.s2)
		},
		hash: function(a) {
			var b, d, c;
			c = 4022871197;
			a = a.toString();
			for (d = 0; d < a.length; d++) c += a.charCodeAt(d), b = 0.02519603282416938 * c, c = b >>> 0, b -= c, b *= c, c = b >>> 0, b -= c, c += 4294967296 * b;
			return 2.3283064365386963E-10 * (c >>> 0)
		},
		integer: function() {
			return 4294967296 * this.rnd.apply(this)
		},
		frac: function() {
			return this.rnd.apply(this) + 1.1102230246251565E-16 * (2097152 * this.rnd.apply(this) | 0)
		},
		real: function() {
			return this.integer() +
				this.frac()
		},
		integerInRange: function(a, b) {
			return Math.floor(this.realInRange(a, b))
		},
		realInRange: function(a, b) {
			return this.frac() * (b - a) + a
		},
		normal: function() {
			return 1 - 2 * this.frac()
		},
		uuid: function() {
			for (var a = "", b = "", b = a = ""; 36 > a++; b += ~a % 5 | 3 * a & 4 ? (a ^ 15 ? 8 ^ this.frac() * (a ^ 20 ? 16 : 4) : 4).toString(16) : "-");
			return b
		},
		pick: function(a) {
			return a[this.integerInRange(0, a.length)]
		},
		weightedPick: function(a) {
			return a[~~(Math.pow(this.frac(), 2) * a.length)]
		},
		timestamp: function(a, b) {
			return this.realInRange(a || 9466848E5, b ||
				1577862E6)
		},
		angle: function() {
			return this.integerInRange(-180, 180)
		}
	};
	c.Math = {
		PI2: 2 * Math.PI,
		fuzzyEqual: function(a, b, d) {
			"undefined" === typeof d && (d = 1E-4);
			return Math.abs(a - b) < d
		},
		fuzzyLessThan: function(a, b, d) {
			"undefined" === typeof d && (d = 1E-4);
			return a < b + d
		},
		fuzzyGreaterThan: function(a, b, d) {
			"undefined" === typeof d && (d = 1E-4);
			return a > b - d
		},
		fuzzyCeil: function(a, b) {
			"undefined" === typeof b && (b = 1E-4);
			return Math.ceil(a - b)
		},
		fuzzyFloor: function(a, b) {
			"undefined" === typeof b && (b = 1E-4);
			return Math.floor(a + b)
		},
		average: function() {
			for (var a =
				[], b = 0; b < arguments.length - 0; b++) a[b] = arguments[b + 0];
			for (var d = b = 0; d < a.length; d++) b += a[d];
			return b / a.length
		},
		truncate: function(a) {
			return 0 < a ? Math.floor(a) : Math.ceil(a)
		},
		shear: function(a) {
			return a % 1
		},
		snapTo: function(a, b, d) {
			"undefined" === typeof d && (d = 0);
			if (0 === b) return a;
			a = b * Math.round((a - d) / b);
			return d + a
		},
		snapToFloor: function(a, b, d) {
			"undefined" === typeof d && (d = 0);
			if (0 === b) return a;
			a = b * Math.floor((a - d) / b);
			return d + a
		},
		snapToCeil: function(a, b, d) {
			"undefined" === typeof d && (d = 0);
			if (0 === b) return a;
			a = b * Math.ceil((a -
				d) / b);
			return d + a
		},
		snapToInArray: function(a, b, d) {
			"undefined" === typeof d && (d = !0);
			d && b.sort();
			if (a < b[0]) return b[0];
			for (var c = 1; b[c] < a;) c++;
			d = b[c - 1];
			b = c < b.length ? b[c] : Number.POSITIVE_INFINITY;
			return b - a <= a - d ? b : d
		},
		roundTo: function(a, b, d) {
			"undefined" === typeof b && (b = 0);
			"undefined" === typeof d && (d = 10);
			b = Math.pow(d, -b);
			return Math.round(a * b) / b
		},
		floorTo: function(a, b, d) {
			"undefined" === typeof b && (b = 0);
			"undefined" === typeof d && (d = 10);
			b = Math.pow(d, -b);
			return Math.floor(a * b) / b
		},
		ceilTo: function(a, b, d) {
			"undefined" ===
				typeof b && (b = 0);
			"undefined" === typeof d && (d = 10);
			b = Math.pow(d, -b);
			return Math.ceil(a * b) / b
		},
		interpolateFloat: function(a, b, d) {
			return (b - a) * d + a
		},
		angleBetween: function(a, b, d, c) {
			return Math.atan2(c - b, d - a)
		},
		normalizeAngle: function(a, b) {
			"undefined" === typeof b && (b = !0);
			var d = b ? Math.PI : 180;
			return this.wrap(a, -d, d)
		},
		nearestAngleBetween: function(a, b, d) {
			"undefined" === typeof d && (d = !0);
			var c = d ? Math.PI : 180;
			a = this.normalizeAngle(a, d);
			b = this.normalizeAngle(b, d);
			a < -c / 2 && b > c / 2 && (a += 2 * c);
			b < -c / 2 && a > c / 2 && (b += 2 * c);
			return b -
				a
		},
		interpolateAngles: function(a, b, d, c, e) {
			"undefined" === typeof c && (c = !0);
			"undefined" === typeof e && (e = null);
			a = this.normalizeAngle(a, c);
			b = this.normalizeAngleToAnother(b, a, c);
			return "function" === typeof e ? e(d, a, b - a, 1) : this.interpolateFloat(a, b, d)
		},
		chanceRoll: function(a) {
			"undefined" === typeof a && (a = 50);
			return 0 >= a ? !1 : 100 <= a ? !0 : 100 * Math.random() >= a ? !1 : !0
		},
		numberArray: function(a, b) {
			for (var d = [], c = a; c <= b; c++) d.push(c);
			return d
		},
		maxAdd: function(a, b, d) {
			a += b;
			a > d && (a = d);
			return a
		},
		minSub: function(a, b, d) {
			a -= b;
			a < d &&
				(a = d);
			return a
		},
		wrap: function(a, b, d) {
			d -= b;
			if (0 >= d) return 0;
			a = (a - b) % d;
			0 > a && (a += d);
			return a + b
		},
		wrapValue: function(a, b, d) {
			a = Math.abs(a);
			b = Math.abs(b);
			d = Math.abs(d);
			return (a + b) % d
		},
		randomSign: function() {
			return 0.5 < Math.random() ? 1 : -1
		},
		isOdd: function(a) {
			return a & 1
		},
		isEven: function(a) {
			return a & 1 ? !1 : !0
		},
		max: function() {
			for (var a = 1, b = 0, d = arguments.length; a < d; a++) arguments[b] < arguments[a] && (b = a);
			return arguments[b]
		},
		min: function() {
			for (var a = 1, b = 0, d = arguments.length; a < d; a++) arguments[a] < arguments[b] && (b = a);
			return arguments[b]
		},
		wrapAngle: function(a) {
			return this.wrap(a, -180, 180)
		},
		angleLimit: function(a, b, d) {
			var c = a;
			a > d ? c = d : a < b && (c = b);
			return c
		},
		linearInterpolation: function(a, b) {
			var d = a.length - 1,
				c = d * b,
				e = Math.floor(c);
			return 0 > b ? this.linear(a[0], a[1], c) : 1 < b ? this.linear(a[d], a[d - 1], d - c) : this.linear(a[e], a[e + 1 > d ? d : e + 1], c - e)
		},
		bezierInterpolation: function(a, b) {
			for (var d = 0, c = a.length - 1, e = 0; e <= c; e++) d += Math.pow(1 - b, c - e) * Math.pow(b, e) * a[e] * this.bernstein(c, e);
			return d
		},
		catmullRomInterpolation: function(a, b) {
			var d = a.length - 1,
				c = d * b,
				e =
				Math.floor(c);
			return a[0] === a[d] ? (0 > b && (e = Math.floor(c = d * (1 + b))), this.catmullRom(a[(e - 1 + d) % d], a[e], a[(e + 1) % d], a[(e + 2) % d], c - e)) : 0 > b ? a[0] - (this.catmullRom(a[0], a[0], a[1], a[1], -c) - a[0]) : 1 < b ? a[d] - (this.catmullRom(a[d], a[d], a[d - 1], a[d - 1], c - d) - a[d]) : this.catmullRom(a[e ? e - 1 : 0], a[e], a[d < e + 1 ? d : e + 1], a[d < e + 2 ? d : e + 2], c - e)
		},
		linear: function(a, b, d) {
			return (b - a) * d + a
		},
		bernstein: function(a, b) {
			return this.factorial(a) / this.factorial(b) / this.factorial(a - b)
		},
		catmullRom: function(a, b, d, c, e) {
			a = 0.5 * (d - a);
			c = 0.5 * (c - b);
			var f =
				e * e;
			return (2 * b - 2 * d + a + c) * e * f + (-3 * b + 3 * d - 2 * a - c) * f + a * e + b
		},
		difference: function(a, b) {
			return Math.abs(a - b)
		},
		getRandom: function(a, b, d) {
			"undefined" === typeof b && (b = 0);
			"undefined" === typeof d && (d = 0);
			if (null != a) {
				if (0 === d || d > a.length - b) d = a.length - b;
				if (0 < d) return a[b + Math.floor(Math.random() * d)]
			}
			return null
		},
		floor: function(a) {
			var b = a | 0;
			return 0 < a ? b : b != a ? b - 1 : b
		},
		ceil: function(a) {
			var b = a | 0;
			return 0 < a ? b != a ? b + 1 : b : b
		},
		sinCosGenerator: function(a, b, d, c) {
			"undefined" === typeof b && (b = 1);
			"undefined" === typeof d && (d = 1);
			"undefined" ===
				typeof c && (c = 1);
			c = c * Math.PI / a;
			for (var e = [], f = [], k = 0; k < a; k++) d -= b * c, b += d * c, e[k] = d, f[k] = b;
			return {
				sin: f,
				cos: e,
				length: a
			}
		},
		shift: function(a) {
			var b = a.shift();
			a.push(b);
			return b
		},
		shuffleArray: function(a) {
			for (var b = a.length - 1; 0 < b; b--) {
				var d = Math.floor(Math.random() * (b + 1)),
					c = a[b];
				a[b] = a[d];
				a[d] = c
			}
			return a
		},
		distance: function(a, b, d, c) {
			a -= d;
			b -= c;
			return Math.sqrt(a * a + b * b)
		},
		distanceRounded: function(a, b, d, e) {
			return Math.round(c.Math.distance(a, b, d, e))
		},
		clamp: function(a, b, d) {
			return a < b ? b : a > d ? d : a
		},
		clampBottom: function(a,
			b) {
			return a < b ? b : a
		},
		within: function(a, b, d) {
			return Math.abs(a - b) <= d
		},
		mapLinear: function(a, b, d, c, e) {
			return c + (a - b) * (e - c) / (d - b)
		},
		smoothstep: function(a, b, d) {
			if (a <= b) return 0;
			if (a >= d) return 1;
			a = (a - b) / (d - b);
			return a * a * (3 - 2 * a)
		},
		smootherstep: function(a, b, d) {
			if (a <= b) return 0;
			if (a >= d) return 1;
			a = (a - b) / (d - b);
			return a * a * a * (a * (6 * a - 15) + 10)
		},
		sign: function(a) {
			return 0 > a ? -1 : 0 < a ? 1 : 0
		},
		degToRad: function() {
			var a = Math.PI / 180;
			return function(b) {
				return b * a
			}
		}(),
		radToDeg: function() {
			var a = 180 / Math.PI;
			return function(b) {
				return b *
					a
			}
		}()
	};
	c.QuadTree = function(a, b, d, c, e, f, k, m) {
		this.physicsManager = a;
		this.ID = a.quadTreeID;
		a.quadTreeID++;
		this.maxObjects = f || 10;
		this.maxLevels = k || 4;
		this.level = m || 0;
		this.bounds = {
			x: Math.round(b),
			y: Math.round(d),
			width: c,
			height: e,
			subWidth: Math.floor(c / 2),
			subHeight: Math.floor(e / 2),
			right: Math.round(b) + Math.floor(c / 2),
			bottom: Math.round(d) + Math.floor(e / 2)
		};
		this.objects = [];
		this.nodes = []
	};
	c.QuadTree.prototype = {
		split: function() {
			this.level++;
			this.nodes[0] = new c.QuadTree(this.physicsManager, this.bounds.right, this.bounds.y,
				this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level);
			this.nodes[1] = new c.QuadTree(this.physicsManager, this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level);
			this.nodes[2] = new c.QuadTree(this.physicsManager, this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level);
			this.nodes[3] = new c.QuadTree(this.physicsManager, this.bounds.right, this.bounds.bottom,
				this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level)
		},
		insert: function(a) {
			var b = 0,
				d;
			if (null != this.nodes[0] && (d = this.getIndex(a), -1 !== d)) {
				this.nodes[d].insert(a);
				return
			}
			this.objects.push(a);
			if (this.objects.length > this.maxObjects && this.level < this.maxLevels)
				for (null == this.nodes[0] && this.split(); b < this.objects.length;) d = this.getIndex(this.objects[b]), -1 !== d ? this.nodes[d].insert(this.objects.splice(b, 1)[0]) : b++
		},
		getIndex: function(a) {
			var b = -1;
			a.x < this.bounds.right && a.right <
				this.bounds.right ? a.y < this.bounds.bottom && a.bottom < this.bounds.bottom ? b = 1 : a.y > this.bounds.bottom && (b = 2) : a.x > this.bounds.right && (a.y < this.bounds.bottom && a.bottom < this.bounds.bottom ? b = 0 : a.y > this.bounds.bottom && (b = 3));
			return b
		},
		retrieve: function(a) {
			var b = this.objects;
			a.body.quadTreeIndex = this.getIndex(a.body);
			a.body.quadTreeIDs.push(this.ID);
			this.nodes[0] && (-1 !== a.body.quadTreeIndex ? b = b.concat(this.nodes[a.body.quadTreeIndex].retrieve(a)) : (b = b.concat(this.nodes[0].retrieve(a)), b = b.concat(this.nodes[1].retrieve(a)),
				b = b.concat(this.nodes[2].retrieve(a)), b = b.concat(this.nodes[3].retrieve(a))));
			return b
		},
		clear: function() {
			this.objects = [];
			for (var a = 0, b = this.nodes.length; a < b; a++) this.nodes[a] && (this.nodes[a].clear(), delete this.nodes[a])
		}
	};
	c.Circle = function(a, b, d) {
		d = d || 0;
		this.x = a || 0;
		this.y = b || 0;
		this._diameter = d;
		this._radius = 0 < d ? 0.5 * d : 0
	};
	c.Circle.prototype = {
		circumference: function() {
			return 2 * Math.PI * this._radius
		},
		setTo: function(a, b, d) {
			this.x = a;
			this.y = b;
			this._diameter = d;
			this._radius = 0.5 * d;
			return this
		},
		copyFrom: function(a) {
			return this.setTo(a.x,
				a.y, a.diameter)
		},
		copyTo: function(a) {
			a.x = this.x;
			a.y = this.y;
			a.diameter = this._diameter;
			return a
		},
		distance: function(a, b) {
			"undefined" === typeof b && (b = !1);
			return b ? c.Math.distanceRound(this.x, this.y, a.x, a.y) : c.Math.distance(this.x, this.y, a.x, a.y)
		},
		clone: function(a) {
			"undefined" === typeof a && (a = new c.Circle);
			return a.setTo(this.x, this.y, this.diameter)
		},
		contains: function(a, b) {
			return c.Circle.contains(this, a, b)
		},
		circumferencePoint: function(a, b, d) {
			return c.Circle.circumferencePoint(this, a, b, d)
		},
		offset: function(a,
			b) {
			this.x += a;
			this.y += b;
			return this
		},
		offsetPoint: function(a) {
			return this.offset(a.x, a.y)
		},
		toString: function() {
			return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
		}
	};
	Object.defineProperty(c.Circle.prototype, "diameter", {
		get: function() {
			return this._diameter
		},
		set: function(a) {
			0 < a && (this._diameter = a, this._radius = 0.5 * a)
		}
	});
	Object.defineProperty(c.Circle.prototype, "radius", {
		get: function() {
			return this._radius
		},
		set: function(a) {
			0 < a && (this._radius = a, this._diameter =
				2 * a)
		}
	});
	Object.defineProperty(c.Circle.prototype, "left", {
		get: function() {
			return this.x - this._radius
		},
		set: function(a) {
			a > this.x ? this._diameter = this._radius = 0 : this.radius = this.x - a
		}
	});
	Object.defineProperty(c.Circle.prototype, "right", {
		get: function() {
			return this.x + this._radius
		},
		set: function(a) {
			a < this.x ? this._diameter = this._radius = 0 : this.radius = a - this.x
		}
	});
	Object.defineProperty(c.Circle.prototype, "top", {
		get: function() {
			return this.y - this._radius
		},
		set: function(a) {
			a > this.y ? this._diameter = this._radius = 0 : this.radius =
				this.y - a
		}
	});
	Object.defineProperty(c.Circle.prototype, "bottom", {
		get: function() {
			return this.y + this._radius
		},
		set: function(a) {
			a < this.y ? this._diameter = this._radius = 0 : this.radius = a - this.y
		}
	});
	Object.defineProperty(c.Circle.prototype, "area", {
		get: function() {
			return 0 < this._radius ? Math.PI * this._radius * this._radius : 0
		}
	});
	Object.defineProperty(c.Circle.prototype, "empty", {
		get: function() {
			return 0 === this._diameter
		},
		set: function(a) {
			!0 === a && this.setTo(0, 0, 0)
		}
	});
	c.Circle.contains = function(a, b, d) {
		return b >= a.left && b <=
			a.right && d >= a.top && d <= a.bottom ? (a.x - b) * (a.x - b) + (a.y - d) * (a.y - d) <= a.radius * a.radius : !1
	};
	c.Circle.equals = function(a, b) {
		return a.x == b.x && a.y == b.y && a.diameter == b.diameter
	};
	c.Circle.intersects = function(a, b) {
		return c.Math.distance(a.x, a.y, b.x, b.y) <= a.radius + b.radius
	};
	c.Circle.circumferencePoint = function(a, b, d, e) {
		"undefined" === typeof d && (d = !1);
		"undefined" === typeof e && (e = new c.Point);
		!0 === d && (b = c.Math.radToDeg(b));
		e.x = a.x + a.radius * Math.cos(b);
		e.y = a.y + a.radius * Math.sin(b);
		return e
	};
	c.Circle.intersectsRectangle =
		function(a, b) {
			var d = Math.abs(a.x - b.x - b.halfWidth);
			if (d > b.halfWidth + a.radius) return !1;
			var c = Math.abs(a.y - b.y - b.halfHeight);
			if (c > b.halfHeight + a.radius) return !1;
			if (d <= b.halfWidth || c <= b.halfHeight) return !0;
			d -= b.halfWidth;
			c -= b.halfHeight;
			return d * d + c * c <= a.radius * a.radius
	};
	c.Point = function(a, b) {
		this.x = a || 0;
		this.y = b || 0
	};
	c.Point.prototype = {
		copyFrom: function(a) {
			return this.setTo(a.x, a.y)
		},
		invert: function() {
			return this.setTo(this.y, this.x)
		},
		setTo: function(a, b) {
			this.x = a;
			this.y = b;
			return this
		},
		add: function(a,
			b) {
			this.x += a;
			this.y += b;
			return this
		},
		subtract: function(a, b) {
			this.x -= a;
			this.y -= b;
			return this
		},
		multiply: function(a, b) {
			this.x *= a;
			this.y *= b;
			return this
		},
		divide: function(a, b) {
			this.x /= a;
			this.y /= b;
			return this
		},
		clampX: function(a, b) {
			this.x = c.Math.clamp(this.x, a, b);
			return this
		},
		clampY: function(a, b) {
			this.y = c.Math.clamp(this.y, a, b);
			return this
		},
		clamp: function(a, b) {
			this.x = c.Math.clamp(this.x, a, b);
			this.y = c.Math.clamp(this.y, a, b);
			return this
		},
		clone: function(a) {
			"undefined" === typeof a && (a = new c.Point);
			return a.setTo(this.x,
				this.y)
		},
		copyTo: function(a) {
			a.x = this.x;
			a.y = this.y;
			return a
		},
		distance: function(a, b) {
			return c.Point.distance(this, a, b)
		},
		equals: function(a) {
			return a.x == this.x && a.y == this.y
		},
		rotate: function(a, b, d, e, f) {
			return c.Point.rotate(this, a, b, d, e, f)
		},
		getMagnitude: function() {
			return Math.sqrt(this.x * this.x + this.y * this.y)
		},
		setMagnitude: function(a) {
			return this.normalize().multiply(a, a)
		},
		normalize: function() {
			if (!this.isZero()) {
				var a = this.getMagnitude();
				this.x /= a;
				this.y /= a
			}
			return this
		},
		isZero: function() {
			return 0 === this.x &&
				0 === this.y
		},
		toString: function() {
			return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
		}
	};
	c.Point.add = function(a, b, d) {
		"undefined" === typeof d && (d = new c.Point);
		d.x = a.x + b.x;
		d.y = a.y + b.y;
		return d
	};
	c.Point.subtract = function(a, b, d) {
		"undefined" === typeof d && (d = new c.Point);
		d.x = a.x - b.x;
		d.y = a.y - b.y;
		return d
	};
	c.Point.multiply = function(a, b, d) {
		"undefined" === typeof d && (d = new c.Point);
		d.x = a.x * b.x;
		d.y = a.y * b.y;
		return d
	};
	c.Point.divide = function(a, b, d) {
		"undefined" === typeof d && (d = new c.Point);
		d.x = a.x / b.x;
		d.y = a.y / b.y;
		return d
	};
	c.Point.equals = function(a, b) {
		return a.x == b.x && a.y == b.y
	};
	c.Point.distance = function(a, b, d) {
		"undefined" === typeof d && (d = !1);
		return d ? c.Math.distanceRound(a.x, a.y, b.x, b.y) : c.Math.distance(a.x, a.y, b.x, b.y)
	};
	c.Point.rotate = function(a, b, d, e, f, g) {
		g = g || null;
		f && (e = c.Math.degToRad(e));
		null === g && (g = Math.sqrt((b - a.x) * (b - a.x) + (d - a.y) * (d - a.y)));
		return a.setTo(b + g * Math.cos(e), d + g * Math.sin(e))
	};
	c.Rectangle = function(a, b, d, c) {
		this.x = a || 0;
		this.y = b || 0;
		this.width = d || 0;
		this.height = c || 0
	};
	c.Rectangle.prototype = {
		offset: function(a,
			b) {
			this.x += a;
			this.y += b;
			return this
		},
		offsetPoint: function(a) {
			return this.offset(a.x, a.y)
		},
		setTo: function(a, b, d, c) {
			this.x = a;
			this.y = b;
			this.width = d;
			this.height = c;
			return this
		},
		floor: function() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y)
		},
		floorAll: function() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.width = Math.floor(this.width);
			this.height = Math.floor(this.height)
		},
		copyFrom: function(a) {
			return this.setTo(a.x, a.y, a.width, a.height)
		},
		copyTo: function(a) {
			a.x = this.x;
			a.y = this.y;
			a.width = this.width;
			a.height = this.height;
			return a
		},
		inflate: function(a, b) {
			return c.Rectangle.inflate(this, a, b)
		},
		size: function(a) {
			return c.Rectangle.size(this, a)
		},
		clone: function(a) {
			return c.Rectangle.clone(this, a)
		},
		contains: function(a, b) {
			return c.Rectangle.contains(this, a, b)
		},
		containsRect: function(a) {
			return c.Rectangle.containsRect(this, a)
		},
		equals: function(a) {
			return c.Rectangle.equals(this, a)
		},
		intersection: function(a, b) {
			return c.Rectangle.intersection(this, a, b)
		},
		intersects: function(a, b) {
			return c.Rectangle.intersects(this,
				a, b)
		},
		intersectsRaw: function(a, b, d, e, f) {
			return c.Rectangle.intersectsRaw(this, a, b, d, e, f)
		},
		union: function(a, b) {
			return c.Rectangle.union(this, a, b)
		},
		toString: function() {
			return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
		}
	};
	Object.defineProperty(c.Rectangle.prototype, "halfWidth", {
		get: function() {
			return Math.round(this.width / 2)
		}
	});
	Object.defineProperty(c.Rectangle.prototype, "halfHeight", {
		get: function() {
			return Math.round(this.height / 2)
		}
	});
	Object.defineProperty(c.Rectangle.prototype,
		"bottom", {
			get: function() {
				return this.y + this.height
			},
			set: function(a) {
				this.height = a <= this.y ? 0 : this.y - a
			}
		});
	Object.defineProperty(c.Rectangle.prototype, "bottomRight", {
		get: function() {
			return new c.Point(this.right, this.bottom)
		},
		set: function(a) {
			this.right = a.x;
			this.bottom = a.y
		}
	});
	Object.defineProperty(c.Rectangle.prototype, "left", {
		get: function() {
			return this.x
		},
		set: function(a) {
			this.width = a >= this.right ? 0 : this.right - a;
			this.x = a
		}
	});
	Object.defineProperty(c.Rectangle.prototype, "right", {
		get: function() {
			return this.x +
				this.width
		},
		set: function(a) {
			this.width = a <= this.x ? 0 : this.x + a
		}
	});
	Object.defineProperty(c.Rectangle.prototype, "volume", {
		get: function() {
			return this.width * this.height
		}
	});
	Object.defineProperty(c.Rectangle.prototype, "perimeter", {
		get: function() {
			return 2 * this.width + 2 * this.height
		}
	});
	Object.defineProperty(c.Rectangle.prototype, "centerX", {
		get: function() {
			return this.x + this.halfWidth
		},
		set: function(a) {
			this.x = a - this.halfWidth
		}
	});
	Object.defineProperty(c.Rectangle.prototype, "centerY", {
		get: function() {
			return this.y +
				this.halfHeight
		},
		set: function(a) {
			this.y = a - this.halfHeight
		}
	});
	Object.defineProperty(c.Rectangle.prototype, "top", {
		get: function() {
			return this.y
		},
		set: function(a) {
			a >= this.bottom ? (this.height = 0, this.y = a) : this.height = this.bottom - a
		}
	});
	Object.defineProperty(c.Rectangle.prototype, "topLeft", {
		get: function() {
			return new c.Point(this.x, this.y)
		},
		set: function(a) {
			this.x = a.x;
			this.y = a.y
		}
	});
	Object.defineProperty(c.Rectangle.prototype, "empty", {
		get: function() {
			return !this.width || !this.height
		},
		set: function(a) {
			!0 === a && this.setTo(0,
				0, 0, 0)
		}
	});
	c.Rectangle.inflate = function(a, b, d) {
		a.x -= b;
		a.width += 2 * b;
		a.y -= d;
		a.height += 2 * d;
		return a
	};
	c.Rectangle.inflatePoint = function(a, b) {
		return c.Rectangle.inflate(a, b.x, b.y)
	};
	c.Rectangle.size = function(a, b) {
		"undefined" === typeof b && (b = new c.Point);
		return b.setTo(a.width, a.height)
	};
	c.Rectangle.clone = function(a, b) {
		"undefined" === typeof b && (b = new c.Rectangle);
		return b.setTo(a.x, a.y, a.width, a.height)
	};
	c.Rectangle.contains = function(a, b, d) {
		return b >= a.x && b <= a.right && d >= a.y && d <= a.bottom
	};
	c.Rectangle.containsRaw =
		function(a, b, d, c, e, f) {
			return e >= a && e <= a + d && f >= b && f <= b + c
	};
	c.Rectangle.containsPoint = function(a, b) {
		return c.Rectangle.contains(a, b.x, b.y)
	};
	c.Rectangle.containsRect = function(a, b) {
		return a.volume > b.volume ? !1 : a.x >= b.x && a.y >= b.y && a.right <= b.right && a.bottom <= b.bottom
	};
	c.Rectangle.equals = function(a, b) {
		return a.x == b.x && a.y == b.y && a.width == b.width && a.height == b.height
	};
	c.Rectangle.intersection = function(a, b, d) {
		d = d || new c.Rectangle;
		c.Rectangle.intersects(a, b) && (d.x = Math.max(a.x, b.x), d.y = Math.max(a.y, b.y), d.width =
			Math.min(a.right, b.right) - d.x, d.height = Math.min(a.bottom, b.bottom) - d.y);
		return d
	};
	c.Rectangle.intersects = function(a, b) {
		return a.x < b.right && b.x < a.right && a.y < b.bottom && b.y < a.bottom
	};
	c.Rectangle.intersectsRaw = function(a, b, d, c, e, f) {
		"undefined" === typeof f && (f = 0);
		return !(b > a.right + f || d < a.left - f || c > a.bottom + f || e < a.top - f)
	};
	c.Rectangle.union = function(a, b, d) {
		"undefined" === typeof d && (d = new c.Rectangle);
		return d.setTo(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.max(a.right, b.right) - Math.min(a.left, b.left), Math.max(a.bottom,
			b.bottom) - Math.min(a.top, b.top))
	};
	c.Polygon = function(a) {
		e.Polygon.call(this, a);
		this.type = c.POLYGON
	};
	c.Polygon.prototype = Object.create(e.Polygon.prototype);
	c.Polygon.prototype.constructor = c.Polygon;
	c.Net = function(a) {
		this.game = a
	};
	c.Net.prototype = {
		getHostName: function() {
			return window.location && window.location.hostname ? window.location.hostname : null
		},
		checkDomainName: function(a) {
			return -1 !== window.location.hostname.indexOf(a)
		},
		updateQueryString: function(a, b, d, c) {
			"undefined" === typeof d && (d = !1);
			if ("undefined" ===
				typeof c || "" === c) c = window.location.href;
			var e = "",
				e = RegExp("([?|&])" + a + "=.*?(&|#|$)(.*)", "gi");
			if (e.test(c)) e = "undefined" !== typeof b && null !== b ? c.replace(e, "$1" + a + "=" + b + "$2$3") : c.replace(e, "$1$3").replace(/(&|\?)$/, "");
			else {
				if ("undefined" !== typeof b && null !== b) {
					var e = -1 !== c.indexOf("?") ? "&" : "?",
						f = c.split("#");
					c = f[0] + e + a + "=" + b;
					f[1] && (c += "#" + f[1])
				}
				e = c
			} if (d) window.location.href = e;
			else return e
		},
		getQueryString: function(a) {
			"undefined" === typeof a && (a = "");
			var b = {},
				d = location.search.substring(1).split("&"),
				c;
			for (c in d) {
				var e = d[c].split("=");
				if (1 < e.length) {
					if (a && a == this.decodeURI(e[0])) return this.decodeURI(e[1]);
					b[this.decodeURI(e[0])] = this.decodeURI(e[1])
				}
			}
			return b
		},
		decodeURI: function(a) {
			return decodeURIComponent(a.replace(/\+/g, " "))
		}
	};
	c.TweenManager = function(a) {
		this.game = a;
		this._tweens = [];
		this._add = [];
		this.game.onPause.add(this.pauseAll, this);
		this.game.onResume.add(this.resumeAll, this)
	};
	c.TweenManager.prototype = {
		REVISION: "11dev",
		getAll: function() {
			return this._tweens
		},
		removeAll: function() {
			this._tweens =
				[]
		},
		add: function(a) {
			this._add.push(a)
		},
		create: function(a) {
			return new c.Tween(a, this.game)
		},
		remove: function(a) {
			a = this._tweens.indexOf(a); - 1 !== a && (this._tweens[a].pendingDelete = !0)
		},
		update: function() {
			if (0 === this._tweens.length && 0 === this._add.length) return !1;
			for (var a = 0, b = this._tweens.length; a < b;) this._tweens[a].update(this.game.time.now) ? a++ : (this._tweens.splice(a, 1), b--);
			0 < this._add.length && (this._tweens = this._tweens.concat(this._add), this._add.length = 0);
			return !0
		},
		isTweening: function(a) {
			return this._tweens.some(function(b) {
				return b._object ===
					a
			})
		},
		pauseAll: function() {
			for (var a = this._tweens.length - 1; 0 <= a; a--) this._tweens[a].pause()
		},
		resumeAll: function() {
			for (var a = this._tweens.length - 1; 0 <= a; a--) this._tweens[a].resume()
		}
	};
	c.Tween = function(a, b) {
		this._object = a;
		this.game = b;
		this._manager = this.game.tweens;
		this._valuesStart = {};
		this._valuesEnd = {};
		this._valuesStartRepeat = {};
		this._duration = 1E3;
		this._repeat = 0;
		this._reversed = this._yoyo = !1;
		this._delayTime = 0;
		this._startTime = null;
		this._easingFunction = c.Easing.Linear.None;
		this._interpolationFunction = c.Math.linearInterpolation;
		this._chainedTweens = [];
		this._onStartCallback = null;
		this._onStartCallbackFired = !1;
		this._onCompleteCallback = this._onUpdateCallback = null;
		this._pausedTime = 0;
		this.pendingDelete = !1;
		for (var d in a) this._valuesStart[d] = parseFloat(a[d], 10);
		this.onStart = new c.Signal;
		this.onComplete = new c.Signal;
		this.isRunning = !1
	};
	c.Tween.prototype = {
		to: function(a, b, d, c, e, f, k) {
			b = b || 1E3;
			d = d || null;
			c = c || !1;
			e = e || 0;
			f = f || 0;
			k = k || !1;
			var m;
			this._parent ? (m = this._manager.create(this._object), this._lastChild.chain(m), this._lastChild = m) : (m =
				this, this._parent = this, this._lastChild = this);
			m._repeat = f;
			m._duration = b;
			m._valuesEnd = a;
			null !== d && (m._easingFunction = d);
			0 < e && (m._delayTime = e);
			m._yoyo = k;
			return c ? this.start() : this
		},
		start: function() {
			if (null !== this.game && null !== this._object) {
				this._manager.add(this);
				this.onStart.dispatch(this._object);
				this.isRunning = !0;
				this._onStartCallbackFired = !1;
				this._startTime = this.game.time.now + this._delayTime;
				for (var a in this._valuesEnd) {
					if (this._valuesEnd[a] instanceof Array) {
						if (0 === this._valuesEnd[a].length) continue;
						this._valuesEnd[a] = [this._object[a]].concat(this._valuesEnd[a])
					}
					this._valuesStart[a] = this._object[a];
					!1 === this._valuesStart[a] instanceof Array && (this._valuesStart[a] *= 1);
					this._valuesStartRepeat[a] = this._valuesStart[a] || 0
				}
				return this
			}
		},
		stop: function() {
			this.isRunning = !1;
			this._manager.remove(this);
			return this
		},
		delay: function(a) {
			this._delayTime = a;
			return this
		},
		repeat: function(a) {
			this._repeat = a;
			return this
		},
		yoyo: function(a) {
			this._yoyo = a;
			return this
		},
		easing: function(a) {
			this._easingFunction = a;
			return this
		},
		interpolation: function(a) {
			this._interpolationFunction = a;
			return this
		},
		chain: function() {
			this._chainedTweens = arguments;
			return this
		},
		loop: function() {
			this._lastChild.chain(this);
			return this
		},
		onStartCallback: function(a) {
			this._onStartCallback = a;
			return this
		},
		onUpdateCallback: function(a) {
			this._onUpdateCallback = a;
			return this
		},
		onCompleteCallback: function(a) {
			this._onCompleteCallback = a;
			return this
		},
		pause: function() {
			this._paused = !0;
			this._pausedTime = this.game.time.now
		},
		resume: function() {
			this._paused = !1;
			this._startTime +=
				this.game.time.now - this._pausedTime
		},
		update: function(a) {
			if (this.pendingDelete) return !1;
			if (this._paused || a < this._startTime) return !0;
			var b;
			if (a < this._startTime) return !0;
			!1 === this._onStartCallbackFired && (null !== this._onStartCallback && this._onStartCallback.call(this._object), this._onStartCallbackFired = !0);
			var d = (a - this._startTime) / this._duration,
				d = 1 < d ? 1 : d,
				c = this._easingFunction(d);
			for (b in this._valuesEnd) {
				var e = this._valuesStart[b] || 0,
					f = this._valuesEnd[b];
				f instanceof Array ? this._object[b] = this._interpolationFunction(f,
					c) : ("string" === typeof f && (f = e + parseFloat(f, 10)), "number" === typeof f && (this._object[b] = e + (f - e) * c))
			}
			null !== this._onUpdateCallback && this._onUpdateCallback.call(this._object, c);
			if (1 == d)
				if (0 < this._repeat) {
					isFinite(this._repeat) && this._repeat--;
					for (b in this._valuesStartRepeat) "string" === typeof this._valuesEnd[b] && (this._valuesStartRepeat[b] += parseFloat(this._valuesEnd[b], 10)), this._yoyo && (d = this._valuesStartRepeat[b], this._valuesStartRepeat[b] = this._valuesEnd[b], this._valuesEnd[b] = d, this._reversed = !this._reversed),
						this._valuesStart[b] = this._valuesStartRepeat[b];
					this._startTime = a + this._delayTime;
					this.onComplete.dispatch(this._object);
					null !== this._onCompleteCallback && this._onCompleteCallback.call(this._object)
				} else {
					this.isRunning = !1;
					this.onComplete.dispatch(this._object);
					null !== this._onCompleteCallback && this._onCompleteCallback.call(this._object);
					b = 0;
					for (d = this._chainedTweens.length; b < d; b++) this._chainedTweens[b].start(a);
					return !1
				}
			return !0
		}
	};
	c.Easing = {
		Linear: {
			None: function(a) {
				return a
			}
		},
		Quadratic: {
			In: function(a) {
				return a *
					a
			},
			Out: function(a) {
				return a * (2 - a)
			},
			InOut: function(a) {
				return 1 > (a *= 2) ? 0.5 * a * a : -0.5 * (--a * (a - 2) - 1)
			}
		},
		Cubic: {
			In: function(a) {
				return a * a * a
			},
			Out: function(a) {
				return --a * a * a + 1
			},
			InOut: function(a) {
				return 1 > (a *= 2) ? 0.5 * a * a * a : 0.5 * ((a -= 2) * a * a + 2)
			}
		},
		Quartic: {
			In: function(a) {
				return a * a * a * a
			},
			Out: function(a) {
				return 1 - --a * a * a * a
			},
			InOut: function(a) {
				return 1 > (a *= 2) ? 0.5 * a * a * a * a : -0.5 * ((a -= 2) * a * a * a - 2)
			}
		},
		Quintic: {
			In: function(a) {
				return a * a * a * a * a
			},
			Out: function(a) {
				return --a * a * a * a * a + 1
			},
			InOut: function(a) {
				return 1 > (a *= 2) ? 0.5 * a * a * a *
					a * a : 0.5 * ((a -= 2) * a * a * a * a + 2)
			}
		},
		Sinusoidal: {
			In: function(a) {
				return 1 - Math.cos(a * Math.PI / 2)
			},
			Out: function(a) {
				return Math.sin(a * Math.PI / 2)
			},
			InOut: function(a) {
				return 0.5 * (1 - Math.cos(Math.PI * a))
			}
		},
		Exponential: {
			In: function(a) {
				return 0 === a ? 0 : Math.pow(1024, a - 1)
			},
			Out: function(a) {
				return 1 === a ? 1 : 1 - Math.pow(2, -10 * a)
			},
			InOut: function(a) {
				return 0 === a ? 0 : 1 === a ? 1 : 1 > (a *= 2) ? 0.5 * Math.pow(1024, a - 1) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2)
			}
		},
		Circular: {
			In: function(a) {
				return 1 - Math.sqrt(1 - a * a)
			},
			Out: function(a) {
				return Math.sqrt(1 - --a *
					a)
			},
			InOut: function(a) {
				return 1 > (a *= 2) ? -0.5 * (Math.sqrt(1 - a * a) - 1) : 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1)
			}
		},
		Elastic: {
			In: function(a) {
				var b, d = 0.1;
				if (0 === a) return 0;
				if (1 === a) return 1;
				!d || 1 > d ? (d = 1, b = 0.1) : b = 0.4 * Math.asin(1 / d) / (2 * Math.PI);
				return -(d * Math.pow(2, 10 * (a -= 1)) * Math.sin(2 * (a - b) * Math.PI / 0.4))
			},
			Out: function(a) {
				var b, d = 0.1;
				if (0 === a) return 0;
				if (1 === a) return 1;
				!d || 1 > d ? (d = 1, b = 0.1) : b = 0.4 * Math.asin(1 / d) / (2 * Math.PI);
				return d * Math.pow(2, -10 * a) * Math.sin(2 * (a - b) * Math.PI / 0.4) + 1
			},
			InOut: function(a) {
				var b, d = 0.1;
				if (0 === a) return 0;
				if (1 === a) return 1;
				!d || 1 > d ? (d = 1, b = 0.1) : b = 0.4 * Math.asin(1 / d) / (2 * Math.PI);
				return 1 > (a *= 2) ? -0.5 * d * Math.pow(2, 10 * (a -= 1)) * Math.sin(2 * (a - b) * Math.PI / 0.4) : d * Math.pow(2, -10 * (a -= 1)) * Math.sin(2 * (a - b) * Math.PI / 0.4) * 0.5 + 1
			}
		},
		Back: {
			In: function(a) {
				return a * a * (2.70158 * a - 1.70158)
			},
			Out: function(a) {
				return --a * a * (2.70158 * a + 1.70158) + 1
			},
			InOut: function(a) {
				return 1 > (a *= 2) ? 0.5 * a * a * (3.5949095 * a - 2.5949095) : 0.5 * ((a -= 2) * a * (3.5949095 * a + 2.5949095) + 2)
			}
		},
		Bounce: {
			In: function(a) {
				return 1 - c.Easing.Bounce.Out(1 - a)
			},
			Out: function(a) {
				return a <
					1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375
			},
			InOut: function(a) {
				return 0.5 > a ? 0.5 * c.Easing.Bounce.In(2 * a) : 0.5 * c.Easing.Bounce.Out(2 * a - 1) + 0.5
			}
		}
	};
	c.Time = function(a) {
		this.game = a;
		this.fps = this.elapsed = this.now = this.pausedTime = this.time = this.physicsElapsed = this._pauseStarted = this._timeLastSecond = this._started = 0;
		this.fpsMin = 1E3;
		this.fpsMax = 0;
		this.msMin = 1E3;
		this.lastTime = this.timeToCall = this.pauseDuration = this.frames = this.msMax =
			0;
		this.game.onPause.add(this.gamePaused, this);
		this.game.onResume.add(this.gameResumed, this);
		this._justResumed = !1
	};
	c.Time.prototype = {
		update: function(a) {
			this.now = a;
			this._justResumed && (this.time = this.now, this._justResumed = !1);
			this.timeToCall = this.game.math.max(0, 16 - (a - this.lastTime));
			this.elapsed = this.now - this.time;
			this.msMin = this.game.math.min(this.msMin, this.elapsed);
			this.msMax = this.game.math.max(this.msMax, this.elapsed);
			this.frames++;
			this.now > this._timeLastSecond + 1E3 && (this.fps = Math.round(1E3 * this.frames /
				(this.now - this._timeLastSecond)), this.fpsMin = this.game.math.min(this.fpsMin, this.fps), this.fpsMax = this.game.math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0);
			this.time = this.now;
			this.lastTime = a + this.timeToCall;
			this.physicsElapsed = this.elapsed / 1E3 * 1;
			1 < this.physicsElapsed && (this.physicsElapsed = 1);
			this.game.paused && (this.pausedTime = this.now - this._pauseStarted)
		},
		gamePaused: function() {
			this._pauseStarted = this.now
		},
		gameResumed: function() {
			this.time = Date.now();
			this.pauseDuration = this.pausedTime;
			this._justResumed = !0
		},
		totalElapsedSeconds: function() {
			return 0.001 * (this.now - this._started)
		},
		elapsedSince: function(a) {
			return this.now - a
		},
		elapsedSecondsSince: function(a) {
			return 0.001 * (this.now - a)
		},
		reset: function() {
			this._started = this.now
		}
	};
	c.Timer = function(a) {
		this.game = a;
		this._timeLastSecond = this._started = 0;
		this.running = !1;
		this.events = [];
		this.onEvent = new c.Signal
	};
	c.Timer.prototype = {
		add: function(a) {
			this.events.push({
				delay: a,
				dispatched: !1,
				args: Array.prototype.splice.call(arguments, 1)
			})
		},
		start: function() {
			this._started =
				this.game.time.now;
			this.running = !0
		},
		stop: function() {
			this.running = !1;
			this.events.length = 0
		},
		update: function() {
			if (this.running)
				for (var a = this.seconds(), b = 0, d = this.events.length; b < d; b++)!1 === this.events[b].dispatched && a >= this.events[b].delay && (this.events[b].dispatched = !0, this.onEvent.dispatch.apply(this, this.events[b].args))
		},
		seconds: function() {
			return 0.001 * (this.game.time.now - this._started)
		}
	};
	c.AnimationManager = function(a) {
		this.sprite = a;
		this.game = a.game;
		this.currentFrame = null;
		this.updateIfVisible = !0;
		this.isLoaded = !1;
		this._frameData = null;
		this._anims = {};
		this._outputFrames = []
	};
	c.AnimationManager.prototype = {
		loadFrameData: function(a) {
			this._frameData = a;
			this.frame = 0;
			this.isLoaded = !0
		},
		add: function(a, b, d, f, h) {
			if (null == this._frameData) console.warn("No FrameData available for Phaser.Animation " + a);
			else return d = d || 60, "undefined" === typeof f && (f = !1), "undefined" === typeof h && (h = b && "number" === typeof b[0] ? !0 : !1), null == this.sprite.events.onAnimationStart && (this.sprite.events.onAnimationStart = new c.Signal, this.sprite.events.onAnimationComplete =
				new c.Signal, this.sprite.events.onAnimationLoop = new c.Signal), this._outputFrames.length = 0, this._frameData.getFrameIndexes(b, h, this._outputFrames), this._anims[a] = new c.Animation(this.game, this.sprite, a, this._frameData, this._outputFrames, d, f), this.currentAnim = this._anims[a], this.currentFrame = this.currentAnim.currentFrame, this.sprite.setTexture(e.TextureCache[this.currentFrame.uuid]), this._anims[a]
		},
		validateFrames: function(a, b) {
			"undefined" == typeof b && (b = !0);
			for (var d = 0; d < a.length; d++)
				if (!0 === b) {
					if (a[d] >
						this._frameData.total) return !1
				} else if (!1 === this._frameData.checkFrameName(a[d])) return !1;
			return !0
		},
		play: function(a, b, d, c) {
			if (this._anims[a])
				if (this.currentAnim == this._anims[a]) {
					if (!1 === this.currentAnim.isPlaying) return this.currentAnim.paused = !1, this.currentAnim.play(b, d, c)
				} else return this.currentAnim = this._anims[a], this.currentAnim.paused = !1, this.currentAnim.play(b, d, c)
		},
		stop: function(a, b) {
			"undefined" == typeof b && (b = !1);
			"string" == typeof a ? this._anims[a] && (this.currentAnim = this._anims[a], this.currentAnim.stop(b)) :
				this.currentAnim && this.currentAnim.stop(b)
		},
		update: function() {
			return this.updateIfVisible && !1 === this.sprite.visible ? !1 : this.currentAnim && !0 === this.currentAnim.update() ? (this.currentFrame = this.currentAnim.currentFrame, this.sprite.currentFrame = this.currentFrame, !0) : !1
		},
		getAnimation: function(a) {
			return "string" == typeof a && this._anims[a] ? this._anims[a] : !1
		},
		refreshFrame: function() {
			this.sprite.currentFrame = this.currentFrame;
			this.sprite.setTexture(e.TextureCache[this.currentFrame.uuid])
		},
		destroy: function() {
			this._anims = {};
			this._frameData = null;
			this._frameIndex = 0;
			this.currentFrame = this.currentAnim = null
		}
	};
	Object.defineProperty(c.AnimationManager.prototype, "frameData", {
		get: function() {
			return this._frameData
		}
	});
	Object.defineProperty(c.AnimationManager.prototype, "frameTotal", {
		get: function() {
			return this._frameData ? this._frameData.total : -1
		}
	});
	Object.defineProperty(c.AnimationManager.prototype, "paused", {
		get: function() {
			return this.currentAnim.isPaused
		},
		set: function(a) {
			this.currentAnim.paused = a
		}
	});
	Object.defineProperty(c.AnimationManager.prototype,
		"frame", {
			get: function() {
				if (this.currentFrame) return this._frameIndex
			},
			set: function(a) {
				"number" === typeof a && this._frameData && null !== this._frameData.getFrame(a) && (this.currentFrame = this._frameData.getFrame(a), this._frameIndex = a, this.sprite.currentFrame = this.currentFrame, this.sprite.setTexture(e.TextureCache[this.currentFrame.uuid]))
			}
		});
	Object.defineProperty(c.AnimationManager.prototype, "frameName", {
		get: function() {
			if (this.currentFrame) return this.currentFrame.name
		},
		set: function(a) {
			"string" === typeof a &&
				this._frameData && null !== this._frameData.getFrameByName(a) ? (this.currentFrame = this._frameData.getFrameByName(a), this._frameIndex = this.currentFrame.index, this.sprite.currentFrame = this.currentFrame, this.sprite.setTexture(e.TextureCache[this.currentFrame.uuid])) : console.warn("Cannot set frameName: " + a)
		}
	});
	c.Animation = function(a, b, d, c, e, f, k) {
		this.game = a;
		this._parent = b;
		this._frameData = c;
		this.name = d;
		this._frames = [];
		this._frames = this._frames.concat(e);
		this.delay = 1E3 / f;
		this.looped = k;
		this.isPaused = this.isPlaying =
			this.isFinished = this.killOnComplete = !1;
		this._frameDiff = this._frameIndex = this._pauseStartTime = 0;
		this._frameSkip = 1;
		this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex])
	};
	c.Animation.prototype = {
		play: function(a, b, d) {
			"number" === typeof a && (this.delay = 1E3 / a);
			"boolean" === typeof b && (this.looped = b);
			"undefined" !== typeof d && (this.killOnComplete = d);
			this.isPlaying = !0;
			this.paused = this.isFinished = !1;
			this._timeLastFrame = this.game.time.now;
			this._timeNextFrame = this.game.time.now + this.delay;
			this._frameIndex =
				0;
			this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
			this._parent.setTexture(e.TextureCache[this.currentFrame.uuid]);
			this._parent.events && this._parent.events.onAnimationStart.dispatch(this._parent, this);
			return this
		},
		restart: function() {
			this.isPlaying = !0;
			this.paused = this.isFinished = !1;
			this._timeLastFrame = this.game.time.now;
			this._timeNextFrame = this.game.time.now + this.delay;
			this._frameIndex = 0;
			this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex])
		},
		stop: function(a) {
			"undefined" ===
				typeof a && (a = !1);
			this.isPlaying = !1;
			this.isFinished = !0;
			this.paused = !1;
			a && (this.currentFrame = this._frameData.getFrame(this._frames[0]))
		},
		update: function() {
			if (this.isPaused) return !1;
			if (!0 === this.isPlaying && this.game.time.now >= this._timeNextFrame) {
				this._frameSkip = 1;
				this._frameDiff = this.game.time.now - this._timeNextFrame;
				this._timeLastFrame = this.game.time.now;
				this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay);
				this._timeNextFrame =
					this.game.time.now + (this.delay - this._frameDiff);
				this._frameIndex += this._frameSkip;
				if (this._frameIndex >= this._frames.length)
					if (this.looped) this._frameIndex %= this._frames.length, (this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex])) && this._parent.setTexture(e.TextureCache[this.currentFrame.uuid]), this._parent.events.onAnimationLoop.dispatch(this._parent, this);
					else this.onComplete();
				else(this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex])) && this._parent.setTexture(e.TextureCache[this.currentFrame.uuid]);
				return !0
			}
			return !1
		},
		destroy: function() {
			this.currentFrame = this._frameData = this._frames = this._parent = this.game = null;
			this.isPlaying = !1
		},
		onComplete: function() {
			this.isPlaying = !1;
			this.isFinished = !0;
			this.paused = !1;
			this._parent.events && this._parent.events.onAnimationComplete.dispatch(this._parent, this);
			this.killOnComplete && this._parent.kill()
		}
	};
	Object.defineProperty(c.Animation.prototype, "paused", {
		get: function() {
			return this.isPaused
		},
		set: function(a) {
			(this.isPaused = a) ? this._pauseStartTime = this.game.time.now :
				this.isPlaying && (this._timeNextFrame = this.game.time.now + this.delay)
		}
	});
	Object.defineProperty(c.Animation.prototype, "frameTotal", {
		get: function() {
			return this._frames.length
		}
	});
	Object.defineProperty(c.Animation.prototype, "frame", {
		get: function() {
			return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex
		},
		set: function(a) {
			this.currentFrame = this._frameData.getFrame(a);
			null !== this.currentFrame && (this._frameIndex = a, this._parent.setTexture(e.TextureCache[this.currentFrame.uuid]))
		}
	});
	c.Animation.generateFrameNames =
		function(a, b, d, e, f) {
			"undefined" == typeof e && (e = "");
			var g = [],
				k = "";
			if (b < d)
				for (; b <= d; b++) k = "number" == typeof f ? c.Utils.pad(b.toString(), f, "0", 1) : b.toString(), k = a + k + e, g.push(k);
			else
				for (; b >= d; b--) k = "number" == typeof f ? c.Utils.pad(b.toString(), f, "0", 1) : b.toString(), k = a + k + e, g.push(k);
			return g
	};
	c.Frame = function(a, b, d, e, f, g, k) {
		this.index = a;
		this.x = b;
		this.y = d;
		this.width = e;
		this.height = f;
		this.name = g;
		this.uuid = k;
		this.centerX = Math.floor(e / 2);
		this.centerY = Math.floor(f / 2);
		this.distance = c.Math.distance(0, 0, e, f);
		this.rotated = !1;
		this.rotationDirection = "cw";
		this.trimmed = !1;
		this.sourceSizeW = e;
		this.sourceSizeH = f;
		this.spriteSourceSizeH = this.spriteSourceSizeW = this.spriteSourceSizeY = this.spriteSourceSizeX = 0
	};
	c.Frame.prototype = {
		setTrim: function(a, b, d, c, e, f, k) {
			if (this.trimmed = a) this.width = b, this.height = d, this.sourceSizeW = b, this.sourceSizeH = d, this.centerX = Math.floor(b / 2), this.centerY = Math.floor(d / 2), this.spriteSourceSizeX = c, this.spriteSourceSizeY = e, this.spriteSourceSizeW = f, this.spriteSourceSizeH = k
		}
	};
	c.FrameData = function() {
		this._frames =
			[];
		this._frameNames = []
	};
	c.FrameData.prototype = {
		addFrame: function(a) {
			a.index = this._frames.length;
			this._frames.push(a);
			"" !== a.name && (this._frameNames[a.name] = a.index);
			return a
		},
		getFrame: function(a) {
			return this._frames.length > a ? this._frames[a] : null
		},
		getFrameByName: function(a) {
			return "number" === typeof this._frameNames[a] ? this._frames[this._frameNames[a]] : null
		},
		checkFrameName: function(a) {
			return null == this._frameNames[a] ? !1 : !0
		},
		getFrameRange: function(a, b, d) {
			for ("undefined" === typeof d && (d = []); a <= b; a++) d.push(this._frames[a]);
			return d
		},
		getFrames: function(a, b, d) {
			"undefined" === typeof b && (b = !0);
			"undefined" === typeof d && (d = []);
			if ("undefined" === typeof a || 0 === a.length)
				for (var c = 0; c < this._frames.length; c++) d.push(this._frames[c]);
			else
				for (var c = 0, e = a.length; c < e; c++) b ? d.push(this.getFrame(a[c])) : d.push(this.getFrameByName(a[c]));
			return d
		},
		getFrameIndexes: function(a, b, d) {
			"undefined" === typeof b && (b = !0);
			"undefined" === typeof d && (d = []);
			if ("undefined" === typeof a || 0 === a.length)
				for (var c = 0, e = this._frames.length; c < e; c++) d.push(this._frames[c].index);
			else
				for (c = 0, e = a.length; c < e; c++) b ? d.push(a[c]) : this.getFrameByName(a[c]) && d.push(this.getFrameByName(a[c]).index);
			return d
		}
	};
	Object.defineProperty(c.FrameData.prototype, "total", {
		get: function() {
			return this._frames.length
		}
	});
	c.AnimationParser = {
		spriteSheet: function(a, b, d, f, h) {
			var g = a.cache.getImage(b);
			if (null == g) return null;
			var k = g.width,
				m = g.height;
			0 >= d && (d = Math.floor(-k / Math.min(-1, d)));
			0 >= f && (f = Math.floor(-m / Math.min(-1, f)));
			var g = Math.round(k / d),
				l = Math.round(m / f),
				g = g * l; - 1 !== h && (g = h);
			if (0 === k || 0 ===
				m || k < d || m < f || 0 === g) return console.warn("Phaser.AnimationParser.spriteSheet: width/height zero or width/height < given frameWidth/frameHeight"), null;
			h = new c.FrameData;
			for (var n = l = m = 0; n < g; n++) {
				var q = a.rnd.uuid();
				h.addFrame(new c.Frame(n, m, l, d, f, "", q));
				e.TextureCache[q] = new e.Texture(e.BaseTextureCache[b], {
					x: m,
					y: l,
					width: d,
					height: f
				});
				m += d;
				m === k && (m = 0, l += f)
			}
			return h
		},
		JSONData: function(a, b, d) {
			if (b.frames) {
				var f = new c.FrameData;
				b = b.frames;
				for (var h, g = 0; g < b.length; g++) {
					var k = a.rnd.uuid();
					h = f.addFrame(new c.Frame(g,
						b[g].frame.x, b[g].frame.y, b[g].frame.w, b[g].frame.h, b[g].filename, k));
					e.TextureCache[k] = new e.Texture(e.BaseTextureCache[d], {
						x: b[g].frame.x,
						y: b[g].frame.y,
						width: b[g].frame.w,
						height: b[g].frame.h
					});
					b[g].trimmed && (h.setTrim(b[g].trimmed, b[g].sourceSize.w, b[g].sourceSize.h, b[g].spriteSourceSize.x, b[g].spriteSourceSize.y, b[g].spriteSourceSize.w, b[g].spriteSourceSize.h), e.TextureCache[k].trimmed = !0, e.TextureCache[k].trim.x = b[g].spriteSourceSize.x, e.TextureCache[k].trim.y = b[g].spriteSourceSize.y)
				}
				return f
			}
			console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array");
			console.log(b)
		},
		JSONDataHash: function(a, b, d) {
			if (b.frames) {
				var f = new c.FrameData;
				b = b.frames;
				var h, g = 0,
					k;
				for (k in b) {
					var m = a.rnd.uuid();
					h = f.addFrame(new c.Frame(g, b[k].frame.x, b[k].frame.y, b[k].frame.w, b[k].frame.h, k, m));
					e.TextureCache[m] = new e.Texture(e.BaseTextureCache[d], {
						x: b[k].frame.x,
						y: b[k].frame.y,
						width: b[k].frame.w,
						height: b[k].frame.h
					});
					b[k].trimmed && (h.setTrim(b[k].trimmed, b[k].sourceSize.w, b[k].sourceSize.h, b[k].spriteSourceSize.x, b[k].spriteSourceSize.y, b[k].spriteSourceSize.w, b[k].spriteSourceSize.h),
						e.TextureCache[m].trimmed = !0, e.TextureCache[m].trim.x = b[k].spriteSourceSize.x, e.TextureCache[m].trim.y = b[k].spriteSourceSize.y);
					g++
				}
				return f
			}
			console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object");
			console.log(b)
		},
		XMLData: function(a, b, d) {
			if (b.getElementsByTagName("TextureAtlas")) {
				var f = new c.FrameData;
				b = b.getElementsByTagName("SubTexture");
				for (var h, g, k, m, l, n, q, t, p, v, w, z = 0; z < b.length; z++)
					if (g = a.rnd.uuid(), k = b[z].attributes, h = k.name.nodeValue, m =
						parseInt(k.x.nodeValue, 10), l = parseInt(k.y.nodeValue, 10), n = parseInt(k.width.nodeValue, 10), q = parseInt(k.height.nodeValue, 10), p = t = null, k.frameX && (t = Math.abs(parseInt(k.frameX.nodeValue, 10)), p = Math.abs(parseInt(k.frameY.nodeValue, 10)), v = parseInt(k.frameWidth.nodeValue, 10), w = parseInt(k.frameHeight.nodeValue, 10)), h = f.addFrame(new c.Frame(z, m, l, n, q, h, g)), e.TextureCache[g] = new e.Texture(e.BaseTextureCache[d], {
							x: m,
							y: l,
							width: n,
							height: q
						}), null !== t || null !== p) h.setTrim(!0, n, q, t, p, v, w), e.TextureCache[g].realSize = {
						x: t,
						y: p,
						w: v,
						h: w
					}, e.TextureCache[g].trimmed = !0, e.TextureCache[g].trim.x = t, e.TextureCache[g].trim.y = p;
				return f
			}
			console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag")
		}
	};
	c.Cache = function(a) {
		this.game = a;
		this._canvases = {};
		this._images = {};
		this._textures = {};
		this._sounds = {};
		this._text = {};
		this._tilemaps = {};
		this._tilesets = {};
		this._bitmapDatas = {};
		this.addDefaultImage();
		this.addMissingImage();
		this.onSoundUnlock = new c.Signal
	};
	c.Cache.prototype = {
		addCanvas: function(a,
			b, d) {
			this._canvases[a] = {
				canvas: b,
				context: d
			}
		},
		addBitmapData: function(a, b) {
			return this._bitmapDatas[a] = b
		},
		addRenderTexture: function(a, b) {
			var d = new c.Frame(0, 0, 0, b.width, b.height, "", "");
			this._textures[a] = {
				texture: b,
				frame: d
			}
		},
		addSpriteSheet: function(a, b, d, f, h, g) {
			this._images[a] = {
				url: b,
				data: d,
				spriteSheet: !0,
				frameWidth: f,
				frameHeight: h
			};
			e.BaseTextureCache[a] = new e.BaseTexture(d);
			e.TextureCache[a] = new e.Texture(e.BaseTextureCache[a]);
			this._images[a].frameData = c.AnimationParser.spriteSheet(this.game, a, f, h,
				g)
		},
		addTileset: function(a, b, d, f, h, g, k, l) {
			this._tilesets[a] = {
				url: b,
				data: d,
				tileWidth: f,
				tileHeight: h,
				tileMargin: k,
				tileSpacing: l
			};
			e.BaseTextureCache[a] = new e.BaseTexture(d);
			e.TextureCache[a] = new e.Texture(e.BaseTextureCache[a]);
			this._tilesets[a].tileData = c.TilemapParser.tileset(this.game, a, f, h, g, k, l)
		},
		addTilemap: function(a, b, d, e) {
			this._tilemaps[a] = {
				url: b,
				data: d,
				format: e
			};
			this._tilemaps[a].layers = c.TilemapParser.parse(this.game, d, e)
		},
		addTextureAtlas: function(a, b, d, f, h) {
			this._images[a] = {
				url: b,
				data: d,
				spriteSheet: !0
			};
			e.BaseTextureCache[a] = new e.BaseTexture(d);
			e.TextureCache[a] = new e.Texture(e.BaseTextureCache[a]);
			h == c.Loader.TEXTURE_ATLAS_JSON_ARRAY ? this._images[a].frameData = c.AnimationParser.JSONData(this.game, f, a) : h == c.Loader.TEXTURE_ATLAS_JSON_HASH ? this._images[a].frameData = c.AnimationParser.JSONDataHash(this.game, f, a) : h == c.Loader.TEXTURE_ATLAS_XML_STARLING && (this._images[a].frameData = c.AnimationParser.XMLData(this.game, f, a))
		},
		addBitmapFont: function(a, b, d, f) {
			this._images[a] = {
				url: b,
				data: d,
				spriteSheet: !0
			};
			e.BaseTextureCache[a] =
				new e.BaseTexture(d);
			e.TextureCache[a] = new e.Texture(e.BaseTextureCache[a]);
			c.LoaderParser.bitmapFont(this.game, f, a)
		},
		addDefaultImage: function() {
			var a = new Image;
			a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
			this._images.__default = {
				url: null,
				data: a,
				spriteSheet: !1
			};
			this._images.__default.frame = new c.Frame(0, 0, 0, 32, 32, "", "");
			e.BaseTextureCache.__default = new e.BaseTexture(a);
			e.TextureCache.__default = new e.Texture(e.BaseTextureCache.__default)
		},
		addMissingImage: function() {
			var a = new Image;
			//a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
			this._images.__missing = {
				url: null,
				data: a,
				spriteSheet: !1
			};
			this._images.__missing.frame = new c.Frame(0, 0, 0, 32, 32, "", "");
			e.BaseTextureCache.__missing = new e.BaseTexture(a);
			e.TextureCache.__missing = new e.Texture(e.BaseTextureCache.__missing)
		},
		addText: function(a, b, d) {
			this._text[a] = {
				url: b,
				data: d
			}
		},
		addImage: function(a, b, d) {
			this._images[a] = {
				url: b,
				data: d,
				spriteSheet: !1
			};
			this._images[a].frame = new c.Frame(0, 0, 0, d.width, d.height, a, this.game.rnd.uuid());
			e.BaseTextureCache[a] = new e.BaseTexture(d);
			e.TextureCache[a] = new e.Texture(e.BaseTextureCache[a])
		},
		addSound: function(a, b, d, c, e) {
			e = e || !1;
			var f = !1;
			e && (f = !0);
			this._sounds[a] = {
				url: b,
				data: d,
				isDecoding: !1,
				decoded: f,
				webAudio: c || !0,
				audioTag: e
			}
		},
		reloadSound: function(a) {
			var b = this;
			this._sounds[a] && (this._sounds[a].data.src = this._sounds[a].url, this._sounds[a].data.addEventListener("canplaythrough", function() {
				return b.reloadSoundComplete(a)
			}, !1), this._sounds[a].data.load())
		},
		reloadSoundComplete: function(a) {
			this._sounds[a] && (this._sounds[a].locked = !1, this.onSoundUnlock.dispatch(a))
		},
		updateSound: function(a,
			b, d) {
			this._sounds[a] && (this._sounds[a][b] = d)
		},
		decodedSound: function(a, b) {
			this._sounds[a].data = b;
			this._sounds[a].decoded = !0;
			this._sounds[a].isDecoding = !1
		},
		getCanvas: function(a) {
			return this._canvases[a] ? this._canvases[a].canvas : null
		},
		getBitmapData: function(a) {
			return this._bitmapDatas[a] ? this._bitmapDatas[a] : null
		},
		checkImageKey: function(a) {
			return this._images[a] ? !0 : !1
		},
		getImage: function(a) {
			return this._images[a] ? this._images[a].data : null
		},
		getTilesetImage: function(a) {
			return this._tilesets[a] ? this._tilesets[a].data :
				null
		},
		getTileset: function(a) {
			return this._tilesets[a] ? this._tilesets[a].tileData : null
		},
		getTilemapData: function(a) {
			return this._tilemaps[a] ? this._tilemaps[a] : null
		},
		getFrameData: function(a) {
			return this._images[a] && this._images[a].frameData ? this._images[a].frameData : null
		},
		getFrameByIndex: function(a, b) {
			return this._images[a] && this._images[a].frameData ? this._images[a].frameData.getFrame(b) : null
		},
		getFrameByName: function(a, b) {
			return this._images[a] && this._images[a].frameData ? this._images[a].frameData.getFrameByName(b) :
				null
		},
		getFrame: function(a) {
			return this._images[a] && !1 === this._images[a].spriteSheet ? this._images[a].frame : null
		},
		getTextureFrame: function(a) {
			return this._textures[a] ? this._textures[a].frame : null
		},
		getTexture: function(a) {
			return this._textures[a] ? this._textures[a] : null
		},
		getSound: function(a) {
			return this._sounds[a] ? this._sounds[a] : null
		},
		getSoundData: function(a) {
			return this._sounds[a] ? this._sounds[a].data : null
		},
		isSoundDecoded: function(a) {
			if (this._sounds[a]) return this._sounds[a].decoded
		},
		isSoundReady: function(a) {
			return this._sounds[a] &&
				this._sounds[a].decoded && !1 === this.game.sound.touchLocked
		},
		isSpriteSheet: function(a) {
			return this._images[a] ? this._images[a].spriteSheet : !1
		},
		getText: function(a) {
			return this._text[a] ? this._text[a].data : null
		},
		getKeys: function(a) {
			var b = [],
				d;
			for (d in a) "__default" !== d && b.push(d);
			return b
		},
		getImageKeys: function() {
			return this.getKeys(this._images)
		},
		getSoundKeys: function() {
			return this.getKeys(this._sounds)
		},
		getTextKeys: function() {
			return this.getKeys(this._text)
		},
		removeCanvas: function(a) {
			delete this._canvases[a]
		},
		removeImage: function(a) {
			delete this._images[a]
		},
		removeSound: function(a) {
			delete this._sounds[a]
		},
		removeText: function(a) {
			delete this._text[a]
		},
		destroy: function() {
			for (var a in this._canvases) delete this._canvases[a.key];
			for (a in this._images) delete this._images[a.key];
			for (a in this._sounds) delete this._sounds[a.key];
			for (a in this._text) delete this._text[a.key]
		}
	};
	c.Loader = function(a) {
		this.game = a;
		this._fileList = [];
		this._progressChunk = this._fileIndex = 0;
		this._xhr = new XMLHttpRequest;
		this.hasLoaded = this.isLoading = !1;
		this.progress = 0;
		this.preloadSprite = null;
		this.baseURL = this.crossOrigin = "";
		this.onFileComplete = new c.Signal;
		this.onFileError = new c.Signal;
		this.onLoadStart = new c.Signal;
		this.onLoadComplete = new c.Signal
	};
	c.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0;
	c.Loader.TEXTURE_ATLAS_JSON_HASH = 1;
	c.Loader.TEXTURE_ATLAS_XML_STARLING = 2;
	c.Loader.prototype = {
		setPreloadSprite: function(a, b) {
			b = b || 0;
			this.preloadSprite = {
				sprite: a,
				direction: b,
				width: a.width,
				height: a.height,
				crop: null
			};
			this.preloadSprite.crop = 0 === b ? new c.Rectangle(0, 0,
				1, a.height) : new c.Rectangle(0, 0, a.width, 1);
			a.crop = this.preloadSprite.crop;
			a.cropEnabled = !0
		},
		checkKeyExists: function(a, b) {
			if (0 < this._fileList.length)
				for (var d = 0; d < this._fileList.length; d++)
					if (this._fileList[d].type === a && this._fileList[d].key === b) return !0;
			return !1
		},
		getAsset: function(a, b) {
			if (0 < this._fileList.length)
				for (var d = 0; d < this._fileList.length; d++)
					if (this._fileList[d].type === a && this._fileList[d].key === b) return {
						index: d,
						file: this._fileList[d]
					};
			return !1
		},
		reset: function() {
			this.preloadSprite = null;
			this.isLoading = !1;
			this._fileIndex = this._fileList.length = 0
		},
		addToFileList: function(a, b, d, c) {
			d = {
				type: a,
				key: b,
				url: d,
				data: null,
				error: !1,
				loaded: !1
			};
			if ("undefined" !== typeof c)
				for (var e in c) d[e] = c[e];
			!1 === this.checkKeyExists(a, b) && this._fileList.push(d)
		},
		replaceInFileList: function(a, b, d, c) {
			d = {
				type: a,
				key: b,
				url: d,
				data: null,
				error: !1,
				loaded: !1
			};
			if ("undefined" !== typeof c)
				for (var e in c) d[e] = c[e];
			!1 === this.checkKeyExists(a, b) && this._fileList.push(d)
		},
		image: function(a, b, d) {
			"undefined" === typeof d && (d = !1);
			d ? this.replaceInFileList("image",
				a, b) : this.addToFileList("image", a, b);
			return this
		},
		text: function(a, b, d) {
			"undefined" === typeof d && (d = !1);
			d ? this.replaceInFileList("text", a, b) : this.addToFileList("text", a, b);
			return this
		},
		script: function(a, b) {
			this.addToFileList("script", a, b);
			return this
		},
		spritesheet: function(a, b, d, c, e) {
			"undefined" === typeof e && (e = -1);
			this.addToFileList("spritesheet", a, b, {
				frameWidth: d,
				frameHeight: c,
				frameMax: e
			});
			return this
		},
		tileset: function(a, b, d, c, e, f, k) {
			"undefined" === typeof e && (e = -1);
			"undefined" === typeof f && (f = 0);
			"undefined" ===
				typeof k && (k = 0);
			this.addToFileList("tileset", a, b, {
				tileWidth: d,
				tileHeight: c,
				tileMax: e,
				tileMargin: f,
				tileSpacing: k
			});
			return this
		},
		audio: function(a, b, d) {
			"undefined" === typeof d && (d = !0);
			this.addToFileList("audio", a, b, {
				buffer: null,
				autoDecode: d
			});
			return this
		},
		tilemap: function(a, b, d, e) {
			"undefined" === typeof b && (b = null);
			"undefined" === typeof d && (d = null);
			"undefined" === typeof e && (e = c.Tilemap.CSV);
			if (null == b && null == d) return console.warn("Phaser.Loader.tilemap - Both mapDataURL and mapData are null. One must be set."),
				this;
			if (d) {
				switch (e) {
					case c.Tilemap.TILED_JSON:
						"string" === typeof d && (d = JSON.parse(d))
				}
				this.game.cache.addTilemap(a, null, d, e)
			} else this.addToFileList("tilemap", a, b, {
				format: e
			});
			return this
		},
		bitmapFont: function(a, b, d, c) {
			"undefined" === typeof d && (d = null);
			"undefined" === typeof c && (c = null);
			if (d) this.addToFileList("bitmapfont", a, b, {
				xmlURL: d
			});
			else if ("string" === typeof c) {
				var e;
				try {
					window.DOMParser ? e = (new DOMParser).parseFromString(c, "text/xml") : (e = new ActiveXObject("Microsoft.XMLDOM"), e.async = "false", e.loadXML(c))
				} catch (f) {
					e =
						void 0
				}
				if (e && e.documentElement && !e.getElementsByTagName("parsererror").length) this.addToFileList("bitmapfont", a, b, {
					xmlURL: null,
					xmlData: e
				});
				else throw Error("Phaser.Loader. Invalid Bitmap Font XML given");
			}
			return this
		},
		atlasJSONArray: function(a, b, d, e) {
			return this.atlas(a, b, d, e, c.Loader.TEXTURE_ATLAS_JSON_ARRAY)
		},
		atlasJSONHash: function(a, b, d, e) {
			return this.atlas(a, b, d, e, c.Loader.TEXTURE_ATLAS_JSON_HASH)
		},
		atlasXML: function(a, b, d, e) {
			return this.atlas(a, b, d, e, c.Loader.TEXTURE_ATLAS_XML_STARLING)
		},
		atlas: function(a,
			b, d, e, f) {
			"undefined" === typeof d && (d = null);
			"undefined" === typeof e && (e = null);
			"undefined" === typeof f && (f = c.Loader.TEXTURE_ATLAS_JSON_ARRAY);
			if (d) this.addToFileList("textureatlas", a, b, {
				atlasURL: d,
				format: f
			});
			else {
				switch (f) {
					case c.Loader.TEXTURE_ATLAS_JSON_ARRAY:
						"string" === typeof e && (e = JSON.parse(e));
						break;
					case c.Loader.TEXTURE_ATLAS_XML_STARLING:
						if ("string" === typeof e) {
							var g;
							try {
								window.DOMParser ? g = (new DOMParser).parseFromString(e, "text/xml") : (g = new ActiveXObject("Microsoft.XMLDOM"), g.async = "false", g.loadXML(e))
							} catch (k) {
								g =
									void 0
							}
							if (g && g.documentElement && !g.getElementsByTagName("parsererror").length) e = g;
							else throw Error("Phaser.Loader. Invalid Texture Atlas XML given");
						}
				}
				this.addToFileList("textureatlas", a, b, {
					atlasURL: null,
					atlasData: e,
					format: f
				})
			}
			return this
		},
		removeFile: function(a, b) {
			var d = this.getAsset(a, b);
			!1 !== d && this._fileList.splice(d.index, 1)
		},
		removeAll: function() {
			this._fileList.length = 0
		},
		start: function() {
			this.isLoading || (this.progress = 0, this.hasLoaded = !1, this.isLoading = !0, this.onLoadStart.dispatch(this._fileList.length),
				0 < this._fileList.length ? (this._fileIndex = 0, this._progressChunk = 100 / this._fileList.length, this.loadFile()) : (this.progress = 100, this.hasLoaded = !0, this.onLoadComplete.dispatch()))
		},
		loadFile: function() {
			if (this._fileList[this._fileIndex]) {
				var a = this._fileList[this._fileIndex],
					b = this;
				switch (a.type) {
					case "image":
					case "spritesheet":
					case "textureatlas":
					case "bitmapfont":
					case "tileset":
						a.data = new Image;
						a.data.name = a.key;
						a.data.onload = function() {
							return b.fileComplete(b._fileIndex)
						};
						a.data.onerror = function() {
							return b.fileError(b._fileIndex)
						};
						a.data.crossOrigin = this.crossOrigin;
						a.data.src = this.baseURL + a.url;
						break;
					case "audio":
						a.url = this.getAudioURL(a.url);
						null !== a.url ? this.game.sound.usingWebAudio ? (this._xhr.open("GET", this.baseURL + a.url, !0), this._xhr.responseType = "arraybuffer", this._xhr.onload = function() {
							return b.fileComplete(b._fileIndex)
						}, this._xhr.onerror = function() {
							return b.fileError(b._fileIndex)
						}, this._xhr.send()) : this.game.sound.usingAudioTag && (this.game.sound.touchLocked ? (a.data = new Audio, a.data.name = a.key, a.data.preload = "auto",
							a.data.src = this.baseURL + a.url, this.fileComplete(this._fileIndex)) : (a.data = new Audio, a.data.name = a.key, a.data.onerror = function() {
							return b.fileError(b._fileIndex)
						}, a.data.preload = "auto", a.data.src = this.baseURL + a.url, a.data.addEventListener("canplaythrough", c.GAMES[this.game.id].load.fileComplete(this._fileIndex), !1), a.data.load())) : this.fileError(this._fileIndex);
						break;
					case "tilemap":
						this._xhr.open("GET", this.baseURL + a.url, !0);
						this._xhr.responseType = "text";
						if (a.format === c.Tilemap.TILED_JSON) this._xhr.onload =
							function() {
								return b.jsonLoadComplete(b._fileIndex)
							};
						else if (a.format === c.Tilemap.CSV) this._xhr.onload = function() {
							return b.csvLoadComplete(b._fileIndex)
						};
						else throw Error("Phaser.Loader. Invalid Tilemap format: " + a.format);
						this._xhr.onerror = function() {
							return b.dataLoadError(b._fileIndex)
						};
						this._xhr.send();
						break;
					case "text":
						this._xhr.open("GET", this.baseURL + a.url, !0);
						this._xhr.responseType = "text";
						this._xhr.onload = function() {
							return b.fileComplete(b._fileIndex)
						};
						this._xhr.onerror = function() {
							return b.fileError(b._fileIndex)
						};
						this._xhr.send();
						break;
					case "script":
						this._xhr.open("GET", this.baseURL + a.url, !0), this._xhr.responseType = "text", this._xhr.onload = function() {
							return b.fileComplete(b._fileIndex)
						}, this._xhr.onerror = function() {
							return b.fileError(b._fileIndex)
						}, this._xhr.send()
				}
			} else console.warn("Phaser.Loader loadFile invalid index " + this._fileIndex)
		},
		getAudioURL: function(a) {
			var b;
			"string" === typeof a && (a = [a]);
			for (var d = 0; d < a.length; d++)
				if (b = a[d].toLowerCase(), b = b.substr((Math.max(0, b.lastIndexOf(".")) || Infinity) + 1), this.game.device.canPlayAudio(b)) return a[d];
			return null
		},
		fileError: function(a) {
			this._fileList[a].loaded = !0;
			this._fileList[a].error = !0;
			this.onFileError.dispatch(this._fileList[a].key, this._fileList[a]);
			console.warn("Phaser.Loader error loading file: " + this._fileList[a].key + " from URL " + this._fileList[a].url);
			this.nextFile(a, !1)
		},
		fileComplete: function(a) {
			if (this._fileList[a]) {
				var b = this._fileList[a],
					d = b.loaded = !0,
					e = this;
				switch (b.type) {
					case "image":
						this.game.cache.addImage(b.key, b.url, b.data);
						break;
					case "spritesheet":
						this.game.cache.addSpriteSheet(b.key,
							b.url, b.data, b.frameWidth, b.frameHeight, b.frameMax);
						break;
					case "tileset":
						this.game.cache.addTileset(b.key, b.url, b.data, b.tileWidth, b.tileHeight, b.tileMax, b.tileMargin, b.tileSpacing);
						break;
					case "textureatlas":
						if (null == b.atlasURL) this.game.cache.addTextureAtlas(b.key, b.url, b.data, b.atlasData, b.format);
						else {
							d = !1;
							this._xhr.open("GET", this.baseURL + b.atlasURL, !0);
							this._xhr.responseType = "text";
							if (b.format == c.Loader.TEXTURE_ATLAS_JSON_ARRAY || b.format == c.Loader.TEXTURE_ATLAS_JSON_HASH) this._xhr.onload = function() {
								return e.jsonLoadComplete(a)
							};
							else if (b.format == c.Loader.TEXTURE_ATLAS_XML_STARLING) this._xhr.onload = function() {
								return e.xmlLoadComplete(a)
							};
							else throw Error("Phaser.Loader. Invalid Texture Atlas format: " + b.format);
							this._xhr.onerror = function() {
								return e.dataLoadError(a)
							};
							this._xhr.send()
						}
						break;
					case "bitmapfont":
						null == b.xmlURL ? this.game.cache.addBitmapFont(b.key, b.url, b.data, b.xmlData) : (d = !1, this._xhr.open("GET", this.baseURL + b.xmlURL, !0), this._xhr.responseType = "text", this._xhr.onload = function() {
								return e.xmlLoadComplete(a)
							}, this._xhr.onerror =
							function() {
								return e.dataLoadError(a)
							}, this._xhr.send());
						break;
					case "audio":
						if (this.game.sound.usingWebAudio) {
							if (b.data = this._xhr.response, this.game.cache.addSound(b.key, b.url, b.data, !0, !1), b.autoDecode) {
								this.game.cache.updateSound(g, "isDecoding", !0);
								var f = this,
									g = b.key;
								this.game.sound.context.decodeAudioData(b.data, function(a) {
									a && f.game.cache.decodedSound(g, a)
								})
							}
						} else b.data.removeEventListener("canplaythrough", c.GAMES[this.game.id].load.fileComplete), this.game.cache.addSound(b.key, b.url, b.data, !1, !0);
						break;
					case "text":
						b.data = this._xhr.responseText;
						this.game.cache.addText(b.key, b.url, b.data);
						break;
					case "script":
						b.data = document.createElement("script"), b.data.language = "javascript", b.data.type = "text/javascript", b.data.defer = !1, b.data.text = this._xhr.responseText, document.head.appendChild(b.data)
				}
				d && this.nextFile(a, !0)
			} else console.warn("Phaser.Loader fileComplete invalid index " + a)
		},
		jsonLoadComplete: function(a) {
			if (this._fileList[a]) {
				var b = this._fileList[a],
					d = JSON.parse(this._xhr.responseText);
				b.loaded = !0;
				"tilemap" === b.type ? this.game.cache.addTilemap(b.key, b.url, d, b.format) : this.game.cache.addTextureAtlas(b.key, b.url, b.data, d, b.format);
				this.nextFile(a, !0)
			} else console.warn("Phaser.Loader jsonLoadComplete invalid index " + a)
		},
		csvLoadComplete: function(a) {
			if (this._fileList[a]) {
				var b = this._fileList[a],
					d = this._xhr.responseText;
				b.loaded = !0;
				this.game.cache.addTilemap(b.key, b.url, d, b.format);
				this.nextFile(a, !0)
			} else console.warn("Phaser.Loader csvLoadComplete invalid index " + a)
		},
		dataLoadError: function(a) {
			var b =
				this._fileList[a];
			b.loaded = !0;
			b.error = !0;
			console.warn("Phaser.Loader dataLoadError: " + b.key);
			this.nextFile(a, !0)
		},
		xmlLoadComplete: function(a) {
			var b = this._xhr.responseText,
				d;
			try {
				window.DOMParser ? d = (new DOMParser).parseFromString(b, "text/xml") : (d = new ActiveXObject("Microsoft.XMLDOM"), d.async = "false", d.loadXML(b))
			} catch (c) {
				d = void 0
			}
			if (!d || !d.documentElement || d.getElementsByTagName("parsererror").length) throw Error("Phaser.Loader. Invalid XML given");
			b = this._fileList[a];
			b.loaded = !0;
			"bitmapfont" == b.type ?
				this.game.cache.addBitmapFont(b.key, b.url, b.data, d) : "textureatlas" == b.type && this.game.cache.addTextureAtlas(b.key, b.url, b.data, d, b.format);
			this.nextFile(a, !0)
		},
		nextFile: function(a, b) {
			this.progress = Math.round(this.progress + this._progressChunk);
			100 < this.progress && (this.progress = 100);
			null !== this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.crop.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.crop.height = Math.floor(this.preloadSprite.height / 100 * this.progress),
				this.preloadSprite.sprite.crop = this.preloadSprite.crop);
			this.onFileComplete.dispatch(this.progress, this._fileList[a].key, b, this.totalLoadedFiles(), this._fileList.length);
			0 < this.totalQueuedFiles() ? (this._fileIndex++, this.loadFile()) : (this.hasLoaded = !0, this.isLoading = !1, this.removeAll(), this.onLoadComplete.dispatch())
		},
		totalLoadedFiles: function() {
			for (var a = 0, b = 0; b < this._fileList.length; b++) this._fileList[b].loaded && a++;
			return a
		},
		totalQueuedFiles: function() {
			for (var a = 0, b = 0; b < this._fileList.length; b++)!1 ===
				this._fileList[b].loaded && a++;
			return a
		}
	};
	c.LoaderParser = {
		bitmapFont: function(a, b, d) {
			if (b.getElementsByTagName("font")) {
				var c = e.TextureCache[d];
				a = {};
				d = b.getElementsByTagName("info")[0];
				var f = b.getElementsByTagName("common")[0];
				a.font = d.attributes.getNamedItem("face").nodeValue;
				a.size = parseInt(d.attributes.getNamedItem("size").nodeValue, 10);
				a.lineHeight = parseInt(f.attributes.getNamedItem("lineHeight").nodeValue, 10);
				a.chars = {};
				f = b.getElementsByTagName("char");
				for (d = 0; d < f.length; d++) {
					var g = parseInt(f[d].attributes.getNamedItem("id").nodeValue,
							10),
						k = {
							x: parseInt(f[d].attributes.getNamedItem("x").nodeValue, 10),
							y: parseInt(f[d].attributes.getNamedItem("y").nodeValue, 10),
							width: parseInt(f[d].attributes.getNamedItem("width").nodeValue, 10),
							height: parseInt(f[d].attributes.getNamedItem("height").nodeValue, 10)
						};
					e.TextureCache[g] = new e.Texture(c, k);
					a.chars[g] = {
						xOffset: parseInt(f[d].attributes.getNamedItem("xoffset").nodeValue, 10),
						yOffset: parseInt(f[d].attributes.getNamedItem("yoffset").nodeValue, 10),
						xAdvance: parseInt(f[d].attributes.getNamedItem("xadvance").nodeValue,
							10),
						kerning: {},
						texture: new e.Texture(c, k)
					}
				}
				b = b.getElementsByTagName("kerning");
				for (d = 0; d < b.length; d++) c = parseInt(b[d].attributes.getNamedItem("first").nodeValue, 10), f = parseInt(b[d].attributes.getNamedItem("second").nodeValue, 10), g = parseInt(b[d].attributes.getNamedItem("amount").nodeValue, 10), a.chars[f].kerning[c] = g;
				e.BitmapText.fonts[a.font] = a
			} else console.warn("Phaser.LoaderParser.bitmapFont: Invalid XML given, missing <font> tag")
		}
	};
	c.Sound = function(a, b, d, e, f) {
		"undefined" == typeof d && (d = 1);
		"undefined" ==
			typeof e && (e = !1);
		"undefined" === typeof f && (f = a.sound.connectToMaster);
		this.game = a;
		this.key = this.name = b;
		this.loop = e;
		this._volume = d;
		this.markers = {};
		this._buffer = this.context = null;
		this.autoplay = this._muted = !1;
		this.stopTime = this.duration = this.currentTime = this.startTime = this.totalDuration = 0;
		this.paused = !1;
		this.pausedTime = this.pausedPosition = 0;
		this.isPlaying = !1;
		this.currentMarker = "";
		this.override = this.pendingPlayback = !1;
		this.usingWebAudio = this.game.sound.usingWebAudio;
		this.usingAudioTag = this.game.sound.usingAudioTag;
		this.externalNode = null;
		this.usingWebAudio ? (this.context = this.game.sound.context, this.masterGainNode = this.game.sound.masterGain, this.gainNode = "undefined" === typeof this.context.createGain ? this.context.createGainNode() : this.context.createGain(), this.gainNode.gain.value = d * this.game.sound.volume, f && this.gainNode.connect(this.masterGainNode)) : this.game.cache.getSound(b) && this.game.cache.isSoundReady(b) ? (this._sound = this.game.cache.getSoundData(b), this.totalDuration = 0, this._sound.duration && (this.totalDuration =
			this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this);
		this.onDecoded = new c.Signal;
		this.onPlay = new c.Signal;
		this.onPause = new c.Signal;
		this.onResume = new c.Signal;
		this.onLoop = new c.Signal;
		this.onStop = new c.Signal;
		this.onMute = new c.Signal;
		this.onMarkerComplete = new c.Signal
	};
	c.Sound.prototype = {
		soundHasUnlocked: function(a) {
			a == this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration)
		},
		addMarker: function(a, b, d, c, e) {
			"undefined" == typeof e &&
				(e = !1);
			this.markers[a] = {
				name: a,
				start: b,
				stop: b + d,
				volume: c || 1,
				duration: d,
				durationMS: 1E3 * d,
				loop: e
			}
		},
		removeMarker: function(a) {
			delete this.markers[a]
		},
		update: function() {
			this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop));
			this.isPlaying && (this.currentTime = this.game.time.now - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker ?
				(this.currentTime = 0, this.startTime = this.game.time.now) : this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop() : this.loop ? (this.onLoop.dispatch(this), this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop()))
		},
		play: function(a, b, d, c, e) {
			a = a || "";
			b = b || 0;
			"undefined" === typeof d && (d = this._volume);
			"undefined" === typeof c && (c = !1);
			"undefined" === typeof e && (e = !0);
			if (!0 !== this.isPlaying || !1 !== e || !1 !== this.override) {
				this.isPlaying && this.override && (this.usingWebAudio ? "undefined" === typeof this._sound.stop ?
					this._sound.noteOff(0) : this._sound.stop(0) : this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0));
				this.currentMarker = a;
				if ("" !== a)
					if (this.markers[a]) this.position = this.markers[a].start, this.volume = this.markers[a].volume, this.loop = this.markers[a].loop, this.duration = this.markers[a].duration, this.durationMS = this.markers[a].durationMS, this._tempMarker = a, this._tempPosition = this.position, this._tempVolume = this.volume, this._tempLoop = this.loop;
					else {
						console.warn("Phaser.Sound.play: audio marker " +
							a + " doesn't exist");
						return
					} else this.position = b, this.volume = d, this.loop = c, this.durationMS = this.duration = 0, this._tempMarker = a, this._tempPosition = b, this._tempVolume = d, this._tempLoop = c;
				this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (null == this._buffer && (this._buffer = this.game.cache.getSoundData(this.key)), this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, this.externalNode ? this._sound.connect(this.externalNode.input) : this._sound.connect(this.gainNode), this.totalDuration =
					this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1E3 * this.totalDuration), this.loop && "" === a && (this._sound.loop = !0), "undefined" === typeof this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : this._sound.start(0, this.position, this.duration), this.isPlaying = !0, this.startTime = this.game.time.now, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) &&
					!1 === this.game.cache.getSound(this.key).isDecoding && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) : this._sound && 4 == this._sound.readyState ? (this._sound.play(), this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1E3 * this.totalDuration), this._sound.currentTime = this.position, this._sound.muted = this._muted, this._sound.volume =
					this._muted ? 0 : this._volume, this.isPlaying = !0, this.startTime = this.game.time.now, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0
			}
		},
		restart: function(a, b, d, c) {
			"undefined" == typeof c && (c = !1);
			this.play(a || "", b || 0, d || 1, c, !0)
		},
		pause: function() {
			this.isPlaying && this._sound && (this.stop(), this.isPlaying = !1, this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.now, this.onPause.dispatch(this))
		},
		resume: function() {
			if (this.paused &&
				this._sound) {
				if (this.usingWebAudio) {
					var a = this.position + this.pausedPosition / 1E3;
					this._sound = this.context.createBufferSource();
					this._sound.buffer = this._buffer;
					this._sound.connect(this.gainNode);
					"undefined" === typeof this._sound.start ? this._sound.noteGrainOn(0, a, this.duration) : this._sound.start(0, a, this.duration)
				} else this._sound.play();
				this.isPlaying = !0;
				this.paused = !1;
				this.startTime += this.game.time.now - this.pausedTime;
				this.onResume.dispatch(this)
			}
		},
		stop: function() {
			this.isPlaying && this._sound && (this.usingWebAudio ?
				"undefined" === typeof this._sound.stop ? this._sound.noteOff(0) : this._sound.stop(0) : this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0));
			this.isPlaying = !1;
			var a = this.currentMarker;
			this.currentMarker = "";
			this.onStop.dispatch(this, a)
		}
	};
	Object.defineProperty(c.Sound.prototype, "isDecoding", {
		get: function() {
			return this.game.cache.getSound(this.key).isDecoding
		}
	});
	Object.defineProperty(c.Sound.prototype, "isDecoded", {
		get: function() {
			return this.game.cache.isSoundDecoded(this.key)
		}
	});
	Object.defineProperty(c.Sound.prototype,
		"mute", {
			get: function() {
				return this._muted
			},
			set: function(a) {
				a ? (this._muted = !0, this.usingWebAudio ? (this._muteVolume = this.gainNode.gain.value, this.gainNode.gain.value = 0) : this.usingAudioTag && this._sound && (this._muteVolume = this._sound.volume, this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume));
				this.onMute.dispatch(this)
			}
		});
	Object.defineProperty(c.Sound.prototype, "volume", {
		get: function() {
			return this._volume
		},
		set: function(a) {
			this.usingWebAudio ? (this._volume = a, this.gainNode.gain.value = a) : this.usingAudioTag && this._sound && 0 <= a && 1 >= a && (this._volume = a, this._sound.volume = a)
		}
	});
	c.SoundManager = function(a) {
		this.game = a;
		this.onSoundDecode = new c.Signal;
		this._muted = !1;
		this._unlockSource = null;
		this._volume = 1;
		this._sounds = [];
		this.context = null;
		this.usingWebAudio = !0;
		this.noAudio = this.usingAudioTag = !1;
		this.connectToMaster = !0;
		this.touchLocked = !1;
		this.channels = 32
	};
	c.SoundManager.prototype = {
		boot: function() {
			this.game.device.iOS &&
				!1 === this.game.device.webAudio && (this.channels = 1);
			this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock ? (this.game.input.touch.callbackContext = this, this.game.input.touch.touchStartCallback = this.unlock, this.game.input.mouse.callbackContext = this, this.game.input.mouse.mouseDownCallback = this.unlock, this.touchLocked = !0) : this.touchLocked = !1;
			this.game.device.android ? (this.usingWebAudio = !1, this.usingAudioTag = !0, this.noAudio = !1) : (window.AudioContext ? this.context = new window.AudioContext :
				window.webkitAudioContext ? this.context = new window.webkitAudioContext : window.Audio ? (this.usingWebAudio = !1, this.usingAudioTag = !0) : (this.usingWebAudio = !1, this.noAudio = !0), null !== this.context && (this.masterGain = "undefined" === typeof this.context.createGain ? this.context.createGainNode() : this.context.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination)))
		},
		unlock: function() {
			if (!1 !== this.touchLocked)
				if (!1 === this.game.device.webAudio || window.PhaserGlobal && !0 === window.PhaserGlobal.disableWebAudio) this.touchLocked = !1, this._unlockSource = null, this.game.input.touch.callbackContext = null, this.game.input.touch.touchStartCallback = null, this.game.input.mouse.callbackContext = null, this.game.input.mouse.mouseDownCallback = null;
				else {
					var a = this.context.createBuffer(1, 1, 22050);
					this._unlockSource = this.context.createBufferSource();
					this._unlockSource.buffer = a;
					this._unlockSource.connect(this.context.destination);
					this._unlockSource.noteOn(0)
				}
		},
		stopAll: function() {
			for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].stop()
		},
		pauseAll: function() {
			for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].pause()
		},
		resumeAll: function() {
			for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].resume()
		},
		decode: function(a, b) {
			b = b || null;
			var d = this.game.cache.getSoundData(a);
			if (d && !1 === this.game.cache.isSoundDecoded(a)) {
				this.game.cache.updateSound(a, "isDecoding", !0);
				var c = this;
				this.context.decodeAudioData(d, function(d) {
					c.game.cache.decodedSound(a, d);
					b && c.onSoundDecode.dispatch(b)
				})
			}
		},
		update: function() {
			this.touchLocked &&
				this.game.device.webAudio && null !== this._unlockSource && (this._unlockSource.playbackState === this._unlockSource.PLAYING_STATE || this._unlockSource.playbackState === this._unlockSource.FINISHED_STATE) && (this.touchLocked = !1, this._unlockSource = null, this.game.input.touch.callbackContext = null, this.game.input.touch.touchStartCallback = null);
			for (var a = 0; a < this._sounds.length; a++) this._sounds[a].update()
		},
		add: function(a, b, d, e) {
			"undefined" === typeof b && (b = 1);
			"undefined" === typeof d && (d = !1);
			"undefined" === typeof e &&
				(e = this.connectToMaster);
			a = new c.Sound(this.game, a, b, d, e);
			this._sounds.push(a);
			return a
		},
		play: function(a, b, d, c) {
			a = this.add(a, b, d);
			a.play();
			return a
		}
	};
	Object.defineProperty(c.SoundManager.prototype, "mute", {
		get: function() {
			return this._muted
		},
		set: function(a) {
			if (a) {
				if (!this._muted)
					for (this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0), a = 0; a < this._sounds.length; a++) this._sounds[a].usingAudioTag && (this._sounds[a].mute = !0)
			} else if (!1 !== this._muted)
				for (this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume), a = 0; a < this._sounds.length; a++) this._sounds[a].usingAudioTag && (this._sounds[a].mute = !1)
		}
	});
	Object.defineProperty(c.SoundManager.prototype, "volume", {
		get: function() {
			return this.usingWebAudio ? this.masterGain.gain.value : this._volume
		},
		set: function(a) {
			this._volume = a = this.game.math.clamp(a, 1, 0);
			this.usingWebAudio && (this.masterGain.gain.value = a);
			for (var b = 0; b < this._sounds.length; b++) this._sounds[b].usingAudioTag && (this._sounds[b].volume *=
				a)
		}
	});
	c.Utils.Debug = function(a) {
		this.game = a;
		this.context = a.context;
		this.font = "14px Courier";
		this.lineHeight = 16;
		this.renderShadow = !0;
		this.currentY = this.currentX = 0;
		this.currentAlpha = 1
	};
	c.Utils.Debug.prototype = {
		start: function(a, b, d) {
			null != this.context && ("number" !== typeof a && (a = 0), "number" !== typeof b && (b = 0), d = d || "rgb(255,255,255)", this.currentX = a, this.currentY = b, this.currentColor = d, this.currentAlpha = this.context.globalAlpha, this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.fillStyle =
				d, this.context.font = this.font, this.context.globalAlpha = 1)
		},
		stop: function() {
			this.context.restore();
			this.context.globalAlpha = this.currentAlpha
		},
		line: function(a, b, d) {
			null != this.context && (b = b || null, d = d || null, null !== b && (this.currentX = b), null !== d && (this.currentY = d), this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(a, this.currentX + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), this.context.fillText(a, this.currentX, this.currentY), this.currentY += this.lineHeight)
		},
		renderQuadTree: function(a, b) {
			b = b || "rgba(255,0,0,0.3)";
			this.start();
			var d = a.bounds;
			if (0 === a.nodes.length)
				for (this.context.strokeStyle = b, this.context.strokeRect(d.x, d.y, d.width, d.height), this.renderText(a.ID + " / " + a.objects.length, d.x + 4, d.y + 16, "rgb(0,200,0)", "12px Courier"), this.context.strokeStyle = "rgb(0,255,0)", d = 0; d < a.objects.length; d++) this.context.strokeRect(a.objects[d].x, a.objects[d].y, a.objects[d].width, a.objects[d].height);
			else
				for (d = 0; d < a.nodes.length; d++) this.renderQuadTree(a.nodes[d]);
			this.stop()
		},
		renderSpriteCorners: function(a, b, d, c) {
			null != this.context && (b = b || !1, d = d || !1, c = c || "rgb(255,255,255)", this.start(0, 0, c), d && (this.context.beginPath(), this.context.strokeStyle = "rgba(0, 255, 0, 0.7)", this.context.strokeRect(a.bounds.x, a.bounds.y, a.bounds.width, a.bounds.height), this.context.closePath(), this.context.stroke()), this.context.beginPath(), this.context.moveTo(a.topLeft.x, a.topLeft.y), this.context.lineTo(a.topRight.x, a.topRight.y), this.context.lineTo(a.bottomRight.x, a.bottomRight.y), this.context.lineTo(a.bottomLeft.x,
				a.bottomLeft.y), this.context.closePath(), this.context.strokeStyle = "rgba(255, 0, 255, 0.7)", this.context.stroke(), this.renderPoint(a.offset), this.renderPoint(a.center), this.renderPoint(a.topLeft), this.renderPoint(a.topRight), this.renderPoint(a.bottomLeft), this.renderPoint(a.bottomRight), b && (this.currentColor = c, this.line("x: " + Math.floor(a.topLeft.x) + " y: " + Math.floor(a.topLeft.y), a.topLeft.x, a.topLeft.y), this.line("x: " + Math.floor(a.topRight.x) + " y: " + Math.floor(a.topRight.y), a.topRight.x, a.topRight.y),
				this.line("x: " + Math.floor(a.bottomLeft.x) + " y: " + Math.floor(a.bottomLeft.y), a.bottomLeft.x, a.bottomLeft.y), this.line("x: " + Math.floor(a.bottomRight.x) + " y: " + Math.floor(a.bottomRight.y), a.bottomRight.x, a.bottomRight.y)), this.stop())
		},
		renderSoundInfo: function(a, b, d, c) {
			null != this.context && (this.start(b, d, c || "rgb(255,255,255)"), this.line("Sound: " + a.key + " Locked: " + a.game.sound.touchLocked), this.line("Is Ready?: " + this.game.cache.isSoundReady(a.key) + " Pending Playback: " + a.pendingPlayback), this.line("Decoded: " +
				a.isDecoded + " Decoding: " + a.isDecoding), this.line("Total Duration: " + a.totalDuration + " Playing: " + a.isPlaying), this.line("Time: " + a.currentTime), this.line("Volume: " + a.volume + " Muted: " + a.mute), this.line("WebAudio: " + a.usingWebAudio + " Audio: " + a.usingAudioTag), "" !== a.currentMarker && (this.line("Marker: " + a.currentMarker + " Duration: " + a.duration), this.line("Start: " + a.markers[a.currentMarker].start + " Stop: " + a.markers[a.currentMarker].stop), this.line("Position: " + a.position)), this.stop())
		},
		renderCameraInfo: function(a,
			b, d, c) {
			null != this.context && (this.start(b, d, c || "rgb(255,255,255)"), this.line("Camera (" + a.width + " x " + a.height + ")"), this.line("X: " + a.x + " Y: " + a.y), this.line("Bounds x: " + a.bounds.x + " Y: " + a.bounds.y + " w: " + a.bounds.width + " h: " + a.bounds.height), this.line("View x: " + a.view.x + " Y: " + a.view.y + " w: " + a.view.width + " h: " + a.view.height), this.stop())
		},
		renderPointer: function(a, b, d, c, e) {
			null != this.context && null != a && ("undefined" === typeof b && (b = !1), d = d || "rgba(0,255,0,0.5)", c = c || "rgba(255,0,0,0.5)", !0 !== b || !0 !==
				a.isUp) && (this.start(a.x, a.y - 100, e || "rgb(255,255,255)"), this.context.beginPath(), this.context.arc(a.x, a.y, a.circle.radius, 0, 2 * Math.PI), this.context.fillStyle = a.active ? d : c, this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(a.positionDown.x, a.positionDown.y), this.context.lineTo(a.position.x, a.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath(), this.line("ID: " + a.id + " Active: " + a.active), this.line("World X: " + a.worldX + " World Y: " +
				a.worldY), this.line("Screen X: " + a.x + " Screen Y: " + a.y), this.line("Duration: " + a.duration + " ms"), this.stop())
		},
		renderSpriteInputInfo: function(a, b, d, c) {
			this.start(b, d, c || "rgb(255,255,255)");
			this.line("Sprite Input: (" + a.width + " x " + a.height + ")");
			this.line("x: " + a.input.pointerX().toFixed(1) + " y: " + a.input.pointerY().toFixed(1));
			this.line("over: " + a.input.pointerOver() + " duration: " + a.input.overDuration().toFixed(0));
			this.line("down: " + a.input.pointerDown() + " duration: " + a.input.downDuration().toFixed(0));
			this.line("just over: " + a.input.justOver() + " just out: " + a.input.justOut());
			this.stop()
		},
		renderSpriteCollision: function(a, b, d, c) {
			this.start(b, d, c || "rgb(255,255,255)");
			this.line("Sprite Collision: (" + a.width + " x " + a.height + ")");
			this.line("left: " + a.body.touching.left);
			this.line("right: " + a.body.touching.right);
			this.line("up: " + a.body.touching.up);
			this.line("down: " + a.body.touching.down);
			this.line("velocity.x: " + a.body.velocity.x);
			this.line("velocity.y: " + a.body.velocity.y);
			this.stop()
		},
		renderInputInfo: function(a,
			b, d) {
			null != this.context && (this.start(a, b, d || "rgb(255,255,0)"), this.line("Input"), this.line("X: " + this.game.input.x + " Y: " + this.game.input.y), this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY), this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)), this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY), this.stop())
		},
		renderSpriteInfo: function(a, b, d, c) {
			null != this.context &&
				(this.start(b, d, c || "rgb(255, 255, 255)"), this.line("Sprite:  (" + a.width + " x " + a.height + ") anchor: " + a.anchor.x + " x " + a.anchor.y), this.line("x: " + a.x.toFixed(1) + " y: " + a.y.toFixed(1)), this.line("angle: " + a.angle.toFixed(1) + " rotation: " + a.rotation.toFixed(1)), this.line("visible: " + a.visible + " in camera: " + a.inCamera), this.line("body x: " + a.body.x.toFixed(1) + " y: " + a.body.y.toFixed(1)), this.line("deltaX: " + a.body.deltaX()), this.line("deltaY: " + a.body.deltaY()), this.stop())
		},
		renderWorldTransformInfo: function(a,
			b, d, c) {
			null != this.context && (this.start(b, d, c || "rgb(255, 255, 255)"), this.line("World Transform"), this.line("skewX:  " + a.worldTransform[3]), this.line("skewY:  " + a.worldTransform[1]), this.line("scaleX: " + a.worldTransform[0]), this.line("scaleY: " + a.worldTransform[4]), this.line("transX: " + a.worldTransform[2]), this.line("transY: " + a.worldTransform[5]), this.stop())
		},
		renderLocalTransformInfo: function(a, b, d, c) {
			null != this.context && (this.start(b, d, c || "rgb(255, 255, 255)"), this.line("Local Transform"), this.line("skewX:  " +
				a.localTransform[3]), this.line("skewY:  " + a.localTransform[1]), this.line("scaleX: " + a.localTransform[0]), this.line("scaleY: " + a.localTransform[4]), this.line("transX: " + a.localTransform[2]), this.line("transY: " + a.localTransform[5]), this.stop())
		},
		renderSpriteCoords: function(a, b, d, c) {
			null != this.context && (this.start(b, d, c || "rgb(255, 255, 255)"), a.name && this.line(a.name), this.line("x: " + a.x), this.line("y: " + a.y), this.line("pos x: " + a.position.x), this.line("pos y: " + a.position.y), this.line("local x: " +
				a.localTransform[2]), this.line("local y: " + a.localTransform[5]), this.line("t x: " + a.worldTransform[2]), this.line("t y: " + a.worldTransform[5]), this.line("world x: " + a.world.x), this.line("world y: " + a.world.y), this.stop())
		},
		renderGroupInfo: function(a, b, d, c) {
			null != this.context && (this.start(b, d, c || "rgb(255, 255, 255)"), this.line("Group (size: " + a.length + ")"), this.line("x: " + a.x), this.line("y: " + a.y), this.stop())
		},
		renderPointInfo: function(a, b, d, c) {
			null != this.context && (this.start(b, d, c || "rgb(255, 255, 255)"),
				this.line("px: " + a.x.toFixed(1) + " py: " + a.y.toFixed(1)), this.stop())
		},
		renderSpriteBody: function(a, b) {
			null != this.context && (b = b || "rgba(255,0,255, 0.3)", this.start(0, 0, b), this.context.fillStyle = b, this.context.fillRect(a.body.screenX, a.body.screenY, a.body.width, a.body.height), this.stop())
		},
		renderSpriteBounds: function(a, b, d) {
			null != this.context && (b = b || "rgb(255,0,255)", "undefined" === typeof d && (d = !1), this.start(0, 0, b), d ? (this.context.fillStyle = b, this.context.fillRect(a.bounds.x, a.bounds.y, a.bounds.width,
				a.bounds.height)) : (this.context.strokeStyle = b, this.context.strokeRect(a.bounds.x, a.bounds.y, a.bounds.width, a.bounds.height), this.context.stroke()), this.stop())
		},
		renderPixel: function(a, b, d) {
			null != this.context && (d = d || "rgba(0,255,0,1)", this.start(), this.context.fillStyle = d, this.context.fillRect(a, b, 2, 2), this.stop())
		},
		renderPoint: function(a, b) {
			null != this.context && (b = b || "rgba(0,255,0,1)", this.start(), this.context.fillStyle = b, this.context.fillRect(a.x, a.y, 4, 4), this.stop())
		},
		renderRectangle: function(a, b) {
			null !=
				this.context && (b = b || "rgba(0,255,0,0.3)", this.start(), this.context.fillStyle = b, this.context.fillRect(a.x, a.y, a.width, a.height), this.stop())
		},
		renderCircle: function(a, b) {
			null != this.context && (b = b || "rgba(0,255,0,0.3)", this.start(), this.context.beginPath(), this.context.fillStyle = b, this.context.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !1), this.context.fill(), this.context.closePath(), this.stop())
		},
		renderText: function(a, b, d, c, e) {
			null != this.context && (c = c || "rgb(255,255,255)", e = e || "16px Courier", this.start(), this.context.font =
				e, this.context.fillStyle = c, this.context.fillText(a, b, d), this.stop())
		},
		dumpLinkedList: function(a) {
			var b = "\n" + c.Utils.pad("Node", 20) + "|" + c.Utils.pad("Next", 20) + "|" + c.Utils.pad("Previous", 20) + "|" + c.Utils.pad("First", 20) + "|" + c.Utils.pad("Last", 20);
			console.log(b);
			b = c.Utils.pad("----------", 20) + "|" + c.Utils.pad("----------", 20) + "|" + c.Utils.pad("----------", 20) + "|" + c.Utils.pad("----------", 20) + "|" + c.Utils.pad("----------", 20);
			console.log(b);
			var d = a.last.next;
			a = a.first;
			do {
				var b = a.sprite.name || "*",
					e = "-",
					f =
					"-",
					g = "-",
					k = "-";
				a.next && (e = a.next.sprite.name);
				a.prev && (f = a.prev.sprite.name);
				a.first && (g = a.first.sprite.name);
				a.last && (k = a.last.sprite.name);
				"undefined" === typeof e && (e = "-");
				"undefined" === typeof f && (f = "-");
				"undefined" === typeof g && (g = "-");
				"undefined" === typeof k && (k = "-");
				b = c.Utils.pad(b, 20) + "|" + c.Utils.pad(e, 20) + "|" + c.Utils.pad(f, 20) + "|" + c.Utils.pad(g, 20) + "|" + c.Utils.pad(k, 20);
				console.log(b);
				a = a.next
			} while (a != d)
		}
	};
	c.Color = {
		getColor32: function(a, b, d, c) {
			return a << 24 | b << 16 | d << 8 | c
		},
		getColor: function(a,
			b, d) {
			return a << 16 | b << 8 | d
		},
		hexToRGB: function(a) {
			var b = "#" == a.charAt(0) ? a.substring(1, 7) : a;
			3 == b.length && (b = b.charAt(0) + b.charAt(0) + b.charAt(1) + b.charAt(1) + b.charAt(2) + b.charAt(2));
			a = parseInt(b.substring(0, 2), 16);
			var d = parseInt(b.substring(2, 4), 16),
				b = parseInt(b.substring(4, 6), 16);
			return a << 16 | d << 8 | b
		},
		getColorInfo: function(a) {
			var b = c.Color.getRGB(a),
				d = c.Color.RGBtoHSV(a);
			a = c.Color.RGBtoHexstring(a) + "\n";
			a = a.concat("Alpha: " + b.alpha + " Red: " + b.red + " Green: " + b.green + " Blue: " + b.blue) + "\n";
			return a = a.concat("Hue: " +
				d.hue + " Saturation: " + d.saturation + " Lightnes: " + d.lightness)
		},
		RGBtoHexstring: function(a) {
			a = c.Color.getRGB(a);
			return "0x" + c.Color.colorToHexstring(a.alpha) + c.Color.colorToHexstring(a.red) + c.Color.colorToHexstring(a.green) + c.Color.colorToHexstring(a.blue)
		},
		RGBtoWebstring: function(a) {
			a = c.Color.getRGB(a);
			return "#" + c.Color.colorToHexstring(a.red) + c.Color.colorToHexstring(a.green) + c.Color.colorToHexstring(a.blue)
		},
		colorToHexstring: function(a) {
			var b = a % 16;
			return "0123456789ABCDEF".charAt((a - b) / 16) + "0123456789ABCDEF".charAt(b)
		},
		interpolateColor: function(a, b, d, e, f) {
			"undefined" === typeof f && (f = 255);
			a = c.Color.getRGB(a);
			b = c.Color.getRGB(b);
			return c.Color.getColor32(f, (b.red - a.red) * e / d + a.red, (b.green - a.green) * e / d + a.green, (b.blue - a.blue) * e / d + a.blue)
		},
		interpolateColorWithRGB: function(a, b, d, e, f, g) {
			a = c.Color.getRGB(a);
			return c.Color.getColor((b - a.red) * g / f + a.red, (d - a.green) * g / f + a.green, (e - a.blue) * g / f + a.blue)
		},
		interpolateRGB: function(a, b, d, e, f, g, k, l) {
			return c.Color.getColor((e - a) * l / k + a, (f - b) * l / k + b, (g - d) * l / k + d)
		},
		getRandomColor: function(a,
			b, d) {
			"undefined" === typeof a && (a = 0);
			"undefined" === typeof b && (b = 255);
			"undefined" === typeof d && (d = 255);
			if (255 < b || a > b) return c.Color.getColor(255, 255, 255);
			var e = a + Math.round(Math.random() * (b - a)),
				f = a + Math.round(Math.random() * (b - a));
			a += Math.round(Math.random() * (b - a));
			return c.Color.getColor32(d, e, f, a)
		},
		getRGB: function(a) {
			return {
				alpha: a >>> 24,
				red: a >> 16 & 255,
				green: a >> 8 & 255,
				blue: a & 255
			}
		},
		getWebRGB: function(a) {
			return "rgba(" + (a >> 16 & 255).toString() + "," + (a >> 8 & 255).toString() + "," + (a & 255).toString() + "," + ((a >>> 24) / 255).toString() +
				")"
		},
		getAlpha: function(a) {
			return a >>> 24
		},
		getAlphaFloat: function(a) {
			return (a >>> 24) / 255
		},
		getRed: function(a) {
			return a >> 16 & 255
		},
		getGreen: function(a) {
			return a >> 8 & 255
		},
		getBlue: function(a) {
			return a & 255
		}
	};
	c.Physics = {};
	c.Physics.Arcade = function(a) {
		this.game = a;
		this.gravity = new c.Point;
		this.bounds = new c.Rectangle(0, 0, a.world.width, a.world.height);
		this.maxObjects = 10;
		this.OVERLAP_BIAS = this.maxLevels = 4;
		this.quadTree = new c.QuadTree(this, this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width,
			this.game.world.bounds.height, this.maxObjects, this.maxLevels);
		this.quadTreeID = 0;
		this._bounds1 = new c.Rectangle;
		this._bounds2 = new c.Rectangle;
		this._average = this._newVelocity2 = this._newVelocity1 = this._velocity2 = this._velocity1 = this._maxOverlap = this._overlap = 0;
		this._mapData = [];
		this._mapTiles = 0;
		this._result = !1;
		this._dy = this._dx = this._angle = this._total = 0
	};
	c.Physics.Arcade.prototype = {
		updateMotion: function(a) {
			this._velocityDelta = (this.computeVelocity(0, a, a.angularVelocity, a.angularAcceleration, a.angularDrag,
				a.maxAngular) - a.angularVelocity) * this.game.time.physicsElapsed * 30;
			a.angularVelocity += this._velocityDelta;
			a.rotation += a.angularVelocity * this.game.time.physicsElapsed;
			a.angularVelocity += this._velocityDelta;
			this._velocityDelta = (this.computeVelocity(1, a, a.velocity.x, a.acceleration.x, a.drag.x, a.maxVelocity.x) - a.velocity.x) * this.game.time.physicsElapsed * 30;
			a.velocity.x += this._velocityDelta;
			a.x += a.velocity.x * this.game.time.physicsElapsed;
			a.velocity.x += this._velocityDelta;
			this._velocityDelta = (this.computeVelocity(2,
				a, a.velocity.y, a.acceleration.y, a.drag.y, a.maxVelocity.y) - a.velocity.y) * this.game.time.physicsElapsed * 30;
			a.velocity.y += this._velocityDelta;
			a.y += a.velocity.y * this.game.time.physicsElapsed;
			a.velocity.y += this._velocityDelta
		},
		computeVelocity: function(a, b, d, c, e, f) {
			f = f || 1E4;
			1 == a && b.allowGravity ? d += this.gravity.x + b.gravity.x : 2 == a && b.allowGravity && (d += this.gravity.y + b.gravity.y);
			0 !== c ? d += c * this.game.time.physicsElapsed : 0 !== e && (this._drag = e * this.game.time.physicsElapsed, d = 0 < d - this._drag ? d - this._drag : 0 > d + this._drag ?
				d + this._drag : 0);
			d > f ? d = f : d < -f && (d = -f);
			return d
		},
		preUpdate: function() {
			this.quadTree.clear();
			this.quadTreeID = 0;
			this.quadTree = new c.QuadTree(this, this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels)
		},
		postUpdate: function() {
			this.quadTree.clear()
		},
		overlap: function(a, b, d, e, f) {
			d = d || null;
			e = e || null;
			f = f || d;
			this._result = !1;
			this._total = 0;
			a && b && a.exists && b.exists && (a.type == c.SPRITE ? b.type == c.SPRITE ? this.overlapSpriteVsSprite(a,
				b, d, e, f) : b.type != c.GROUP && b.type != c.EMITTER || this.overlapSpriteVsGroup(a, b, d, e, f) : a.type == c.GROUP ? b.type == c.SPRITE ? this.overlapSpriteVsGroup(b, a, d, e, f) : b.type != c.GROUP && b.type != c.EMITTER || this.overlapGroupVsGroup(a, b, d, e, f) : a.type == c.EMITTER && (b.type == c.SPRITE ? this.overlapSpriteVsGroup(b, a, d, e, f) : b.type != c.GROUP && b.type != c.EMITTER || this.overlapGroupVsGroup(a, b, d, e, f)));
			return 0 < this._total
		},
		overlapSpriteVsSprite: function(a, b, d, e, f) {
			if (this._result = c.Rectangle.intersects(a.body, b.body)) e ? e.call(f,
				a, b) && (this._total++, d && d.call(f, a, b)) : (this._total++, d && d.call(f, a, b))
		},
		overlapSpriteVsGroup: function(a, b, d, e, f) {
			if (0 !== b.length) {
				this._potentials = this.quadTree.retrieve(a);
				for (var g = 0, k = this._potentials.length; g < k; g++) this._potentials[g].sprite.group == b && ((this._result = c.Rectangle.intersects(a.body, this._potentials[g])) && e && (this._result = e.call(f, a, this._potentials[g].sprite)), this._result && (this._total++, d && d.call(f, a, this._potentials[g].sprite)))
			}
		},
		overlapGroupVsGroup: function(a, b, d, c, e) {
			if (0 !==
				a.length && 0 !== b.length && a._container.first._iNext) {
				var f = a._container.first._iNext;
				do f.exists && this.overlapSpriteVsGroup(f, b, d, c, e), f = f._iNext; while (f != a._container.last._iNext)
			}
		},
		collide: function(a, b, d, e, f) {
			d = d || null;
			e = e || null;
			f = f || d;
			this._result = !1;
			this._total = 0;
			a && b && a.exists && b.exists && (a.type == c.SPRITE ? b.type == c.SPRITE ? this.collideSpriteVsSprite(a, b, d, e, f) : b.type == c.GROUP || b.type == c.EMITTER ? this.collideSpriteVsGroup(a, b, d, e, f) : b.type == c.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(a, b, d, e,
				f) : a.type == c.GROUP ? b.type == c.SPRITE ? this.collideSpriteVsGroup(b, a, d, e, f) : b.type == c.GROUP || b.type == c.EMITTER ? this.collideGroupVsGroup(a, b, d, e, f) : b.type == c.TILEMAPLAYER && this.collideGroupVsTilemapLayer(a, b, d, e, f) : a.type == c.TILEMAPLAYER ? b.type == c.SPRITE ? this.collideSpriteVsTilemapLayer(b, a, d, e, f) : b.type != c.GROUP && b.type != c.EMITTER || this.collideGroupVsTilemapLayer(b, a, d, e, f) : a.type == c.EMITTER && (b.type == c.SPRITE ? this.collideSpriteVsGroup(b, a, d, e, f) : b.type == c.GROUP || b.type == c.EMITTER ? this.collideGroupVsGroup(a,
				b, d, e, f) : b.type == c.TILEMAPLAYER && this.collideGroupVsTilemapLayer(a, b, d, e, f)));
			return 0 < this._total
		},
		collideSpriteVsTilemapLayer: function(a, b, d, c, e) {
			this._mapData = b.getTiles(a.body.x, a.body.y, a.body.width, a.body.height, !0);
			if (0 !== this._mapData.length)
				for (b = 0; b < this._mapData.length; b++) this.separateTile(a.body, this._mapData[b]) && (c ? c.call(e, a, this._mapData[b]) && (this._total++, d && d.call(e, a, this._mapData[b])) : (this._total++, d && d.call(e, a, this._mapData[b])))
		},
		collideGroupVsTilemapLayer: function(a, b, d,
			c, e) {
			if (0 !== a.length && 0 !== a.length && a._container.first._iNext) {
				var f = a._container.first._iNext;
				do f.exists && this.collideSpriteVsTilemapLayer(f, b, d, c, e), f = f._iNext; while (f != a._container.last._iNext)
			}
		},
		collideSpriteVsSprite: function(a, b, d, c, e) {
			this.separate(a.body, b.body);
			this._result && (c ? c.call(e, a, b) && (this._total++, d && d.call(e, a, b)) : (this._total++, d && d.call(e, a, b)))
		},
		collideSpriteVsGroup: function(a, b, d, c, e) {
			if (0 !== b.length) {
				this._potentials = this.quadTree.retrieve(a);
				for (var f = 0, k = this._potentials.length; f <
					k; f++) this._potentials[f].sprite.group == b && (this.separate(a.body, this._potentials[f]), this._result && c && (this._result = c.call(e, a, this._potentials[f].sprite)), this._result && (this._total++, d && d.call(e, a, this._potentials[f].sprite)))
			}
		},
		collideGroupVsGroup: function(a, b, d, c, e) {
			if (0 !== a.length && 0 !== b.length && a._container.first._iNext) {
				var f = a._container.first._iNext;
				do f.exists && this.collideSpriteVsGroup(f, b, d, c, e), f = f._iNext; while (f != a._container.last._iNext)
			}
		},
		separate: function(a, b) {
			this._result = this.separateX(a,
				b) || this.separateY(a, b)
		},
		separateX: function(a, b) {
			if (a.immovable && b.immovable) return !1;
			this._overlap = 0;
			if (c.Rectangle.intersects(a, b) && (this._maxOverlap = a.deltaAbsX() + b.deltaAbsX() + this.OVERLAP_BIAS, 0 === a.deltaX() && 0 === b.deltaX() ? (a.embedded = !0, b.embedded = !0) : a.deltaX() > b.deltaX() ? (this._overlap = a.x + a.width - b.x, this._overlap > this._maxOverlap || !1 === a.allowCollision.right || !1 === b.allowCollision.left ? this._overlap = 0 : (a.touching.right = !0, b.touching.left = !0)) : a.deltaX() < b.deltaX() && (this._overlap = a.x - b.width -
				b.x, -this._overlap > this._maxOverlap || !1 === a.allowCollision.left || !1 === b.allowCollision.right ? this._overlap = 0 : (a.touching.left = !0, b.touching.right = !0)), 0 !== this._overlap)) {
				a.overlapX = this._overlap;
				b.overlapX = this._overlap;
				if (a.customSeparateX || b.customSeparateX) return !0;
				this._velocity1 = a.velocity.x;
				this._velocity2 = b.velocity.x;
				a.immovable || b.immovable ? a.immovable ? b.immovable || (b.x += this._overlap, b.velocity.x = this._velocity1 - this._velocity2 * b.bounce.x) : (a.x -= this._overlap, a.velocity.x = this._velocity2 -
					this._velocity1 * a.bounce.x) : (this._overlap *= 0.5, a.x -= this._overlap, b.x += this._overlap, this._newVelocity1 = Math.sqrt(this._velocity2 * this._velocity2 * b.mass / a.mass) * (0 < this._velocity2 ? 1 : -1), this._newVelocity2 = Math.sqrt(this._velocity1 * this._velocity1 * a.mass / b.mass) * (0 < this._velocity1 ? 1 : -1), this._average = 0.5 * (this._newVelocity1 + this._newVelocity2), this._newVelocity1 -= this._average, this._newVelocity2 -= this._average, a.velocity.x = this._average + this._newVelocity1 * a.bounce.x, b.velocity.x = this._average + this._newVelocity2 *
					b.bounce.x);
				a.updateHulls();
				b.updateHulls();
				return !0
			}
			return !1
		},
		separateY: function(a, b) {
			if (a.immovable && b.immovable) return !1;
			this._overlap = 0;
			if (c.Rectangle.intersects(a, b) && (this._maxOverlap = a.deltaAbsY() + b.deltaAbsY() + this.OVERLAP_BIAS, 0 === a.deltaY() && 0 === b.deltaY() ? (a.embedded = !0, b.embedded = !0) : a.deltaY() > b.deltaY() ? (this._overlap = a.y + a.height - b.y, this._overlap > this._maxOverlap || !1 === a.allowCollision.down || !1 === b.allowCollision.up ? this._overlap = 0 : (a.touching.down = !0, b.touching.up = !0)) : a.deltaY() <
				b.deltaY() && (this._overlap = a.y - b.height - b.y, -this._overlap > this._maxOverlap || !1 === a.allowCollision.up || !1 === b.allowCollision.down ? this._overlap = 0 : (a.touching.up = !0, b.touching.down = !0)), 0 !== this._overlap)) {
				a.overlapY = this._overlap;
				b.overlapY = this._overlap;
				if (a.customSeparateY || b.customSeparateY) return !0;
				this._velocity1 = a.velocity.y;
				this._velocity2 = b.velocity.y;
				a.immovable || b.immovable ? a.immovable ? b.immovable || (b.y += this._overlap, b.velocity.y = this._velocity1 - this._velocity2 * b.bounce.y, a.sprite.active &&
					a.moves && a.deltaY() < b.deltaY() && (b.x += a.x - a.lastX)) : (a.y -= this._overlap, a.velocity.y = this._velocity2 - this._velocity1 * a.bounce.y, b.active && b.moves && a.deltaY() > b.deltaY() && (a.x += b.x - b.lastX)) : (this._overlap *= 0.5, a.y -= this._overlap, b.y += this._overlap, this._newVelocity1 = Math.sqrt(this._velocity2 * this._velocity2 * b.mass / a.mass) * (0 < this._velocity2 ? 1 : -1), this._newVelocity2 = Math.sqrt(this._velocity1 * this._velocity1 * a.mass / b.mass) * (0 < this._velocity1 ? 1 : -1), this._average = 0.5 * (this._newVelocity1 + this._newVelocity2),
					this._newVelocity1 -= this._average, this._newVelocity2 -= this._average, a.velocity.y = this._average + this._newVelocity1 * a.bounce.y, b.velocity.y = this._average + this._newVelocity2 * b.bounce.y);
				a.updateHulls();
				b.updateHulls();
				return !0
			}
			return !1
		},
		separateTile: function(a, b) {
			return this._result = this.separateTileX(a, b, !0) || this.separateTileY(a, b, !0)
		},
		separateTileX: function(a, b, d) {
			if (a.immovable || 0 === a.deltaX() || !1 === c.Rectangle.intersects(a.hullX, b)) return !1;
			this._overlap = 0;
			0 > a.deltaX() ? (this._overlap = b.right - a.hullX.x, !1 === a.allowCollision.left || !1 === b.tile.collideRight ? this._overlap = 0 : a.touching.left = !0) : (this._overlap = a.hullX.right - b.x, !1 === a.allowCollision.right || !1 === b.tile.collideLeft ? this._overlap = 0 : a.touching.right = !0);
			return 0 !== this._overlap ? (d && (0 > a.deltaX() ? a.x += this._overlap : a.x -= this._overlap, a.velocity.x = 0 === a.bounce.x ? 0 : -a.velocity.x * a.bounce.x, a.updateHulls()), !0) : !1
		},
		separateTileY: function(a, b, d) {
			if (a.immovable || 0 === a.deltaY() || !1 === c.Rectangle.intersects(a.hullY, b)) return !1;
			this._overlap = 0;
			0 >
				a.deltaY() ? (this._overlap = b.bottom - a.hullY.y, !1 === a.allowCollision.up || !1 === b.tile.collideDown ? this._overlap = 0 : a.touching.up = !0) : (this._overlap = a.hullY.bottom - b.y, !1 === a.allowCollision.down || !1 === b.tile.collideUp ? this._overlap = 0 : a.touching.down = !0);
			return 0 !== this._overlap ? (d && (0 > a.deltaY() ? a.y += this._overlap : a.y -= this._overlap, a.velocity.y = 0 === a.bounce.y ? 0 : -a.velocity.y * a.bounce.y, a.updateHulls()), !0) : !1
		},
		moveToObject: function(a, b, d, c) {
			"undefined" === typeof d && (d = 60);
			"undefined" === typeof c && (c = 0);
			this._angle = Math.atan2(b.y - a.y, b.x - a.x);
			0 < c && (d = this.distanceBetween(a, b) / (c / 1E3));
			a.body.velocity.x = Math.cos(this._angle) * d;
			a.body.velocity.y = Math.sin(this._angle) * d;
			return this._angle
		},
		moveToPointer: function(a, b, d, c) {
			"undefined" === typeof b && (b = 60);
			d = d || this.game.input.activePointer;
			"undefined" === typeof c && (c = 0);
			this._angle = this.angleToPointer(a, d);
			0 < c && (b = this.distanceToPointer(a, d) / (c / 1E3));
			a.body.velocity.x = Math.cos(this._angle) * b;
			a.body.velocity.y = Math.sin(this._angle) * b;
			return this._angle
		},
		moveToXY: function(a, b, d, c, e) {
			"undefined" === typeof c && (c = 60);
			"undefined" === typeof e && (e = 0);
			this._angle = Math.atan2(d - a.y, b - a.x);
			0 < e && (c = this.distanceToXY(a, b, d) / (e / 1E3));
			a.body.velocity.x = Math.cos(this._angle) * c;
			a.body.velocity.y = Math.sin(this._angle) * c;
			return this._angle
		},
		velocityFromAngle: function(a, b, d) {
			"undefined" === typeof b && (b = 60);
			d = d || new c.Point;
			return d.setTo(Math.cos(this.game.math.degToRad(a)) * b, Math.sin(this.game.math.degToRad(a)) * b)
		},
		velocityFromRotation: function(a, b, d) {
			"undefined" === typeof b &&
				(b = 60);
			d = d || new c.Point;
			return d.setTo(Math.cos(a) * b, Math.sin(a) * b)
		},
		accelerationFromRotation: function(a, b, d) {
			"undefined" === typeof b && (b = 60);
			d = d || new c.Point;
			return d.setTo(Math.cos(a) * b, Math.sin(a) * b)
		},
		accelerateToObject: function(a, b, d, c, e) {
			"undefined" === typeof d && (d = 60);
			"undefined" === typeof c && (c = 1E3);
			"undefined" === typeof e && (e = 1E3);
			this._angle = this.angleBetween(a, b);
			a.body.acceleration.setTo(Math.cos(this._angle) * d, Math.sin(this._angle) * d);
			a.body.maxVelocity.setTo(c, e);
			return this._angle
		},
		accelerateToPointer: function(a,
			b, d, c, e) {
			"undefined" === typeof d && (d = 60);
			"undefined" === typeof b && (b = this.game.input.activePointer);
			"undefined" === typeof c && (c = 1E3);
			"undefined" === typeof e && (e = 1E3);
			this._angle = this.angleToPointer(a, b);
			a.body.acceleration.setTo(Math.cos(this._angle) * d, Math.sin(this._angle) * d);
			a.body.maxVelocity.setTo(c, e);
			return this._angle
		},
		accelerateToXY: function(a, b, d, c, e, f) {
			"undefined" === typeof c && (c = 60);
			"undefined" === typeof e && (e = 1E3);
			"undefined" === typeof f && (f = 1E3);
			this._angle = this.angleToXY(a, b, d);
			a.body.acceleration.setTo(Math.cos(this._angle) *
				c, Math.sin(this._angle) * c);
			a.body.maxVelocity.setTo(e, f);
			return this._angle
		},
		distanceBetween: function(a, b) {
			this._dx = a.x - b.x;
			this._dy = a.y - b.y;
			return Math.sqrt(this._dx * this._dx + this._dy * this._dy)
		},
		distanceToXY: function(a, b, d) {
			this._dx = a.x - b;
			this._dy = a.y - d;
			return Math.sqrt(this._dx * this._dx + this._dy * this._dy)
		},
		distanceToPointer: function(a, b) {
			b = b || this.game.input.activePointer;
			this._dx = a.x - b.x;
			this._dy = a.y - b.y;
			return Math.sqrt(this._dx * this._dx + this._dy * this._dy)
		},
		angleBetween: function(a, b) {
			this._dx =
				b.x - a.x;
			this._dy = b.y - a.y;
			return Math.atan2(this._dy, this._dx)
		},
		angleToXY: function(a, b, d) {
			this._dx = b - a.x;
			this._dy = d - a.y;
			return Math.atan2(this._dy, this._dx)
		},
		angleToPointer: function(a, b) {
			b = b || this.game.input.activePointer;
			this._dx = b.worldX - a.x;
			this._dy = b.worldY - a.y;
			return Math.atan2(this._dy, this._dx)
		}
	};
	c.Physics.Arcade.Body = function(a) {
		this.sprite = a;
		this.game = a.game;
		this.offset = new c.Point;
		this.x = a.x;
		this.y = a.y;
		this.preX = a.x;
		this.preY = a.y;
		this.preRotation = a.angle;
		this.screenX = a.x;
		this.screenY = a.y;
		this.sourceWidth = a.currentFrame.sourceSizeW;
		this.sourceHeight = a.currentFrame.sourceSizeH;
		this.width = a.currentFrame.sourceSizeW;
		this.height = a.currentFrame.sourceSizeH;
		this.halfWidth = Math.floor(a.currentFrame.sourceSizeW / 2);
		this.halfHeight = Math.floor(a.currentFrame.sourceSizeH / 2);
		this.center = new c.Point(this.x + this.halfWidth, this.y + this.halfHeight);
		this._sx = a.scale.x;
		this._sy = a.scale.y;
		this.velocity = new c.Point;
		this.acceleration = new c.Point;
		this.drag = new c.Point;
		this.gravity = new c.Point;
		this.bounce =
			new c.Point;
		this.maxVelocity = new c.Point(1E4, 1E4);
		this.angularDrag = this.angularAcceleration = this.angularVelocity = 0;
		this.maxAngular = 1E3;
		this.mass = 1;
		this.skipQuadTree = !1;
		this.quadTreeIDs = [];
		this.quadTreeIndex = -1;
		this.allowCollision = {
			none: !1,
			any: !0,
			up: !0,
			down: !0,
			left: !0,
			right: !0
		};
		this.touching = {
			none: !0,
			up: !1,
			down: !1,
			left: !1,
			right: !1
		};
		this.wasTouching = {
			none: !0,
			up: !1,
			down: !1,
			left: !1,
			right: !1
		};
		this.facing = c.NONE;
		this.immovable = !1;
		this.moves = !0;
		this.rotation = 0;
		this.allowGravity = this.allowRotation = !0;
		this.customSeparateY =
			this.customSeparateX = !1;
		this.overlapY = this.overlapX = 0;
		this.hullX = new c.Rectangle;
		this.hullY = new c.Rectangle;
		this.collideWorldBounds = this.embedded = !1
	};
	c.Physics.Arcade.Body.prototype = {
		updateBounds: function(a, b, d, c) {
			if (d != this._sx || c != this._sy) this.width = this.sourceWidth * d, this.height = this.sourceHeight * c, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this._sx = d, this._sy = c, this.center.setTo(this.x + this.halfWidth, this.y + this.halfHeight)
		},
		preUpdate: function() {
			this.wasTouching.none =
				this.touching.none;
			this.wasTouching.up = this.touching.up;
			this.wasTouching.down = this.touching.down;
			this.wasTouching.left = this.touching.left;
			this.wasTouching.right = this.touching.right;
			this.touching.none = !0;
			this.touching.up = !1;
			this.touching.down = !1;
			this.touching.left = !1;
			this.embedded = this.touching.right = !1;
			this.screenX = this.sprite.worldTransform[2] - this.sprite.anchor.x * this.width + this.offset.x;
			this.screenY = this.sprite.worldTransform[5] - this.sprite.anchor.y * this.height + this.offset.y;
			this.preX = this.sprite.world.x -
				this.sprite.anchor.x * this.width + this.offset.x;
			this.preY = this.sprite.world.y - this.sprite.anchor.y * this.height + this.offset.y;
			this.preRotation = this.sprite.angle;
			this.x = this.preX;
			this.y = this.preY;
			this.rotation = this.preRotation;
			this.moves && (this.game.physics.updateMotion(this), this.collideWorldBounds && this.checkWorldBounds(), this.updateHulls());
			!1 === this.skipQuadTree && !1 === this.allowCollision.none && this.sprite.visible && this.sprite.alive && (this.quadTreeIDs = [], this.quadTreeIndex = -1, this.game.physics.quadTree.insert(this))
		},
		postUpdate: function() {
			0 > this.deltaX() ? this.facing = c.LEFT : 0 < this.deltaX() && (this.facing = c.RIGHT);
			0 > this.deltaY() ? this.facing = c.UP : 0 < this.deltaY() && (this.facing = c.DOWN);
			if (0 !== this.deltaX() || 0 !== this.deltaY()) this.sprite.x += this.deltaX(), this.sprite.y += this.deltaY(), this.center.setTo(this.x + this.halfWidth, this.y + this.halfHeight);
			this.allowRotation && (this.sprite.angle += this.deltaZ())
		},
		updateHulls: function() {
			this.hullX.setTo(this.x, this.preY, this.width, this.height);
			this.hullY.setTo(this.preX, this.y, this.width,
				this.height)
		},
		checkWorldBounds: function() {
			this.x < this.game.world.bounds.x ? (this.x = this.game.world.bounds.x, this.velocity.x *= -this.bounce.x) : this.right > this.game.world.bounds.right && (this.x = this.game.world.bounds.right - this.width, this.velocity.x *= -this.bounce.x);
			this.y < this.game.world.bounds.y ? (this.y = this.game.world.bounds.y, this.velocity.y *= -this.bounce.y) : this.bottom > this.game.world.bounds.bottom && (this.y = this.game.world.bounds.bottom - this.height, this.velocity.y *= -this.bounce.y)
		},
		setSize: function(a,
			b, c, e) {
			c = c || this.offset.x;
			e = e || this.offset.y;
			this.sourceWidth = a;
			this.sourceHeight = b;
			this.width = this.sourceWidth * this._sx;
			this.height = this.sourceHeight * this._sy;
			this.halfWidth = Math.floor(this.width / 2);
			this.halfHeight = Math.floor(this.height / 2);
			this.offset.setTo(c, e);
			this.center.setTo(this.x + this.halfWidth, this.y + this.halfHeight)
		},
		reset: function() {
			this.velocity.setTo(0, 0);
			this.acceleration.setTo(0, 0);
			this.angularAcceleration = this.angularVelocity = 0;
			this.preX = this.sprite.world.x - this.sprite.anchor.x * this.width +
				this.offset.x;
			this.preY = this.sprite.world.y - this.sprite.anchor.y * this.height + this.offset.y;
			this.preRotation = this.sprite.angle;
			this.x = this.preX;
			this.y = this.preY;
			this.rotation = this.preRotation;
			this.center.setTo(this.x + this.halfWidth, this.y + this.halfHeight)
		},
		deltaAbsX: function() {
			return 0 < this.deltaX() ? this.deltaX() : -this.deltaX()
		},
		deltaAbsY: function() {
			return 0 < this.deltaY() ? this.deltaY() : -this.deltaY()
		},
		deltaX: function() {
			return this.x - this.preX
		},
		deltaY: function() {
			return this.y - this.preY
		},
		deltaZ: function() {
			return this.rotation -
				this.preRotation
		}
	};
	Object.defineProperty(c.Physics.Arcade.Body.prototype, "bottom", {
		get: function() {
			return this.y + this.height
		},
		set: function(a) {
			this.height = a <= this.y ? 0 : this.y - a
		}
	});
	Object.defineProperty(c.Physics.Arcade.Body.prototype, "right", {
		get: function() {
			return this.x + this.width
		},
		set: function(a) {
			this.width = a <= this.x ? 0 : this.x + a
		}
	});
	c.Particles = function(a) {
		this.game = a;
		this.emitters = {};
		this.ID = 0
	};
	c.Particles.prototype = {
		add: function(a) {
			return this.emitters[a.name] = a
		},
		remove: function(a) {
			delete this.emitters[a.name]
		},
		update: function() {
			for (var a in this.emitters) this.emitters[a].exists && this.emitters[a].update()
		}
	};
	c.Particles.Arcade = {};
	c.Particles.Arcade.Emitter = function(a, b, d, e) {
		this.maxParticles = e || 50;
		c.Group.call(this, a);
		this.name = "emitter" + this.game.particles.ID++;
		this.type = c.EMITTER;
		this.y = this.x = 0;
		this.height = this.width = 1;
		this.minParticleSpeed = new c.Point(-100, -100);
		this.maxParticleSpeed = new c.Point(100, 100);
		this.maxParticleScale = this.minParticleScale = 1;
		this.minRotation = -360;
		this.maxRotation = 360;
		this.gravity =
			2;
		this.particleClass = null;
		this.particleDrag = new c.Point;
		this.angularDrag = 0;
		this.frequency = 100;
		this.lifespan = 2E3;
		this.bounce = new c.Point;
		this._counter = this._timer = this._quantity = 0;
		this._explode = !0;
		this.on = !1;
		this.exists = !0;
		this.emitX = b;
		this.emitY = d
	};
	c.Particles.Arcade.Emitter.prototype = Object.create(c.Group.prototype);
	c.Particles.Arcade.Emitter.prototype.constructor = c.Particles.Arcade.Emitter;
	c.Particles.Arcade.Emitter.prototype.update = function() {
		if (this.on)
			if (this._explode) {
				this._counter = 0;
				do this.emitParticle(),
					this._counter++; while (this._counter < this._quantity);
				this.on = !1
			} else this.game.time.now >= this._timer && (this.emitParticle(), this._counter++, 0 < this._quantity && this._counter >= this._quantity && (this.on = !1), this._timer = this.game.time.now + this.frequency)
	};
	c.Particles.Arcade.Emitter.prototype.makeParticles = function(a, b, d, e, f) {
		"undefined" == typeof b && (b = 0);
		d = d || this.maxParticles;
		e = e || 0;
		"undefined" == typeof f && (f = !1);
		for (var g, k = 0, l = a, n = 0; k < d;) null == this.particleClass && ("object" == typeof a && (l = this.game.rnd.pick(a)),
			"object" == typeof b && (n = this.game.rnd.pick(b)), g = new c.Sprite(this.game, 0, 0, l, n)), 0 < e ? (g.body.allowCollision.any = !0, g.body.allowCollision.none = !1) : g.body.allowCollision.none = !0, g.body.collideWorldBounds = f, g.exists = !1, g.visible = !1, g.anchor.setTo(0.5, 0.5), this.add(g), k++;
		return this
	};
	c.Particles.Arcade.Emitter.prototype.kill = function() {
		this.exists = this.alive = this.on = !1
	};
	c.Particles.Arcade.Emitter.prototype.revive = function() {
		this.exists = this.alive = !0
	};
	c.Particles.Arcade.Emitter.prototype.start = function(a,
		b, c, e) {
		"boolean" !== typeof a && (a = !0);
		b = b || 0;
		c = c || 250;
		e = e || 0;
		this.revive();
		this.on = this.visible = !0;
		this._explode = a;
		this.lifespan = b;
		this.frequency = c;
		this._quantity = a ? e : this._quantity + e;
		this._counter = 0;
		this._timer = this.game.time.now + c
	};
	c.Particles.Arcade.Emitter.prototype.emitParticle = function() {
		var a = this.getFirstExists(!1);
		if (null != a) {
			1 < this.width || 1 < this.height ? a.reset(this.game.rnd.integerInRange(this.left, this.right), this.game.rnd.integerInRange(this.top, this.bottom)) : a.reset(this.emitX, this.emitY);
			a.lifespan = this.lifespan;
			a.body.bounce.setTo(this.bounce.x, this.bounce.y);
			a.body.velocity.x = this.minParticleSpeed.x != this.maxParticleSpeed.x ? this.game.rnd.integerInRange(this.minParticleSpeed.x, this.maxParticleSpeed.x) : this.minParticleSpeed.x;
			a.body.velocity.y = this.minParticleSpeed.y != this.maxParticleSpeed.y ? this.game.rnd.integerInRange(this.minParticleSpeed.y, this.maxParticleSpeed.y) : this.minParticleSpeed.y;
			a.body.gravity.y = this.gravity;
			a.body.angularVelocity = this.minRotation != this.maxRotation ? this.game.rnd.integerInRange(this.minRotation,
				this.maxRotation) : this.minRotation;
			if (1 !== this.minParticleScale || 1 !== this.maxParticleScale) {
				var b = this.game.rnd.realInRange(this.minParticleScale, this.maxParticleScale);
				a.scale.setTo(b, b)
			}
			a.body.drag.x = this.particleDrag.x;
			a.body.drag.y = this.particleDrag.y;
			a.body.angularDrag = this.angularDrag
		}
	};
	c.Particles.Arcade.Emitter.prototype.setSize = function(a, b) {
		this.width = a;
		this.height = b
	};
	c.Particles.Arcade.Emitter.prototype.setXSpeed = function(a, b) {
		this.minParticleSpeed.x = a || 0;
		this.maxParticleSpeed.x = b || 0
	};
	c.Particles.Arcade.Emitter.prototype.setYSpeed = function(a, b) {
		this.minParticleSpeed.y = a || 0;
		this.maxParticleSpeed.y = b || 0
	};
	c.Particles.Arcade.Emitter.prototype.setRotation = function(a, b) {
		this.minRotation = a || 0;
		this.maxRotation = b || 0
	};
	c.Particles.Arcade.Emitter.prototype.at = function(a) {
		this.emitX = a.center.x;
		this.emitY = a.center.y
	};
	Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "alpha", {
		get: function() {
			return this._container.alpha
		},
		set: function(a) {
			this._container.alpha = a
		}
	});
	Object.defineProperty(c.Particles.Arcade.Emitter.prototype,
		"visible", {
			get: function() {
				return this._container.visible
			},
			set: function(a) {
				this._container.visible = a
			}
		});
	Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "x", {
		get: function() {
			return this.emitX
		},
		set: function(a) {
			this.emitX = a
		}
	});
	Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "y", {
		get: function() {
			return this.emitY
		},
		set: function(a) {
			this.emitY = a
		}
	});
	Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "left", {
		get: function() {
			return Math.floor(this.x - this.width / 2)
		}
	});
	Object.defineProperty(c.Particles.Arcade.Emitter.prototype,
		"right", {
			get: function() {
				return Math.floor(this.x + this.width / 2)
			}
		});
	Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "top", {
		get: function() {
			return Math.floor(this.y - this.height / 2)
		}
	});
	Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "bottom", {
		get: function() {
			return Math.floor(this.y + this.height / 2)
		}
	});
	c.Tile = function(a, b, c, e, f, g) {
		this.tileset = a;
		this.index = b;
		this.width = f;
		this.height = g;
		this.x = c;
		this.y = e;
		this.mass = 1;
		this.collideNone = !0;
		this.collideDown = this.collideUp = this.collideRight =
			this.collideLeft = !1;
		this.separateY = this.separateX = !0;
		this.collisionCallback = null;
		this.collisionCallbackContext = this
	};
	c.Tile.prototype = {
		setCollisionCallback: function(a, b) {
			this.collisionCallbackContext = b;
			this.collisionCallback = a
		},
		destroy: function() {
			this.tileset = null
		},
		setCollision: function(a, b, c, e) {
			this.collideLeft = a;
			this.collideRight = b;
			this.collideUp = c;
			this.collideDown = e;
			this.collideNone = a || b || c || e ? !1 : !0
		},
		resetCollision: function() {
			this.collideNone = !0;
			this.collideDown = this.collideUp = this.collideRight =
				this.collideLeft = !1
		}
	};
	Object.defineProperty(c.Tile.prototype, "bottom", {
		get: function() {
			return this.y + this.height
		}
	});
	Object.defineProperty(c.Tile.prototype, "right", {
		get: function() {
			return this.x + this.width
		}
	});
	c.Tilemap = function(a, b) {
		this.game = a;
		this.layers = null;
		"string" === typeof b ? (this.key = b, this.layers = a.cache.getTilemapData(b).layers, this.calculateIndexes()) : this.layers = [];
		this.currentLayer = 0;
		this.debugMap = [];
		this.dirty = !1;
		this._results = [];
		this._tempB = this._tempA = 0
	};
	c.Tilemap.CSV = 0;
	c.Tilemap.TILED_JSON =
		1;
	c.Tilemap.prototype = {
		create: function(a, b, d) {
			for (var e = [], f = 0; f < d; f++) {
				e[f] = [];
				for (var g = 0; g < b; g++) e[f][g] = 0
			}
			this.layers.push({
				name: a,
				width: b,
				height: d,
				alpha: 1,
				visible: !0,
				tileMargin: 0,
				tileSpacing: 0,
				format: c.Tilemap.CSV,
				data: e,
				indexes: []
			});
			this.currentLayer = this.layers.length - 1;
			this.dirty = !0
		},
		calculateIndexes: function() {
			for (var a = 0; a < this.layers.length; a++) {
				this.layers[a].indexes = [];
				for (var b = 0; b < this.layers[a].height; b++)
					for (var c = 0; c < this.layers[a].width; c++) {
						var e = this.layers[a].data[b][c]; - 1 ===
							this.layers[a].indexes.indexOf(e) && this.layers[a].indexes.push(e)
					}
			}
		},
		setLayer: function(a) {
			this.layers[a] && (this.currentLayer = a)
		},
		putTile: function(a, b, c, e) {
			"undefined" === typeof e && (e = this.currentLayer);
			0 <= b && b < this.layers[e].width && 0 <= c && c < this.layers[e].height && (this.layers[e].data[c][b] = a);
			this.dirty = !0
		},
		getTile: function(a, b, c) {
			"undefined" === typeof c && (c = this.currentLayer);
			if (0 <= a && a < this.layers[c].width && 0 <= b && b < this.layers[c].height) return this.layers[c].data[b][a]
		},
		getTileWorldXY: function(a, b,
			c, e, f) {
			"undefined" === typeof f && (f = this.currentLayer);
			a = this.game.math.snapToFloor(a, c) / c;
			b = this.game.math.snapToFloor(b, e) / e;
			if (0 <= a && a < this.layers[f].width && 0 <= b && b < this.layers[f].height) return this.layers[f].data[b][a]
		},
		putTileWorldXY: function(a, b, c, e, f, g) {
			"undefined" === typeof g && (g = this.currentLayer);
			b = this.game.math.snapToFloor(b, e) / e;
			c = this.game.math.snapToFloor(c, f) / f;
			0 <= b && b < this.layers[g].width && 0 <= c && c < this.layers[g].height && (this.layers[g].data[c][b] = a);
			this.dirty = !0
		},
		copy: function(a, b,
			c, e, f) {
			"undefined" === typeof f && (f = this.currentLayer);
			if (this.layers[f]) {
				"undefined" === typeof a && (a = 0);
				"undefined" === typeof b && (b = 0);
				"undefined" === typeof c && (c = this.layers[f].width);
				"undefined" === typeof e && (e = this.layers[f].height);
				0 > a && (a = 0);
				0 > b && (b = 0);
				c > this.layers[f].width && (c = this.layers[f].width);
				e > this.layers[f].height && (e = this.layers[f].height);
				this._results.length = 0;
				this._results.push({
					x: a,
					y: b,
					width: c,
					height: e,
					layer: f
				});
				for (var g = b; g < b + e; g++)
					for (var k = a; k < a + c; k++) this._results.push({
						x: k,
						y: g,
						index: this.layers[f].data[g][k]
					});
				return this._results
			}
			this._results.length = 0
		},
		paste: function(a, b, c, e) {
			"undefined" === typeof a && (a = 0);
			"undefined" === typeof b && (b = 0);
			"undefined" === typeof e && (e = this.currentLayer);
			if (c && !(2 > c.length)) {
				a = c[1].x - a;
				b = c[1].y - b;
				for (var f = 1; f < c.length; f++) this.layers[e].data[b + c[f].y][a + c[f].x] = c[f].index;
				this.dirty = !0
			}
		},
		swap: function(a, b, c, e, f, g, k) {
			this.copy(c, e, f, g, k);
			2 > this._results.length || (this._tempA = a, this._tempB = b, this._results.forEach(this.swapHandler, this), this.paste(c,
				e, this._results))
		},
		swapHandler: function(a, b) {
			a.index === this._tempA ? this._results[b].index = this._tempB : a.index === this._tempB && (this._results[b].index = this._tempA)
		},
		forEach: function(a, b, c, e, f, g, k) {
			this.copy(c, e, f, g, k);
			2 > this._results.length || (this._results.forEach(a, b), this.paste(c, e, this._results))
		},
		replace: function(a, b, c, e, f, g, k) {
			this.copy(c, e, f, g, k);
			if (!(2 > this._results.length)) {
				for (f = 1; f < this._results.length; f++) this._results[f].index === a && (this._results[f].index = b);
				this.paste(c, e, this._results)
			}
		},
		random: function(a, b, c, e, f) {
			"undefined" === typeof f && (f = this.currentLayer);
			this.copy(a, b, c, e, f);
			if (!(2 > this._results.length)) {
				c = [];
				for (e = 1; e < this._results.length; e++) f = this._results[e].index, -1 === c.indexOf(f) && c.push(f);
				for (e = 1; e < this._results.length; e++) this._results[e].index = this.game.rnd.pick(c);
				this.paste(a, b, this._results)
			}
		},
		shuffle: function(a, b, d, e, f) {
			"undefined" === typeof f && (f = this.currentLayer);
			this.copy(a, b, d, e, f);
			2 > this._results.length || (d = this._results.shift(), c.Utils.shuffle(this._results),
				this._results.unshift(d), this.paste(a, b, this._results))
		},
		fill: function(a, b, c, e, f, g) {
			this.copy(b, c, e, f, g);
			if (!(2 > this._results.length)) {
				for (e = 1; e < this._results.length; e++) this._results[e].index = a;
				this.paste(b, c, this._results)
			}
		},
		removeAllLayers: function() {
			this.currentLayer = this.layers.length = 0
		},
		dump: function() {
			for (var a = "", b = [""], c = 0; c < this.layers[this.currentLayer].height; c++) {
				for (var e = 0; e < this.layers[this.currentLayer].width; e++) a += "%c  ", 1 < this.layers[this.currentLayer].data[c][e] ? this.debugMap[this.layers[this.currentLayer].data[c][e]] ?
					b.push("background: " + this.debugMap[this.layers[this.currentLayer].data[c][e]]) : b.push("background: #ffffff") : b.push("background: rgb(0, 0, 0)");
				a += "\n"
			}
			b[0] = a;
			console.log.apply(console, b)
		},
		destroy: function() {
			this.removeAllLayers();
			this.game = null
		}
	};
	c.TilemapLayer = function(a, b, d, f, h, g, k, l) {
		this.game = a;
		this.canvas = c.Canvas.create(f, h);
		this.context = this.canvas.getContext("2d");
		this.baseTexture = new e.BaseTexture(this.canvas);
		this.texture = new e.Texture(this.baseTexture);
		this.textureFrame = new c.Frame(0,
			0, 0, f, h, "tilemaplayer", a.rnd.uuid());
		c.Sprite.call(this, this.game, b, d, this.texture, this.textureFrame);
		this.type = c.TILEMAPLAYER;
		this.fixedToCamera = !0;
		this.tileset = null;
		this.heightInPixels = this.widthInPixels = this.tileSpacing = this.tileMargin = this.tileHeight = this.tileWidth = 0;
		this.renderWidth = f;
		this.renderHeight = h;
		this._ga = 1;
		this._startY = this._startX = this._maxY = this._maxX = this._tl = this._th = this._tw = this._ty = this._tx = this._dh = this._dw = this._dy = this._dx = 0;
		this._results = [];
		this._prevY = this._prevX = this._y =
			this._x = 0;
		this.scrollFactorY = this.scrollFactorX = 1;
		this.layer = this.tilemap = null;
		this.index = 0;
		this.dirty = !0;
		(g instanceof c.Tileset || "string" === typeof g) && this.updateTileset(g);
		k instanceof c.Tilemap && this.updateMapData(k, l)
	};
	c.TilemapLayer.prototype = Object.create(c.Sprite.prototype);
	c.TilemapLayer.prototype = c.Utils.extend(!0, c.TilemapLayer.prototype, c.Sprite.prototype, e.Sprite.prototype);
	c.TilemapLayer.prototype.constructor = c.TilemapLayer;
	c.TilemapLayer.prototype.update = function() {
		this.scrollX = this.game.camera.x *
			this.scrollFactorX;
		this.scrollY = this.game.camera.y * this.scrollFactorY;
		this.render()
	};
	c.TilemapLayer.prototype.resizeWorld = function() {
		this.game.world.setBounds(0, 0, this.widthInPixels, this.heightInPixels)
	};
	c.TilemapLayer.prototype.updateTileset = function(a) {
		if (a instanceof c.Tileset) this.tileset = a;
		else if ("string" === typeof a) this.tileset = this.game.cache.getTileset("tiles");
		else return;
		this.tileWidth = this.tileset.tileWidth;
		this.tileHeight = this.tileset.tileHeight;
		this.tileMargin = this.tileset.tileMargin;
		this.tileSpacing = this.tileset.tileSpacing;
		this.updateMax()
	};
	c.TilemapLayer.prototype.updateMapData = function(a, b) {
		"undefined" === typeof b && (b = 0);
		a instanceof c.Tilemap && (this.tilemap = a, this.layer = this.tilemap.layers[b], this.index = b, this.updateMax(), this.tilemap.dirty = !0)
	};
	c.TilemapLayer.prototype._fixX = function(a) {
		return 1 === this.scrollFactorX ? a : this._x + (a - this._x / this.scrollFactorX)
	};
	c.TilemapLayer.prototype._unfixX = function(a) {
		return 1 === this.scrollFactorX ? a : this._x / this.scrollFactorX + (a - this._x)
	};
	c.TilemapLayer.prototype._fixY = function(a) {
		return 1 === this.scrollFactorY ? a : this._y + (a - this._y / this.scrollFactorY)
	};
	c.TilemapLayer.prototype._unfixY = function(a) {
		return 1 === this.scrollFactorY ? a : this._y / this.scrollFactorY + (a - this._y)
	};
	c.TilemapLayer.prototype.getTileX = function(a) {
		var b = this.tileWidth * this.scale.x;
		return this.game.math.snapToFloor(this._fixX(a), b) / b
	};
	c.TilemapLayer.prototype.getTileY = function(a) {
		var b = this.tileHeight * this.scale.y;
		return this.game.math.snapToFloor(this._fixY(a), b) / b
	};
	c.TilemapLayer.prototype.getTileXY = function(a, b, c) {
		c.x = this.getTileX(a);
		c.y = this.getTileY(b);
		return c
	};
	c.TilemapLayer.prototype.getTiles = function(a, b, c, e, f) {
		if (null !== this.tilemap) {
			"undefined" === typeof f && (f = !1);
			0 > a && (a = 0);
			0 > b && (b = 0);
			a = this._fixX(a);
			b = this._fixY(b);
			c > this.widthInPixels && (c = this.widthInPixels);
			e > this.heightInPixels && (e = this.heightInPixels);
			var g = this.tileWidth * this.scale.x,
				k = this.tileHeight * this.scale.y;
			this._tx = this.game.math.snapToFloor(a, g) / g;
			this._ty = this.game.math.snapToFloor(b,
				k) / k;
			this._tw = (this.game.math.snapToCeil(c, g) + g) / g;
			this._th = (this.game.math.snapToCeil(e, k) + k) / k;
			this._results = [];
			c = 0;
			c = null;
			var l = e = 0;
			for (a = this._ty; a < this._ty + this._th; a++)
				for (b = this._tx; b < this._tx + this._tw; b++)
					if (this.layer.data[a] && this.layer.data[a][b] && (c = this.layer.data[a][b] - 1, c = this.tileset.getTile(c), e = c.width * this.scale.x, l = c.height * this.scale.y, !1 === f || f && !1 === c.collideNone)) {
						var n = this._unfixX(b * e) / g,
							F = this._unfixY(a * l) / k;
						this._results.push({
							x: n * e,
							right: n * e + e,
							y: F * l,
							bottom: F * l + l,
							width: e,
							height: l,
							tx: n,
							ty: F,
							tile: c
						})
					}
			return this._results
		}
	};
	c.TilemapLayer.prototype.updateMax = function() {
		this._maxX = this.game.math.ceil(this.canvas.width / this.tileWidth) + 1;
		this._maxY = this.game.math.ceil(this.canvas.height / this.tileHeight) + 1;
		this.layer && (this._maxX > this.layer.width && (this._maxX = this.layer.width), this._maxY > this.layer.height && (this._maxY = this.layer.height), this.widthInPixels = this.layer.width * this.tileWidth, this.heightInPixels = this.layer.height * this.tileHeight);
		this.dirty = !0
	};
	c.TilemapLayer.prototype.render =
		function() {
			this.tilemap && this.tilemap.dirty && (this.dirty = !0);
			if (this.dirty && this.tileset && this.tilemap && this.visible) {
				this._prevX = this._dx;
				this._prevY = this._dy;
				this._dx = -(this._x - this._startX * this.tileWidth);
				this._dy = -(this._y - this._startY * this.tileHeight);
				this._tx = this._dx;
				this._ty = this._dy;
				this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
				for (var a = this._startY; a < this._startY + this._maxY; a++) {
					this._column = this.layer.data[a];
					for (var b = this._startX; b < this._startX + this._maxX; b++) {
						var d =
							this.tileset.tiles[this._column[b] - 1];
						d && this.context.drawImage(this.tileset.image, d.x, d.y, this.tileWidth, this.tileHeight, Math.floor(this._tx), Math.floor(this._ty), this.tileWidth, this.tileHeight);
						this._tx += this.tileWidth
					}
					this._tx = this._dx;
					this._ty += this.tileHeight
				}
				this.game.renderType == c.WEBGL && e.texturesToUpdate.push(this.baseTexture);
				this.dirty = !1;
				this.tilemap.dirty && (this.tilemap.dirty = !1);
				return !0
			}
	};
	c.TilemapLayer.prototype.deltaAbsX = function() {
		return 0 < this.deltaX() ? this.deltaX() : -this.deltaX()
	};
	c.TilemapLayer.prototype.deltaAbsY = function() {
		return 0 < this.deltaY() ? this.deltaY() : -this.deltaY()
	};
	c.TilemapLayer.prototype.deltaX = function() {
		return this._dx - this._prevX
	};
	c.TilemapLayer.prototype.deltaY = function() {
		return this._dy - this._prevY
	};
	Object.defineProperty(c.TilemapLayer.prototype, "scrollX", {
		get: function() {
			return this._x
		},
		set: function(a) {
			a !== this._x && 0 <= a && this.layer && (this._x = a, this._x > this.widthInPixels - this.renderWidth && (this._x = this.widthInPixels - this.renderWidth), this._startX = this.game.math.floor(this._x /
				this.tileWidth), 0 > this._startX && (this._startX = 0), this._startX + this._maxX > this.layer.width && (this._startX = this.layer.width - this._maxX), this.dirty = !0)
		}
	});
	Object.defineProperty(c.TilemapLayer.prototype, "scrollY", {
		get: function() {
			return this._y
		},
		set: function(a) {
			a !== this._y && 0 <= a && this.layer && (this._y = a, this._y > this.heightInPixels - this.renderHeight && (this._y = this.heightInPixels - this.renderHeight), this._startY = this.game.math.floor(this._y / this.tileHeight), 0 > this._startY && (this._startY = 0), this._startY + this._maxY >
				this.layer.height && (this._startY = this.layer.height - this._maxY), this.dirty = !0)
		}
	});
	c.TilemapParser = {
		tileset: function(a, b, d, e, f, g, k) {
			var l = a.cache.getTilesetImage(b);
			if (null == l) return null;
			a = l.width;
			var n = l.height;
			0 >= d && (d = Math.floor(-a / Math.min(-1, d)));
			0 >= e && (e = Math.floor(-n / Math.min(-1, e)));
			var F = Math.round(a / d),
				q = Math.round(n / e),
				F = F * q; - 1 !== f && (F = f);
			if (0 === a || 0 === n || a < d || n < e || 0 === F) return console.warn("Phaser.TilemapParser.tileSet: width/height zero or width/height < given tileWidth/tileHeight"), null;
			n = f = g;
			b = new c.Tileset(l, b, d, e, g, k);
			for (l = 0; l < F; l++) b.addTile(new c.Tile(b, l, f, n, d, e)), f += d + k, f === a && (f = g, n += e + k);
			return b
		},
		parse: function(a, b, d) {
			if (d === c.Tilemap.CSV) return this.parseCSV(b);
			if (d === c.Tilemap.TILED_JSON) return this.parseTiledJSON(b)
		},
		parseCSV: function(a) {
			a = a.trim();
			var b = [];
			a = a.split("\n");
			for (var c = a.length, e = 0, f = 0; f < a.length; f++) {
				b[f] = [];
				for (var g = a[f].split(","), k = 0; k < g.length; k++) b[f][k] = parseInt(g[k], 10);
				0 === e && (e = g.length)
			}
			return [{
				name: "csv",
				width: e,
				height: c,
				alpha: 1,
				visible: !0,
				indexes: [],
				tileMargin: 0,
				tileSpacing: 0,
				data: b
			}]
		},
		parseTiledJSON: function(a) {
			for (var b = [], c = 0; c < a.layers.length; c++)
				if (a.layers[c].data) {
					for (var e = {
						name: a.layers[c].name,
						width: a.layers[c].width,
						height: a.layers[c].height,
						alpha: a.layers[c].opacity,
						visible: a.layers[c].visible,
						indexes: [],
						tileMargin: a.tilesets[0].margin,
						tileSpacing: a.tilesets[0].spacing
					}, f = [], g = 0, k, l = 0; l < a.layers[c].data.length; l++) 0 === g && (k = []), k.push(a.layers[c].data[l]), g++, g == a.layers[c].width && (f.push(k), g = 0);
					e.data = f;
					b.push(e)
				}
			return b
		}
	};
	c.Tileset = function(a, b, c, e, f, g) {
		"undefined" === typeof f && (f = 0);
		"undefined" === typeof g && (g = 0);
		this.key = b;
		this.image = a;
		this.tileWidth = c;
		this.tileHeight = e;
		this.margin = f;
		this.spacing = g;
		this.tiles = []
	};
	c.Tileset.prototype = {
		addTile: function(a) {
			this.tiles.push(a);
			return a
		},
		getTile: function(a) {
			return this.tiles[a] ? this.tiles[a] : null
		},
		setSpacing: function(a, b) {
			this.tileMargin = a;
			this.tileSpacing = b
		},
		canCollide: function(a) {
			return this.tiles[a] ? this.tiles[a].collideNone : null
		},
		checkTileIndex: function(a) {
			return this.tiles[a]
		},
		setCollisionRange: function(a, b, c, e, f, g) {
			if (this.tiles[a] && this.tiles[b] && a < b)
				for (; a <= b; a++) this.tiles[a].setCollision(c, e, f, g)
		},
		setCollision: function(a, b, c, e, f) {
			this.tiles[a] && this.tiles[a].setCollision(b, c, e, f)
		}
	};
	Object.defineProperty(c.Tileset.prototype, "total", {
		get: function() {
			return this.tiles.length
		}
	});
	e.CanvasRenderer.prototype.render = function(a) {
		e.texturesToUpdate.length = 0;
		e.texturesToDestroy.length = 0;
		e.visibleCount++;
		a.updateTransform();
		this.context.setTransform(1, 0, 0, 1, 0, 0);
		this.context.clearRect(0,
			0, this.width, this.height);
		this.renderDisplayObject(a);
		0 < e.Texture.frameUpdates.length && (e.Texture.frameUpdates.length = 0)
	};
	e.CanvasRenderer.prototype.renderDisplayObject = function(a) {
		var b = a.last._iNext;
		a = a.first;
		do
			if (a.visible) {
				if (a.renderable && 0 !== a.alpha)
					if (a instanceof e.Sprite) a.texture.frame && (this.context.globalAlpha = a.worldAlpha, a.texture.trimmed ? this.context.setTransform(a.worldTransform[0], a.worldTransform[3], a.worldTransform[1], a.worldTransform[4], a.worldTransform[2] + a.texture.trim.x, a.worldTransform[5] +
						a.texture.trim.y) : this.context.setTransform(a.worldTransform[0], a.worldTransform[3], a.worldTransform[1], a.worldTransform[4], a.worldTransform[2], a.worldTransform[5]), this.context.drawImage(a.texture.baseTexture.source, a.texture.frame.x, a.texture.frame.y, a.texture.frame.width, a.texture.frame.height, a.anchor.x * -a.texture.frame.width, a.anchor.y * -a.texture.frame.height, a.texture.frame.width, a.texture.frame.height));
					else if (a instanceof e.Strip) this.context.setTransform(a.worldTransform[0], a.worldTransform[3],
					a.worldTransform[1], a.worldTransform[4], a.worldTransform[2], a.worldTransform[5]), this.renderStrip(a);
				else if (a instanceof e.TilingSprite) this.context.setTransform(a.worldTransform[0], a.worldTransform[3], a.worldTransform[1], a.worldTransform[4], a.worldTransform[2], a.worldTransform[5]), this.renderTilingSprite(a);
				else if (a instanceof e.CustomRenderable) a.renderCanvas(this);
				else if (a instanceof e.Graphics) this.context.setTransform(a.worldTransform[0], a.worldTransform[3], a.worldTransform[1], a.worldTransform[4],
					a.worldTransform[2], a.worldTransform[5]), e.CanvasGraphics.renderGraphics(a, this.context);
				else if (a instanceof e.FilterBlock)
					if (a.open) {
						this.context.save();
						var c = a.mask.alpha,
							f = a.mask.worldTransform;
						this.context.setTransform(f[0], f[3], f[1], f[4], f[2], f[5]);
						a.mask.worldAlpha = 0.5;
						this.context.worldAlpha = 0;
						e.CanvasGraphics.renderGraphicsMask(a.mask, this.context);
						this.context.clip();
						a.mask.worldAlpha = c
					} else this.context.restore();
				a = a._iNext
			} else a = a.last._iNext;
		while (a != b)
	};
	e.WebGLBatch.prototype.update =
		function() {
			for (var a, b, c, f, h, g, k, l, n, F, q, t = 0, p = this.head; p;) {
				if (p.vcount === e.visibleCount) {
					b = p.texture.frame.width;
					c = p.texture.frame.height;
					f = p.anchor.x;
					h = p.anchor.y;
					g = b * (1 - f);
					b *= -f;
					f = c * (1 - h);
					h = c * -h;
					c = 8 * t;
					a = p.worldTransform;
					k = a[0];
					l = a[3];
					n = a[1];
					F = a[4];
					q = a[2];
					a = a[5];
					p.texture.trimmed && (q += p.texture.trim.x, a += p.texture.trim.y);
					this.verticies[c + 0] = k * b + n * h + q;
					this.verticies[c + 1] = F * h + l * b + a;
					this.verticies[c + 2] = k * g + n * h + q;
					this.verticies[c + 3] = F * h + l * g + a;
					this.verticies[c + 4] = k * g + n * f + q;
					this.verticies[c + 5] = F * f +
						l * g + a;
					this.verticies[c + 6] = k * b + n * f + q;
					this.verticies[c + 7] = F * f + l * b + a;
					if (p.updateFrame || p.texture.updateFrame) this.dirtyUVS = !0, f = p.texture, g = f.frame, b = f.baseTexture.width, f = f.baseTexture.height, this.uvs[c + 0] = g.x / b, this.uvs[c + 1] = g.y / f, this.uvs[c + 2] = (g.x + g.width) / b, this.uvs[c + 3] = g.y / f, this.uvs[c + 4] = (g.x + g.width) / b, this.uvs[c + 5] = (g.y + g.height) / f, this.uvs[c + 6] = g.x / b, this.uvs[c + 7] = (g.y + g.height) / f, p.updateFrame = !1;
					p.cacheAlpha != p.worldAlpha && (p.cacheAlpha = p.worldAlpha, g = 4 * t, this.colors[g] = this.colors[g + 1] =
						this.colors[g + 2] = this.colors[g + 3] = p.worldAlpha, this.dirtyColors = !0)
				} else c = 8 * t, this.verticies[c + 0] = 0, this.verticies[c + 1] = 0, this.verticies[c + 2] = 0, this.verticies[c + 3] = 0, this.verticies[c + 4] = 0, this.verticies[c + 5] = 0, this.verticies[c + 6] = 0, this.verticies[c + 7] = 0;
				t++;
				p = p.__next
			}
	};
	return c
});
var fullscreen = !1,
	lastHeight = 0;
window.onload = function() {
	window.onscroll = function(f) {
		setTimeout(function() {
			window.scrollTo(0, 0)
		}, 0)
	};
	window.addEventListener("resize", resizeGame, !1);
	window.addEventListener("orientationchange", orientationChanged, !1);
	window.ontouchmove = function(f) {
		fullscreen ? (document.body.style.height = lastHeight + "px", setTimeout(function() {
			window.scrollTo(0, 0)
		}, 0), preventDefault(f)) : lastHeight <= window.outerHeight && (lastHeight = window.outerHeight, fullscreen = !0)
	};
	this.game = new Phaser.Game(896, 640, Phaser.CANVAS, null, null, !0);
	language = "en";
	Boot = function(f) {
		this.game = f
	};
	Boot.prototype = {
		preload: function() {
			this.game.load.image("logo_large", "assets/branding/logo_large.png");
			this.game.load.image("logo_small", GameAPI.Branding.getLogo().image);
			this.game.load.image("loading_title", "assets/static/loading_title.png");
			this.game.load.atlas("preloader_animations", "assets/animations/preloader.png", "assets/animations/preloader.json");
			this.game.input.maxPointers = 1;
			this.game.device.desktop && (this.game.stage.scale.maxWidth = 896, this.game.stage.scale.maxHeight =
				640);
			this.game.stage.disableVisibilityChange = !0;
			orientationChanged()
		},
		create: function() {
			this.game.state.start("preloader")
		}
	};
	GameAPI.loadAPI(function(f) {
		this.game.state.add("preloader", Preloader);
		this.game.state.add("splashScreen", SplashScreen);
		this.game.state.add("mainScreen", MainScreen);
		this.game.state.add("storyScreen", StoryScreen);
		this.game.state.add("creditsScreen", CreditsScreen);
		this.game.state.add("levelsScreen", LevelsScreen);
		this.game.state.add("game", Game);
		this.game.state.add("boot", Boot, !0)
	})
};

function preventDefault(f) {
	f = f || window.event;
	f.preventDefault && f.preventDefault();
	f.returnValue = !1
}

function resizeGame() {
	this.game.stage && (fullscreen = !1, lastHeight = window.outerHeight, setTimeout(fitToScreen, 100))
}

function orientationChanged() {
	resizeGame()
}

function fitToScreen() {
	setTimeout(function() {
		window.scrollTo(0, 0)
	}, 0);
	this.game.stage.scaleMode = Phaser.StageScaleMode.SHOW_ALL;
	this.game.stage.scale.setShowAll();
	this.game.stage.disableVisibilityChange = !0;
	this.game.stage.scale.pageAlignHorizontally = !0;
	this.game.stage.scale.pageAlignVertically = !0;
	this.game.stage.scale.refresh()
}
Background = function(f, e) {
	this.game = f;
	this.drawBackground(f, e)
};
Background.prototype = {
	drawBackground: function(f, e) {
		var c = this.game.add.renderTexture("background", this.game.width, this.game.height);
		f.add.sprite(0, 0, c);
		for (var l = new Phaser.Sprite(this.game, 0, 0, "statics"), n = 0 == e ? [
			["floor_dark_1", "floor_dark_2", "floor_dark_3", "floor_dark_2"],
			["floor_dark_2", "floor_dark_1"],
			["floor_dark_3", "floor_dark_2", "floor_dark_1", "floor_dark_2"]
		] : [
			["floor_light_1", "floor_light_2", "floor_light_3", "floor_light_2"],
			["floor_light_2", "floor_light_1"],
			["floor_light_3", "floor_light_2",
				"floor_light_1", "floor_light_2"
			]
		], a = 0, b = 1, d = 0; d < ROWS; d++) {
			0 == a % 2 && 0 < d && (b *= -1);
			for (var x = 0; x < COLUMNS; x++) l.frameName = n[a][x % n[a].length], c.renderXY(l, x * CELL_SIZE, d * CELL_SIZE, !1);
			a += b
		}
		l.destroy()
	},
	destroy: function() {}
};
BaseButton = function(f, e, c, l, n, a) {
	this.game = f;
	Phaser.Sprite.call(this, f, 0, 0, e);
	this.frameName = c;
	this.scale.setTo(a, a);
	this.x = l;
	this.y = n;
	this.anchor.setTo(0.5, 0.5);
	this.inputEnabled = !0;
	this.input.useHandCursor = !0
};
BaseButton.prototype = Object.create(Phaser.Sprite.prototype);
BaseButton.prototype.constructor = BaseButton;
SoundButton = function(f, e, c, l) {
	this.game = f;
	BaseButton.call(this, f, "gui", soundEnabled ? "sound_on_button" : "sound_off_button", e, c, l);
	this.events.onInputDown.add(this.toggleSound, this)
};
SoundButton.prototype = Object.create(BaseButton.prototype);
SoundButton.prototype.constructor = SoundButton;
SoundButton.prototype.toggleSound = function() {
	music && (soundEnabled = !soundEnabled, setSoundEnabled(soundEnabled), this.frameName = soundEnabled ? "sound_on_button" : "sound_off_button", soundEnabled ? music.resume() : music.pause())
};
SoundButton.prototype.onMusicPlay = function() {
	var f = this;
	setTimeout(function() {
		f.checkVisibility()
	}, 1E3)
};
SoundButton.prototype.toggleEnabled = function() {
	this.alpha = 1
};
SoundButton.prototype.checkVisibility = function() {
	music.isPlaying && music._sound && 0 < music._sound.currentTime && this.toggleEnabled()
};
BackButton = function(f, e, c, l) {
	this.game = f;
	BaseButton.call(this, f, "gui", "back_button", e, c, l)
};
BackButton.prototype = Object.create(BaseButton.prototype);
BackButton.prototype.constructor = BackButton;
RestartButton = function(f, e, c, l) {
	this.game = f;
	BaseButton.call(this, f, "gui", "restart_level_button", e, c, l)
};
RestartButton.prototype = Object.create(BaseButton.prototype);
RestartButton.prototype.constructor = RestartButton;
LevelScreenButton = function(f, e, c, l) {
	this.game = f;
	BaseButton.call(this, f, "gui", "levels_screen_button", e, c, l)
};
LevelScreenButton.prototype = Object.create(BaseButton.prototype);
LevelScreenButton.prototype.constructor = LevelScreenButton;
CreditsScreenButton = function(f, e, c, l) {
	this.game = f;
	BaseButton.call(this, f, "gui", "credits_button", e, c, l)
};
CreditsScreenButton.prototype = Object.create(BaseButton.prototype);
CreditsScreenButton.prototype.constructor = CreditsScreenButton;
Logo = function(f, e, c, l) {
	Phaser.Sprite.call(this, f, e, c, l);
	f.add.existing(this);
	this.inputEnabled = !0;
	this.events.onInputDown.add(this.onClick, this);
	this.input.useHandCursor = !0
};
Logo.prototype = Object.create(Phaser.Sprite.prototype);
Logo.prototype.constructor = Logo;
Logo.prototype.onClick = function() {
	var f = this.game.input.mouse.event || this.game.input.touch.event;
	"logo_large" === this.key ? GameAPI.Branding.getSplashScreen().action(f) : GameAPI.Branding.getLogo().action(f)
};
MoreGamesButton = function(f, e, c) {
	Phaser.Button.call(this, f, e, c, "more_games_button", this.onClick, this, 0, 0, 1);
	f.add.existing(this)
};
MoreGamesButton.prototype = Object.create(Phaser.Button.prototype);
MoreGamesButton.prototype.constructor = MoreGamesButton;
MoreGamesButton.prototype.onClick = function() {
	var f = this.game.input.mouse.event || this.game.input.touch.event;
	GameAPI.Branding.getLink("more_games").action(f)
};

function getCookie(f) {
	return (f = document.cookie.match(RegExp("(?:^|; )" + f.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, "\\$1") + "=([^;]*)"))) ? decodeURIComponent(f[1]) : void 0
}

function setCookie(f, e, c) {
	c = c || {};
	var l = c.expires;
	if ("number" == typeof l && l) {
		var n = new Date;
		n.setTime(n.getTime() + 1E3 * l);
		l = c.expires = n
	}
	l && l.toUTCString && (c.expires = l.toUTCString());
	e = encodeURIComponent(e);
	f = f + "=" + e;
	for (var a in c) f += "; " + a, e = c[a], !0 !== e && (f += "=" + e);
	document.cookie = f
}

function deleteCookie(f) {
	setCookie(f, "", {
		expires: -1
	})
}
CreditsScreen = function(f) {
	this.game = f;
	this.buttons = [];
	this.currentPage = 0
};
CreditsScreen.prototype = {
	create: function() {
		this.game.add.sprite(0, 0, "creditsScreen");
		new Logo(this.game, 20, this.game.height - 90, "logo_small");
		this.buttonBack = new BackButton(this.game, 40, 50, 0.8);
		this.buttonBack.events.onInputDown.add(this.back, this);
		this.game.add.existing(this.buttonBack);
		this.buttonSound = new SoundButton(this.game, this.game.width - 40, 50, 0.8);
		this.game.add.existing(this.buttonSound)
	},
	back: function() {
		this.game.state.start("mainScreen", !0)
	},
	shutdown: function() {
		this.buttonBack.destroy();
		this.buttonSound.destroy()
	}
};
DelayedAnimation = function(f, e, c) {
	this.sprite = f;
	this.animation = e;
	this.delay = c || 0;
	this.sprite.events.onAnimationComplete.add(this.onComplete, this)
};
DelayedAnimation.prototype = {
	onComplete: function() {
		var f = this;
		setTimeout(function() {
			f.restart(f.animation)
		}, f.delay)
	},
	restart: function(f) {
		f.restart()
	}
};
DoctorHelper = function(f, e, c) {
	this.game = f;
	Phaser.Group.call(this, f);
	this.icon = this.create(0, 0, "statics");
	this.icon.frameName = "doctor_icon";
	this.icon.scale.setTo(0.8, 0.8);
	this.bubble = new Phaser.Graphics(f, 0, 0);
	this.add(this.bubble);
	this.visible = !1;
	this.x = e;
	this.tempY = c;
	this.timeout = 0;
	this.duration = 4E3
};
DoctorHelper.prototype = Object.create(Phaser.Group.prototype);
DoctorHelper.prototype.constructor = DoctorHelper;
DoctorHelper.prototype.showMessage = function(f, e, c) {
	clearTimeout(this.timeout);
	this.text && this.text.destroy();
	this.text = new Phaser.BitmapText(this.game, 10, 10, f, {
		font: "18px FuturaRound",
		align: "center"
	});
	this.add(this.text);
	this.text.x = 100;
	this.text.y = -this.text.height;
	this.bubble.clear();
	this.bubble.beginFill(0);
	this.duration = e || 4E3;
	this.delay = c || 0;
	f = 0;
	for (var l in this.text.children) e = this.text.children[l], e.position.x + e.texture.width > f && (f = e.position.x + e.texture.width);
	Utils.drawRoundRect(this.bubble,
		this.text.x - 10, this.text.y - 10, f + 15, this.text.height + 20, 15);
	var n = this;
	this.timeout = setTimeout(function() {
		n.show(n)
	}, n.delay)
};
DoctorHelper.prototype.show = function(f) {
	f.visible = !0;
	f.y = f.game.height + 100;
	var e = f.game.add.tween(f);
	e.to({
		y: f.tempY
	}, 300, Phaser.Easing.Back.Out);
	e.start();
	this.time = f.game.time.time; - 1 < f.duration && (f.timeout = setTimeout(function() {
		f.hide(f)
	}, f.duration))
};
DoctorHelper.prototype.hide = function(f) {
	var e = f.game.add.tween(f);
	e.to({
		y: f.game.height + 100
	}, 300, Phaser.Easing.Back.In);
	e.start();
	this.timeout = setTimeout(function() {
		f.visible = !1
	}, 300, f)
};
Enemy = function(f, e, c, l, n, a) {
	this.container = f;
	this.type = e;
	this.fromX = c * CELL_SIZE;
	this.toX = l * CELL_SIZE;
	this.fromY = n * CELL_SIZE;
	this.toY = a * CELL_SIZE;
	this.direction = 0.5 < Math.random() ? -1 : 1;
	this.speed = 0.9;
	this.idle = 0;
	this.x = Math.random() * (this.toX - this.fromX) + this.fromX;
	this.y = Math.random() * (this.toY - this.fromY) + this.fromY;
	this.sprite = f.create(this.fromX, this.fromY, "animations");
	this.sprite.x = this.x;
	this.sprite.y = this.y;
	this.sprite.scale.setTo(0.7, 0.7);
	this.sprite.anchor.y = 0.15;
	this.sprite.animations.add("run",
		Phaser.Animation.generateFrameNames("medic_run", 1, 4, "", 4, !1));
	this.sprite.animations.add("idle", Phaser.Animation.generateFrameNames("medic_idle", 1, 2, "", 4, !1));
	this.setIdle();
	this.paused = !1
};
Enemy.prototype = {
	update: function() {
		150 < this.idle ? this.fromX != this.toX ? (this.x += this.direction * this.speed, this.toX < this.x ? (this.x = this.toX, this.direction *= -1, this.setIdle()) : this.fromX > this.x && (this.x = this.fromX, this.direction *= -1, this.setIdle())) : this.fromY != this.toY && (this.y += this.direction * this.speed, this.toY < this.y ? (this.y = this.toY, this.direction *= -1, this.setIdle()) : this.fromY > this.y && (this.y = this.fromY, this.direction *= -1, this.setIdle())) : (this.idle++, 150 < this.idle && this.setRun());
		this.sprite.x =
			this.x;
		this.sprite.y = this.y
	},
	setIdle: function() {
		this.idle = 0;
		this.sprite.animations.play("idle", 4, !0);
		this.fromX != this.toX && (0 > this.direction ? (this.sprite.scale.x = -0.7, this.sprite.anchor.x = 1) : (this.sprite.scale.x = 0.7, this.sprite.anchor.x = 0))
	},
	setRun: function() {
		this.sprite.animations.play("run", 8, !0)
	},
	checkCollision: function(f) {
		var e = this.sprite.bounds.clone().inflate(-10, -10);
		f = f.bounds.clone().inflate(-10, -10);
		return e.intersects(f)
	},
	destroy: function() {
		this.sprite.destroy()
	}
};
Game = function(f) {
	this.game = f;
	this.offsetY = this.offsetX = 0;
	this.checkCollisions = !0;
	this.died = !1;
	this.intervals = []
};
Game.prototype = {
	create: function() {
		this.startGame();
		this.footstepsSound = this.game.add.audio("footsteps")
	},
	startGame: function() {
		this.loadLevel(LEVEL_NUM);
		this.hero = this.level.hero;
		this.hero.x = CELL_SIZE * this.level.startX + this.offsetX;
		this.hero.y = CELL_SIZE * this.level.startY + this.offsetY;
		this.lastX = this.hero.x;
		this.lastY = this.hero.y;
		this.curX = this.level.startX;
		this.curY = this.level.startY;
		this.game.input.keyboard.addKey(Phaser.Keyboard.LEFT).onDown.add(this.onKeyDown, this);
		this.game.input.keyboard.addKey(Phaser.Keyboard.RIGHT).onDown.add(this.onKeyDown,
			this);
		this.game.input.keyboard.addKey(Phaser.Keyboard.UP).onDown.add(this.onKeyDown, this);
		this.game.input.keyboard.addKey(Phaser.Keyboard.DOWN).onDown.add(this.onKeyDown, this);
		this.inputLayer = this.game.add.sprite(0, 0, "empty");
		this.inputLayer.width = this.game.width;
		this.inputLayer.height = this.game.height;
		this.inputLayer.alpha = 0;
		this.inputLayer.inputEnabled = !0;
		this.game.input.touch.touchMoveCallback = this.onTouchMove.bind(this);
		this.game.input.touch.touchLeaveCallback = this.onTouchMove.bind(this);
		this.inputLayer.events.onInputDown.add(this.onDown,
			this);
		this.inputLayer.events.onInputUp.add(this.onClick, this);
		this.buttonSound = new SoundButton(this.game, this.game.width - 40, 50, 0.8);
		this.game.add.existing(this.buttonSound);
		this.restartButton = new RestartButton(this.game, this.game.width - 100, 50, 0.8);
		this.restartButton.events.onInputDown.add(this.restart, this);
		this.game.add.existing(this.restartButton);
		this.levelScreenButton = new LevelScreenButton(this.game, this.game.width - 160, 50, 0.8);
		this.levelScreenButton.events.onInputDown.add(this.backToLevelsScreen,
			this);
		this.game.add.existing(this.levelScreenButton);
		new Darkness(this.game, !0);
		var f = this;
		this.intervals.push(setTimeout(function() {
			f.unpause(f)
		}, 500));
		(new Logo(this.game, 25, 5, "logo_small")).scale.setTo(0.6, 0.6)
	},
	showPopups: function() {
		1 != LEVEL_NUM || getTutorialComplete("0") ? this.died && !getTutorialComplete("1") ? (this.showHint(getLocalizedString("died"), 2E3), setTutorialComplete("1")) : this.showHint(getLocalizedString("level_start"), 2E3) : (this.showHint(this.game.device.touch ? getLocalizedString("tutorial1_touch",
			2E3) : getLocalizedString("tutorial1_desktop", 2E3)), setTutorialComplete("0"));
		(new PopupText(this.game, 2E3)).showMessage(getLocalizedString("level_title") + LEVEL_NUM)
	},
	showHint: function(f, e) {
		e || (e = 0);
		this.doctorHelper || (this.doctorHelper = new DoctorHelper(this.game, 20, this.game.height - 130));
		this.doctorHelper.showMessage(f, -1, e)
	},
	onClick: function(f) {
		f = this.lastPointerX - this.game.input.activePointer.x;
		var e = this.lastPointerY - this.game.input.activePointer.y;
		10 < f * f + e * e || this.hero.bounds.contains(this.game.input.activePointer.x,
			this.game.input.activePointer.y) && this.doctorHelper.showMessage(getLocalizedString("hero_click"), 2E3)
	},
	onDown: function(f) {
		console.log("DOWN");
		if (!this.busy && !this.gamePaused)
			if (this.lastPointerX = this.game.input.activePointer.x, this.lastPointerY = this.game.input.activePointer.y, this.doctorHelper && this.doctorHelper.visible && 1E3 < this.game.time.time - this.doctorHelper.time && this.doctorHelper.hide(this.doctorHelper), this.game.device.touch) console.log("START TOUCH");
			else {
				var e = f = 0;
				f = this.lastPointerX - this.hero.center.x;
				e = this.lastPointerY - this.hero.center.y;
				Math.abs(f) > Math.abs(e) ? (f = 0 < f ? 1 : -1, e = 0) : (f = 0, e = 0 < e ? 1 : -1);
				0 == f && 0 == e || this.moveHero(f, e)
			}
	},
	onTouchMove: function(f) {
		console.log("MOVE");
		if (!this.busy && !this.gamePaused) {
			var e = f = 0;
			f = this.game.input.activePointer.x - this.lastPointerX;
			e = this.game.input.activePointer.y - this.lastPointerY;
			600 < f * f + e * e && (Math.abs(f) > Math.abs(e) ? (f = 0 < f ? 1 : -1, e = 0) : (f = 0, e = 0 < e ? 1 : -1), 0 == f && 0 == e || this.moveHero(f, e))
		}
	},
	onKeyDown: function() {
		if (this.doctorHelper && this.doctorHelper.visible && 1E3 <
			this.game.time.time - this.doctorHelper.time) this.doctorHelper.hide(this.doctorHelper);
		else if (!this.busy && !this.gamePaused) {
			var f = 0,
				e = 0;
			this.game.input.keyboard.isDown(Phaser.Keyboard.LEFT) ? f = -1 : this.game.input.keyboard.isDown(Phaser.Keyboard.RIGHT) ? f = 1 : this.game.input.keyboard.isDown(Phaser.Keyboard.UP) ? e = -1 : this.game.input.keyboard.isDown(Phaser.Keyboard.DOWN) && (e = 1);
			0 == f && 0 == e || this.moveHero(f, e)
		}
	},
	moveHero: function(f, e, c) {
		totalMoves++; - 1 === startTime && (startTime = this.game.time.time);
		c || this.collectItems(this.curX,
			this.curY);
		this.curX = Math.round((this.hero.x - this.offsetX) / CELL_SIZE);
		this.curY = Math.round((this.hero.y - this.offsetY) / CELL_SIZE);
		this.dirX = f;
		this.dirY = e;
		var l = this.curX;
		if (0 != f)
			for (; - 1 < l && l < COLUMNS; l += f)
				if (void 0 != this.level.getWallAt(l, this.curY)) {
					l -= f;
					break
				}
		if (l == COLUMNS || -1 == l) l -= f;
		f = this.curY;
		if (0 != e)
			for (; - 1 < f && f < ROWS; f += e)
				if (void 0 != this.level.getWallAt(this.curX, f)) {
					f -= e;
					break
				}
		if (f == ROWS || -1 == f) f -= e;
		this.curX == l && this.curY == f ? (c = this.level.getWallAt(this.curX + this.dirX, this.curY + this.dirY)) &&
			this.keysCollected == this.level.totalKeys && c.x == this.level.door.x && c.y == this.level.door.y && this.win() : (this.hero.animations.play("run", 14, !0), this.curX > l ? (this.hero.scale.x = -0.7, this.hero.anchor.x = 1.2) : this.curX < l && (this.hero.scale.x = 0.7, this.hero.anchor.x = -0.2), this.checkCollisions = !1, this.moveTween && this.moveTween.stop(), this.moveTween = this.game.add.tween(this.hero), e = 150 * (Math.abs(this.curX - l) + Math.abs(this.curY - f)), this.curX = l, this.curY = f, this.moveTween.to({
				x: this.curX * CELL_SIZE + this.offsetX,
				y: this.curY *
					CELL_SIZE + this.offsetY
			}, e, Phaser.Easing.Linear.In), this.moveTween.onComplete.add(this.moveComplete, this), this.moveTween.start(), this.lastX = this.hero.x, this.lastY = this.hero.y, this.busy = !0, !c && soundEnabled && (game.device.desktop || game.device.iOS) && this.footstepsSound.play("", 0, 1, !0))
	},
	win: function() {
		var f = [0, 0, 0, 0, 0],
			e = 0,
			c = 0,
			l;
		for (l in this.level.bonuses) {
			var n = this.level.bonuses[l].frameName; - 1 < n.indexOf("switch") || (c++, this.level.bonuses[l].visible || (e++, n == this.level.tileDatas[10].name ? f[3]++ : n ==
				this.level.tileDatas[11].name ? f[0]++ : -1 < n.indexOf("pill") ? f[1]++ : -1 < n.indexOf("star") && f[2]++))
		}
		f[4] = 0 < c ? Math.round(e / c * 3) : 3;
		setLevelScores(LEVEL_NUM, f);
		LEVEL_NUM++;
		if (0 !== LEVEL_NUM % 2) {
			var a = this;
			GameAPI.GameBreak.request(function() {}, function() {
				a.goToTheNextLevel()
			})
		} else this.goToTheNextLevel();
		playSound(this.game, "level_win");
		restarts = 0;
		startTime = -1;
		totalMoves = 0
	},
	goToTheNextLevel: function() {
		void 0 !== LEVEL_DATA[LEVEL_NUM] ? getTotalBonuses() >= LEVEL_DATA[LEVEL_NUM].unlock ? this.game.state.start("game", !0) : (this.game.state.states.levelsScreen.levelToUnlock = LEVEL_NUM, this.game.state.start("levelsScreen", !0)) : (this.game.state.states.storyScreen.mode = "end", this.game.state.start("storyScreen", !0))
	},
	moveComplete: function() {
		var f = this;
		this.intervals.push(setTimeout(function() {
			f.busy = !1;
			f.switchActivated = !1
		}, 50));
		this.footstepsSound.stop();
		var e = this.level.getWallAt(this.curX + this.dirX, this.curY + this.dirY),
			c = this.level.getWallAt(this.curX + 2 * this.dirX, this.curY + 2 * this.dirY);
		if (e && this.keysCollected == this.level.totalKeys &&
			e.x == this.level.door.x && e.y == this.level.door.y) this.update(), this.win();
		else {
			this.playSmashSound(e);
			if (void 0 != e)
				if ("aquarium" == e.frameName) getTutorialComplete("2") || (this.showHint(getLocalizedString("aquarium"), 300), setTutorialComplete("2")), e.frameName = "aquarium_crack1";
				else if ("aquarium_crack1" == e.frameName) {
				getTutorialComplete("3") || (this.showHint(getLocalizedString("aquarium_cracked"), 300), setTutorialComplete("3"));
				var l = this.level.getTileTopAt(this.curX + this.dirX, this.curY + this.dirY);
				l.visible = !1;
				e.visible = !1;
				this.level.setWallAt(this.curX + this.dirX, this.curY + this.dirY, void 0);
				l = this.level.bottomLayer.create(e.x + 0.5 * CELL_SIZE, e.y + 0.5 * CELL_SIZE, "statics");
				l.frameName = "fish_puddle";
				l.anchor.setTo(0.5, 0.5)
			}
			if (void 0 != e && void 0 == c && -1 == e.frameName.indexOf("wall")) {
				e.x = (this.curX + this.dirX) * CELL_SIZE;
				e.y = (this.curY + this.dirY) * CELL_SIZE;
				c = this.game.add.tween(e);
				c.to({
					x: e.x + 10 * this.dirX,
					y: e.y + 10 * this.dirY
				}, 200, Phaser.Easing.Exponential.Out, !1, 0, 1, !0);
				c.start();
				if (l = this.level.getTileTopAt(this.curX +
					this.dirX, this.curY + this.dirY)) l.x = e.x, l.y = e.y + this.level.tileDatas[this.level.getTileId(e)].offsetY, e = this.game.add.tween(l), e.to({
					x: l.x + 10 * this.dirX,
					y: l.y + 10 * this.dirY
				}, 200, Phaser.Easing.Exponential.Out, !1, 0, 1, !0), e.start();
				this.moveTween = this.game.add.tween(this.hero);
				this.moveTween.to({
					x: this.hero.x - 8 * this.dirX,
					y: this.hero.y - 8 * this.dirY
				}, 200, Phaser.Easing.Exponential.Out, !1, 0, 1, !0);
				this.moveTween.start()
			}
			this.hero.animations.play("idle", 4, !0)
		}
	},
	update: function() {
		if (!this.gamePaused) {
			var f = 0.25 *
				CELL_SIZE;
			if (Math.abs(this.lastX - this.hero.x) > f || Math.abs(this.lastY - this.hero.y) > f) {
				this.lastX = this.hero.x;
				this.lastY = this.hero.y;
				var f = Math.round((this.hero.x - this.offsetX) / CELL_SIZE),
					e = Math.round((this.hero.y - this.offsetY) / CELL_SIZE);
				this.collectItems(f, e)
			}
			if (this.checkCollisions)
				for (f = this.level.enemies.length, e = 0; e < f; e++)
					if (this.level.enemies[e].update(), this.level.enemies[e].checkCollision(this.hero)) {
						this.moveTween && this.moveTween.stop();
						this.level.enemies[e].sprite.visible = !1;
						this.hero.visible = !1;
						this.fight = this.level.middleLayer.create(this.hero.center.x, this.hero.center.y, "animations");
						this.fight.anchor.setTo(0.5, 0.5);
						this.fight.animations.add("battle", Phaser.Animation.generateFrameNames("battle", 1, 2, "", 4, !1));
						this.fight.animations.play("battle", 12, !0);
						playSound(this.game, "enemy_fight");
						this.footstepsSound.stop();
						this.gamePaused = this.died = !0;
						new Darkness(this.game, !1, 500);
						var c = this;
						this.intervals.push(setTimeout(function() {
							c.restart(c.game)
						}, 900));
						return
					}
			this.checkCollisions || (this.checkCollisions = !0)
		}
	},
	collectItems: function(f, e) {
		var c = this.level.getKeyAt(f, e);
		void 0 != c && c.visible && (c.visible = !1, this.keysCollected++, playSound(this.game, "bonus"), this.keysCollected == this.level.totalKeys && (c = this.game.add.sprite(this.level.door.x, this.level.door.y, "animations"), c.animations.add("door", Phaser.Animation.generateFrameNames("portal_opened", 1, 2, "", 4, !1)), c.animations.play("door", 2, !0), this.level.door.visible = !1, this.level.door = c, this.level.keyBubble.visible = !1));
		c = this.level.getBonusAt(f, e);
		void 0 !=
			c && c.visible && (-1 != c.frameName.indexOf("switch") ? this.toggleSwitch(c) : (playSound(this.game, "bonus"), c.visible = !1));
		c = this.level.getTrapAt(f, e);
		if (void 0 != c) {
			this.moveTween && this.moveTween.stop();
			c.visible = !1;
			this.hero.visible = !1;
			this.fight = this.game.add.sprite(this.hero.center.x, this.hero.center.y, "animations");
			this.fight.anchor.setTo(0.5, 0.5);
			this.fight.animations.add("battle", Phaser.Animation.generateFrameNames("battle", 1, 2, "", 4, !1));
			this.fight.animations.play("battle", 12, !0);
			playSound(this.game,
				"enemy_fight");
			this.footstepsSound.stop();
			this.gamePaused = this.died = !0;
			new Darkness(this.game, !1, 500);
			var l = this;
			this.intervals.push(setTimeout(function() {
				l.restart(l.game)
			}, 900))
		}
	},
	toggleSwitch: function(f) {
		if (!this.switchActivated) {
			playSound(this.game, "lever");
			f.frameName = "switch_1" != f.frameName || this.switchedOn ? "switch_1" : "switch_2";
			this.switchedOn = !this.switchedOn;
			this.switchActivated = !0;
			var e = LEVEL_DATA[LEVEL_NUM].toggles,
				c;
			for (c in e)
				if (f = e[c], this.switchedOn) {
					var l = this.level.getWallAt(f.fromX,
						f.fromY);
					void 0 != l && (this.moveTileTo(l, f.toX, f.toY, f.fromX, f.fromY), this.level.setWallAt(f.fromX, f.fromY, void 0), this.level.setWallAt(f.toX, f.toY, l))
				} else l = this.level.getWallAt(f.toX, f.toY), void 0 != l && (this.moveTileTo(l, f.fromX, f.fromY, f.toX, f.toY), this.level.setWallAt(f.toX, f.toY, void 0), this.level.setWallAt(f.fromX, f.fromY, l));
			this.moveHero(this.dirX, this.dirY, !0);
			var n = this;
			this.intervals.push(setTimeout(function() {
				n.switchActivated = !1
			}, 200))
		}
	},
	moveTileTo: function(f, e, c, l, n) {
		var a = this.level.getTileId(f),
			a = this.level.tileDatas[a];
		if (a.composite) {
			var b = this.level.getTileTopAt(l, n);
			b && (this.level.setTileTopAt(l, n, void 0), this.level.setTileTopAt(e, c, b), l = this.game.add.tween(b), l.to({
				x: e * CELL_SIZE + a.offsetX,
				y: c * CELL_SIZE + a.offsetY
			}, 500, Phaser.Easing.Exponential.Out), l.start())
		}
		f = this.game.add.tween(f);
		f.to({
			x: e * CELL_SIZE,
			y: c * CELL_SIZE
		}, 500, Phaser.Easing.Exponential.Out);
		f.start()
	},
	playSmashSound: function(f) {
		void 0 === f || -1 < f.frameName.indexOf("wall") ? playSound(this.game, "wall_smash") : -1 < f.frameName.indexOf("bed") ?
			playSound(this.game, "bed_smash") : -1 < f.frameName.indexOf("door_closed") ? playSound(this.game, "wall_smash") : -1 < f.frameName.indexOf("table") ? playSound(this.game, "table_smash") : -1 < f.frameName.indexOf("drugs") ? playSound(this.game, "drugs_smash") : -1 < f.frameName.indexOf("aquarium_crack1") ? playSound(this.game, "aquarium_broken") : -1 < f.frameName.indexOf("aquarium") && playSound(this.game, "aquarium_cracked")
	},
	unpause: function(f) {
		f.gamePaused = !1;
		f.showPopups();
		this.died = !1
	},
	restart: function(f) {
		this.game ? this.game.state.start("game", !0) : f.state.start("game", !0);
		restarts++
	},
	backToLevelsScreen: function() {
		this.game.state.start("levelsScreen", !0)
	},
	loadLevel: function(f) {
		this.level = new Level(this.game, LEVEL_DATA[f]);
		this.busy = !1;
		this.c = this.keysCollected = 0;
		this.gamePaused = !0;
		this.switchActivated = this.switchedOn = !1
	},
	shutdown: function() {
		this.moveTween && (this.moveTween.stop(), this.moveTween.onComplete.removeAll());
		this.moveTween = null;
		this.wallTween && (this.wallTween.stop(), this.wallTween.onComplete.removeAll());
		this.wallTween = null;
		this.wallTopTween &&
			(this.wallTopTween.stop(), this.wallTopTween.onComplete.removeAll());
		this.wallTopTween = null;
		this.tileTween && (this.tileTween.stop(), this.tileTween.onComplete.removeAll());
		this.tileTween = null;
		this.tileTopTween && (this.tileTopTween.stop(), this.tileTopTween.onComplete.removeAll());
		this.tileTopTween = null;
		for (this.level.dispose(); 0 < this.intervals.length;) clearTimeout(this.intervals.pop());
		this.footstepsSound && this.footstepsSound.stop();
		this.doctorHelper = null
	}
};
Darkness = function(f, e, c, l) {
	this.game = f;
	l || (l = 400);
	this.darkness = this.game.add.graphics(0, 0);
	this.darkness.beginFill(0);
	this.darkness.drawRect(0, 0, this.game.width, this.game.height);
	this.darknessTween = this.game.add.tween(this.darkness);
	e ? this.darknessTween.to({
		alpha: 0
	}, l, Phaser.Easing.Quadratic.In, !0, c) : (this.darkness.alpha = 0, this.darknessTween.to({
		alpha: 1
	}, l, Phaser.Easing.Quadratic.Out, !0, c))
};
var restarts = 0,
	startTime = -1,
	totalMoves = 0;
Level = function(f, e) {
	this.game = f;
	this.walls = [];
	this.keys = [];
	this.bonuses = [];
	this.traps = [];
	this.totalKeys = 0;
	this.objects = [];
	this.enemies = [];
	this.tilesTop = [];
	this.tileDatas = [];
	this.tileDatas[1] = {
		name: "upper_wall",
		code: 1,
		offsetX: 0,
		offsetY: 0,
		scale: 1
	};
	this.tileDatas[2] = {
		name: "upper_wall_t",
		code: 2,
		offsetX: 0,
		offsetY: 0,
		scale: 1
	};
	this.tileDatas[3] = {
		name: "wall_vertical",
		code: 3,
		offsetX: 0,
		offsetY: 0,
		scale: 1
	};
	this.tileDatas[4] = {
		name: "wall_vertical_end",
		code: 4,
		offsetX: 0,
		offsetY: 0,
		scale: 1
	};
	this.tileDatas[5] = {
		name: "aquarium",
		code: 5,
		offsetX: 0,
		offsetY: -13,
		scale: 1,
		composite: !0
	};
	this.tileDatas[6] = {
		name: "bed_1",
		code: 6,
		offsetX: 0,
		offsetY: -14,
		scale: 1,
		composite: !0
	};
	this.tileDatas[7] = {
		name: "bed_2",
		code: 7,
		offsetX: 0,
		offsetY: -14,
		scale: 1,
		composite: !0
	};
	this.tileDatas[8] = {
		name: "bed_3",
		code: 8,
		offsetX: 0,
		offsetY: -18,
		scale: 1,
		composite: !0
	};
	this.tileDatas[9] = {
		name: "bed_4",
		code: 9,
		offsetX: 0,
		offsetY: -18,
		scale: 1,
		composite: !0
	};
	this.tileDatas[10] = {
		name: "bottle",
		code: 10,
		offsetX: 12,
		offsetY: 10,
		scale: 1
	};
	this.tileDatas[11] = {
		name: "capsule",
		code: 11,
		offsetX: 15,
		offsetY: 15,
		scale: 1
	};
	this.tileDatas[12] = {
		name: "door_closed",
		code: 12,
		offsetX: 0,
		offsetY: -23,
		scale: 1,
		composite: !0
	};
	this.tileDatas[13] = {
		name: "drugs",
		code: 13,
		offsetX: 0,
		offsetY: -16,
		scale: 1,
		composite: !0
	};
	this.tileDatas[14] = {
		name: "table",
		code: 14,
		offsetX: 0,
		offsetY: -2,
		scale: 1
	};
	this.tileDatas[19] = {
		name: "wall_vertical_start",
		code: 19,
		offsetX: 0,
		offsetY: 0,
		scale: 1
	};
	this.tileDatas[20] = {
		name: "window_wall",
		code: 20,
		offsetX: 0,
		offsetY: 0,
		scale: 1
	};
	this.tileDatas[21] = {
		name: "switch_1",
		code: 21,
		offsetX: 14,
		offsetY: 14,
		scale: 0.6
	};
	this.parseLevel(e)
};
Level.prototype = {
	parseLevel: function(f) {
		this.width = f.width;
		this.height = f.height;
		this.data = f.data;
		this.startX = f.startX;
		this.startY = f.startY;
		COLUMNS = this.width;
		ROWS = this.height;
		this.background = new Background(this.game, LEVEL_NUM % 2);
		this.bottomLayer = this.game.add.group();
		this.middleLayer = this.game.add.group();
		this.topLayer = this.game.add.group();
		this.drawLevel();
		this.hero = this.middleLayer.create(0, 0, "animations");
		this.hero.scale.setTo(0.7, 0.7);
		this.hero.anchor.setTo(-0.2, 0);
		this.hero.animations.add("run", Phaser.Animation.generateFrameNames("loony_run",
			1, 2, "", 4, !1));
		this.hero.animations.add("idle", Phaser.Animation.generateFrameNames("loony_idle", 1, 2, "", 4, !1));
		this.hero.animations.play("idle", 4, !0);
		f = f.enemies;
		for (var e in f) {
			var c = f[e];
			this.enemies[e] = new Enemy(this.middleLayer, c.type, c.fromX, c.toX, c.fromY, c.toY)
		}
	},
	drawLevel: function() {
		for (var f = 0; f < this.data.length; f++) {
			var e = this.data[f],
				c = this.addTileByCode(f % this.width * CELL_SIZE, Math.floor(f / this.width) * CELL_SIZE, e, f);
			0 != e && (this.isBonus(e) ? (16 == e ? (c = this.bottomLayer.create(f % this.width * CELL_SIZE,
					Math.floor(f / this.width) * CELL_SIZE, "animations"), c.animations.add("pill", Phaser.Animation.generateFrameNames("pill", 1, 2, "", 4, !1)), c.animations.play("pill", 1, !0), c.scale.setTo(0.8, 0.8), c.anchor.setTo(-0.4, -0.2)) : 17 == e && (c = this.bottomLayer.create(f % this.width * CELL_SIZE, Math.floor(f / this.width) * CELL_SIZE, "animations"), c.animations.add("star", Phaser.Animation.generateFrameNames("star", 1, 2, "", 4, !1)), c.animations.play("star", 2, !0), c.scale.setTo(0.7, 0.7), c.anchor.setTo(-0.4, -0.1)), this.bonuses[f] = c) : this.isKey(e) ?
				(c = this.bottomLayer.create(f % this.width * CELL_SIZE, Math.floor(f / this.width) * CELL_SIZE, "animations"), new DelayedAnimation(c, c.animations.add("key", Phaser.Animation.generateFrameNames("key", 1, 5, "", 4, !1)), 2E3 * Math.random() + 3E3), c.animations.play("key", 10), c.scale.setTo(0.7, 0.7), c.anchor.setTo(-0.2, -0.1), this.keys[f] = c, this.totalKeys++) : this.isDoor(e) ? (this.door = c, this.doorX = f % this.width, this.doorY = Math.floor(f / this.width), this.keyBubble = this.topLayer.create(this.doorX * CELL_SIZE + 0.7 * CELL_SIZE, this.doorY *
					CELL_SIZE - 40, "statics"), this.keyBubble.frameName = "key_bubble", this.walls[f] = c) : this.isTrap(e) ? (c = this.bottomLayer.create(f % this.width * CELL_SIZE, Math.floor(f / this.width) * CELL_SIZE, "animations"), c.animations.add("monster", Phaser.Animation.generateFrameNames("monster_red", 1, 2, "", 4, !1)), c.animations.play("monster", 1, !0), c.scale.setTo(0.7, 0.7), this.traps[f] = c) : this.walls[f] = c, c && (this.objects[f] = c))
		}
	},
	addTileByCode: function(f, e, c, l) {
		if (c = this.tileDatas[c]) {
			var n = this.bottomLayer.create(f, e, "statics");
			n.frameName = c.name;
			c.composite ? (f = this.topLayer.create(f, e, "statics"), f.frameName = c.name + "_top", f.x += c.offsetX, f.y += c.offsetY, this.tilesTop[l] = f) : (n.x += c.offsetX, n.y += c.offsetY, n.scale.x = n.scale.y = parseFloat(c.scale));
			return n
		}
	},
	getTileTopAt: function(f, e) {
		return 0 > f || f >= COLUMNS || 0 > e || e >= ROWS ? void 0 : this.tilesTop[f + e * COLUMNS]
	},
	setTileTopAt: function(f, e, c) {
		this.tilesTop[f + e * COLUMNS] = c
	},
	getWallAt: function(f, e) {
		return 0 > f || f >= COLUMNS || 0 > e || e >= ROWS ? void 0 : this.walls[f + e * COLUMNS]
	},
	setWallAt: function(f,
		e, c) {
		this.walls[f + e * COLUMNS] = c
	},
	getKeyAt: function(f, e) {
		return 0 > f || f >= COLUMNS || 0 > e || e >= ROWS ? void 0 : this.keys[f + e * COLUMNS]
	},
	getBonusAt: function(f, e) {
		return 0 > f || f >= COLUMNS || 0 > e || e >= ROWS ? void 0 : this.bonuses[f + e * COLUMNS]
	},
	getTrapAt: function(f, e) {
		return 0 > f || f >= COLUMNS || 0 > e || e >= ROWS ? void 0 : this.traps[f + e * COLUMNS]
	},
	isKey: function(f) {
		return 18 == f
	},
	isBonus: function(f) {
		return 10 == f || 11 == f || 16 == f || 17 == f || 21 == f
	},
	isTrap: function(f) {
		return 15 == f
	},
	isDoor: function(f) {
		return 12 == f
	},
	getTileId: function(f) {
		for (var e in this.tileDatas)
			if (-1 !==
				f.frameName.indexOf(this.tileDatas[e].name)) return this.tileDatas[e].code;
		return null
	},
	dispose: function() {
		for (var f in this.objects) this.objects[f] && this.objects[f].destroy();
		this.objects = null;
		for (f in this.tilesTop) this.tilesTop[f] && this.tilesTop[f].destroy();
		this.traps = this.bonuses = this.keys = this.walls = this.tilesTop = null;
		this.totalKeys = 0;
		for (f in this.enemies) this.enemies[f].destroy();
		this.enemies = null;
		this.keyBubble.destroy();
		this.background.destroy()
	}
};
LevelsScreen = function(f) {
	this.game = f;
	this.buttons = [];
	this.currentPage = 0
};
LevelsScreen.prototype = {
	create: function() {
		for (var f = new Phaser.Graphics(this.game, 0, 0), e = [
			[8307154, 8964820, 10997471, 8964820],
			[8964820, 10997471],
			[10997471, 8964820, 8307154, 8964820]
		], c = 0, l = 1, n = 0; n < ROWS; n++) {
			0 == c % 2 && 0 < n && (l *= -1);
			for (var a = 0; a < COLUMNS; a++) f.beginFill(e[c][a % e[c].length]), f.drawRect(a * CELL_SIZE, n * CELL_SIZE, CELL_SIZE, CELL_SIZE);
			c += l
		}
		e = this.game.add.renderTexture("background", this.game.width, this.game.height);
		e.renderXY(f, 0, 0);
		game.add.sprite(0, 0, e);
		f.destroy();
		new Logo(this.game, 20, this.game.height -
			90, "logo_small");
		new MoreGamesButton(this.game, this.game.width - 200, this.game.height - 90);
		this.levels = [];
		for (n in LEVEL_DATA) this.levels.push({
			id: n,
			unlock: LEVEL_DATA[n].unlock
		});
		this.pagesNum = Math.ceil(this.levels.length / 12);
		f = 0.5 * (this.game.width - 22 * this.pagesNum - 30 * (this.pagesNum - 1));
		for (n = 0; n < this.pagesNum; n++) e = this.game.add.sprite(f + 50 * n, this.game.height - 130, "gui"), e.frameName = "level_button_back", e.scale.setTo(0.2, 0.2), e.name = n, e.inputEnabled = !0, e.input.useHandCursor = !0, e.events.onInputDown.add(this.openPage,
			this);
		this.drawStats();
		this.activePageMarker = this.game.add.sprite(f + 4, this.game.height - 126, "gui");
		this.activePageMarker.frameName = "active_page";
		this.showPage(this.currentPage);
		this.leftArrow = this.game.add.sprite(50, 0.5 * this.game.height, "gui");
		this.leftArrow.frameName = "level_page_arrow";
		this.leftArrow.anchor.setTo(0.5, 0.5);
		this.leftArrow.inputEnabled = !0;
		this.leftArrow.input.useHandCursor = !0;
		this.leftArrow.events.onInputDown.add(this.scrollLeft, this);
		this.rightArrow = this.game.add.sprite(this.game.width -
			50, 0.5 * this.game.height, "gui");
		this.rightArrow.frameName = "level_page_arrow";
		this.rightArrow.scale.x = -1;
		this.rightArrow.anchor.setTo(0.5, 0.5);
		this.rightArrow.inputEnabled = !0;
		this.rightArrow.input.useHandCursor = !0;
		this.rightArrow.events.onInputDown.add(this.scrollRight, this);
		this.buttonBack = new BackButton(this.game, 40, 50, 0.8);
		this.buttonBack.events.onInputDown.add(this.back, this);
		this.game.add.existing(this.buttonBack);
		this.buttonSound = new SoundButton(this.game, this.game.width - 40, 50, 0.8);
		this.game.add.existing(this.buttonSound);
		this.doctorHelper = new DoctorHelper(this.game, 20, this.game.height - 130);
		this.levelToUnlock && -1 != this.levelToUnlock && (n = LEVEL_DATA[this.levelToUnlock].unlock, this.doctorHelper.showMessage(getLocalizedString("not_enough_bonuses").split("###").join(n - this.totalBonuses + ""), 2E3), this.levelToUnlock = -1)
	},
	scrollLeft: function() {
		0 < this.currentPage && (this.currentPage--, this.showPage(this.currentPage))
	},
	scrollRight: function() {
		this.currentPage < this.pagesNum - 1 && (this.currentPage++, this.showPage(this.currentPage))
	},
	showPage: function(f) {
		this.activePageMarker.x = 0.5 * (this.game.width - 22 * this.pagesNum - 30 * (this.pagesNum - 1)) + 50 * f + 4;
		for (var e = 0; e < this.buttons.length; e++) this.buttons[e].destroy();
		this.buttons = [];
		this.createButtons(f);
		this.currentPage = f
	},
	createButtons: function(f) {
		f *= 12;
		for (var e = Math.min(12, this.levels.length - f), c = 0; c < e; c++) {
			if (0 < c + f && !getLevelScores(this.levels[c + f - 1].id)) var l = new LevelLockedButton(this.game);
			else this.levels[c + f].unlock > this.totalBonuses ? l = new LevelLockedButton(this.game, this.levels[c +
				f].unlock) : (l = getLevelScores(this.levels[c + f].id), l = new LevelButton(this.game, this.levels[c + f].id, l ? l[4] : 0));
			l.x = c % 4 * 177 + 0.5 * (this.game.width - 708 + 70);
			l.y = -300;
			this.buttons.push(l);
			this.tween = this.game.add.tween(l);
			this.tween.to({
				y: 152 * Math.floor(c / 4) + 0.5 * (this.game.height - 456) - 30
			}, 1E3, Phaser.Easing.Elastic.Out, !0, 50 * c)
		}
	},
	drawStats: function() {
		this.stats = this.game.add.sprite(0.5 * this.game.width, this.game.height - 60, "gui");
		this.stats.frameName = "stats";
		this.stats.anchor.setTo(0.5, 0.5);
		for (var f = [0, 0, 0,
			0, 0
		], e = 0, c = 0, l = 0, n = 0, a = 0; a < this.levels.length; a++)
			if (f = getLevelScores(this.levels[a].id)) e += parseInt(f[0]), c += parseInt(f[1]), l += parseInt(f[2]), n += parseInt(f[3]);
		this.totalBonuses = e + c + l + n;
		this.capsuleCollectedText = this.game.add.bitmapText(this.stats.x - 0.5 * this.stats.width + 70, this.stats.y + 4, e + "", {
			font: "20px ComickBook"
		});
		this.capsuleCollectedText.anchor.setTo(0, 0.5);
		this.pillsCollectedText = this.game.add.bitmapText(this.stats.x - 0.5 * this.stats.width + 170, this.stats.y + 4, c + "", {
			font: "20px ComickBook"
		});
		this.pillsCollectedText.anchor.setTo(0,
			0.5);
		this.starsCollectedText = this.game.add.bitmapText(this.stats.x - 0.5 * this.stats.width + 265, this.stats.y + 4, l + "", {
			font: "20px ComickBook"
		});
		this.starsCollectedText.anchor.setTo(0, 0.5);
		this.bottlesCollectedText = this.game.add.bitmapText(this.stats.x - 0.5 * this.stats.width + 356, this.stats.y + 4, n + "", {
			font: "20px ComickBook"
		});
		this.bottlesCollectedText.anchor.setTo(0, 0.5)
	},
	openPage: function(f) {
		this.showPage(parseInt(f.name))
	},
	back: function() {
		this.game.state.start("mainScreen", !0)
	},
	shutdown: function() {
		for (var f =
			0; f < this.buttons.length; f++) this.buttons[f].destroy();
		this.buttons = [];
		this.leftArrow.destroy();
		this.rightArrow.destroy();
		this.buttonBack.destroy();
		this.buttonSound.destroy();
		this.doctorHelper.destroy();
		this.capsuleCollectedText.destroy();
		this.pillsCollectedText.destroy();
		this.starsCollectedText.destroy();
		this.bottlesCollectedText.destroy()
	}
};
LevelButton = function(f, e, c) {
	this.game = f;
	this.number = e;
	Phaser.Group.call(this, f);
	this.back = this.create(0, 0, "gui");
	this.back.frameName = "level_button_back";
	this.back.inputEnabled = !0;
	this.back.input.useHandCursor = !0;
	this.back.events.onInputDown.add(this.onClick, this);
	this.text = new Phaser.BitmapText(f, 0.5 * this.back.width - 2, 0.5 * this.back.height - 5, e + "", {
		font: "ComickBook"
	});
	this.text.anchor.setTo(0.5, 0.5);
	this.add(this.text);
	this.stars = [];
	for (f = 0; 3 > f; f++) e = this.create(0, 0, "gui"), e.frameName = f < c ? "star_filled" :
		"star_empty", e.x = 0.5 * (this.back.width - 3 * (e.width + 4)) + (e.width + 5) * f, e.y = this.back.height - e.height - 15, this.stars[f] = e
};
LevelButton.prototype = Object.create(Phaser.Group.prototype);
LevelButton.prototype.constructor = LevelButton;
LevelButton.prototype.onClick = function() {
	LEVEL_NUM = this.number;
	1 != LEVEL_NUM || getIntroViewed() ? this.game.state.start("game", !0) : (this.game.state.states.storyScreen.mode = "begin", this.game.state.start("storyScreen", !0));
	restarts = 0;
	startTime = -1;
	totalMoves = 0
};
LevelButton.prototype.destroy = function() {
	this.game.input.onDown.remove(this.onClick, this);
	this.text.destroy();
	this.back.destroy();
	for (var f = 0; 3 > f; f++) this.stars[f].destroy()
};
LevelLockedButton = function(f, e) {
	this.game = f;
	this.bonusesToUnlock = e;
	Phaser.Group.call(this, f);
	this.back = this.create(0, 0, "gui");
	this.back.frameName = "level_button_back";
	this.back.inputEnabled = !0;
	this.back.input.useHandCursor = !0;
	this.back.events.onInputDown.add(this.onClick, this);
	this.lock = this.create(0.5 * this.back.width, 0.5 * this.back.height, "gui");
	this.lock.frameName = "lock";
	this.lock.anchor.setTo(0.5, 0.5)
};
LevelLockedButton.prototype = Object.create(Phaser.Group.prototype);
LevelLockedButton.prototype.constructor = LevelButton;
LevelLockedButton.prototype.onClick = function() {
	var f = this.game.state.states[this.game.state.current];
	this.bonusesToUnlock ? f.doctorHelper.showMessage(getLocalizedString("not_enough_bonuses").split("###").join(this.bonusesToUnlock - f.totalBonuses + ""), 2E3) : f.doctorHelper.showMessage(getLocalizedString("level_locked"), 2E3)
};
LevelLockedButton.prototype.destroy = function() {
	this.game.input.onDown.remove(this.onClick, this);
	this.lock.destroy();
	this.back.destroy()
};
var locale = {
	ru: {},
	en: {}
};
locale.ru.story_begin_1 = ["\u0424\u0435\u043b\u0438\u043a\u0441, \u0432\u044b \u043d\u0435 \u0441\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442\u0435\u0441\u044c\n\u0441\u043e \u0441\u0432\u043e\u0435\u0439 \u0440\u0430\u0431\u043e\u0442\u043e\u0439. \u042f \u0432\u0430\u0441 \u0443\u0432\u043e\u043b\u044e!"];
locale.ru.story_begin_2 = ["\u041e\u0447\u0435\u043d\u044c \u0438\u043d\u0442\u0435\u0440\u0435\u0441\u043d\u044b\u0439 \u0441\u043b\u0443\u0447\u0430\u0439 \u043f\u0440\u043e\u044f\u0432\u043b\u0435\u043d\u0438\u044f \u0430\u0433\u0440\u0435\u0441\u0441\u0438\u0438 \u043d\u0430 \u0440\u0430\u0431\u043e\u0442\u0435."];
locale.ru.story_end = ["\u041a\u0430\u0436\u0435\u0442\u0441\u044f, \u0434\u043e\u043c\u0430 \u044f \u0437\u0430\u0431\u044b\u043b \u0432\u044b\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u0443\u0442\u044e\u0433."];
locale.ru.level_title = ["\u041f\u0430\u043b\u0430\u0442\u0430 #"];
locale.ru.tutorial1_desktop = ["\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439 \u0441\u0442\u0440\u0435\u043b\u043e\u0447\u043a\u0438 \u0438\u043b\u0438 \u043c\u044b\u0448\u043a\u0443.\n\u0421\u0435\u0440\u0434\u0446\u0435 \u043f\u043e\u0434\u0441\u043a\u0430\u0436\u0435\u0442 \u0442\u0435\u0431\u0435 \u043f\u0443\u0442\u044c."];
locale.ru.tutorial1_touch = ["\u041f\u0440\u043e\u0432\u0435\u0434\u0438 \u043f\u043e \u044d\u043a\u0440\u0430\u043d\u0443 \u0447\u0442\u043e\u0431\u044b \u044e\u043d\u0438\u0442 \u043f\u043e\u0431\u0435\u0436\u0430\u043b.\n\u0421\u0435\u0440\u0434\u0446\u0435 \u043f\u043e\u0434\u0441\u043a\u0430\u0436\u0435\u0442 \u0442\u0435\u0431\u0435 \u043f\u0443\u0442\u044c."];
locale.ru.level_start = "\u0424\u0435\u043b\u0438\u043a\u0441, \u0442\u0435\u0431\u044f \u0435\u0449\u0435 \u0440\u0430\u043d\u043e \u0432\u044b\u043f\u0438\u0441\u044b\u0432\u0430\u0442\u044c.;\u0422\u0443\u0442 \u043a\u043b\u0438\u043d\u0438\u043a\u0430 \u0434\u043b\u044f \u043f\u043e\u0440\u044f\u0434\u043e\u0447\u043d\u044b\u0445 \u0431\u043e\u043b\u044c\u043d\u044b\u0445,\n\u0432\u0435\u0434\u0438 \u0441\u0435\u0431\u044f \u0434\u043e\u0441\u0442\u043e\u0439\u043d\u043e.;\u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439 \u0441\u043e\u0431\u0440\u0430\u0442\u044c \u0432\u0441\u0435 \u0431\u043e\u043d\u0443\u0441\u044b \u043d\u0430 \u0443\u0440\u043e\u0432\u043d\u0435.;\u0422\u0435\u043f\u0435\u0440\u044c \u043c\u044b - \u0442\u0432\u043e\u044f \u0441\u0435\u043c\u044c\u044f, \u0424\u0435\u043b\u0438\u043a\u0441, \u043e\u0441\u0442\u0430\u0432\u0430\u0439\u0441\u044f \u0441 \u043d\u0430\u043c\u0438.;\u0421\u043a\u0443\u0447\u0430\u0435\u0448\u044c \u043f\u043e \u0440\u0430\u0431\u043e\u0442\u0435?\n\u041d\u0435 \u0441\u0442\u043e\u0438\u043b\u043e \u043e\u0431\u0438\u0436\u0430\u0442\u044c \u0431\u043e\u0441\u0441\u0430.;\u0421\u043c\u0438\u0440\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0440\u0443\u0431\u0430\u0448\u043a\u0430 \u0442\u0435\u0431\u0435 \u043e\u0447\u0435\u043d\u044c \u0438\u0434\u0435\u0442.;\u0423 \u043d\u0430\u0441 \u0432 \u0431\u043e\u043b\u044c\u043d\u0438\u0446\u0435 \u043b\u0443\u0447\u0448\u0438\u0435 \u043b\u0435\u043a\u0430\u0440\u0441\u0442\u0432\u0430!\n\u0412\u043e\u0442, \u043f\u043e\u043f\u0440\u043e\u0431\u0443\u0439.;\u0422\u044b \u0443\u0436\u0435 \u043e\u0442\u0447\u0430\u044f\u043b\u0441\u044f \u043d\u0430\u0439\u0442\u0438 \u0432\u044b\u0445\u043e\u0434\n\u0438\u0437 \u043d\u0430\u0448\u0435\u0439 \u043a\u043b\u0438\u043d\u0438\u043a\u0438?;\u0424\u0435\u043b\u0438\u043a\u0441, \u0443 \u0441\u0442\u0435\u043d \u0442\u043e\u0436\u0435 \u0435\u0441\u0442\u044c \u0443\u0448\u0438,\n\u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u044c \u0440\u0443\u0433\u0430\u0442\u044c\u0441\u044f.;\u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e, \u0432\u0430\u0448\u0438 \u0441\u0442\u0440\u0430\u0445\u0438 \u043e\u043f\u0440\u0430\u0432\u0434\u0430\u043d\u044b,\n\u0432\u0435\u0434\u044c \u043d\u0430\u0448\u0438 \u0441\u0430\u043d\u0438\u0442\u0430\u0440\u044b \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0436\u0443\u0442\u043a\u043e \u0441\u0443\u0440\u043e\u0432\u044b.".split(";");
locale.ru.died = ["\u041e\u0441\u0442\u0435\u0440\u0435\u0433\u0430\u0439\u0441\u044f \u0441\u0430\u043d\u0438\u0442\u0430\u0440\u043e\u0432 \u0438 \u0434\u044c\u044f\u0432\u043e\u043b\u043e\u0432."];
locale.ru.aquarium = ["\u041e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e, \u0430\u043a\u0432\u0430\u0440\u0438\u0443\u043c \u043d\u0435 \u0432\u044b\u0434\u0435\u0440\u0436\u0438\u0442 \u043c\u043d\u043e\u0433\u043e \u0443\u0434\u0430\u0440\u043e\u0432."];
locale.ru.aquarium_cracked = ["\u0422\u0430\u043c, \u0433\u0434\u0435 \u0431\u044b\u043b \u0430\u043a\u0432\u0430\u0440\u0438\u0443\u043c, \u0442\u0435\u043f\u0435\u0440\u044c \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0439\u0442\u0438."];
locale.ru.level_locked = ["\u041d\u043e\u0441 \u043d\u0435 \u0434\u043e\u0440\u043e\u0441!", "\u042d\u0442\u043e\u0442 \u0443\u0440\u043e\u0432\u0435\u043d\u044c \u043f\u043e\u043a\u0430 \u0437\u0430\u043a\u0440\u044b\u0442, \u043f\u043e\u043f\u0440\u043e\u0431\u0443\u0439 \u0437\u0430\u0432\u0435\u0440\u0448\u0438\u0442\u044c \u043e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0435."];
locale.ru.not_enough_bonuses = ["\u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u0441\u043e\u0431\u0435\u0440\u0438 \u043d\u0435\u0434\u043e\u0441\u0442\u0430\u044e\u0449\u0438\u0435 \u0431\u043e\u043d\u0443\u0441\u044b. \u041d\u0435 \u0445\u0432\u0430\u0442\u0430\u0435\u0442: ###.", "\u0421\u043e\u0431\u0438\u0440\u0430\u0439 \u0431\u043e\u043d\u0443\u0441\u044b, \u0447\u0442\u043e\u0431\u044b \u043e\u0442\u043a\u0440\u044b\u0442\u044c \u044d\u0442\u0438 \u0443\u0440\u043e\u0432\u043d\u0438. \u0415\u0449\u0435 \u043d\u0443\u0436\u043d\u043e: ###."];
locale.ru.hero_click = ["\u041d\u0435 \u043c\u0443\u0447\u0430\u0439 \u0441\u0435\u0431\u044f, \u0424\u0435\u043b\u0438\u043a\u0441.", "\u041a\u0430\u043a \u043d\u0430\u043c \u044d\u0442\u043e \u043f\u043e\u043c\u043e\u0436\u0435\u0442?", "\u041b\u0443\u0447\u0448\u0435 \u043f\u043e\u0434\u0443\u043c\u0430\u0439 \u043a\u0430\u043a \u0432\u044b\u0431\u0440\u0430\u0442\u044c\u0441\u044f.", "\u0417\u0430\u0439\u043c\u0438\u0441\u044c \u0443\u0436\u0435 \u0434\u0435\u043b\u043e\u043c."];
locale.en.story_begin_1 = ["You don't cope with your\nwork, Felix! You'll be fired!"];
locale.en.story_begin_2 = ["Mmm... Aggression at work? What an interesting situation!"];
locale.en.story_end = ["I remember... I forgot to turn off my iron!"];
locale.en.level_title = ["Ward #"];
locale.en.tutorial1_desktop = ["Use arrows or mouse for moving.\nHeart will show you the way."];
locale.en.tutorial1_touch = ["Swipe your finger to move.\nHeart will show you the way."];
locale.en.level_start = "Oh, Felix. You're not ready to be discharged from our clinic.;Our clinic is for respectable patients,\nbehave yourself decently.;Try to collect all bonuses in each level.;Now we are your family, Felix. Stay with us.;You miss work, right?\nIt was a bad idea to hurt your boss.;Straitjacket fits you well, Felix!;In this hospital we use the best medicines!\nYou can try them too.;Are you desperate to find a way out\nfrom our clinic?;Felix, walls have ears, you know.\nKeep calm and stop swearing.;Maybe your fears are justified...\nSometimes our nurses are really harsh.".split(";");
locale.en.died = ["Oh, Felix, next time will be better. \nBeware nurses and devils."];
locale.en.aquarium = ["Be careful! You can break our aquarium!"];
locale.en.aquarium_cracked = ["Well, you shall pass here now."];
locale.en.level_locked = ["You're still green.", "This level is locked, try to complete other."];
locale.en.not_enough_bonuses = ["Collect the missing bonuses. You need ### to continue.", "Collect bonuses to unlock more levels. Missing: ###."];
locale.en.hero_click = ["Don't torture yourself, Felix.", "How it can help us?", "You should think about how to get out.", "Do something already."];
var language = "ru";

function getLocalizedString(f) {
	f = locale[language][f];
	return f[Math.floor(Math.random() * f.length)]
}
MainScreen = function(f) {
	this.game = f
};
MainScreen.prototype = {
	create: function() {
		var f = this.game.add.graphics(0, 0);
		f.beginFill(4700112);
		f.drawRect(0, 0, this.game.width, this.game.height);
		new Logo(this.game, 20, this.game.height - 90, "logo_small");
		new MoreGamesButton(this.game, this.game.width - 200, this.game.height - 90);
		f = this.game.add.sprite(0, 0, "main_background");
		this.scale = Math.min(this.game.width / f.width, this.game.height / f.height);
		f.width *= this.scale;
		f.height *= this.scale;
		this.offsetX = f.x = 0.5 * (this.game.width - f.width);
		this.offsetY = f.y = 0.5 * (this.game.height -
			f.height);
		var e = this.game.add.sprite(0, 0, "gui");
		e.anchor.setTo(0.5, 0.5);
		e.x = 0.5 * this.game.width;
		e.y = f.height - 140;
		e.frameName = "play_button";
		e.inputEnabled = !0;
		e.input.useHandCursor = !0;
		e.events.onInputDown.add(this.startGame, this);
		e.events.onInputOver.add(this.onOver, this);
		e.events.onInputOut.add(this.onOut, this);
		this.leftEye = this.game.add.graphics(0, 0);
		this.leftEye.beginFill(3735552);
		this.leftEye.drawCircle(0, 0, 9);
		this.rightEye = this.game.add.graphics(0, 0);
		this.rightEye.beginFill(3735552);
		this.rightEye.drawCircle(0,
			0, 6);
		f = this.game.add.sprite(630 * this.scale, 350 * this.scale, "animations");
		f.animations.add("monster", Phaser.Animation.generateFrameNames("monster_red", 1, 2, "", 4, !1));
		f.animations.play("monster", 2, !0);
		f.scale.setTo(0.9, 0.9);
		f = this.game.add.sprite(310 * this.scale, 352 * this.scale, "animations");
		f.animations.add("idle", Phaser.Animation.generateFrameNames("medic_idle", 1, 4, "", 4, !1));
		f.animations.play("idle", 2, !0);
		f.scale.setTo(0.9, 0.9);
		this.buttonSound = new SoundButton(this.game, this.game.width - 40, 50, 0.8);
		this.game.add.existing(this.buttonSound);
		this.buttonCredits = new CreditsScreenButton(this.game, this.game.width - 100, 50, 0.8);
		this.buttonCredits.events.onInputDown.add(this.credits, this);
		this.game.add.existing(this.buttonCredits);
		music || (music = this.game.add.audio("music"), music.play("", 0, 1, !0), music.onPlay.add(this.onMusicPlay, this), getSoundEnabled() || music.pause())
	},
	onMusicPlay: function() {
		getSoundEnabled() || music.pause();
		music.onPlay.remove(this.onMusicPlay, this)
	},
	update: function() {
		var f = this.game.input.activePointer,
			e = 448 * this.scale + this.offsetX,
			c = 281 * this.scale + this.offsetY;
		this.leftEye.x = e + 10 * (f.x - e) / this.game.width;
		this.leftEye.y = c + 10 * (f.y - c) / this.game.height;
		e = 492 * this.scale + this.offsetX;
		c = 274 * this.scale + this.offsetY;
		this.rightEye.x = e + 10 * (f.x - e) / this.game.width;
		this.rightEye.y = c + 10 * (f.y - c) / this.game.height
	},
	credits: function() {
		this.game.state.start("creditsScreen", !0)
	},
	startGame: function() {
		this.game.state.start("levelsScreen", !0)
	},
	onOver: function(f) {
		f.y -= 5
	},
	onOut: function(f) {
		f.y += 5
	}
};
var CELL_SIZE = 64,
	ROWS = 10,
	COLUMNS = 14,
	LEVEL_NUM = 0,
	LEVEL_DATA = {};

function getLevelScores(f) {
	return (f = getCookie("level" + f)) ? f.split(",") : null
}

function setLevelScores(f, e) {
	updateShareScore(f);
	var c = new Date;
	c.setFullYear(c.getFullYear() + 1);
	var l = getLevelScores(f);
	(!l || l[4] < e[4]) && setCookie("level" + f, e.join(","), {
		expires: c
	})
}

function getIntroViewed() {
	return "1" === getCookie("intro")
}

function setIntroViewed(f) {
	setCookie("intro", f ? "1" : "0")
}

function getSoundEnabled() {
	return "0" !== getCookie("sound")
}

function setSoundEnabled(f) {
	var e = new Date;
	e.setFullYear(e.getFullYear() + 1);
	setCookie("sound", f ? "1" : "0", {
		expires: e
	})
}

function getTutorialComplete(f) {
	var e = getCookie("tutorial");
	return e && -1 !== e.indexOf(f)
}

function setTutorialComplete(f) {
	var e = getCookie("tutorial");
	setCookie("tutorial", e ? e + "," + f : f)
}

function getTotalBonuses() {
	var f = 0,
		e;
	for (e in LEVEL_DATA)
		if (savedData = getLevelScores(e)) f += parseInt(savedData[0]), f += parseInt(savedData[1]), f += parseInt(savedData[2]), f += parseInt(savedData[3]);
	return f
}
PopupText = function(f, e) {
	this.game = f;
	this.duration = e;
	Phaser.Group.call(this, f);
	this.bubble = new Phaser.Graphics(f, 0, 0);
	this.add(this.bubble)
};
PopupText.prototype = Object.create(Phaser.Group.prototype);
PopupText.prototype.constructor = PopupText;
PopupText.prototype.showMessage = function(f) {
	this.text = new Phaser.BitmapText(this.game, 10, 10, f, {
		font: "24px FuturaRound",
		align: "center"
	});
	this.add(this.text);
	this.bubble.clear();
	this.bubble.beginFill(0);
	f = 0;
	var e, c;
	for (c in this.text.children) e = this.text.children[c], e.position.x + e.texture.width > f && (f = e.position.x + e.texture.width);
	this.width = f + 15;
	this.height = this.text.height + 20;
	Utils.drawRoundRect(this.bubble, 0, 0, f + 15, this.text.height + 20, 15);
	this.show()
};
PopupText.prototype.show = function() {
	this.x = -500;
	this.y = 0.5 * (this.game.height - this.height);
	var f = this.game.add.tween(this);
	f.to({
		x: 0.5 * (this.game.width - this.width)
	}, 500, Phaser.Easing.Quadratic.In);
	f.start();
	var e = this;
	setTimeout(function() {
		e.hide(e)
	}, this.duration)
};
PopupText.prototype.hide = function(f) {
	var e = f.game.add.tween(f);
	e.to({
		x: f.game.width + 100
	}, 500, Phaser.Easing.Back.Out);
	e.onComplete.add(f.dispose, f);
	e.start()
};
PopupText.prototype.dispose = function() {
	this.bubble.destroy();
	this.text.destroy()
};
Preloader = function(f) {
	this.game = f
};
Preloader.prototype = {
	preload: function() {
		var f = this.game.width,
			e = this.game.height,
			c = this.game.add.graphics(0, 0);
		c.beginFill(4700112);
		c.drawRect(0, 0, f, e);
		c = this.game.add.graphics(0.5 * f, 0.5 * e + 150);
		c.beginFill(16777215);
		for (var l = -15; 15 > l; l++) c.drawCircle(20 * l, 0, 3);
		GameAPI.Branding.getLogo();
		this.leftMask = this.game.add.graphics(-300, c.y - 20);
		this.leftMask.beginFill(4700112);
		this.leftMask.drawRect(-400, 0, 400, 40);
		this.rightMask = this.game.add.graphics(-300, c.y - 20);
		this.rightMask.beginFill(4700112);
		this.rightMask.drawRect(0,
			0, 400, 40);
		c = new Logo(this.game, 0, 0, "logo_large");
		c.x = 0.5 * (f - c.width);
		c.y = 100;
		c = this.game.add.sprite(0, 0, "loading_title");
		c.x = 0.5 * (f - c.width);
		c.y = 0.5 * (e - c.height) + 250;
		this.medic = this.game.add.sprite(0, 0, "preloader_animations");
		this.medic.animations.add("run", Phaser.Animation.generateFrameNames("medic_preloader_run", 1, 4, "", 4, !1));
		this.medic.animations.play("run", 8, !0);
		this.medic.x = 0.5 * f - 340;
		this.medic.y = 0.5 * e + 150;
		this.medic.anchor.setTo(0.5, 0.5);
		this.loony = this.game.add.sprite(0, 0, "preloader_animations");
		this.loony.animations.add("run", Phaser.Animation.generateFrameNames("loony_preloader_run", 1, 2, "", 4, !1));
		this.loony.animations.play("run", 12, !0);
		this.loony.x = 0.5 * f + 340;
		this.loony.y = 0.5 * e + 150;
		this.loony.anchor.setTo(0.5, 0.5);
		if (game.device.desktop || game.device.iOS)
			for (var n in soundDatas) 0 < soundDatas[n].urls.length && this.game.load.audio(n, soundDatas[n].urls);
		else this.game.load.audio("music", soundDatas.music.urls);
		this.game.load.image("main_background", "assets/main_background.png");
		this.game.load.image("creditsScreen",
			"assets/credits_screen.png");
		this.game.load.atlas("gui", "assets/gui/gui.png", "assets/gui/gui.json");
		this.game.load.atlas("statics", "assets/static/static.png", "assets/static/static.json");
		this.game.load.atlas("animations", "assets/animations/animations.png", "assets/animations/animations.json");
		this.game.load.spritesheet("more_games_button", "assets/branding/more_games_button.png", 174, 66);
		this.game.load.text("levelData", "data/levels.json");
		this.game.load.bitmapFont("levelButtonFont", "assets/fonts/levelButtonFont.png",
			"assets/fonts/levelButtonFont.fnt");
		this.game.load.bitmapFont("font", "assets/fonts/font.png", "assets/fonts/font.fnt");
		this.game.load.bitmapFont("font_black", "assets/fonts/font_black.png", "assets/fonts/font_black.fnt");
		if (!getIntroViewed())
			for (l = 1; 8 > l; l++) this.game.load.image("begin_story_frame_" + l, "assets/story/begin/" + l + ".png");
		for (l = 1; 4 > l; l++) this.game.load.image("end_story_frame_" + l, "assets/story/end/" + l + ".png");
		this.game.load.onFileComplete.add(this.progress, this)
	},
	progress: function(f) {
		var e =
			0.5 * this.game.width;
		this.medic.x = this.leftMask.x = e - 300 * (100 - f) / 100 - 40;
		this.loony.x = this.rightMask.x = e + 300 * (100 - f) / 100 + 40
	},
	update: function() {
		if (this.cache.isSoundDecoded("music") && !this.soundDecoded && (this.soundDecoded = !0, this.gameLoaded)) {
			var f = this;
			setTimeout(function() {
				f.start(f.game)
			}, 1E3)
		}
	},
	create: function() {
		LEVEL_DATA = JSON.parse(this.game.cache.getText("levelData"));
		this.gameLoaded = !0;
		if (this.soundDecoded) {
			var f = this;
			setTimeout(function() {
				f.start(f.game)
			}, 1E3)
		}
	},
	handleLoad: function(f) {
		this.soundsNumLoaded++;
		console.log(this.soundsNumLoaded, this.manifest.length);
		if (this.soundsNumLoaded == this.manifest.length && (this.soundLoaded = !0, this.gameLoaded)) {
			var e = this;
			setTimeout(function() {
				e.start(e.game)
			}, 1E3)
		}
	},
	start: function(f) {
		GameAPI.Branding.getSplashScreen().show ? f.state.start("splashScreen", !0) : f.state.start("mainScreen", !0)
	}
};
var soundEnabled = getSoundEnabled(),
	soundDatas = {
		bed_smash: {
			urls: ["assets/sounds/1_1.mp3", "assets/sounds/1_1.ogg"]
		},
		table_smash: {
			urls: ["assets/sounds/1_2.mp3", "assets/sounds/1_2.ogg"]
		},
		drugs_smash: {
			urls: ["assets/sounds/1_4.mp3", "assets/sounds/1_4.ogg"]
		},
		aquarium_cracked: {
			urls: ["assets/sounds/1_5.mp3", "assets/sounds/1_5.ogg"]
		},
		aquarium_broken: {
			urls: ["assets/sounds/1_6.mp3", "assets/sounds/1_6.ogg"]
		},
		wall_smash: {
			urls: ["assets/sounds/1_7.mp3", "assets/sounds/1_7.ogg"]
		},
		lever: {
			urls: ["assets/sounds/2.mp3",
				"assets/sounds/2.ogg"
			]
		},
		enemy_fight: {
			urls: ["assets/sounds/3.mp3", "assets/sounds/3.ogg"]
		},
		bonus: {
			urls: ["assets/sounds/4.mp3", "assets/sounds/4.ogg"]
		},
		level_win: {
			urls: ["assets/sounds/5.mp3", "assets/sounds/5.ogg"]
		},
		footsteps: {
			urls: ["assets/sounds/7_2.mp3", "assets/sounds/7_2.ogg"]
		},
		music: {
			urls: ["assets/sounds/music2.mp3", "assets/sounds/music2.ogg"]
		}
	},
	music;

function playSound(f, e) {
	if (soundEnabled && (f.device.desktop || f.device.iOS)) {
		var c = f.add.audio(e);
		c.play("", 0, 1, soundDatas[e].loop);
		return c
	}
}
SplashScreen = function(f) {
	this.game = f
};
SplashScreen.prototype = {
    create: function() {
        var f = this.game.width,
            e = this.game.height,
            c = this.game.add.graphics(0, 0);
        c.beginFill(16777215);
        c.drawRect(0, 0, f, e);
        c = new Logo(this.game, 0, 0, "logo_large");
        c.x = 0.5 * (f - c.width);
        c.y = 0.5 * (e - c.height);
        var l = this;
        setTimeout(function() {
            this.game.state.start("mainScreen", !0)
        }, 3E3)
    },
//	showButton: function(f) {
//		f.button = f.game.add.sprite(0.5 * f.game.width, f.game.height - 100, "gui");
//		f.button.frameName = "button_continue";
//		f.button.anchor.setTo(0.5, 0.5);
//		f.button.inputEnabled = !0;
//		f.button.input.useHandCursor = !0;
//		f.button.events.onInputDown.add(f.start, f)
//	},
    start: function() {
        this.game.state.start("mainScreen", !0)
    }
};
StoryScreen = function(f) {
	this.game = f;
	this.mode = "begin";
	this.frames = {};
	this.frames.begin = [];
	this.frames.end = [];
	for (f = 1; 8 > f; f++) this.frames.begin.push("begin_story_frame_" + f);
	for (f = 1; 4 > f; f++) this.frames.end.push("end_story_frame_" + f);
	this.directions = {};
	this.directions.begin = [-1, 1, -1, -1, 0, 1, -1];
	this.directions.end = [-1, -1, 1]
};
StoryScreen.prototype = {
	create: function() {
		new Phaser.Graphics(this.game, 0, 0);
		this.buttonSound = new SoundButton(this.game, this.game.width - 50, 50, 0.6);
		this.game.add.existing(this.buttonSound);
		this.currentFrame = -1;
		this.image = this.game.add.sprite(0, 0, "empty");
		this.image.inputEnabled = !0;
		this.image.useHandCursor = !0;
		this.image.events.onInputDown.add(this.showNextFrame, this);
		this.text = new Phaser.BitmapText(this.game, 0, 0, "", {
			font: "28px FuturaRoundBlack",
			align: "center"
		});
		this.game.add.existing(this.text);
		this.text.visible = !1;
		this.text.anchor.setTo(0.5, 0.5);
		this.showNextFrame()
	},
	showNextFrame: function() {
		this.tween && (this.tween.stop(), this.tween.onComplete.removeAll());
		this.currentFrame++;
		this.frames[this.mode].length > this.currentFrame ? this.showFrame(this.frames[this.mode][this.currentFrame], this.directions[this.mode][this.currentFrame]) : (setIntroViewed(!0), "begin" === this.mode ? this.game.state.start("game", !0) : this.game.state.start("levelsScreen", !0));
		new Darkness(this.game, !0, 0, 300)
	},
	showFrame: function(f, e) {
		this.image.loadTexture(f,
			0);
		this.tween = this.add.tween(this.image);
		this.tween.onComplete.add(this.showNextFrame, this); - 1 === e ? (this.image.x = this.game.width - this.image.width, this.tween.to({
			x: 0
		}, 8E3, null, !0)) : 1 === e ? (this.image.x = 0, this.tween.to({
			x: this.game.width - this.image.width
		}, 8E3, null, !0)) : this.tween.to({
			x: 0
		}, 8E3, null, !0);
		0 !== this.currentFrame && 1 !== this.currentFrame || "begin" !== this.mode ? 4 === this.currentFrame && "begin" === this.mode ? (this.text.setText(getLocalizedString("story_begin_2")), this.textOffsetX = 0.5 * this.game.width +
			40, this.textOffsetY = 550, this.text.visible = !0) : 2 === this.currentFrame && "end" === this.mode ? (this.text.setStyle({
			font: "33px FuturaRound",
			align: "center"
		}), this.text.setText(getLocalizedString("story_end")), this.textOffsetX = 0.5 * this.game.width, this.textOffsetY = 70, this.text.visible = !0) : this.text.visible = !1 : (this.text.setText(getLocalizedString("story_begin_1")), this.textOffsetX = 670, this.textOffsetY = 95, this.text.visible = !0)
	},
	update: function() {
		this.text.visible && (this.text.x = this.image.x + this.textOffsetX, this.text.y =
			this.image.y + this.textOffsetY)
	},
	shutdown: function() {}
};

function Utils() {}
Utils.drawRoundRect = function(f, e, c, l, n, a) {
	f.moveTo(e, c + a);
	f.lineTo(e + a, c);
	f.lineTo(e + l - a, c);
	f.lineTo(e + l, c + a);
	f.lineTo(e + l, c + n - a);
	f.lineTo(e + l - a, c + n);
	f.lineTo(e + a, c + n);
	f.lineTo(e, c + n - a);
	f.drawCircle(e + a, c + a, a);
	f.drawCircle(e + l - a, c + a, a);
	f.drawCircle(e + l - a, c + n - a, a);
	f.drawCircle(e + a, c + n - a, a)
};
Utils.clearCanvas = function(f) {
	var e = f.getContext("2d");
	e.save();
	e.setTransform(1, 0, 0, 1, 0, 0);
	e.clearRect(0, 0, f.width, f.height);
	f.width = f.width;
	e.restore();
	f.width++;
	f.width--;
	f.style.opacity = 0.99;
	setTimeout(function() {
		f.style.opacity = 1
	}, 1)
};